import {
  __commonJS
} from "./chunk-RSJERJUL.js";

// node_modules/agora-rtc-sdk-ng/AgoraRTC_N-production.js
var require_AgoraRTC_N_production = __commonJS({
  "node_modules/agora-rtc-sdk-ng/AgoraRTC_N-production.js"(exports, module) {
    !function(e, t) {
      typeof exports == "object" && typeof module != "undefined" ? module.exports = t() : typeof define == "function" && define.amd ? define(t) : (e = typeof globalThis != "undefined" ? globalThis : e || self).AgoraRTC = t();
    }(exports, function() {
      "use strict";
      var e = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {}, t = function(e2) {
        return e2 && e2.Math == Math && e2;
      }, r = t(typeof globalThis == "object" && globalThis) || t(typeof window == "object" && window) || t(typeof self == "object" && self) || t(typeof e == "object" && e) || function() {
        return this;
      }() || Function("return this")(), i = {}, n = function(e2) {
        try {
          return !!e2();
        } catch (e3) {
          return true;
        }
      }, o = !n(function() {
        return Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1] != 7;
      }), s = !n(function() {
        var e2 = function() {
        }.bind();
        return typeof e2 != "function" || e2.hasOwnProperty("prototype");
      }), a = s, c = Function.prototype.call, d = a ? c.bind(c) : function() {
        return c.apply(c, arguments);
      }, u = {}, A = {}.propertyIsEnumerable, h = Object.getOwnPropertyDescriptor, l = h && !A.call({ 1: 2 }, 1);
      u.f = l ? function(e2) {
        var t2 = h(this, e2);
        return !!t2 && t2.enumerable;
      } : A;
      var p, g, f = function(e2, t2) {
        return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t2 };
      }, E = s, I = Function.prototype, m = I.bind, _ = I.call, C = E && m.bind(_, _), v = E ? function(e2) {
        return e2 && C(e2);
      } : function(e2) {
        return e2 && function() {
          return _.apply(e2, arguments);
        };
      }, S = v, R = S({}.toString), y = S("".slice), T = function(e2) {
        return y(R(e2), 8, -1);
      }, w = v, b = n, O = T, N = r.Object, D = w("".split), L = b(function() {
        return !N("z").propertyIsEnumerable(0);
      }) ? function(e2) {
        return O(e2) == "String" ? D(e2, "") : N(e2);
      } : N, P = r.TypeError, k = function(e2) {
        if (e2 == null)
          throw P("Can't call method on " + e2);
        return e2;
      }, B = L, M = k, U = function(e2) {
        return B(M(e2));
      }, Q = function(e2) {
        return typeof e2 == "function";
      }, x = Q, F = function(e2) {
        return typeof e2 == "object" ? e2 !== null : x(e2);
      }, V = r, j = Q, G = function(e2) {
        return j(e2) ? e2 : void 0;
      }, K = function(e2, t2) {
        return arguments.length < 2 ? G(V[e2]) : V[e2] && V[e2][t2];
      }, H = v({}.isPrototypeOf), Y = K("navigator", "userAgent") || "", W = r, J = Y, q = W.process, z = W.Deno, X = q && q.versions || z && z.version, Z = X && X.v8;
      Z && (g = (p = Z.split("."))[0] > 0 && p[0] < 4 ? 1 : +(p[0] + p[1])), !g && J && (!(p = J.match(/Edge\/(\d+)/)) || p[1] >= 74) && (p = J.match(/Chrome\/(\d+)/)) && (g = +p[1]);
      var $ = g, ee = $, te = n, re = !!Object.getOwnPropertySymbols && !te(function() {
        var e2 = Symbol();
        return !String(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && ee && ee < 41;
      }), ie = re && !Symbol.sham && typeof Symbol.iterator == "symbol", ne = K, oe = Q, se = H, ae = ie, ce = r.Object, de = ae ? function(e2) {
        return typeof e2 == "symbol";
      } : function(e2) {
        var t2 = ne("Symbol");
        return oe(t2) && se(t2.prototype, ce(e2));
      }, ue = r.String, Ae = function(e2) {
        try {
          return ue(e2);
        } catch (e3) {
          return "Object";
        }
      }, he = Q, le = Ae, pe = r.TypeError, ge = function(e2) {
        if (he(e2))
          return e2;
        throw pe(le(e2) + " is not a function");
      }, fe = ge, Ee = function(e2, t2) {
        var r2 = e2[t2];
        return r2 == null ? void 0 : fe(r2);
      }, Ie = d, me = Q, _e = F, Ce = r.TypeError, ve = { exports: {} }, Se = r, Re = Object.defineProperty, ye = function(e2, t2) {
        try {
          Re(Se, e2, { value: t2, configurable: true, writable: true });
        } catch (r2) {
          Se[e2] = t2;
        }
        return t2;
      }, Te = ye, we = "__core-js_shared__", be = r[we] || Te(we, {}), Oe = be;
      (ve.exports = function(e2, t2) {
        return Oe[e2] || (Oe[e2] = t2 !== void 0 ? t2 : {});
      })("versions", []).push({ version: "3.20.3", mode: "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.20.3/LICENSE", source: "https://github.com/zloirock/core-js" });
      var Ne = k, De = r.Object, Le = function(e2) {
        return De(Ne(e2));
      }, Pe = Le, ke = v({}.hasOwnProperty), Be = Object.hasOwn || function(e2, t2) {
        return ke(Pe(e2), t2);
      }, Me = v, Ue = 0, Qe = Math.random(), xe = Me(1 .toString), Fe = function(e2) {
        return "Symbol(" + (e2 === void 0 ? "" : e2) + ")_" + xe(++Ue + Qe, 36);
      }, Ve = r, je = ve.exports, Ge = Be, Ke = Fe, He = re, Ye = ie, We = je("wks"), Je = Ve.Symbol, qe = Je && Je.for, ze = Ye ? Je : Je && Je.withoutSetter || Ke, Xe = function(e2) {
        if (!Ge(We, e2) || !He && typeof We[e2] != "string") {
          var t2 = "Symbol." + e2;
          He && Ge(Je, e2) ? We[e2] = Je[e2] : We[e2] = Ye && qe ? qe(t2) : ze(t2);
        }
        return We[e2];
      }, Ze = d, $e = F, et = de, tt = Ee, rt = function(e2, t2) {
        var r2, i2;
        if (t2 === "string" && me(r2 = e2.toString) && !_e(i2 = Ie(r2, e2)))
          return i2;
        if (me(r2 = e2.valueOf) && !_e(i2 = Ie(r2, e2)))
          return i2;
        if (t2 !== "string" && me(r2 = e2.toString) && !_e(i2 = Ie(r2, e2)))
          return i2;
        throw Ce("Can't convert object to primitive value");
      }, it = Xe, nt = r.TypeError, ot = it("toPrimitive"), st = function(e2, t2) {
        if (!$e(e2) || et(e2))
          return e2;
        var r2, i2 = tt(e2, ot);
        if (i2) {
          if (t2 === void 0 && (t2 = "default"), r2 = Ze(i2, e2, t2), !$e(r2) || et(r2))
            return r2;
          throw nt("Can't convert object to primitive value");
        }
        return t2 === void 0 && (t2 = "number"), rt(e2, t2);
      }, at = de, ct = function(e2) {
        var t2 = st(e2, "string");
        return at(t2) ? t2 : t2 + "";
      }, dt = F, ut = r.document, At = dt(ut) && dt(ut.createElement), ht = function(e2) {
        return At ? ut.createElement(e2) : {};
      }, lt = ht, pt = !o && !n(function() {
        return Object.defineProperty(lt("div"), "a", { get: function() {
          return 7;
        } }).a != 7;
      }), gt = o, ft = d, Et = u, It = f, mt = U, _t = ct, Ct = Be, vt = pt, St = Object.getOwnPropertyDescriptor;
      i.f = gt ? St : function(e2, t2) {
        if (e2 = mt(e2), t2 = _t(t2), vt)
          try {
            return St(e2, t2);
          } catch (e3) {
          }
        if (Ct(e2, t2))
          return It(!ft(Et.f, e2, t2), e2[t2]);
      };
      var Rt = {}, yt = o && n(function() {
        return Object.defineProperty(function() {
        }, "prototype", { value: 42, writable: false }).prototype != 42;
      }), Tt = r, wt = F, bt = Tt.String, Ot = Tt.TypeError, Nt = function(e2) {
        if (wt(e2))
          return e2;
        throw Ot(bt(e2) + " is not an object");
      }, Dt = o, Lt = pt, Pt = yt, kt = Nt, Bt = ct, Mt = r.TypeError, Ut = Object.defineProperty, Qt = Object.getOwnPropertyDescriptor, xt = "enumerable", Ft = "configurable", Vt = "writable";
      Rt.f = Dt ? Pt ? function(e2, t2, r2) {
        if (kt(e2), t2 = Bt(t2), kt(r2), typeof e2 == "function" && t2 === "prototype" && "value" in r2 && Vt in r2 && !r2.writable) {
          var i2 = Qt(e2, t2);
          i2 && i2.writable && (e2[t2] = r2.value, r2 = { configurable: Ft in r2 ? r2.configurable : i2.configurable, enumerable: xt in r2 ? r2.enumerable : i2.enumerable, writable: false });
        }
        return Ut(e2, t2, r2);
      } : Ut : function(e2, t2, r2) {
        if (kt(e2), t2 = Bt(t2), kt(r2), Lt)
          try {
            return Ut(e2, t2, r2);
          } catch (e3) {
          }
        if ("get" in r2 || "set" in r2)
          throw Mt("Accessors not supported");
        return "value" in r2 && (e2[t2] = r2.value), e2;
      };
      var jt = Rt, Gt = f, Kt = o ? function(e2, t2, r2) {
        return jt.f(e2, t2, Gt(1, r2));
      } : function(e2, t2, r2) {
        return e2[t2] = r2, e2;
      }, Ht = { exports: {} }, Yt = Q, Wt = be, Jt = v(Function.toString);
      Yt(Wt.inspectSource) || (Wt.inspectSource = function(e2) {
        return Jt(e2);
      });
      var qt, zt, Xt, Zt = Wt.inspectSource, $t = Q, er = Zt, tr = r.WeakMap, rr = $t(tr) && /native code/.test(er(tr)), ir = ve.exports, nr = Fe, or = ir("keys"), sr = function(e2) {
        return or[e2] || (or[e2] = nr(e2));
      }, ar = {}, cr = rr, dr = r, ur = v, Ar = F, hr = Kt, lr = Be, pr = be, gr = sr, fr = ar, Er = "Object already initialized", Ir = dr.TypeError, mr = dr.WeakMap;
      if (cr || pr.state) {
        var _r = pr.state || (pr.state = new mr()), Cr = ur(_r.get), vr = ur(_r.has), Sr = ur(_r.set);
        qt = function(e2, t2) {
          if (vr(_r, e2))
            throw new Ir(Er);
          return t2.facade = e2, Sr(_r, e2, t2), t2;
        }, zt = function(e2) {
          return Cr(_r, e2) || {};
        }, Xt = function(e2) {
          return vr(_r, e2);
        };
      } else {
        var Rr = gr("state");
        fr[Rr] = true, qt = function(e2, t2) {
          if (lr(e2, Rr))
            throw new Ir(Er);
          return t2.facade = e2, hr(e2, Rr, t2), t2;
        }, zt = function(e2) {
          return lr(e2, Rr) ? e2[Rr] : {};
        }, Xt = function(e2) {
          return lr(e2, Rr);
        };
      }
      var yr = { set: qt, get: zt, has: Xt, enforce: function(e2) {
        return Xt(e2) ? zt(e2) : qt(e2, {});
      }, getterFor: function(e2) {
        return function(t2) {
          var r2;
          if (!Ar(t2) || (r2 = zt(t2)).type !== e2)
            throw Ir("Incompatible receiver, " + e2 + " required");
          return r2;
        };
      } }, Tr = o, wr = Be, br = Function.prototype, Or = Tr && Object.getOwnPropertyDescriptor, Nr = wr(br, "name"), Dr = { EXISTS: Nr, PROPER: Nr && function() {
      }.name === "something", CONFIGURABLE: Nr && (!Tr || Tr && Or(br, "name").configurable) }, Lr = r, Pr = Q, kr = Be, Br = Kt, Mr = ye, Ur = Zt, Qr = Dr.CONFIGURABLE, xr = yr.get, Fr = yr.enforce, Vr = String(String).split("String");
      (Ht.exports = function(e2, t2, r2, i2) {
        var n2, o2 = !!i2 && !!i2.unsafe, s2 = !!i2 && !!i2.enumerable, a2 = !!i2 && !!i2.noTargetGet, c2 = i2 && i2.name !== void 0 ? i2.name : t2;
        Pr(r2) && (String(c2).slice(0, 7) === "Symbol(" && (c2 = "[" + String(c2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!kr(r2, "name") || Qr && r2.name !== c2) && Br(r2, "name", c2), (n2 = Fr(r2)).source || (n2.source = Vr.join(typeof c2 == "string" ? c2 : ""))), e2 !== Lr ? (o2 ? !a2 && e2[t2] && (s2 = true) : delete e2[t2], s2 ? e2[t2] = r2 : Br(e2, t2, r2)) : s2 ? e2[t2] = r2 : Mr(t2, r2);
      })(Function.prototype, "toString", function() {
        return Pr(this) && xr(this).source || Ur(this);
      });
      var jr = {}, Gr = Math.ceil, Kr = Math.floor, Hr = function(e2) {
        var t2 = +e2;
        return t2 != t2 || t2 === 0 ? 0 : (t2 > 0 ? Kr : Gr)(t2);
      }, Yr = Hr, Wr = Math.max, Jr = Math.min, qr = function(e2, t2) {
        var r2 = Yr(e2);
        return r2 < 0 ? Wr(r2 + t2, 0) : Jr(r2, t2);
      }, zr = Hr, Xr = Math.min, Zr = function(e2) {
        return e2 > 0 ? Xr(zr(e2), 9007199254740991) : 0;
      }, $r = Zr, ei = function(e2) {
        return $r(e2.length);
      }, ti = U, ri = qr, ii = ei, ni = function(e2) {
        return function(t2, r2, i2) {
          var n2, o2 = ti(t2), s2 = ii(o2), a2 = ri(i2, s2);
          if (e2 && r2 != r2) {
            for (; s2 > a2; )
              if ((n2 = o2[a2++]) != n2)
                return true;
          } else
            for (; s2 > a2; a2++)
              if ((e2 || a2 in o2) && o2[a2] === r2)
                return e2 || a2 || 0;
          return !e2 && -1;
        };
      }, oi = { includes: ni(true), indexOf: ni(false) }, si = Be, ai = U, ci = oi.indexOf, di = ar, ui = v([].push), Ai = function(e2, t2) {
        var r2, i2 = ai(e2), n2 = 0, o2 = [];
        for (r2 in i2)
          !si(di, r2) && si(i2, r2) && ui(o2, r2);
        for (; t2.length > n2; )
          si(i2, r2 = t2[n2++]) && (~ci(o2, r2) || ui(o2, r2));
        return o2;
      }, hi = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], li = Ai, pi = hi.concat("length", "prototype");
      jr.f = Object.getOwnPropertyNames || function(e2) {
        return li(e2, pi);
      };
      var gi = {};
      gi.f = Object.getOwnPropertySymbols;
      var fi = K, Ei = jr, Ii = gi, mi = Nt, _i = v([].concat), Ci = fi("Reflect", "ownKeys") || function(e2) {
        var t2 = Ei.f(mi(e2)), r2 = Ii.f;
        return r2 ? _i(t2, r2(e2)) : t2;
      }, vi = Be, Si = Ci, Ri = i, yi = Rt, Ti = function(e2, t2, r2) {
        for (var i2 = Si(t2), n2 = yi.f, o2 = Ri.f, s2 = 0; s2 < i2.length; s2++) {
          var a2 = i2[s2];
          vi(e2, a2) || r2 && vi(r2, a2) || n2(e2, a2, o2(t2, a2));
        }
      }, wi = n, bi = Q, Oi = /#|\.prototype\./, Ni = function(e2, t2) {
        var r2 = Li[Di(e2)];
        return r2 == ki || r2 != Pi && (bi(t2) ? wi(t2) : !!t2);
      }, Di = Ni.normalize = function(e2) {
        return String(e2).replace(Oi, ".").toLowerCase();
      }, Li = Ni.data = {}, Pi = Ni.NATIVE = "N", ki = Ni.POLYFILL = "P", Bi = Ni, Mi = r, Ui = i.f, Qi = Kt, xi = Ht.exports, Fi = ye, Vi = Ti, ji = Bi, Gi = function(e2, t2) {
        var r2, i2, n2, o2, s2, a2 = e2.target, c2 = e2.global, d2 = e2.stat;
        if (r2 = c2 ? Mi : d2 ? Mi[a2] || Fi(a2, {}) : (Mi[a2] || {}).prototype)
          for (i2 in t2) {
            if (o2 = t2[i2], n2 = e2.noTargetGet ? (s2 = Ui(r2, i2)) && s2.value : r2[i2], !ji(c2 ? i2 : a2 + (d2 ? "." : "#") + i2, e2.forced) && n2 !== void 0) {
              if (typeof o2 == typeof n2)
                continue;
              Vi(o2, n2);
            }
            (e2.sham || n2 && n2.sham) && Qi(o2, "sham", true), xi(r2, i2, o2, e2);
          }
      }, Ki = r.Promise, Hi = Ht.exports, Yi = function(e2, t2, r2) {
        for (var i2 in t2)
          Hi(e2, i2, t2[i2], r2);
        return e2;
      }, Wi = r, Ji = Q, qi = Wi.String, zi = Wi.TypeError, Xi = v, Zi = Nt, $i = function(e2) {
        if (typeof e2 == "object" || Ji(e2))
          return e2;
        throw zi("Can't set " + qi(e2) + " as a prototype");
      }, en = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var e2, t2 = false, r2 = {};
        try {
          (e2 = Xi(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(r2, []), t2 = r2 instanceof Array;
        } catch (e3) {
        }
        return function(r3, i2) {
          return Zi(r3), $i(i2), t2 ? e2(r3, i2) : r3.__proto__ = i2, r3;
        };
      }() : void 0), tn = Rt.f, rn = Be, nn = Xe("toStringTag"), on = function(e2, t2, r2) {
        e2 && !r2 && (e2 = e2.prototype), e2 && !rn(e2, nn) && tn(e2, nn, { configurable: true, value: t2 });
      }, sn = K, an = Rt, cn = o, dn = Xe("species"), un = function(e2) {
        var t2 = sn(e2), r2 = an.f;
        cn && t2 && !t2[dn] && r2(t2, dn, { configurable: true, get: function() {
          return this;
        } });
      }, An = H, hn = r.TypeError, ln = function(e2, t2) {
        if (An(t2, e2))
          return e2;
        throw hn("Incorrect invocation");
      }, pn = ge, gn = s, fn = v(v.bind), En = function(e2, t2) {
        return pn(e2), t2 === void 0 ? e2 : gn ? fn(e2, t2) : function() {
          return e2.apply(t2, arguments);
        };
      }, In = {}, mn = In, _n = Xe("iterator"), Cn = Array.prototype, vn = function(e2) {
        return e2 !== void 0 && (mn.Array === e2 || Cn[_n] === e2);
      }, Sn = {};
      Sn[Xe("toStringTag")] = "z";
      var Rn = r, yn = String(Sn) === "[object z]", Tn = Q, wn = T, bn = Xe("toStringTag"), On = Rn.Object, Nn = wn(function() {
        return arguments;
      }()) == "Arguments", Dn = yn ? wn : function(e2) {
        var t2, r2, i2;
        return e2 === void 0 ? "Undefined" : e2 === null ? "Null" : typeof (r2 = function(e3, t3) {
          try {
            return e3[t3];
          } catch (e4) {
          }
        }(t2 = On(e2), bn)) == "string" ? r2 : Nn ? wn(t2) : (i2 = wn(t2)) == "Object" && Tn(t2.callee) ? "Arguments" : i2;
      }, Ln = Dn, Pn = Ee, kn = In, Bn = Xe("iterator"), Mn = function(e2) {
        if (e2 != null)
          return Pn(e2, Bn) || Pn(e2, "@@iterator") || kn[Ln(e2)];
      }, Un = d, Qn = ge, xn = Nt, Fn = Ae, Vn = Mn, jn = r.TypeError, Gn = function(e2, t2) {
        var r2 = arguments.length < 2 ? Vn(e2) : t2;
        if (Qn(r2))
          return xn(Un(r2, e2));
        throw jn(Fn(e2) + " is not iterable");
      }, Kn = d, Hn = Nt, Yn = Ee, Wn = En, Jn = d, qn = Nt, zn = Ae, Xn = vn, Zn = ei, $n = H, eo = Gn, to = Mn, ro = function(e2, t2, r2) {
        var i2, n2;
        Hn(e2);
        try {
          if (!(i2 = Yn(e2, "return"))) {
            if (t2 === "throw")
              throw r2;
            return r2;
          }
          i2 = Kn(i2, e2);
        } catch (e3) {
          n2 = true, i2 = e3;
        }
        if (t2 === "throw")
          throw r2;
        if (n2)
          throw i2;
        return Hn(i2), r2;
      }, io = r.TypeError, no = function(e2, t2) {
        this.stopped = e2, this.result = t2;
      }, oo = no.prototype, so = Xe("iterator"), ao = false;
      try {
        var co = 0, uo = { next: function() {
          return { done: !!co++ };
        }, return: function() {
          ao = true;
        } };
        uo[so] = function() {
          return this;
        }, Array.from(uo, function() {
          throw 2;
        });
      } catch (e2) {
      }
      var Ao = function(e2, t2) {
        if (!t2 && !ao)
          return false;
        var r2 = false;
        try {
          var i2 = {};
          i2[so] = function() {
            return { next: function() {
              return { done: r2 = true };
            } };
          }, e2(i2);
        } catch (e3) {
        }
        return r2;
      }, ho = v, lo = n, po = Q, go = Dn, fo = Zt, Eo = function() {
      }, Io = [], mo = K("Reflect", "construct"), _o = /^\s*(?:class|function)\b/, Co = ho(_o.exec), vo = !_o.exec(Eo), So = function(e2) {
        if (!po(e2))
          return false;
        try {
          return mo(Eo, Io, e2), true;
        } catch (e3) {
          return false;
        }
      }, Ro = function(e2) {
        if (!po(e2))
          return false;
        switch (go(e2)) {
          case "AsyncFunction":
          case "GeneratorFunction":
          case "AsyncGeneratorFunction":
            return false;
        }
        try {
          return vo || !!Co(_o, fo(e2));
        } catch (e3) {
          return true;
        }
      };
      Ro.sham = true;
      var yo, To, wo, bo, Oo = !mo || lo(function() {
        var e2;
        return So(So.call) || !So(Object) || !So(function() {
          e2 = true;
        }) || e2;
      }) ? Ro : So, No = Oo, Do = Ae, Lo = r.TypeError, Po = function(e2) {
        if (No(e2))
          return e2;
        throw Lo(Do(e2) + " is not a constructor");
      }, ko = Nt, Bo = Po, Mo = Xe("species"), Uo = function(e2, t2) {
        var r2, i2 = ko(e2).constructor;
        return i2 === void 0 || (r2 = ko(i2)[Mo]) == null ? t2 : Bo(r2);
      }, Qo = s, xo = Function.prototype, Fo = xo.apply, Vo = xo.call, jo = typeof Reflect == "object" && Reflect.apply || (Qo ? Vo.bind(Fo) : function() {
        return Vo.apply(Fo, arguments);
      }), Go = K("document", "documentElement"), Ko = v([].slice), Ho = /(?:ipad|iphone|ipod).*applewebkit/i.test(Y), Yo = T(r.process) == "process", Wo = r, Jo = jo, qo = En, zo = Q, Xo = Be, Zo = n, $o = Go, es = Ko, ts = ht, rs = Ho, is = Yo, ns = Wo.setImmediate, os = Wo.clearImmediate, ss = Wo.process, as = Wo.Dispatch, cs = Wo.Function, ds = Wo.MessageChannel, us = Wo.String, As = 0, hs = {}, ls = "onreadystatechange";
      try {
        yo = Wo.location;
      } catch (e2) {
      }
      var ps = function(e2) {
        if (Xo(hs, e2)) {
          var t2 = hs[e2];
          delete hs[e2], t2();
        }
      }, gs = function(e2) {
        return function() {
          ps(e2);
        };
      }, fs = function(e2) {
        ps(e2.data);
      }, Es = function(e2) {
        Wo.postMessage(us(e2), yo.protocol + "//" + yo.host);
      };
      ns && os || (ns = function(e2) {
        var t2 = es(arguments, 1);
        return hs[++As] = function() {
          Jo(zo(e2) ? e2 : cs(e2), void 0, t2);
        }, To(As), As;
      }, os = function(e2) {
        delete hs[e2];
      }, is ? To = function(e2) {
        ss.nextTick(gs(e2));
      } : as && as.now ? To = function(e2) {
        as.now(gs(e2));
      } : ds && !rs ? (bo = (wo = new ds()).port2, wo.port1.onmessage = fs, To = qo(bo.postMessage, bo)) : Wo.addEventListener && zo(Wo.postMessage) && !Wo.importScripts && yo && yo.protocol !== "file:" && !Zo(Es) ? (To = Es, Wo.addEventListener("message", fs, false)) : To = ls in ts("script") ? function(e2) {
        $o.appendChild(ts("script")).onreadystatechange = function() {
          $o.removeChild(this), ps(e2);
        };
      } : function(e2) {
        setTimeout(gs(e2), 0);
      });
      var Is, ms, _s, Cs, vs, Ss, Rs, ys, Ts = { set: ns, clear: os }, ws = r, bs = /ipad|iphone|ipod/i.test(Y) && ws.Pebble !== void 0, Os = /web0s(?!.*chrome)/i.test(Y), Ns = r, Ds = En, Ls = i.f, Ps = Ts.set, ks = Ho, Bs = bs, Ms = Os, Us = Yo, Qs = Ns.MutationObserver || Ns.WebKitMutationObserver, xs = Ns.document, Fs = Ns.process, Vs = Ns.Promise, js = Ls(Ns, "queueMicrotask"), Gs = js && js.value;
      Gs || (Is = function() {
        var e2, t2;
        for (Us && (e2 = Fs.domain) && e2.exit(); ms; ) {
          t2 = ms.fn, ms = ms.next;
          try {
            t2();
          } catch (e3) {
            throw ms ? Cs() : _s = void 0, e3;
          }
        }
        _s = void 0, e2 && e2.enter();
      }, ks || Us || Ms || !Qs || !xs ? !Bs && Vs && Vs.resolve ? ((Rs = Vs.resolve(void 0)).constructor = Vs, ys = Ds(Rs.then, Rs), Cs = function() {
        ys(Is);
      }) : Us ? Cs = function() {
        Fs.nextTick(Is);
      } : (Ps = Ds(Ps, Ns), Cs = function() {
        Ps(Is);
      }) : (vs = true, Ss = xs.createTextNode(""), new Qs(Is).observe(Ss, { characterData: true }), Cs = function() {
        Ss.data = vs = !vs;
      }));
      var Ks = Gs || function(e2) {
        var t2 = { fn: e2, next: void 0 };
        _s && (_s.next = t2), ms || (ms = t2, Cs()), _s = t2;
      }, Hs = {}, Ys = ge, Ws = function(e2) {
        var t2, r2;
        this.promise = new e2(function(e3, i2) {
          if (t2 !== void 0 || r2 !== void 0)
            throw TypeError("Bad Promise constructor");
          t2 = e3, r2 = i2;
        }), this.resolve = Ys(t2), this.reject = Ys(r2);
      };
      Hs.f = function(e2) {
        return new Ws(e2);
      };
      var Js = Nt, qs = F, zs = Hs, Xs = function(e2, t2) {
        if (Js(e2), qs(t2) && t2.constructor === e2)
          return t2;
        var r2 = zs.f(e2);
        return (0, r2.resolve)(t2), r2.promise;
      }, Zs = r, $s = function() {
        this.head = null, this.tail = null;
      };
      $s.prototype = { add: function(e2) {
        var t2 = { item: e2, next: null };
        this.head ? this.tail.next = t2 : this.head = t2, this.tail = t2;
      }, get: function() {
        var e2 = this.head;
        if (e2)
          return this.head = e2.next, this.tail === e2 && (this.tail = null), e2.item;
      } };
      var ea, ta, ra, ia, na = $s, oa = typeof window == "object", sa = Gi, aa = r, ca = K, da = d, ua = Ki, Aa = Ht.exports, ha = Yi, la = en, pa = on, ga = un, fa = ge, Ea = Q, Ia = F, ma = ln, _a = Zt, Ca = function(e2, t2, r2) {
        var i2, n2, o2, s2, a2, c2, d2, u2 = r2 && r2.that, A2 = !(!r2 || !r2.AS_ENTRIES), h2 = !(!r2 || !r2.IS_ITERATOR), l2 = !(!r2 || !r2.INTERRUPTED), p2 = Wn(t2, u2), g2 = function(e3) {
          return i2 && ro(i2, "normal", e3), new no(true, e3);
        }, f2 = function(e3) {
          return A2 ? (qn(e3), l2 ? p2(e3[0], e3[1], g2) : p2(e3[0], e3[1])) : l2 ? p2(e3, g2) : p2(e3);
        };
        if (h2)
          i2 = e2;
        else {
          if (!(n2 = to(e2)))
            throw io(zn(e2) + " is not iterable");
          if (Xn(n2)) {
            for (o2 = 0, s2 = Zn(e2); s2 > o2; o2++)
              if ((a2 = f2(e2[o2])) && $n(oo, a2))
                return a2;
            return new no(false);
          }
          i2 = eo(e2, n2);
        }
        for (c2 = i2.next; !(d2 = Jn(c2, i2)).done; ) {
          try {
            a2 = f2(d2.value);
          } catch (e3) {
            ro(i2, "throw", e3);
          }
          if (typeof a2 == "object" && a2 && $n(oo, a2))
            return a2;
        }
        return new no(false);
      }, va = Ao, Sa = Uo, Ra = Ts.set, ya = Ks, Ta = Xs, wa = function(e2, t2) {
        var r2 = Zs.console;
        r2 && r2.error && (arguments.length == 1 ? r2.error(e2) : r2.error(e2, t2));
      }, ba = Hs, Oa = function(e2) {
        try {
          return { error: false, value: e2() };
        } catch (e3) {
          return { error: true, value: e3 };
        }
      }, Na = na, Da = yr, La = Bi, Pa = oa, ka = Yo, Ba = $, Ma = Xe("species"), Ua = "Promise", Qa = Da.getterFor(Ua), xa = Da.set, Fa = Da.getterFor(Ua), Va = ua && ua.prototype, ja = ua, Ga = Va, Ka = aa.TypeError, Ha = aa.document, Ya = aa.process, Wa = ba.f, Ja = Wa, qa = !!(Ha && Ha.createEvent && aa.dispatchEvent), za = Ea(aa.PromiseRejectionEvent), Xa = "unhandledrejection", Za = false, $a = La(Ua, function() {
        var e2 = _a(ja), t2 = e2 !== String(ja);
        if (!t2 && Ba === 66)
          return true;
        if (Ba >= 51 && /native code/.test(e2))
          return false;
        var r2 = new ja(function(e3) {
          e3(1);
        }), i2 = function(e3) {
          e3(function() {
          }, function() {
          });
        };
        return (r2.constructor = {})[Ma] = i2, !(Za = r2.then(function() {
        }) instanceof i2) || !t2 && Pa && !za;
      }), ec = $a || !va(function(e2) {
        ja.all(e2).catch(function() {
        });
      }), tc = function(e2) {
        var t2;
        return !(!Ia(e2) || !Ea(t2 = e2.then)) && t2;
      }, rc = function(e2, t2) {
        var r2, i2, n2, o2 = t2.value, s2 = t2.state == 1, a2 = s2 ? e2.ok : e2.fail, c2 = e2.resolve, d2 = e2.reject, u2 = e2.domain;
        try {
          a2 ? (s2 || (t2.rejection === 2 && ac(t2), t2.rejection = 1), a2 === true ? r2 = o2 : (u2 && u2.enter(), r2 = a2(o2), u2 && (u2.exit(), n2 = true)), r2 === e2.promise ? d2(Ka("Promise-chain cycle")) : (i2 = tc(r2)) ? da(i2, r2, c2, d2) : c2(r2)) : d2(o2);
        } catch (e3) {
          u2 && !n2 && u2.exit(), d2(e3);
        }
      }, ic = function(e2, t2) {
        e2.notified || (e2.notified = true, ya(function() {
          for (var r2, i2 = e2.reactions; r2 = i2.get(); )
            rc(r2, e2);
          e2.notified = false, t2 && !e2.rejection && oc(e2);
        }));
      }, nc = function(e2, t2, r2) {
        var i2, n2;
        qa ? ((i2 = Ha.createEvent("Event")).promise = t2, i2.reason = r2, i2.initEvent(e2, false, true), aa.dispatchEvent(i2)) : i2 = { promise: t2, reason: r2 }, !za && (n2 = aa["on" + e2]) ? n2(i2) : e2 === Xa && wa("Unhandled promise rejection", r2);
      }, oc = function(e2) {
        da(Ra, aa, function() {
          var t2, r2 = e2.facade, i2 = e2.value;
          if (sc(e2) && (t2 = Oa(function() {
            ka ? Ya.emit("unhandledRejection", i2, r2) : nc(Xa, r2, i2);
          }), e2.rejection = ka || sc(e2) ? 2 : 1, t2.error))
            throw t2.value;
        });
      }, sc = function(e2) {
        return e2.rejection !== 1 && !e2.parent;
      }, ac = function(e2) {
        da(Ra, aa, function() {
          var t2 = e2.facade;
          ka ? Ya.emit("rejectionHandled", t2) : nc("rejectionhandled", t2, e2.value);
        });
      }, cc = function(e2, t2, r2) {
        return function(i2) {
          e2(t2, i2, r2);
        };
      }, dc = function(e2, t2, r2) {
        e2.done || (e2.done = true, r2 && (e2 = r2), e2.value = t2, e2.state = 2, ic(e2, true));
      }, uc = function(e2, t2, r2) {
        if (!e2.done) {
          e2.done = true, r2 && (e2 = r2);
          try {
            if (e2.facade === t2)
              throw Ka("Promise can't be resolved itself");
            var i2 = tc(t2);
            i2 ? ya(function() {
              var r3 = { done: false };
              try {
                da(i2, t2, cc(uc, r3, e2), cc(dc, r3, e2));
              } catch (t3) {
                dc(r3, t3, e2);
              }
            }) : (e2.value = t2, e2.state = 1, ic(e2, false));
          } catch (t3) {
            dc({ done: false }, t3, e2);
          }
        }
      };
      if ($a && (Ga = (ja = function(e2) {
        ma(this, Ga), fa(e2), da(ea, this);
        var t2 = Qa(this);
        try {
          e2(cc(uc, t2), cc(dc, t2));
        } catch (e3) {
          dc(t2, e3);
        }
      }).prototype, (ea = function(e2) {
        xa(this, { type: Ua, done: false, notified: false, parent: false, reactions: new Na(), rejection: false, state: 0, value: void 0 });
      }).prototype = ha(Ga, { then: function(e2, t2) {
        var r2 = Fa(this), i2 = Wa(Sa(this, ja));
        return r2.parent = true, i2.ok = !Ea(e2) || e2, i2.fail = Ea(t2) && t2, i2.domain = ka ? Ya.domain : void 0, r2.state == 0 ? r2.reactions.add(i2) : ya(function() {
          rc(i2, r2);
        }), i2.promise;
      }, catch: function(e2) {
        return this.then(void 0, e2);
      } }), ta = function() {
        var e2 = new ea(), t2 = Qa(e2);
        this.promise = e2, this.resolve = cc(uc, t2), this.reject = cc(dc, t2);
      }, ba.f = Wa = function(e2) {
        return e2 === ja || e2 === ra ? new ta(e2) : Ja(e2);
      }, Ea(ua) && Va !== Object.prototype)) {
        ia = Va.then, Za || (Aa(Va, "then", function(e2, t2) {
          var r2 = this;
          return new ja(function(e3, t3) {
            da(ia, r2, e3, t3);
          }).then(e2, t2);
        }, { unsafe: true }), Aa(Va, "catch", Ga.catch, { unsafe: true }));
        try {
          delete Va.constructor;
        } catch (e2) {
        }
        la && la(Va, Ga);
      }
      sa({ global: true, wrap: true, forced: $a }, { Promise: ja }), pa(ja, Ua, false), ga(Ua), ra = ca(Ua), sa({ target: Ua, stat: true, forced: $a }, { reject: function(e2) {
        var t2 = Wa(this);
        return da(t2.reject, void 0, e2), t2.promise;
      } }), sa({ target: Ua, stat: true, forced: $a }, { resolve: function(e2) {
        return Ta(this, e2);
      } }), sa({ target: Ua, stat: true, forced: ec }, { all: function(e2) {
        var t2 = this, r2 = Wa(t2), i2 = r2.resolve, n2 = r2.reject, o2 = Oa(function() {
          var r3 = fa(t2.resolve), o3 = [], s2 = 0, a2 = 1;
          Ca(e2, function(e3) {
            var c2 = s2++, d2 = false;
            a2++, da(r3, t2, e3).then(function(e4) {
              d2 || (d2 = true, o3[c2] = e4, --a2 || i2(o3));
            }, n2);
          }), --a2 || i2(o3);
        });
        return o2.error && n2(o2.value), r2.promise;
      }, race: function(e2) {
        var t2 = this, r2 = Wa(t2), i2 = r2.reject, n2 = Oa(function() {
          var n3 = fa(t2.resolve);
          Ca(e2, function(e3) {
            da(n3, t2, e3).then(r2.resolve, i2);
          });
        });
        return n2.error && i2(n2.value), r2.promise;
      } });
      var Ac = Gi, hc = K, lc = jo, pc = v, gc = n, fc = r.Array, Ec = hc("JSON", "stringify"), Ic = pc(/./.exec), mc = pc("".charAt), _c = pc("".charCodeAt), Cc = pc("".replace), vc = pc(1 .toString), Sc = /[\uD800-\uDFFF]/g, Rc = /^[\uD800-\uDBFF]$/, yc = /^[\uDC00-\uDFFF]$/, Tc = function(e2, t2, r2) {
        var i2 = mc(r2, t2 - 1), n2 = mc(r2, t2 + 1);
        return Ic(Rc, e2) && !Ic(yc, n2) || Ic(yc, e2) && !Ic(Rc, i2) ? "\\u" + vc(_c(e2, 0), 16) : e2;
      }, wc = gc(function() {
        return Ec("\uDF06\uD834") !== '"\\udf06\\ud834"' || Ec("\uDEAD") !== '"\\udead"';
      });
      Ec && Ac({ target: "JSON", stat: true, forced: wc }, { stringify: function(e2, t2, r2) {
        for (var i2 = 0, n2 = arguments.length, o2 = fc(n2); i2 < n2; i2++)
          o2[i2] = arguments[i2];
        var s2 = lc(Ec, null, o2);
        return typeof s2 == "string" ? Cc(s2, Sc, Tc) : s2;
      } });
      var bc = function(e2) {
        try {
          return !!e2();
        } catch (e3) {
          return true;
        }
      }, Oc = !bc(function() {
        var e2 = function() {
        }.bind();
        return typeof e2 != "function" || e2.hasOwnProperty("prototype");
      }), Nc = Oc, Dc = Function.prototype, Lc = Dc.bind, Pc = Dc.call, kc = Nc && Lc.bind(Pc, Pc), Bc = Nc ? function(e2) {
        return e2 && kc(e2);
      } : function(e2) {
        return e2 && function() {
          return Pc.apply(e2, arguments);
        };
      }, Mc = Bc({}.isPrototypeOf), Uc = function(e2) {
        return e2 && e2.Math == Math && e2;
      }, Qc = Uc(typeof globalThis == "object" && globalThis) || Uc(typeof window == "object" && window) || Uc(typeof self == "object" && self) || Uc(typeof e == "object" && e) || function() {
        return this;
      }() || Function("return this")(), xc = Oc, Fc = Function.prototype, Vc = Fc.apply, jc = Fc.call, Gc = typeof Reflect == "object" && Reflect.apply || (xc ? jc.bind(Vc) : function() {
        return jc.apply(Vc, arguments);
      }), Kc = function(e2) {
        return typeof e2 == "function";
      }, Hc = {}, Yc = !bc(function() {
        return Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1] != 7;
      }), Wc = Oc, Jc = Function.prototype.call, qc = Wc ? Jc.bind(Jc) : function() {
        return Jc.apply(Jc, arguments);
      }, zc = {}, Xc = {}.propertyIsEnumerable, Zc = Object.getOwnPropertyDescriptor, $c = Zc && !Xc.call({ 1: 2 }, 1);
      zc.f = $c ? function(e2) {
        var t2 = Zc(this, e2);
        return !!t2 && t2.enumerable;
      } : Xc;
      var ed, td, rd = function(e2, t2) {
        return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t2 };
      }, id = Bc, nd = id({}.toString), od = id("".slice), sd = function(e2) {
        return od(nd(e2), 8, -1);
      }, ad = Bc, cd = bc, dd = sd, ud = Qc.Object, Ad = ad("".split), hd = cd(function() {
        return !ud("z").propertyIsEnumerable(0);
      }) ? function(e2) {
        return dd(e2) == "String" ? Ad(e2, "") : ud(e2);
      } : ud, ld = Qc.TypeError, pd = function(e2) {
        if (e2 == null)
          throw ld("Can't call method on " + e2);
        return e2;
      }, gd = hd, fd = pd, Ed = function(e2) {
        return gd(fd(e2));
      }, Id = Kc, md = function(e2) {
        return typeof e2 == "object" ? e2 !== null : Id(e2);
      }, _d = {}, Cd = _d, vd = Qc, Sd = Kc, Rd = function(e2) {
        return Sd(e2) ? e2 : void 0;
      }, yd = function(e2, t2) {
        return arguments.length < 2 ? Rd(Cd[e2]) || Rd(vd[e2]) : Cd[e2] && Cd[e2][t2] || vd[e2] && vd[e2][t2];
      }, Td = yd("navigator", "userAgent") || "", wd = Qc, bd = Td, Od = wd.process, Nd = wd.Deno, Dd = Od && Od.versions || Nd && Nd.version, Ld = Dd && Dd.v8;
      Ld && (td = (ed = Ld.split("."))[0] > 0 && ed[0] < 4 ? 1 : +(ed[0] + ed[1])), !td && bd && (!(ed = bd.match(/Edge\/(\d+)/)) || ed[1] >= 74) && (ed = bd.match(/Chrome\/(\d+)/)) && (td = +ed[1]);
      var Pd = td, kd = Pd, Bd = bc, Md = !!Object.getOwnPropertySymbols && !Bd(function() {
        var e2 = Symbol();
        return !String(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && kd && kd < 41;
      }), Ud = Md && !Symbol.sham && typeof Symbol.iterator == "symbol", Qd = yd, xd = Kc, Fd = Mc, Vd = Ud, jd = Qc.Object, Gd = Vd ? function(e2) {
        return typeof e2 == "symbol";
      } : function(e2) {
        var t2 = Qd("Symbol");
        return xd(t2) && Fd(t2.prototype, jd(e2));
      }, Kd = Qc.String, Hd = function(e2) {
        try {
          return Kd(e2);
        } catch (e3) {
          return "Object";
        }
      }, Yd = Kc, Wd = Hd, Jd = Qc.TypeError, qd = function(e2) {
        if (Yd(e2))
          return e2;
        throw Jd(Wd(e2) + " is not a function");
      }, zd = qd, Xd = function(e2, t2) {
        var r2 = e2[t2];
        return r2 == null ? void 0 : zd(r2);
      }, Zd = qc, $d = Kc, eu = md, tu = Qc.TypeError, ru = { exports: {} }, iu = Qc, nu = Object.defineProperty, ou = function(e2, t2) {
        try {
          nu(iu, e2, { value: t2, configurable: true, writable: true });
        } catch (r2) {
          iu[e2] = t2;
        }
        return t2;
      }, su = "__core-js_shared__", au = Qc[su] || ou(su, {}), cu = au;
      (ru.exports = function(e2, t2) {
        return cu[e2] || (cu[e2] = t2 !== void 0 ? t2 : {});
      })("versions", []).push({ version: "3.20.3", mode: "pure", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.20.3/LICENSE", source: "https://github.com/zloirock/core-js" });
      var du = pd, uu = Qc.Object, Au = function(e2) {
        return uu(du(e2));
      }, hu = Au, lu = Bc({}.hasOwnProperty), pu = Object.hasOwn || function(e2, t2) {
        return lu(hu(e2), t2);
      }, gu = Bc, fu = 0, Eu = Math.random(), Iu = gu(1 .toString), mu = function(e2) {
        return "Symbol(" + (e2 === void 0 ? "" : e2) + ")_" + Iu(++fu + Eu, 36);
      }, _u = Qc, Cu = ru.exports, vu = pu, Su = mu, Ru = Md, yu = Ud, Tu = Cu("wks"), wu = _u.Symbol, bu = wu && wu.for, Ou = yu ? wu : wu && wu.withoutSetter || Su, Nu = function(e2) {
        if (!vu(Tu, e2) || !Ru && typeof Tu[e2] != "string") {
          var t2 = "Symbol." + e2;
          Ru && vu(wu, e2) ? Tu[e2] = wu[e2] : Tu[e2] = yu && bu ? bu(t2) : Ou(t2);
        }
        return Tu[e2];
      }, Du = qc, Lu = md, Pu = Gd, ku = Xd, Bu = function(e2, t2) {
        var r2, i2;
        if (t2 === "string" && $d(r2 = e2.toString) && !eu(i2 = Zd(r2, e2)))
          return i2;
        if ($d(r2 = e2.valueOf) && !eu(i2 = Zd(r2, e2)))
          return i2;
        if (t2 !== "string" && $d(r2 = e2.toString) && !eu(i2 = Zd(r2, e2)))
          return i2;
        throw tu("Can't convert object to primitive value");
      }, Mu = Nu, Uu = Qc.TypeError, Qu = Mu("toPrimitive"), xu = function(e2, t2) {
        if (!Lu(e2) || Pu(e2))
          return e2;
        var r2, i2 = ku(e2, Qu);
        if (i2) {
          if (t2 === void 0 && (t2 = "default"), r2 = Du(i2, e2, t2), !Lu(r2) || Pu(r2))
            return r2;
          throw Uu("Can't convert object to primitive value");
        }
        return t2 === void 0 && (t2 = "number"), Bu(e2, t2);
      }, Fu = Gd, Vu = function(e2) {
        var t2 = xu(e2, "string");
        return Fu(t2) ? t2 : t2 + "";
      }, ju = md, Gu = Qc.document, Ku = ju(Gu) && ju(Gu.createElement), Hu = function(e2) {
        return Ku ? Gu.createElement(e2) : {};
      }, Yu = Hu, Wu = !Yc && !bc(function() {
        return Object.defineProperty(Yu("div"), "a", { get: function() {
          return 7;
        } }).a != 7;
      }), Ju = Yc, qu = qc, zu = zc, Xu = rd, Zu = Ed, $u = Vu, eA = pu, tA = Wu, rA = Object.getOwnPropertyDescriptor;
      Hc.f = Ju ? rA : function(e2, t2) {
        if (e2 = Zu(e2), t2 = $u(t2), tA)
          try {
            return rA(e2, t2);
          } catch (e3) {
          }
        if (eA(e2, t2))
          return Xu(!qu(zu.f, e2, t2), e2[t2]);
      };
      var iA = bc, nA = Kc, oA = /#|\.prototype\./, sA = function(e2, t2) {
        var r2 = cA[aA(e2)];
        return r2 == uA || r2 != dA && (nA(t2) ? iA(t2) : !!t2);
      }, aA = sA.normalize = function(e2) {
        return String(e2).replace(oA, ".").toLowerCase();
      }, cA = sA.data = {}, dA = sA.NATIVE = "N", uA = sA.POLYFILL = "P", AA = sA, hA = qd, lA = Oc, pA = Bc(Bc.bind), gA = function(e2, t2) {
        return hA(e2), t2 === void 0 ? e2 : lA ? pA(e2, t2) : function() {
          return e2.apply(t2, arguments);
        };
      }, fA = {}, EA = Yc && bc(function() {
        return Object.defineProperty(function() {
        }, "prototype", { value: 42, writable: false }).prototype != 42;
      }), IA = Qc, mA = md, _A = IA.String, CA = IA.TypeError, vA = function(e2) {
        if (mA(e2))
          return e2;
        throw CA(_A(e2) + " is not an object");
      }, SA = Yc, RA = Wu, yA = EA, TA = vA, wA = Vu, bA = Qc.TypeError, OA = Object.defineProperty, NA = Object.getOwnPropertyDescriptor, DA = "enumerable", LA = "configurable", PA = "writable";
      fA.f = SA ? yA ? function(e2, t2, r2) {
        if (TA(e2), t2 = wA(t2), TA(r2), typeof e2 == "function" && t2 === "prototype" && "value" in r2 && PA in r2 && !r2.writable) {
          var i2 = NA(e2, t2);
          i2 && i2.writable && (e2[t2] = r2.value, r2 = { configurable: LA in r2 ? r2.configurable : i2.configurable, enumerable: DA in r2 ? r2.enumerable : i2.enumerable, writable: false });
        }
        return OA(e2, t2, r2);
      } : OA : function(e2, t2, r2) {
        if (TA(e2), t2 = wA(t2), TA(r2), RA)
          try {
            return OA(e2, t2, r2);
          } catch (e3) {
          }
        if ("get" in r2 || "set" in r2)
          throw bA("Accessors not supported");
        return "value" in r2 && (e2[t2] = r2.value), e2;
      };
      var kA = fA, BA = rd, MA = Yc ? function(e2, t2, r2) {
        return kA.f(e2, t2, BA(1, r2));
      } : function(e2, t2, r2) {
        return e2[t2] = r2, e2;
      }, UA = Qc, QA = Gc, xA = Bc, FA = Kc, VA = Hc.f, jA = AA, GA = _d, KA = gA, HA = MA, YA = pu, WA = function(e2) {
        var t2 = function(r2, i2, n2) {
          if (this instanceof t2) {
            switch (arguments.length) {
              case 0:
                return new e2();
              case 1:
                return new e2(r2);
              case 2:
                return new e2(r2, i2);
            }
            return new e2(r2, i2, n2);
          }
          return QA(e2, this, arguments);
        };
        return t2.prototype = e2.prototype, t2;
      }, JA = function(e2, t2) {
        var r2, i2, n2, o2, s2, a2, c2, d2, u2 = e2.target, A2 = e2.global, h2 = e2.stat, l2 = e2.proto, p2 = A2 ? UA : h2 ? UA[u2] : (UA[u2] || {}).prototype, g2 = A2 ? GA : GA[u2] || HA(GA, u2, {})[u2], f2 = g2.prototype;
        for (n2 in t2)
          r2 = !jA(A2 ? n2 : u2 + (h2 ? "." : "#") + n2, e2.forced) && p2 && YA(p2, n2), s2 = g2[n2], r2 && (a2 = e2.noTargetGet ? (d2 = VA(p2, n2)) && d2.value : p2[n2]), o2 = r2 && a2 ? a2 : t2[n2], r2 && typeof s2 == typeof o2 || (c2 = e2.bind && r2 ? KA(o2, UA) : e2.wrap && r2 ? WA(o2) : l2 && FA(o2) ? xA(o2) : o2, (e2.sham || o2 && o2.sham || s2 && s2.sham) && HA(c2, "sham", true), HA(g2, n2, c2), l2 && (YA(GA, i2 = u2 + "Prototype") || HA(GA, i2, {}), HA(GA[i2], n2, o2), e2.real && f2 && !f2[n2] && HA(f2, n2, o2)));
      }, qA = Math.ceil, zA = Math.floor, XA = function(e2) {
        var t2 = +e2;
        return t2 != t2 || t2 === 0 ? 0 : (t2 > 0 ? zA : qA)(t2);
      }, ZA = XA, $A = Math.min, eh = function(e2) {
        return e2 > 0 ? $A(ZA(e2), 9007199254740991) : 0;
      }, th = function(e2) {
        return eh(e2.length);
      }, rh = qd, ih = Au, nh = hd, oh = th, sh = Qc.TypeError, ah = function(e2) {
        return function(t2, r2, i2, n2) {
          rh(r2);
          var o2 = ih(t2), s2 = nh(o2), a2 = oh(o2), c2 = e2 ? a2 - 1 : 0, d2 = e2 ? -1 : 1;
          if (i2 < 2)
            for (; ; ) {
              if (c2 in s2) {
                n2 = s2[c2], c2 += d2;
                break;
              }
              if (c2 += d2, e2 ? c2 < 0 : a2 <= c2)
                throw sh("Reduce of empty array with no initial value");
            }
          for (; e2 ? c2 >= 0 : a2 > c2; c2 += d2)
            c2 in s2 && (n2 = r2(n2, s2[c2], c2, o2));
          return n2;
        };
      }, ch = { left: ah(false), right: ah(true) }, dh = bc, uh = function(e2, t2) {
        var r2 = [][e2];
        return !!r2 && dh(function() {
          r2.call(null, t2 || function() {
            throw 1;
          }, 1);
        });
      }, Ah = sd(Qc.process) == "process", hh = ch.left, lh = Pd, ph = Ah;
      JA({ target: "Array", proto: true, forced: !uh("reduce") || !ph && lh > 79 && lh < 83 }, { reduce: function(e2) {
        var t2 = arguments.length;
        return hh(this, e2, t2, t2 > 1 ? arguments[1] : void 0);
      } });
      var gh = _d, fh = function(e2) {
        return gh[e2 + "Prototype"];
      }, Eh = fh("Array").reduce, Ih = Mc, mh = Eh, _h = Array.prototype, Ch = function(e2) {
        var t2 = e2.reduce;
        return e2 === _h || Ih(_h, e2) && t2 === _h.reduce ? mh : t2;
      }, vh = Ch, Sh = Dn, Rh = r.String, yh = function(e2) {
        if (Sh(e2) === "Symbol")
          throw TypeError("Cannot convert a Symbol value to a string");
        return Rh(e2);
      }, Th = Nt, wh = function() {
        var e2 = Th(this), t2 = "";
        return e2.global && (t2 += "g"), e2.ignoreCase && (t2 += "i"), e2.multiline && (t2 += "m"), e2.dotAll && (t2 += "s"), e2.unicode && (t2 += "u"), e2.sticky && (t2 += "y"), t2;
      }, bh = n, Oh = r.RegExp, Nh = bh(function() {
        var e2 = Oh("a", "y");
        return e2.lastIndex = 2, e2.exec("abcd") != null;
      }), Dh = Nh || bh(function() {
        return !Oh("a", "y").sticky;
      }), Lh = { BROKEN_CARET: Nh || bh(function() {
        var e2 = Oh("^r", "gy");
        return e2.lastIndex = 2, e2.exec("str") != null;
      }), MISSED_STICKY: Dh, UNSUPPORTED_Y: Nh }, Ph = {}, kh = Ai, Bh = hi, Mh = Object.keys || function(e2) {
        return kh(e2, Bh);
      }, Uh = o, Qh = yt, xh = Rt, Fh = Nt, Vh = U, jh = Mh;
      Ph.f = Uh && !Qh ? Object.defineProperties : function(e2, t2) {
        Fh(e2);
        for (var r2, i2 = Vh(t2), n2 = jh(t2), o2 = n2.length, s2 = 0; o2 > s2; )
          xh.f(e2, r2 = n2[s2++], i2[r2]);
        return e2;
      };
      var Gh, Kh = Nt, Hh = Ph, Yh = hi, Wh = ar, Jh = Go, qh = ht, zh = sr("IE_PROTO"), Xh = function() {
      }, Zh = function(e2) {
        return "<script>" + e2 + "<\/script>";
      }, $h = function(e2) {
        e2.write(Zh("")), e2.close();
        var t2 = e2.parentWindow.Object;
        return e2 = null, t2;
      }, el = function() {
        try {
          Gh = new ActiveXObject("htmlfile");
        } catch (e3) {
        }
        var e2, t2;
        el = typeof document != "undefined" ? document.domain && Gh ? $h(Gh) : ((t2 = qh("iframe")).style.display = "none", Jh.appendChild(t2), t2.src = String("javascript:"), (e2 = t2.contentWindow.document).open(), e2.write(Zh("document.F=Object")), e2.close(), e2.F) : $h(Gh);
        for (var r2 = Yh.length; r2--; )
          delete el.prototype[Yh[r2]];
        return el();
      };
      Wh[zh] = true;
      var tl = Object.create || function(e2, t2) {
        var r2;
        return e2 !== null ? (Xh.prototype = Kh(e2), r2 = new Xh(), Xh.prototype = null, r2[zh] = e2) : r2 = el(), t2 === void 0 ? r2 : Hh.f(r2, t2);
      }, rl = n, il = r.RegExp, nl = rl(function() {
        var e2 = il(".", "s");
        return !(e2.dotAll && e2.exec("\n") && e2.flags === "s");
      }), ol = n, sl = r.RegExp, al = ol(function() {
        var e2 = sl("(?<a>b)", "g");
        return e2.exec("b").groups.a !== "b" || "b".replace(e2, "$<a>c") !== "bc";
      }), cl = d, dl = v, ul = yh, Al = wh, hl = Lh, ll = ve.exports, pl = tl, gl = yr.get, fl = nl, El = al, Il = ll("native-string-replace", String.prototype.replace), ml = RegExp.prototype.exec, _l = ml, Cl = dl("".charAt), vl = dl("".indexOf), Sl = dl("".replace), Rl = dl("".slice), yl = function() {
        var e2 = /a/, t2 = /b*/g;
        return cl(ml, e2, "a"), cl(ml, t2, "a"), e2.lastIndex !== 0 || t2.lastIndex !== 0;
      }(), Tl = hl.BROKEN_CARET, wl = /()??/.exec("")[1] !== void 0;
      (yl || wl || Tl || fl || El) && (_l = function(e2) {
        var t2, r2, i2, n2, o2, s2, a2, c2 = this, d2 = gl(c2), u2 = ul(e2), A2 = d2.raw;
        if (A2)
          return A2.lastIndex = c2.lastIndex, t2 = cl(_l, A2, u2), c2.lastIndex = A2.lastIndex, t2;
        var h2 = d2.groups, l2 = Tl && c2.sticky, p2 = cl(Al, c2), g2 = c2.source, f2 = 0, E2 = u2;
        if (l2 && (p2 = Sl(p2, "y", ""), vl(p2, "g") === -1 && (p2 += "g"), E2 = Rl(u2, c2.lastIndex), c2.lastIndex > 0 && (!c2.multiline || c2.multiline && Cl(u2, c2.lastIndex - 1) !== "\n") && (g2 = "(?: " + g2 + ")", E2 = " " + E2, f2++), r2 = new RegExp("^(?:" + g2 + ")", p2)), wl && (r2 = new RegExp("^" + g2 + "$(?!\\s)", p2)), yl && (i2 = c2.lastIndex), n2 = cl(ml, l2 ? r2 : c2, E2), l2 ? n2 ? (n2.input = Rl(n2.input, f2), n2[0] = Rl(n2[0], f2), n2.index = c2.lastIndex, c2.lastIndex += n2[0].length) : c2.lastIndex = 0 : yl && n2 && (c2.lastIndex = c2.global ? n2.index + n2[0].length : i2), wl && n2 && n2.length > 1 && cl(Il, n2[0], r2, function() {
          for (o2 = 1; o2 < arguments.length - 2; o2++)
            arguments[o2] === void 0 && (n2[o2] = void 0);
        }), n2 && h2)
          for (n2.groups = s2 = pl(null), o2 = 0; o2 < h2.length; o2++)
            s2[(a2 = h2[o2])[0]] = n2[a2[1]];
        return n2;
      });
      var bl = _l;
      Gi({ target: "RegExp", proto: true, forced: /./.exec !== bl }, { exec: bl });
      var Ol = tl, Nl = Rt, Dl = Xe("unscopables"), Ll = Array.prototype;
      Ll[Dl] == null && Nl.f(Ll, Dl, { configurable: true, value: Ol(null) });
      var Pl, kl, Bl, Ml = !n(function() {
        function e2() {
        }
        return e2.prototype.constructor = null, Object.getPrototypeOf(new e2()) !== e2.prototype;
      }), Ul = r, Ql = Be, xl = Q, Fl = Le, Vl = Ml, jl = sr("IE_PROTO"), Gl = Ul.Object, Kl = Gl.prototype, Hl = Vl ? Gl.getPrototypeOf : function(e2) {
        var t2 = Fl(e2);
        if (Ql(t2, jl))
          return t2[jl];
        var r2 = t2.constructor;
        return xl(r2) && t2 instanceof r2 ? r2.prototype : t2 instanceof Gl ? Kl : null;
      }, Yl = n, Wl = Q, Jl = Hl, ql = Ht.exports, zl = Xe("iterator"), Xl = false;
      [].keys && ("next" in (Bl = [].keys()) ? (kl = Jl(Jl(Bl))) !== Object.prototype && (Pl = kl) : Xl = true), (Pl == null || Yl(function() {
        var e2 = {};
        return Pl[zl].call(e2) !== e2;
      })) && (Pl = {}), Wl(Pl[zl]) || ql(Pl, zl, function() {
        return this;
      });
      var Zl = { IteratorPrototype: Pl, BUGGY_SAFARI_ITERATORS: Xl }, $l = Zl.IteratorPrototype, ep = tl, tp = f, rp = on, ip = In, np = function() {
        return this;
      }, op = Gi, sp = d, ap = Dr, cp = Q, dp = function(e2, t2, r2, i2) {
        var n2 = t2 + " Iterator";
        return e2.prototype = ep($l, { next: tp(+!i2, r2) }), rp(e2, n2, false), ip[n2] = np, e2;
      }, up = Hl, Ap = en, hp = on, lp = Kt, pp = Ht.exports, gp = In, fp = ap.PROPER, Ep = ap.CONFIGURABLE, Ip = Zl.IteratorPrototype, mp = Zl.BUGGY_SAFARI_ITERATORS, _p = Xe("iterator"), Cp = "keys", vp = "values", Sp = "entries", Rp = function() {
        return this;
      }, yp = U, Tp = function(e2) {
        Ll[Dl][e2] = true;
      }, wp = In, bp = yr, Op = Rt.f, Np = function(e2, t2, r2, i2, n2, o2, s2) {
        dp(r2, t2, i2);
        var a2, c2, d2, u2 = function(e3) {
          if (e3 === n2 && g2)
            return g2;
          if (!mp && e3 in l2)
            return l2[e3];
          switch (e3) {
            case Cp:
            case vp:
            case Sp:
              return function() {
                return new r2(this, e3);
              };
          }
          return function() {
            return new r2(this);
          };
        }, A2 = t2 + " Iterator", h2 = false, l2 = e2.prototype, p2 = l2[_p] || l2["@@iterator"] || n2 && l2[n2], g2 = !mp && p2 || u2(n2), f2 = t2 == "Array" && l2.entries || p2;
        if (f2 && (a2 = up(f2.call(new e2()))) !== Object.prototype && a2.next && (up(a2) !== Ip && (Ap ? Ap(a2, Ip) : cp(a2[_p]) || pp(a2, _p, Rp)), hp(a2, A2, true)), fp && n2 == vp && p2 && p2.name !== vp && (Ep ? lp(l2, "name", vp) : (h2 = true, g2 = function() {
          return sp(p2, this);
        })), n2)
          if (c2 = { values: u2(vp), keys: o2 ? g2 : u2(Cp), entries: u2(Sp) }, s2)
            for (d2 in c2)
              (mp || h2 || !(d2 in l2)) && pp(l2, d2, c2[d2]);
          else
            op({ target: t2, proto: true, forced: mp || h2 }, c2);
        return l2[_p] !== g2 && pp(l2, _p, g2, { name: n2 }), gp[t2] = g2, c2;
      }, Dp = o, Lp = "Array Iterator", Pp = bp.set, kp = bp.getterFor(Lp), Bp = Np(Array, "Array", function(e2, t2) {
        Pp(this, { type: Lp, target: yp(e2), index: 0, kind: t2 });
      }, function() {
        var e2 = kp(this), t2 = e2.target, r2 = e2.kind, i2 = e2.index++;
        return !t2 || i2 >= t2.length ? (e2.target = void 0, { value: void 0, done: true }) : r2 == "keys" ? { value: i2, done: false } : r2 == "values" ? { value: t2[i2], done: false } : { value: [i2, t2[i2]], done: false };
      }, "values"), Mp = wp.Arguments = wp.Array;
      if (Tp("keys"), Tp("values"), Tp("entries"), Dp && Mp.name !== "values")
        try {
          Op(Mp, "name", { value: "values" });
        } catch (e2) {
        }
      var Up = ht("span").classList, Qp = Up && Up.constructor && Up.constructor.prototype, xp = Qp === Object.prototype ? void 0 : Qp, Fp = r, Vp = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, jp = xp, Gp = Bp, Kp = Kt, Hp = Xe, Yp = Hp("iterator"), Wp = Hp("toStringTag"), Jp = Gp.values, qp = function(e2, t2) {
        if (e2) {
          if (e2[Yp] !== Jp)
            try {
              Kp(e2, Yp, Jp);
            } catch (t3) {
              e2[Yp] = Jp;
            }
          if (e2[Wp] || Kp(e2, Wp, t2), Vp[t2]) {
            for (var r2 in Gp)
              if (e2[r2] !== Gp[r2])
                try {
                  Kp(e2, r2, Gp[r2]);
                } catch (t3) {
                  e2[r2] = Gp[r2];
                }
          }
        }
      };
      for (var zp in Vp)
        qp(Fp[zp] && Fp[zp].prototype, zp);
      qp(jp, "DOMTokenList");
      var Xp = Q, Zp = F, $p = en, eg = function(e2, t2, r2) {
        var i2, n2;
        return $p && Xp(i2 = t2.constructor) && i2 !== r2 && Zp(n2 = i2.prototype) && n2 !== r2.prototype && $p(e2, n2), e2;
      }, tg = yh, rg = function(e2, t2) {
        return e2 === void 0 ? arguments.length < 2 ? "" : t2 : tg(e2);
      }, ig = F, ng = Kt, og = v("".replace), sg = String(Error("zxcasd").stack), ag = /\n\s*at [^:]*:[^\n]*/, cg = ag.test(sg), dg = function(e2, t2) {
        if (cg && typeof e2 == "string")
          for (; t2--; )
            e2 = og(e2, ag, "");
        return e2;
      }, ug = f, Ag = !n(function() {
        var e2 = Error("a");
        return !("stack" in e2) || (Object.defineProperty(e2, "stack", ug(1, 7)), e2.stack !== 7);
      }), hg = K, lg = Be, pg = Kt, gg = H, fg = en, Eg = Ti, Ig = eg, mg = rg, _g = function(e2, t2) {
        ig(t2) && "cause" in t2 && ng(e2, "cause", t2.cause);
      }, Cg = dg, vg = Ag, Sg = Gi, Rg = jo, yg = function(e2, t2, r2, i2) {
        var n2 = i2 ? 2 : 1, o2 = e2.split("."), s2 = o2[o2.length - 1], a2 = hg.apply(null, o2);
        if (a2) {
          var c2 = a2.prototype;
          if (lg(c2, "cause") && delete c2.cause, !r2)
            return a2;
          var d2 = hg("Error"), u2 = t2(function(e3, t3) {
            var r3 = mg(i2 ? t3 : e3, void 0), o3 = i2 ? new a2(e3) : new a2();
            return r3 !== void 0 && pg(o3, "message", r3), vg && pg(o3, "stack", Cg(o3.stack, 2)), this && gg(c2, this) && Ig(o3, this, u2), arguments.length > n2 && _g(o3, arguments[n2]), o3;
          });
          u2.prototype = c2, s2 !== "Error" && (fg ? fg(u2, d2) : Eg(u2, d2, { name: true })), Eg(u2, a2);
          try {
            c2.name !== s2 && pg(c2, "name", s2), c2.constructor = u2;
          } catch (e3) {
          }
          return u2;
        }
      }, Tg = "WebAssembly", wg = r.WebAssembly, bg = Error("e", { cause: 7 }).cause !== 7, Og = function(e2, t2) {
        var r2 = {};
        r2[e2] = yg(e2, t2, bg), Sg({ global: true, forced: bg }, r2);
      }, Ng = function(e2, t2) {
        if (wg && wg[e2]) {
          var r2 = {};
          r2[e2] = yg("WebAssembly." + e2, t2, bg), Sg({ target: Tg, stat: true, forced: bg }, r2);
        }
      };
      Og("Error", function(e2) {
        return function(t2) {
          return Rg(e2, this, arguments);
        };
      }), Og("EvalError", function(e2) {
        return function(t2) {
          return Rg(e2, this, arguments);
        };
      }), Og("RangeError", function(e2) {
        return function(t2) {
          return Rg(e2, this, arguments);
        };
      }), Og("ReferenceError", function(e2) {
        return function(t2) {
          return Rg(e2, this, arguments);
        };
      }), Og("SyntaxError", function(e2) {
        return function(t2) {
          return Rg(e2, this, arguments);
        };
      }), Og("TypeError", function(e2) {
        return function(t2) {
          return Rg(e2, this, arguments);
        };
      }), Og("URIError", function(e2) {
        return function(t2) {
          return Rg(e2, this, arguments);
        };
      }), Ng("CompileError", function(e2) {
        return function(t2) {
          return Rg(e2, this, arguments);
        };
      }), Ng("LinkError", function(e2) {
        return function(t2) {
          return Rg(e2, this, arguments);
        };
      }), Ng("RuntimeError", function(e2) {
        return function(t2) {
          return Rg(e2, this, arguments);
        };
      });
      let Dg = true, Lg = true;
      function Pg(e2, t2, r2) {
        const i2 = e2.match(t2);
        return i2 && i2.length >= r2 && parseInt(i2[r2], 10);
      }
      function kg(e2, t2, r2) {
        if (!e2.RTCPeerConnection)
          return;
        const i2 = e2.RTCPeerConnection.prototype, n2 = i2.addEventListener;
        i2.addEventListener = function(e3, i3) {
          if (e3 !== t2)
            return n2.apply(this, arguments);
          const o3 = (e4) => {
            const t3 = r2(e4);
            t3 && (i3.handleEvent ? i3.handleEvent(t3) : i3(t3));
          };
          return this._eventMap = this._eventMap || {}, this._eventMap[t2] || (this._eventMap[t2] = /* @__PURE__ */ new Map()), this._eventMap[t2].set(i3, o3), n2.apply(this, [e3, o3]);
        };
        const o2 = i2.removeEventListener;
        i2.removeEventListener = function(e3, r3) {
          if (e3 !== t2 || !this._eventMap || !this._eventMap[t2])
            return o2.apply(this, arguments);
          if (!this._eventMap[t2].has(r3))
            return o2.apply(this, arguments);
          const i3 = this._eventMap[t2].get(r3);
          return this._eventMap[t2].delete(r3), this._eventMap[t2].size === 0 && delete this._eventMap[t2], Object.keys(this._eventMap).length === 0 && delete this._eventMap, o2.apply(this, [e3, i3]);
        }, Object.defineProperty(i2, "on" + t2, { get() {
          return this["_on" + t2];
        }, set(e3) {
          this["_on" + t2] && (this.removeEventListener(t2, this["_on" + t2]), delete this["_on" + t2]), e3 && this.addEventListener(t2, this["_on" + t2] = e3);
        }, enumerable: true, configurable: true });
      }
      function Bg(e2) {
        return typeof e2 != "boolean" ? new Error("Argument type: " + typeof e2 + ". Please use a boolean.") : (Dg = e2, e2 ? "adapter.js logging disabled" : "adapter.js logging enabled");
      }
      function Mg(e2) {
        return typeof e2 != "boolean" ? new Error("Argument type: " + typeof e2 + ". Please use a boolean.") : (Lg = !e2, "adapter.js deprecation warnings " + (e2 ? "disabled" : "enabled"));
      }
      function Ug() {
        if (typeof window == "object") {
          if (Dg)
            return;
          typeof console != "undefined" && typeof console.log == "function" && console.log.apply(console, arguments);
        }
      }
      function Qg(e2, t2) {
        Lg && console.warn(e2 + " is deprecated, please use " + t2 + " instead.");
      }
      function xg(e2) {
        const t2 = { browser: null, version: null };
        if (e2 === void 0 || !e2.navigator)
          return t2.browser = "Not a browser.", t2;
        const { navigator: r2 } = e2;
        if (r2.mozGetUserMedia)
          t2.browser = "firefox", t2.version = Pg(r2.userAgent, /Firefox\/(\d+)\./, 1);
        else if (r2.webkitGetUserMedia || e2.isSecureContext === false && e2.webkitRTCPeerConnection && !e2.RTCIceGatherer)
          t2.browser = "chrome", t2.version = Pg(r2.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
        else if (r2.mediaDevices && r2.userAgent.match(/Edge\/(\d+).(\d+)$/))
          t2.browser = "edge", t2.version = Pg(r2.userAgent, /Edge\/(\d+).(\d+)$/, 2);
        else {
          if (!e2.RTCPeerConnection || !r2.userAgent.match(/AppleWebKit\/(\d+)\./))
            return t2.browser = "Not a supported browser.", t2;
          t2.browser = "safari", t2.version = Pg(r2.userAgent, /AppleWebKit\/(\d+)\./, 1), t2.supportsUnifiedPlan = e2.RTCRtpTransceiver && "currentDirection" in e2.RTCRtpTransceiver.prototype;
        }
        return t2;
      }
      function Fg(e2) {
        return Object.prototype.toString.call(e2) === "[object Object]";
      }
      function Vg(e2) {
        var t2;
        return Fg(e2) ? vh(t2 = Object.keys(e2)).call(t2, function(t3, r2) {
          const i2 = Fg(e2[r2]), n2 = i2 ? Vg(e2[r2]) : e2[r2], o2 = i2 && !Object.keys(n2).length;
          return n2 === void 0 || o2 ? t3 : Object.assign(t3, { [r2]: n2 });
        }, {}) : e2;
      }
      function jg(e2, t2, r2) {
        const i2 = r2 ? "outbound-rtp" : "inbound-rtp", n2 = /* @__PURE__ */ new Map();
        if (t2 === null)
          return n2;
        const o2 = [];
        return e2.forEach((e3) => {
          e3.type === "track" && e3.trackIdentifier === t2.id && o2.push(e3);
        }), o2.forEach((t3) => {
          e2.forEach((r3) => {
            r3.type === i2 && r3.trackId === t3.id && function e3(t4, r4, i3) {
              r4 && !i3.has(r4.id) && (i3.set(r4.id, r4), Object.keys(r4).forEach((n3) => {
                n3.endsWith("Id") ? e3(t4, t4.get(r4[n3]), i3) : n3.endsWith("Ids") && r4[n3].forEach((r5) => {
                  e3(t4, t4.get(r5), i3);
                });
              }));
            }(e2, r3, n2);
          });
        }), n2;
      }
      var Gg = ru.exports, Kg = mu, Hg = Gg("keys"), Yg = function(e2) {
        return Hg[e2] || (Hg[e2] = Kg(e2));
      }, Wg = !bc(function() {
        function e2() {
        }
        return e2.prototype.constructor = null, Object.getPrototypeOf(new e2()) !== e2.prototype;
      }), Jg = Qc, qg = pu, zg = Kc, Xg = Au, Zg = Wg, $g = Yg("IE_PROTO"), ef = Jg.Object, tf = ef.prototype, rf = Zg ? ef.getPrototypeOf : function(e2) {
        var t2 = Xg(e2);
        if (qg(t2, $g))
          return t2[$g];
        var r2 = t2.constructor;
        return zg(r2) && t2 instanceof r2 ? r2.prototype : t2 instanceof ef ? tf : null;
      }, nf = Qc, of = Kc, sf = nf.String, af = nf.TypeError, cf = Bc, df = vA, uf = function(e2) {
        if (typeof e2 == "object" || of(e2))
          return e2;
        throw af("Can't set " + sf(e2) + " as a prototype");
      }, Af = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var e2, t2 = false, r2 = {};
        try {
          (e2 = cf(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(r2, []), t2 = r2 instanceof Array;
        } catch (e3) {
        }
        return function(r3, i2) {
          return df(r3), uf(i2), t2 ? e2(r3, i2) : r3.__proto__ = i2, r3;
        };
      }() : void 0), hf = {}, lf = XA, pf = Math.max, gf = Math.min, ff = function(e2, t2) {
        var r2 = lf(e2);
        return r2 < 0 ? pf(r2 + t2, 0) : gf(r2, t2);
      }, Ef = Ed, If = ff, mf = th, _f = function(e2) {
        return function(t2, r2, i2) {
          var n2, o2 = Ef(t2), s2 = mf(o2), a2 = If(i2, s2);
          if (e2 && r2 != r2) {
            for (; s2 > a2; )
              if ((n2 = o2[a2++]) != n2)
                return true;
          } else
            for (; s2 > a2; a2++)
              if ((e2 || a2 in o2) && o2[a2] === r2)
                return e2 || a2 || 0;
          return !e2 && -1;
        };
      }, Cf = { includes: _f(true), indexOf: _f(false) }, vf = {}, Sf = pu, Rf = Ed, yf = Cf.indexOf, Tf = vf, wf = Bc([].push), bf = function(e2, t2) {
        var r2, i2 = Rf(e2), n2 = 0, o2 = [];
        for (r2 in i2)
          !Sf(Tf, r2) && Sf(i2, r2) && wf(o2, r2);
        for (; t2.length > n2; )
          Sf(i2, r2 = t2[n2++]) && (~yf(o2, r2) || wf(o2, r2));
        return o2;
      }, Of = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], Nf = bf, Df = Of.concat("length", "prototype");
      hf.f = Object.getOwnPropertyNames || function(e2) {
        return Nf(e2, Df);
      };
      var Lf = {};
      Lf.f = Object.getOwnPropertySymbols;
      var Pf = yd, kf = hf, Bf = Lf, Mf = vA, Uf = Bc([].concat), Qf = Pf("Reflect", "ownKeys") || function(e2) {
        var t2 = kf.f(Mf(e2)), r2 = Bf.f;
        return r2 ? Uf(t2, r2(e2)) : t2;
      }, xf = pu, Ff = Qf, Vf = Hc, jf = fA, Gf = {}, Kf = bf, Hf = Of, Yf = Object.keys || function(e2) {
        return Kf(e2, Hf);
      }, Wf = Yc, Jf = EA, qf = fA, zf = vA, Xf = Ed, Zf = Yf;
      Gf.f = Wf && !Jf ? Object.defineProperties : function(e2, t2) {
        zf(e2);
        for (var r2, i2 = Xf(t2), n2 = Zf(t2), o2 = n2.length, s2 = 0; o2 > s2; )
          qf.f(e2, r2 = n2[s2++], i2[r2]);
        return e2;
      };
      var $f, eE = yd("document", "documentElement"), tE = vA, rE = Gf, iE = Of, nE = vf, oE = eE, sE = Hu, aE = Yg("IE_PROTO"), cE = function() {
      }, dE = function(e2) {
        return "<script>" + e2 + "<\/script>";
      }, uE = function(e2) {
        e2.write(dE("")), e2.close();
        var t2 = e2.parentWindow.Object;
        return e2 = null, t2;
      }, AE = function() {
        try {
          $f = new ActiveXObject("htmlfile");
        } catch (e3) {
        }
        var e2, t2;
        AE = typeof document != "undefined" ? document.domain && $f ? uE($f) : ((t2 = sE("iframe")).style.display = "none", oE.appendChild(t2), t2.src = String("javascript:"), (e2 = t2.contentWindow.document).open(), e2.write(dE("document.F=Object")), e2.close(), e2.F) : uE($f);
        for (var r2 = iE.length; r2--; )
          delete AE.prototype[iE[r2]];
        return AE();
      };
      nE[aE] = true;
      var hE = Object.create || function(e2, t2) {
        var r2;
        return e2 !== null ? (cE.prototype = tE(e2), r2 = new cE(), cE.prototype = null, r2[aE] = e2) : r2 = AE(), t2 === void 0 ? r2 : rE.f(r2, t2);
      }, lE = Bc("".replace), pE = String(Error("zxcasd").stack), gE = /\n\s*at [^:]*:[^\n]*/, fE = gE.test(pE), EE = md, IE = MA, mE = {}, _E = mE, CE = Nu("iterator"), vE = Array.prototype, SE = function(e2) {
        return e2 !== void 0 && (_E.Array === e2 || vE[CE] === e2);
      }, RE = {};
      RE[Nu("toStringTag")] = "z";
      var yE = String(RE) === "[object z]", TE = Qc, wE = yE, bE = Kc, OE = sd, NE = Nu("toStringTag"), DE = TE.Object, LE = OE(function() {
        return arguments;
      }()) == "Arguments", PE = wE ? OE : function(e2) {
        var t2, r2, i2;
        return e2 === void 0 ? "Undefined" : e2 === null ? "Null" : typeof (r2 = function(e3, t3) {
          try {
            return e3[t3];
          } catch (e4) {
          }
        }(t2 = DE(e2), NE)) == "string" ? r2 : LE ? OE(t2) : (i2 = OE(t2)) == "Object" && bE(t2.callee) ? "Arguments" : i2;
      }, kE = PE, BE = Xd, ME = mE, UE = Nu("iterator"), QE = function(e2) {
        if (e2 != null)
          return BE(e2, UE) || BE(e2, "@@iterator") || ME[kE(e2)];
      }, xE = qc, FE = qd, VE = vA, jE = Hd, GE = QE, KE = Qc.TypeError, HE = function(e2, t2) {
        var r2 = arguments.length < 2 ? GE(e2) : t2;
        if (FE(r2))
          return VE(xE(r2, e2));
        throw KE(jE(e2) + " is not iterable");
      }, YE = qc, WE = vA, JE = Xd, qE = function(e2, t2, r2) {
        var i2, n2;
        WE(e2);
        try {
          if (!(i2 = JE(e2, "return"))) {
            if (t2 === "throw")
              throw r2;
            return r2;
          }
          i2 = YE(i2, e2);
        } catch (e3) {
          n2 = true, i2 = e3;
        }
        if (t2 === "throw")
          throw r2;
        if (n2)
          throw i2;
        return WE(i2), r2;
      }, zE = gA, XE = qc, ZE = vA, $E = Hd, eI = SE, tI = th, rI = Mc, iI = HE, nI = QE, oI = qE, sI = Qc.TypeError, aI = function(e2, t2) {
        this.stopped = e2, this.result = t2;
      }, cI = aI.prototype, dI = function(e2, t2, r2) {
        var i2, n2, o2, s2, a2, c2, d2, u2 = r2 && r2.that, A2 = !(!r2 || !r2.AS_ENTRIES), h2 = !(!r2 || !r2.IS_ITERATOR), l2 = !(!r2 || !r2.INTERRUPTED), p2 = zE(t2, u2), g2 = function(e3) {
          return i2 && oI(i2, "normal", e3), new aI(true, e3);
        }, f2 = function(e3) {
          return A2 ? (ZE(e3), l2 ? p2(e3[0], e3[1], g2) : p2(e3[0], e3[1])) : l2 ? p2(e3, g2) : p2(e3);
        };
        if (h2)
          i2 = e2;
        else {
          if (!(n2 = nI(e2)))
            throw sI($E(e2) + " is not iterable");
          if (eI(n2)) {
            for (o2 = 0, s2 = tI(e2); s2 > o2; o2++)
              if ((a2 = f2(e2[o2])) && rI(cI, a2))
                return a2;
            return new aI(false);
          }
          i2 = iI(e2, n2);
        }
        for (c2 = i2.next; !(d2 = XE(c2, i2)).done; ) {
          try {
            a2 = f2(d2.value);
          } catch (e3) {
            oI(i2, "throw", e3);
          }
          if (typeof a2 == "object" && a2 && rI(cI, a2))
            return a2;
        }
        return new aI(false);
      }, uI = PE, AI = Qc.String, hI = function(e2) {
        if (uI(e2) === "Symbol")
          throw TypeError("Cannot convert a Symbol value to a string");
        return AI(e2);
      }, lI = hI, pI = rd, gI = !bc(function() {
        var e2 = Error("a");
        return !("stack" in e2) || (Object.defineProperty(e2, "stack", pI(1, 7)), e2.stack !== 7);
      }), fI = JA, EI = Qc, II = Mc, mI = rf, _I = Af, CI = function(e2, t2, r2) {
        for (var i2 = Ff(t2), n2 = jf.f, o2 = Vf.f, s2 = 0; s2 < i2.length; s2++) {
          var a2 = i2[s2];
          xf(e2, a2) || r2 && xf(r2, a2) || n2(e2, a2, o2(t2, a2));
        }
      }, vI = hE, SI = MA, RI = rd, yI = function(e2, t2) {
        if (fE && typeof e2 == "string")
          for (; t2--; )
            e2 = lE(e2, gE, "");
        return e2;
      }, TI = function(e2, t2) {
        EE(t2) && "cause" in t2 && IE(e2, "cause", t2.cause);
      }, wI = dI, bI = function(e2, t2) {
        return e2 === void 0 ? arguments.length < 2 ? "" : t2 : lI(e2);
      }, OI = gI, NI = Nu("toStringTag"), DI = EI.Error, LI = [].push, PI = function(e2, t2) {
        var r2, i2 = arguments.length > 2 ? arguments[2] : void 0, n2 = II(kI, this);
        _I ? r2 = _I(new DI(), n2 ? mI(this) : kI) : (r2 = n2 ? this : vI(kI), SI(r2, NI, "Error")), t2 !== void 0 && SI(r2, "message", bI(t2)), OI && SI(r2, "stack", yI(r2.stack, 1)), TI(r2, i2);
        var o2 = [];
        return wI(e2, LI, { that: o2 }), SI(r2, "errors", o2), r2;
      };
      _I ? _I(PI, DI) : CI(PI, DI, { name: true });
      var kI = PI.prototype = vI(DI.prototype, { constructor: RI(1, PI), message: RI(1, ""), name: RI(1, "AggregateError") });
      fI({ global: true }, { AggregateError: PI });
      var BI = Kc, MI = au, UI = Bc(Function.toString);
      BI(MI.inspectSource) || (MI.inspectSource = function(e2) {
        return UI(e2);
      });
      var QI, xI, FI, VI = MI.inspectSource, jI = Kc, GI = VI, KI = Qc.WeakMap, HI = jI(KI) && /native code/.test(GI(KI)), YI = Qc, WI = Bc, JI = md, qI = MA, zI = pu, XI = au, ZI = Yg, $I = vf, em = "Object already initialized", tm = YI.TypeError, rm = YI.WeakMap;
      if (HI || XI.state) {
        var im = XI.state || (XI.state = new rm()), nm = WI(im.get), om = WI(im.has), sm = WI(im.set);
        QI = function(e2, t2) {
          if (om(im, e2))
            throw new tm(em);
          return t2.facade = e2, sm(im, e2, t2), t2;
        }, xI = function(e2) {
          return nm(im, e2) || {};
        }, FI = function(e2) {
          return om(im, e2);
        };
      } else {
        var am = ZI("state");
        $I[am] = true, QI = function(e2, t2) {
          if (zI(e2, am))
            throw new tm(em);
          return t2.facade = e2, qI(e2, am, t2), t2;
        }, xI = function(e2) {
          return zI(e2, am) ? e2[am] : {};
        }, FI = function(e2) {
          return zI(e2, am);
        };
      }
      var cm, dm, um, Am = { set: QI, get: xI, has: FI, enforce: function(e2) {
        return FI(e2) ? xI(e2) : QI(e2, {});
      }, getterFor: function(e2) {
        return function(t2) {
          var r2;
          if (!JI(t2) || (r2 = xI(t2)).type !== e2)
            throw tm("Incompatible receiver, " + e2 + " required");
          return r2;
        };
      } }, hm = Yc, lm = pu, pm = Function.prototype, gm = hm && Object.getOwnPropertyDescriptor, fm = lm(pm, "name"), Em = { EXISTS: fm, PROPER: fm && function() {
      }.name === "something", CONFIGURABLE: fm && (!hm || hm && gm(pm, "name").configurable) }, Im = MA, mm = function(e2, t2, r2, i2) {
        i2 && i2.enumerable ? e2[t2] = r2 : Im(e2, t2, r2);
      }, _m = bc, Cm = Kc, vm = hE, Sm = rf, Rm = mm, ym = Nu("iterator"), Tm = false;
      [].keys && ("next" in (um = [].keys()) ? (dm = Sm(Sm(um))) !== Object.prototype && (cm = dm) : Tm = true);
      var wm = cm == null || _m(function() {
        var e2 = {};
        return cm[ym].call(e2) !== e2;
      });
      Cm((cm = wm ? {} : vm(cm))[ym]) || Rm(cm, ym, function() {
        return this;
      });
      var bm = { IteratorPrototype: cm, BUGGY_SAFARI_ITERATORS: Tm }, Om = PE, Nm = yE ? {}.toString : function() {
        return "[object " + Om(this) + "]";
      }, Dm = yE, Lm = fA.f, Pm = MA, km = pu, Bm = Nm, Mm = Nu("toStringTag"), Um = function(e2, t2, r2, i2) {
        if (e2) {
          var n2 = r2 ? e2 : e2.prototype;
          km(n2, Mm) || Lm(n2, Mm, { configurable: true, value: t2 }), i2 && !Dm && Pm(n2, "toString", Bm);
        }
      }, Qm = bm.IteratorPrototype, xm = hE, Fm = rd, Vm = Um, jm = mE, Gm = function() {
        return this;
      }, Km = function(e2, t2, r2, i2) {
        var n2 = t2 + " Iterator";
        return e2.prototype = xm(Qm, { next: Fm(+!i2, r2) }), Vm(e2, n2, false, true), jm[n2] = Gm, e2;
      }, Hm = JA, Ym = qc, Wm = Km, Jm = rf, qm = Um, zm = mm, Xm = mE, Zm = Em.PROPER, $m = bm.BUGGY_SAFARI_ITERATORS, e_ = Nu("iterator"), t_ = "keys", r_ = "values", i_ = "entries", n_ = function() {
        return this;
      }, o_ = function(e2, t2, r2, i2, n2, o2, s2) {
        Wm(r2, t2, i2);
        var a2, c2, d2, u2 = function(e3) {
          if (e3 === n2 && g2)
            return g2;
          if (!$m && e3 in l2)
            return l2[e3];
          switch (e3) {
            case t_:
            case r_:
            case i_:
              return function() {
                return new r2(this, e3);
              };
          }
          return function() {
            return new r2(this);
          };
        }, A2 = t2 + " Iterator", h2 = false, l2 = e2.prototype, p2 = l2[e_] || l2["@@iterator"] || n2 && l2[n2], g2 = !$m && p2 || u2(n2), f2 = t2 == "Array" && l2.entries || p2;
        if (f2 && (a2 = Jm(f2.call(new e2()))) !== Object.prototype && a2.next && (qm(a2, A2, true, true), Xm[A2] = n_), Zm && n2 == r_ && p2 && p2.name !== r_ && (h2 = true, g2 = function() {
          return Ym(p2, this);
        }), n2)
          if (c2 = { values: u2(r_), keys: o2 ? g2 : u2(t_), entries: u2(i_) }, s2)
            for (d2 in c2)
              ($m || h2 || !(d2 in l2)) && zm(l2, d2, c2[d2]);
          else
            Hm({ target: t2, proto: true, forced: $m || h2 }, c2);
        return s2 && l2[e_] !== g2 && zm(l2, e_, g2, { name: n2 }), Xm[t2] = g2, c2;
      }, s_ = Ed, a_ = mE, c_ = Am;
      fA.f;
      var d_ = o_, u_ = "Array Iterator", A_ = c_.set, h_ = c_.getterFor(u_);
      d_(Array, "Array", function(e2, t2) {
        A_(this, { type: u_, target: s_(e2), index: 0, kind: t2 });
      }, function() {
        var e2 = h_(this), t2 = e2.target, r2 = e2.kind, i2 = e2.index++;
        return !t2 || i2 >= t2.length ? (e2.target = void 0, { value: void 0, done: true }) : r2 == "keys" ? { value: i2, done: false } : r2 == "values" ? { value: t2[i2], done: false } : { value: [i2, t2[i2]], done: false };
      }, "values"), a_.Arguments = a_.Array;
      var l_ = Qc.Promise, p_ = mm, g_ = function(e2, t2, r2) {
        for (var i2 in t2)
          r2 && r2.unsafe && e2[i2] ? e2[i2] = t2[i2] : p_(e2, i2, t2[i2], r2);
        return e2;
      }, f_ = yd, E_ = fA, I_ = Yc, m_ = Nu("species"), __ = Mc, C_ = Qc.TypeError, v_ = function(e2, t2) {
        if (__(t2, e2))
          return e2;
        throw C_("Incorrect invocation");
      }, S_ = Nu("iterator"), R_ = false;
      try {
        var y_ = 0, T_ = { next: function() {
          return { done: !!y_++ };
        }, return: function() {
          R_ = true;
        } };
        T_[S_] = function() {
          return this;
        }, Array.from(T_, function() {
          throw 2;
        });
      } catch (e2) {
      }
      var w_ = Bc, b_ = bc, O_ = Kc, N_ = PE, D_ = VI, L_ = function() {
      }, P_ = [], k_ = yd("Reflect", "construct"), B_ = /^\s*(?:class|function)\b/, M_ = w_(B_.exec), U_ = !B_.exec(L_), Q_ = function(e2) {
        if (!O_(e2))
          return false;
        try {
          return k_(L_, P_, e2), true;
        } catch (e3) {
          return false;
        }
      }, x_ = function(e2) {
        if (!O_(e2))
          return false;
        switch (N_(e2)) {
          case "AsyncFunction":
          case "GeneratorFunction":
          case "AsyncGeneratorFunction":
            return false;
        }
        try {
          return U_ || !!M_(B_, D_(e2));
        } catch (e3) {
          return true;
        }
      };
      x_.sham = true;
      var F_, V_, j_, G_, K_ = !k_ || b_(function() {
        var e2;
        return Q_(Q_.call) || !Q_(Object) || !Q_(function() {
          e2 = true;
        }) || e2;
      }) ? x_ : Q_, H_ = K_, Y_ = Hd, W_ = Qc.TypeError, J_ = vA, q_ = function(e2) {
        if (H_(e2))
          return e2;
        throw W_(Y_(e2) + " is not a constructor");
      }, z_ = Nu("species"), X_ = function(e2, t2) {
        var r2, i2 = J_(e2).constructor;
        return i2 === void 0 || (r2 = J_(i2)[z_]) == null ? t2 : q_(r2);
      }, Z_ = Bc([].slice), $_ = /(?:ipad|iphone|ipod).*applewebkit/i.test(Td), eC = Qc, tC = Gc, rC = gA, iC = Kc, nC = pu, oC = bc, sC = eE, aC = Z_, cC = Hu, dC = $_, uC = Ah, AC = eC.setImmediate, hC = eC.clearImmediate, lC = eC.process, pC = eC.Dispatch, gC = eC.Function, fC = eC.MessageChannel, EC = eC.String, IC = 0, mC = {}, _C = "onreadystatechange";
      try {
        F_ = eC.location;
      } catch (e2) {
      }
      var CC = function(e2) {
        if (nC(mC, e2)) {
          var t2 = mC[e2];
          delete mC[e2], t2();
        }
      }, vC = function(e2) {
        return function() {
          CC(e2);
        };
      }, SC = function(e2) {
        CC(e2.data);
      }, RC = function(e2) {
        eC.postMessage(EC(e2), F_.protocol + "//" + F_.host);
      };
      AC && hC || (AC = function(e2) {
        var t2 = aC(arguments, 1);
        return mC[++IC] = function() {
          tC(iC(e2) ? e2 : gC(e2), void 0, t2);
        }, V_(IC), IC;
      }, hC = function(e2) {
        delete mC[e2];
      }, uC ? V_ = function(e2) {
        lC.nextTick(vC(e2));
      } : pC && pC.now ? V_ = function(e2) {
        pC.now(vC(e2));
      } : fC && !dC ? (G_ = (j_ = new fC()).port2, j_.port1.onmessage = SC, V_ = rC(G_.postMessage, G_)) : eC.addEventListener && iC(eC.postMessage) && !eC.importScripts && F_ && F_.protocol !== "file:" && !oC(RC) ? (V_ = RC, eC.addEventListener("message", SC, false)) : V_ = _C in cC("script") ? function(e2) {
        sC.appendChild(cC("script")).onreadystatechange = function() {
          sC.removeChild(this), CC(e2);
        };
      } : function(e2) {
        setTimeout(vC(e2), 0);
      });
      var yC, TC, wC, bC, OC, NC, DC, LC, PC = { set: AC, clear: hC }, kC = Qc, BC = /ipad|iphone|ipod/i.test(Td) && kC.Pebble !== void 0, MC = /web0s(?!.*chrome)/i.test(Td), UC = Qc, QC = gA, xC = Hc.f, FC = PC.set, VC = $_, jC = BC, GC = MC, KC = Ah, HC = UC.MutationObserver || UC.WebKitMutationObserver, YC = UC.document, WC = UC.process, JC = UC.Promise, qC = xC(UC, "queueMicrotask"), zC = qC && qC.value;
      zC || (yC = function() {
        var e2, t2;
        for (KC && (e2 = WC.domain) && e2.exit(); TC; ) {
          t2 = TC.fn, TC = TC.next;
          try {
            t2();
          } catch (e3) {
            throw TC ? bC() : wC = void 0, e3;
          }
        }
        wC = void 0, e2 && e2.enter();
      }, VC || KC || GC || !HC || !YC ? !jC && JC && JC.resolve ? ((DC = JC.resolve(void 0)).constructor = JC, LC = QC(DC.then, DC), bC = function() {
        LC(yC);
      }) : KC ? bC = function() {
        WC.nextTick(yC);
      } : (FC = QC(FC, UC), bC = function() {
        FC(yC);
      }) : (OC = true, NC = YC.createTextNode(""), new HC(yC).observe(NC, { characterData: true }), bC = function() {
        NC.data = OC = !OC;
      }));
      var XC = zC || function(e2) {
        var t2 = { fn: e2, next: void 0 };
        wC && (wC.next = t2), TC || (TC = t2, bC()), wC = t2;
      }, ZC = {}, $C = qd, ev = function(e2) {
        var t2, r2;
        this.promise = new e2(function(e3, i2) {
          if (t2 !== void 0 || r2 !== void 0)
            throw TypeError("Bad Promise constructor");
          t2 = e3, r2 = i2;
        }), this.resolve = $C(t2), this.reject = $C(r2);
      };
      ZC.f = function(e2) {
        return new ev(e2);
      };
      var tv = vA, rv = md, iv = ZC, nv = function(e2, t2) {
        if (tv(e2), rv(t2) && t2.constructor === e2)
          return t2;
        var r2 = iv.f(e2);
        return (0, r2.resolve)(t2), r2.promise;
      }, ov = Qc, sv = function(e2) {
        try {
          return { error: false, value: e2() };
        } catch (e3) {
          return { error: true, value: e3 };
        }
      }, av = function() {
        this.head = null, this.tail = null;
      };
      av.prototype = { add: function(e2) {
        var t2 = { item: e2, next: null };
        this.head ? this.tail.next = t2 : this.head = t2, this.tail = t2;
      }, get: function() {
        var e2 = this.head;
        if (e2)
          return this.head = e2.next, this.tail === e2 && (this.tail = null), e2.item;
      } };
      var cv, dv, uv, Av = typeof window == "object", hv = JA, lv = Qc, pv = yd, gv = qc, fv = l_, Ev = g_, Iv = Um, mv = function(e2) {
        var t2 = f_(e2), r2 = E_.f;
        I_ && t2 && !t2[m_] && r2(t2, m_, { configurable: true, get: function() {
          return this;
        } });
      }, _v = qd, Cv = Kc, vv = md, Sv = v_, Rv = VI, yv = dI, Tv = function(e2, t2) {
        if (!t2 && !R_)
          return false;
        var r2 = false;
        try {
          var i2 = {};
          i2[S_] = function() {
            return { next: function() {
              return { done: r2 = true };
            } };
          }, e2(i2);
        } catch (e3) {
        }
        return r2;
      }, wv = X_, bv = PC.set, Ov = XC, Nv = nv, Dv = function(e2, t2) {
        var r2 = ov.console;
        r2 && r2.error && (arguments.length == 1 ? r2.error(e2) : r2.error(e2, t2));
      }, Lv = ZC, Pv = sv, kv = av, Bv = Am, Mv = AA, Uv = Av, Qv = Ah, xv = Pd, Fv = Nu("species"), Vv = "Promise", jv = Bv.getterFor(Vv), Gv = Bv.set, Kv = Bv.getterFor(Vv), Hv = fv && fv.prototype, Yv = fv, Wv = Hv, Jv = lv.TypeError, qv = lv.document, zv = lv.process, Xv = Lv.f, Zv = Xv, $v = !!(qv && qv.createEvent && lv.dispatchEvent), eS = Cv(lv.PromiseRejectionEvent), tS = "unhandledrejection", rS = Mv(Vv, function() {
        var e2 = Rv(Yv), t2 = e2 !== String(Yv);
        if (!t2 && xv === 66)
          return true;
        if (!Wv.finally)
          return true;
        if (xv >= 51 && /native code/.test(e2))
          return false;
        var r2 = new Yv(function(e3) {
          e3(1);
        }), i2 = function(e3) {
          e3(function() {
          }, function() {
          });
        };
        return (r2.constructor = {})[Fv] = i2, !(r2.then(function() {
        }) instanceof i2) || !t2 && Uv && !eS;
      }), iS = rS || !Tv(function(e2) {
        Yv.all(e2).catch(function() {
        });
      }), nS = function(e2) {
        var t2;
        return !(!vv(e2) || !Cv(t2 = e2.then)) && t2;
      }, oS = function(e2, t2) {
        var r2, i2, n2, o2 = t2.value, s2 = t2.state == 1, a2 = s2 ? e2.ok : e2.fail, c2 = e2.resolve, d2 = e2.reject, u2 = e2.domain;
        try {
          a2 ? (s2 || (t2.rejection === 2 && uS(t2), t2.rejection = 1), a2 === true ? r2 = o2 : (u2 && u2.enter(), r2 = a2(o2), u2 && (u2.exit(), n2 = true)), r2 === e2.promise ? d2(Jv("Promise-chain cycle")) : (i2 = nS(r2)) ? gv(i2, r2, c2, d2) : c2(r2)) : d2(o2);
        } catch (e3) {
          u2 && !n2 && u2.exit(), d2(e3);
        }
      }, sS = function(e2, t2) {
        e2.notified || (e2.notified = true, Ov(function() {
          for (var r2, i2 = e2.reactions; r2 = i2.get(); )
            oS(r2, e2);
          e2.notified = false, t2 && !e2.rejection && cS(e2);
        }));
      }, aS = function(e2, t2, r2) {
        var i2, n2;
        $v ? ((i2 = qv.createEvent("Event")).promise = t2, i2.reason = r2, i2.initEvent(e2, false, true), lv.dispatchEvent(i2)) : i2 = { promise: t2, reason: r2 }, !eS && (n2 = lv["on" + e2]) ? n2(i2) : e2 === tS && Dv("Unhandled promise rejection", r2);
      }, cS = function(e2) {
        gv(bv, lv, function() {
          var t2, r2 = e2.facade, i2 = e2.value;
          if (dS(e2) && (t2 = Pv(function() {
            Qv ? zv.emit("unhandledRejection", i2, r2) : aS(tS, r2, i2);
          }), e2.rejection = Qv || dS(e2) ? 2 : 1, t2.error))
            throw t2.value;
        });
      }, dS = function(e2) {
        return e2.rejection !== 1 && !e2.parent;
      }, uS = function(e2) {
        gv(bv, lv, function() {
          var t2 = e2.facade;
          Qv ? zv.emit("rejectionHandled", t2) : aS("rejectionhandled", t2, e2.value);
        });
      }, AS = function(e2, t2, r2) {
        return function(i2) {
          e2(t2, i2, r2);
        };
      }, hS = function(e2, t2, r2) {
        e2.done || (e2.done = true, r2 && (e2 = r2), e2.value = t2, e2.state = 2, sS(e2, true));
      }, lS = function(e2, t2, r2) {
        if (!e2.done) {
          e2.done = true, r2 && (e2 = r2);
          try {
            if (e2.facade === t2)
              throw Jv("Promise can't be resolved itself");
            var i2 = nS(t2);
            i2 ? Ov(function() {
              var r3 = { done: false };
              try {
                gv(i2, t2, AS(lS, r3, e2), AS(hS, r3, e2));
              } catch (t3) {
                hS(r3, t3, e2);
              }
            }) : (e2.value = t2, e2.state = 1, sS(e2, false));
          } catch (t3) {
            hS({ done: false }, t3, e2);
          }
        }
      };
      rS && (Wv = (Yv = function(e2) {
        Sv(this, Wv), _v(e2), gv(cv, this);
        var t2 = jv(this);
        try {
          e2(AS(lS, t2), AS(hS, t2));
        } catch (e3) {
          hS(t2, e3);
        }
      }).prototype, (cv = function(e2) {
        Gv(this, { type: Vv, done: false, notified: false, parent: false, reactions: new kv(), rejection: false, state: 0, value: void 0 });
      }).prototype = Ev(Wv, { then: function(e2, t2) {
        var r2 = Kv(this), i2 = Xv(wv(this, Yv));
        return r2.parent = true, i2.ok = !Cv(e2) || e2, i2.fail = Cv(t2) && t2, i2.domain = Qv ? zv.domain : void 0, r2.state == 0 ? r2.reactions.add(i2) : Ov(function() {
          oS(i2, r2);
        }), i2.promise;
      }, catch: function(e2) {
        return this.then(void 0, e2);
      } }), dv = function() {
        var e2 = new cv(), t2 = jv(e2);
        this.promise = e2, this.resolve = AS(lS, t2), this.reject = AS(hS, t2);
      }, Lv.f = Xv = function(e2) {
        return e2 === Yv || e2 === uv ? new dv(e2) : Zv(e2);
      }), hv({ global: true, wrap: true, forced: rS }, { Promise: Yv }), Iv(Yv, Vv, false, true), mv(Vv), uv = pv(Vv), hv({ target: Vv, stat: true, forced: rS }, { reject: function(e2) {
        var t2 = Xv(this);
        return gv(t2.reject, void 0, e2), t2.promise;
      } }), hv({ target: Vv, stat: true, forced: true }, { resolve: function(e2) {
        return Nv(this === uv ? Yv : this, e2);
      } }), hv({ target: Vv, stat: true, forced: iS }, { all: function(e2) {
        var t2 = this, r2 = Xv(t2), i2 = r2.resolve, n2 = r2.reject, o2 = Pv(function() {
          var r3 = _v(t2.resolve), o3 = [], s2 = 0, a2 = 1;
          yv(e2, function(e3) {
            var c2 = s2++, d2 = false;
            a2++, gv(r3, t2, e3).then(function(e4) {
              d2 || (d2 = true, o3[c2] = e4, --a2 || i2(o3));
            }, n2);
          }), --a2 || i2(o3);
        });
        return o2.error && n2(o2.value), r2.promise;
      }, race: function(e2) {
        var t2 = this, r2 = Xv(t2), i2 = r2.reject, n2 = Pv(function() {
          var n3 = _v(t2.resolve);
          yv(e2, function(e3) {
            gv(n3, t2, e3).then(r2.resolve, i2);
          });
        });
        return n2.error && i2(n2.value), r2.promise;
      } });
      var pS = qc, gS = qd, fS = ZC, ES = sv, IS = dI;
      JA({ target: "Promise", stat: true }, { allSettled: function(e2) {
        var t2 = this, r2 = fS.f(t2), i2 = r2.resolve, n2 = r2.reject, o2 = ES(function() {
          var r3 = gS(t2.resolve), n3 = [], o3 = 0, s2 = 1;
          IS(e2, function(e3) {
            var a2 = o3++, c2 = false;
            s2++, pS(r3, t2, e3).then(function(e4) {
              c2 || (c2 = true, n3[a2] = { status: "fulfilled", value: e4 }, --s2 || i2(n3));
            }, function(e4) {
              c2 || (c2 = true, n3[a2] = { status: "rejected", reason: e4 }, --s2 || i2(n3));
            });
          }), --s2 || i2(n3);
        });
        return o2.error && n2(o2.value), r2.promise;
      } });
      var mS = qd, _S = yd, CS = qc, vS = ZC, SS = sv, RS = dI, yS = "No one promise resolved";
      JA({ target: "Promise", stat: true }, { any: function(e2) {
        var t2 = this, r2 = _S("AggregateError"), i2 = vS.f(t2), n2 = i2.resolve, o2 = i2.reject, s2 = SS(function() {
          var i3 = mS(t2.resolve), s3 = [], a2 = 0, c2 = 1, d2 = false;
          RS(e2, function(e3) {
            var u2 = a2++, A2 = false;
            c2++, CS(i3, t2, e3).then(function(e4) {
              A2 || d2 || (d2 = true, n2(e4));
            }, function(e4) {
              A2 || d2 || (A2 = true, s3[u2] = e4, --c2 || o2(new r2(s3, yS)));
            });
          }), --c2 || o2(new r2(s3, yS));
        });
        return s2.error && o2(s2.value), i2.promise;
      } });
      var TS = l_, wS = yd, bS = Kc, OS = X_, NS = nv;
      JA({ target: "Promise", proto: true, real: true, forced: !!TS && bc(function() {
        TS.prototype.finally.call({ then: function() {
        } }, function() {
        });
      }) }, { finally: function(e2) {
        var t2 = OS(this, wS("Promise")), r2 = bS(e2);
        return this.then(r2 ? function(r3) {
          return NS(t2, e2()).then(function() {
            return r3;
          });
        } : e2, r2 ? function(r3) {
          return NS(t2, e2()).then(function() {
            throw r3;
          });
        } : e2);
      } });
      var DS = Bc, LS = XA, PS = hI, kS = pd, BS = DS("".charAt), MS = DS("".charCodeAt), US = DS("".slice), QS = function(e2) {
        return function(t2, r2) {
          var i2, n2, o2 = PS(kS(t2)), s2 = LS(r2), a2 = o2.length;
          return s2 < 0 || s2 >= a2 ? e2 ? "" : void 0 : (i2 = MS(o2, s2)) < 55296 || i2 > 56319 || s2 + 1 === a2 || (n2 = MS(o2, s2 + 1)) < 56320 || n2 > 57343 ? e2 ? BS(o2, s2) : i2 : e2 ? US(o2, s2, s2 + 2) : n2 - 56320 + (i2 - 55296 << 10) + 65536;
        };
      }, xS = { codeAt: QS(false), charAt: QS(true) }, FS = xS.charAt, VS = hI, jS = Am, GS = o_, KS = "String Iterator", HS = jS.set, YS = jS.getterFor(KS);
      GS(String, "String", function(e2) {
        HS(this, { type: KS, string: VS(e2), index: 0 });
      }, function() {
        var e2, t2 = YS(this), r2 = t2.string, i2 = t2.index;
        return i2 >= r2.length ? { value: void 0, done: true } : (e2 = FS(r2, i2), t2.index += e2.length, { value: e2, done: false });
      });
      var WS = _d.Promise, JS = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, qS = Qc, zS = PE, XS = MA, ZS = mE, $S = Nu("toStringTag");
      for (var eR in JS) {
        var tR = qS[eR], rR = tR && tR.prototype;
        rR && zS(rR) !== $S && XS(rR, $S, eR), ZS[eR] = ZS.Array;
      }
      var iR = WS, nR = iR, oR = Yo, sR = o, aR = n, cR = Nt, dR = tl, uR = rg, AR = Error.prototype.toString, hR = aR(function() {
        if (sR) {
          var e2 = dR(Object.defineProperty({}, "name", { get: function() {
            return this === e2;
          } }));
          if (AR.call(e2) !== "true")
            return true;
        }
        return AR.call({ message: 1, name: 2 }) !== "2: 1" || AR.call({}) !== "Error";
      }) ? function() {
        var e2 = cR(this), t2 = uR(e2.name, "Error"), r2 = uR(e2.message);
        return t2 ? r2 ? t2 + ": " + r2 : t2 : r2;
      } : AR, lR = { IndexSizeError: { s: "INDEX_SIZE_ERR", c: 1, m: 1 }, DOMStringSizeError: { s: "DOMSTRING_SIZE_ERR", c: 2, m: 0 }, HierarchyRequestError: { s: "HIERARCHY_REQUEST_ERR", c: 3, m: 1 }, WrongDocumentError: { s: "WRONG_DOCUMENT_ERR", c: 4, m: 1 }, InvalidCharacterError: { s: "INVALID_CHARACTER_ERR", c: 5, m: 1 }, NoDataAllowedError: { s: "NO_DATA_ALLOWED_ERR", c: 6, m: 0 }, NoModificationAllowedError: { s: "NO_MODIFICATION_ALLOWED_ERR", c: 7, m: 1 }, NotFoundError: { s: "NOT_FOUND_ERR", c: 8, m: 1 }, NotSupportedError: { s: "NOT_SUPPORTED_ERR", c: 9, m: 1 }, InUseAttributeError: { s: "INUSE_ATTRIBUTE_ERR", c: 10, m: 1 }, InvalidStateError: { s: "INVALID_STATE_ERR", c: 11, m: 1 }, SyntaxError: { s: "SYNTAX_ERR", c: 12, m: 1 }, InvalidModificationError: { s: "INVALID_MODIFICATION_ERR", c: 13, m: 1 }, NamespaceError: { s: "NAMESPACE_ERR", c: 14, m: 1 }, InvalidAccessError: { s: "INVALID_ACCESS_ERR", c: 15, m: 1 }, ValidationError: { s: "VALIDATION_ERR", c: 16, m: 0 }, TypeMismatchError: { s: "TYPE_MISMATCH_ERR", c: 17, m: 1 }, SecurityError: { s: "SECURITY_ERR", c: 18, m: 1 }, NetworkError: { s: "NETWORK_ERR", c: 19, m: 1 }, AbortError: { s: "ABORT_ERR", c: 20, m: 1 }, URLMismatchError: { s: "URL_MISMATCH_ERR", c: 21, m: 1 }, QuotaExceededError: { s: "QUOTA_EXCEEDED_ERR", c: 22, m: 1 }, TimeoutError: { s: "TIMEOUT_ERR", c: 23, m: 1 }, InvalidNodeTypeError: { s: "INVALID_NODE_TYPE_ERR", c: 24, m: 1 }, DataCloneError: { s: "DATA_CLONE_ERR", c: 25, m: 1 } }, pR = Gi, gR = function(e2) {
        try {
          if (oR)
            return Function('return require("' + e2 + '")')();
        } catch (e3) {
        }
      }, fR = K, ER = n, IR = tl, mR = f, _R = Rt.f, CR = Ph.f, vR = Ht.exports, SR = Be, RR = ln, yR = Nt, TR = hR, wR = rg, bR = lR, OR = dg, NR = yr, DR = o, LR = "DOMException", PR = "DATA_CLONE_ERR", kR = fR("Error"), BR = fR(LR) || function() {
        try {
          new (fR("MessageChannel") || gR("worker_threads").MessageChannel)().port1.postMessage(/* @__PURE__ */ new WeakMap());
        } catch (e2) {
          if (e2.name == PR && e2.code == 25)
            return e2.constructor;
        }
      }(), MR = BR && BR.prototype, UR = kR.prototype, QR = NR.set, xR = NR.getterFor(LR), FR = "stack" in kR(LR), VR = function(e2) {
        return SR(bR, e2) && bR[e2].m ? bR[e2].c : 0;
      }, jR = function() {
        RR(this, GR);
        var e2 = arguments.length, t2 = wR(e2 < 1 ? void 0 : arguments[0]), r2 = wR(e2 < 2 ? void 0 : arguments[1], "Error"), i2 = VR(r2);
        if (QR(this, { type: LR, name: r2, message: t2, code: i2 }), DR || (this.name = r2, this.message = t2, this.code = i2), FR) {
          var n2 = kR(t2);
          n2.name = LR, _R(this, "stack", mR(1, OR(n2.stack, 1)));
        }
      }, GR = jR.prototype = IR(UR), KR = function(e2) {
        return { enumerable: true, configurable: true, get: e2 };
      }, HR = function(e2) {
        return KR(function() {
          return xR(this)[e2];
        });
      };
      DR && CR(GR, { name: HR("name"), message: HR("message"), code: HR("code") }), _R(GR, "constructor", mR(1, jR));
      var YR = ER(function() {
        return !(new BR() instanceof kR);
      }), WR = YR || ER(function() {
        return UR.toString !== TR || String(new BR(1, 2)) !== "2: 1";
      }), JR = YR || ER(function() {
        return new BR(1, "DataCloneError").code !== 25;
      });
      YR || BR.DATA_CLONE_ERR !== 25 || MR.DATA_CLONE_ERR;
      pR({ global: true, forced: YR }, { DOMException: YR ? jR : BR });
      var qR = fR(LR), zR = qR.prototype;
      for (var XR in WR && BR === qR && vR(zR, "toString", TR), JR && DR && BR === qR && _R(zR, "code", KR(function() {
        return VR(yR(this).name);
      })), bR)
        if (SR(bR, XR)) {
          var ZR = bR[XR], $R = ZR.s, ey = mR(6, ZR.c);
          SR(qR, $R) || _R(qR, $R, ey), SR(zR, $R) || _R(zR, $R, ey);
        }
      var ty = Gi, ry = K, iy = f, ny = Rt.f, oy = Be, sy = ln, ay = eg, cy = rg, dy = lR, uy = dg, Ay = "DOMException", hy = ry("Error"), ly = ry(Ay), py = function() {
        sy(this, gy);
        var e2 = arguments.length, t2 = cy(e2 < 1 ? void 0 : arguments[0]), r2 = cy(e2 < 2 ? void 0 : arguments[1], "Error"), i2 = new ly(t2, r2), n2 = hy(t2);
        return n2.name = Ay, ny(i2, "stack", iy(1, uy(n2.stack, 1))), ay(i2, this, py), i2;
      }, gy = py.prototype = ly.prototype, fy = "stack" in hy(Ay), Ey = "stack" in new ly(1, 2), Iy = fy && !Ey;
      ty({ global: true, forced: Iy }, { DOMException: Iy ? py : ly });
      var my = ry(Ay), _y = my.prototype;
      if (_y.constructor !== my) {
        for (var Cy in ny(_y, "constructor", iy(1, my)), dy)
          if (oy(dy, Cy)) {
            var vy = dy[Cy], Sy = vy.s;
            oy(my, Sy) || ny(my, Sy, iy(6, vy.c));
          }
      }
      var Ry = "DOMException";
      on(K(Ry), Ry);
      var yy = v, Ty = Ht.exports, wy = bl, by = n, Oy = Xe, Ny = Kt, Dy = Oy("species"), Ly = RegExp.prototype, Py = v, ky = Hr, By = yh, My = k, Uy = Py("".charAt), Qy = Py("".charCodeAt), xy = Py("".slice), Fy = function(e2) {
        return function(t2, r2) {
          var i2, n2, o2 = By(My(t2)), s2 = ky(r2), a2 = o2.length;
          return s2 < 0 || s2 >= a2 ? e2 ? "" : void 0 : (i2 = Qy(o2, s2)) < 55296 || i2 > 56319 || s2 + 1 === a2 || (n2 = Qy(o2, s2 + 1)) < 56320 || n2 > 57343 ? e2 ? Uy(o2, s2) : i2 : e2 ? xy(o2, s2, s2 + 2) : n2 - 56320 + (i2 - 55296 << 10) + 65536;
        };
      }, Vy = { codeAt: Fy(false), charAt: Fy(true) }.charAt, jy = v, Gy = Le, Ky = Math.floor, Hy = jy("".charAt), Yy = jy("".replace), Wy = jy("".slice), Jy = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, qy = /\$([$&'`]|\d{1,2})/g, zy = d, Xy = Nt, Zy = Q, $y = T, eT = bl, tT = r.TypeError, rT = jo, iT = d, nT = v, oT = function(e2, t2, r2, i2) {
        var n2 = Oy(e2), o2 = !by(function() {
          var t3 = {};
          return t3[n2] = function() {
            return 7;
          }, ""[e2](t3) != 7;
        }), s2 = o2 && !by(function() {
          var t3 = false, r3 = /a/;
          return e2 === "split" && ((r3 = {}).constructor = {}, r3.constructor[Dy] = function() {
            return r3;
          }, r3.flags = "", r3[n2] = /./[n2]), r3.exec = function() {
            return t3 = true, null;
          }, r3[n2](""), !t3;
        });
        if (!o2 || !s2 || r2) {
          var a2 = yy(/./[n2]), c2 = t2(n2, ""[e2], function(e3, t3, r3, i3, n3) {
            var s3 = yy(e3), c3 = t3.exec;
            return c3 === wy || c3 === Ly.exec ? o2 && !n3 ? { done: true, value: a2(t3, r3, i3) } : { done: true, value: s3(r3, t3, i3) } : { done: false };
          });
          Ty(String.prototype, e2, c2[0]), Ty(Ly, n2, c2[1]);
        }
        i2 && Ny(Ly[n2], "sham", true);
      }, sT = n, aT = Nt, cT = Q, dT = Hr, uT = Zr, AT = yh, hT = k, lT = function(e2, t2, r2) {
        return t2 + (r2 ? Vy(e2, t2).length : 1);
      }, pT = Ee, gT = function(e2, t2, r2, i2, n2, o2) {
        var s2 = r2 + e2.length, a2 = i2.length, c2 = qy;
        return n2 !== void 0 && (n2 = Gy(n2), c2 = Jy), Yy(o2, c2, function(o3, c3) {
          var d2;
          switch (Hy(c3, 0)) {
            case "$":
              return "$";
            case "&":
              return e2;
            case "`":
              return Wy(t2, 0, r2);
            case "'":
              return Wy(t2, s2);
            case "<":
              d2 = n2[Wy(c3, 1, -1)];
              break;
            default:
              var u2 = +c3;
              if (u2 === 0)
                return o3;
              if (u2 > a2) {
                var A2 = Ky(u2 / 10);
                return A2 === 0 ? o3 : A2 <= a2 ? i2[A2 - 1] === void 0 ? Hy(c3, 1) : i2[A2 - 1] + Hy(c3, 1) : o3;
              }
              d2 = i2[u2 - 1];
          }
          return d2 === void 0 ? "" : d2;
        });
      }, fT = function(e2, t2) {
        var r2 = e2.exec;
        if (Zy(r2)) {
          var i2 = zy(r2, e2, t2);
          return i2 !== null && Xy(i2), i2;
        }
        if ($y(e2) === "RegExp")
          return zy(eT, e2, t2);
        throw tT("RegExp#exec called on incompatible receiver");
      }, ET = Xe("replace"), IT = Math.max, mT = Math.min, _T = nT([].concat), CT = nT([].push), vT = nT("".indexOf), ST = nT("".slice), RT = "a".replace(/./, "$0") === "$0", yT = !!/./[ET] && /./[ET]("a", "$0") === "";
      oT("replace", function(e2, t2, r2) {
        var i2 = yT ? "$" : "$0";
        return [function(e3, r3) {
          var i3 = hT(this), n2 = e3 == null ? void 0 : pT(e3, ET);
          return n2 ? iT(n2, e3, i3, r3) : iT(t2, AT(i3), e3, r3);
        }, function(e3, n2) {
          var o2 = aT(this), s2 = AT(e3);
          if (typeof n2 == "string" && vT(n2, i2) === -1 && vT(n2, "$<") === -1) {
            var a2 = r2(t2, o2, s2, n2);
            if (a2.done)
              return a2.value;
          }
          var c2 = cT(n2);
          c2 || (n2 = AT(n2));
          var d2 = o2.global;
          if (d2) {
            var u2 = o2.unicode;
            o2.lastIndex = 0;
          }
          for (var A2 = []; ; ) {
            var h2 = fT(o2, s2);
            if (h2 === null)
              break;
            if (CT(A2, h2), !d2)
              break;
            AT(h2[0]) === "" && (o2.lastIndex = lT(s2, uT(o2.lastIndex), u2));
          }
          for (var l2, p2 = "", g2 = 0, f2 = 0; f2 < A2.length; f2++) {
            for (var E2 = AT((h2 = A2[f2])[0]), I2 = IT(mT(dT(h2.index), s2.length), 0), m2 = [], _2 = 1; _2 < h2.length; _2++)
              CT(m2, (l2 = h2[_2]) === void 0 ? l2 : String(l2));
            var C2 = h2.groups;
            if (c2) {
              var v2 = _T([E2], m2, I2, s2);
              C2 !== void 0 && CT(v2, C2);
              var S2 = AT(rT(n2, void 0, v2));
            } else
              S2 = gT(E2, s2, I2, m2, C2, n2);
            I2 >= g2 && (p2 += ST(s2, g2, I2) + S2, g2 = I2 + E2.length);
          }
          return p2 + ST(s2, g2);
        }];
      }, !!sT(function() {
        var e2 = /./;
        return e2.exec = function() {
          var e3 = [];
          return e3.groups = { a: "7" }, e3;
        }, "".replace(e2, "$<a>") !== "7";
      }) || !RT || yT);
      var TT = F, wT = T, bT = Xe("match"), OT = o, NT = r, DT = v, LT = Bi, PT = eg, kT = Kt, BT = Rt.f, MT = jr.f, UT = H, QT = function(e2) {
        var t2;
        return TT(e2) && ((t2 = e2[bT]) !== void 0 ? !!t2 : wT(e2) == "RegExp");
      }, xT = yh, FT = wh, VT = Lh, jT = Ht.exports, GT = n, KT = Be, HT = yr.enforce, YT = un, WT = nl, JT = al, qT = Xe("match"), zT = NT.RegExp, XT = zT.prototype, ZT = NT.SyntaxError, $T = DT(FT), ew = DT(XT.exec), tw = DT("".charAt), rw = DT("".replace), iw = DT("".indexOf), nw = DT("".slice), ow = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/, sw = /a/g, aw = /a/g, cw = new zT(sw) !== sw, dw = VT.MISSED_STICKY, uw = VT.UNSUPPORTED_Y, Aw = OT && (!cw || dw || WT || JT || GT(function() {
        return aw[qT] = false, zT(sw) != sw || zT(aw) == aw || zT(sw, "i") != "/a/i";
      }));
      if (LT("RegExp", Aw)) {
        for (var hw = function(e2, t2) {
          var r2, i2, n2, o2, s2, a2, c2 = UT(XT, this), d2 = QT(e2), u2 = t2 === void 0, A2 = [], h2 = e2;
          if (!c2 && d2 && u2 && e2.constructor === hw)
            return e2;
          if ((d2 || UT(XT, e2)) && (e2 = e2.source, u2 && (t2 = "flags" in h2 ? h2.flags : $T(h2))), e2 = e2 === void 0 ? "" : xT(e2), t2 = t2 === void 0 ? "" : xT(t2), h2 = e2, WT && "dotAll" in sw && (i2 = !!t2 && iw(t2, "s") > -1) && (t2 = rw(t2, /s/g, "")), r2 = t2, dw && "sticky" in sw && (n2 = !!t2 && iw(t2, "y") > -1) && uw && (t2 = rw(t2, /y/g, "")), JT && (e2 = (o2 = function(e3) {
            for (var t3, r3 = e3.length, i3 = 0, n3 = "", o3 = [], s3 = {}, a3 = false, c3 = false, d3 = 0, u3 = ""; i3 <= r3; i3++) {
              if ((t3 = tw(e3, i3)) === "\\")
                t3 += tw(e3, ++i3);
              else if (t3 === "]")
                a3 = false;
              else if (!a3)
                switch (true) {
                  case t3 === "[":
                    a3 = true;
                    break;
                  case t3 === "(":
                    ew(ow, nw(e3, i3 + 1)) && (i3 += 2, c3 = true), n3 += t3, d3++;
                    continue;
                  case (t3 === ">" && c3):
                    if (u3 === "" || KT(s3, u3))
                      throw new ZT("Invalid capture group name");
                    s3[u3] = true, o3[o3.length] = [u3, d3], c3 = false, u3 = "";
                    continue;
                }
              c3 ? u3 += t3 : n3 += t3;
            }
            return [n3, o3];
          }(e2))[0], A2 = o2[1]), s2 = PT(zT(e2, t2), c2 ? this : XT, hw), (i2 || n2 || A2.length) && (a2 = HT(s2), i2 && (a2.dotAll = true, a2.raw = hw(function(e3) {
            for (var t3, r3 = e3.length, i3 = 0, n3 = "", o3 = false; i3 <= r3; i3++)
              (t3 = tw(e3, i3)) !== "\\" ? o3 || t3 !== "." ? (t3 === "[" ? o3 = true : t3 === "]" && (o3 = false), n3 += t3) : n3 += "[\\s\\S]" : n3 += t3 + tw(e3, ++i3);
            return n3;
          }(e2), r2)), n2 && (a2.sticky = true), A2.length && (a2.groups = A2)), e2 !== h2)
            try {
              kT(s2, "source", h2 === "" ? "(?:)" : h2);
            } catch (e3) {
            }
          return s2;
        }, lw = function(e2) {
          e2 in hw || BT(hw, e2, { configurable: true, get: function() {
            return zT[e2];
          }, set: function(t2) {
            zT[e2] = t2;
          } });
        }, pw = MT(zT), gw = 0; pw.length > gw; )
          lw(pw[gw++]);
        XT.constructor = hw, hw.prototype = XT, jT(NT, "RegExp", hw);
      }
      YT("RegExp");
      var fw = r, Ew = o, Iw = nl, mw = T, _w = Rt.f, Cw = yr.get, vw = RegExp.prototype, Sw = fw.TypeError;
      Ew && Iw && _w(vw, "dotAll", { configurable: true, get: function() {
        if (this !== vw) {
          if (mw(this) === "RegExp")
            return !!Cw(this).dotAll;
          throw Sw("Incompatible receiver, RegExp required");
        }
      } });
      const Rw = Ug;
      function yw(e2, t2) {
        const r2 = e2 && e2.navigator;
        if (!r2.mediaDevices)
          return;
        const i2 = function(e3) {
          if (typeof e3 != "object" || e3.mandatory || e3.optional)
            return e3;
          const t3 = {};
          return Object.keys(e3).forEach((r3) => {
            if (r3 === "require" || r3 === "advanced" || r3 === "mediaSource")
              return;
            const i3 = typeof e3[r3] == "object" ? e3[r3] : { ideal: e3[r3] };
            i3.exact !== void 0 && typeof i3.exact == "number" && (i3.min = i3.max = i3.exact);
            const n3 = function(e4, t4) {
              return e4 ? e4 + t4.charAt(0).toUpperCase() + t4.slice(1) : t4 === "deviceId" ? "sourceId" : t4;
            };
            if (i3.ideal !== void 0) {
              t3.optional = t3.optional || [];
              let e4 = {};
              typeof i3.ideal == "number" ? (e4[n3("min", r3)] = i3.ideal, t3.optional.push(e4), e4 = {}, e4[n3("max", r3)] = i3.ideal, t3.optional.push(e4)) : (e4[n3("", r3)] = i3.ideal, t3.optional.push(e4));
            }
            i3.exact !== void 0 && typeof i3.exact != "number" ? (t3.mandatory = t3.mandatory || {}, t3.mandatory[n3("", r3)] = i3.exact) : ["min", "max"].forEach((e4) => {
              i3[e4] !== void 0 && (t3.mandatory = t3.mandatory || {}, t3.mandatory[n3(e4, r3)] = i3[e4]);
            });
          }), e3.advanced && (t3.optional = (t3.optional || []).concat(e3.advanced)), t3;
        }, n2 = function(e3, n3) {
          if (t2.version >= 61)
            return n3(e3);
          if ((e3 = JSON.parse(JSON.stringify(e3))) && typeof e3.audio == "object") {
            const t3 = function(e4, t4, r3) {
              t4 in e4 && !(r3 in e4) && (e4[r3] = e4[t4], delete e4[t4]);
            };
            t3((e3 = JSON.parse(JSON.stringify(e3))).audio, "autoGainControl", "googAutoGainControl"), t3(e3.audio, "noiseSuppression", "googNoiseSuppression"), e3.audio = i2(e3.audio);
          }
          if (e3 && typeof e3.video == "object") {
            let o3 = e3.video.facingMode;
            o3 = o3 && (typeof o3 == "object" ? o3 : { ideal: o3 });
            const s2 = t2.version < 66;
            if (o3 && (o3.exact === "user" || o3.exact === "environment" || o3.ideal === "user" || o3.ideal === "environment") && (!r2.mediaDevices.getSupportedConstraints || !r2.mediaDevices.getSupportedConstraints().facingMode || s2)) {
              let t3;
              if (delete e3.video.facingMode, o3.exact === "environment" || o3.ideal === "environment" ? t3 = ["back", "rear"] : o3.exact !== "user" && o3.ideal !== "user" || (t3 = ["front"]), t3)
                return r2.mediaDevices.enumerateDevices().then((r3) => {
                  let s3 = (r3 = r3.filter((e4) => e4.kind === "videoinput")).find((e4) => t3.some((t4) => e4.label.toLowerCase().includes(t4)));
                  return !s3 && r3.length && t3.includes("back") && (s3 = r3[r3.length - 1]), s3 && (e3.video.deviceId = o3.exact ? { exact: s3.deviceId } : { ideal: s3.deviceId }), e3.video = i2(e3.video), Rw("chrome: " + JSON.stringify(e3)), n3(e3);
                });
            }
            e3.video = i2(e3.video);
          }
          return Rw("chrome: " + JSON.stringify(e3)), n3(e3);
        }, o2 = function(e3) {
          return t2.version >= 64 ? e3 : { name: { PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" }[e3.name] || e3.name, message: e3.message, constraint: e3.constraint || e3.constraintName, toString() {
            return this.name + (this.message && ": ") + this.message;
          } };
        };
        if (r2.getUserMedia = function(e3, t3, i3) {
          n2(e3, (e4) => {
            r2.webkitGetUserMedia(e4, t3, (e5) => {
              i3 && i3(o2(e5));
            });
          });
        }.bind(r2), r2.mediaDevices.getUserMedia) {
          const e3 = r2.mediaDevices.getUserMedia.bind(r2.mediaDevices);
          r2.mediaDevices.getUserMedia = function(t3) {
            return n2(t3, (t4) => e3(t4).then((e4) => {
              if (t4.audio && !e4.getAudioTracks().length || t4.video && !e4.getVideoTracks().length)
                throw e4.getTracks().forEach((e5) => {
                  e5.stop();
                }), new DOMException("", "NotFoundError");
              return e4;
            }, (e4) => nR.reject(o2(e4))));
          };
        }
      }
      function Tw(e2) {
        e2.MediaStream = e2.MediaStream || e2.webkitMediaStream;
      }
      function ww(e2) {
        if (typeof e2 == "object" && e2.RTCPeerConnection && !("ontrack" in e2.RTCPeerConnection.prototype)) {
          Object.defineProperty(e2.RTCPeerConnection.prototype, "ontrack", { get() {
            return this._ontrack;
          }, set(e3) {
            this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e3);
          }, enumerable: true, configurable: true });
          const t2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
          e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
            return this._ontrackpoly || (this._ontrackpoly = (t3) => {
              t3.stream.addEventListener("addtrack", (r2) => {
                let i2;
                i2 = e2.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e3) => e3.track && e3.track.id === r2.track.id) : { track: r2.track };
                const n2 = new Event("track");
                n2.track = r2.track, n2.receiver = i2, n2.transceiver = { receiver: i2 }, n2.streams = [t3.stream], this.dispatchEvent(n2);
              }), t3.stream.getTracks().forEach((r2) => {
                let i2;
                i2 = e2.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e3) => e3.track && e3.track.id === r2.id) : { track: r2 };
                const n2 = new Event("track");
                n2.track = r2, n2.receiver = i2, n2.transceiver = { receiver: i2 }, n2.streams = [t3.stream], this.dispatchEvent(n2);
              });
            }, this.addEventListener("addstream", this._ontrackpoly)), t2.apply(this, arguments);
          };
        } else
          kg(e2, "track", (e3) => (e3.transceiver || Object.defineProperty(e3, "transceiver", { value: { receiver: e3.receiver } }), e3));
      }
      function bw(e2) {
        if (typeof e2 == "object" && e2.RTCPeerConnection && !("getSenders" in e2.RTCPeerConnection.prototype) && "createDTMFSender" in e2.RTCPeerConnection.prototype) {
          const t2 = function(e3, t3) {
            return { track: t3, get dtmf() {
              return this._dtmf === void 0 && (t3.kind === "audio" ? this._dtmf = e3.createDTMFSender(t3) : this._dtmf = null), this._dtmf;
            }, _pc: e3 };
          };
          if (!e2.RTCPeerConnection.prototype.getSenders) {
            e2.RTCPeerConnection.prototype.getSenders = function() {
              return this._senders = this._senders || [], this._senders.slice();
            };
            const r3 = e2.RTCPeerConnection.prototype.addTrack;
            e2.RTCPeerConnection.prototype.addTrack = function(e3, i4) {
              let n2 = r3.apply(this, arguments);
              return n2 || (n2 = t2(this, e3), this._senders.push(n2)), n2;
            };
            const i3 = e2.RTCPeerConnection.prototype.removeTrack;
            e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
              i3.apply(this, arguments);
              const t3 = this._senders.indexOf(e3);
              t3 !== -1 && this._senders.splice(t3, 1);
            };
          }
          const r2 = e2.RTCPeerConnection.prototype.addStream;
          e2.RTCPeerConnection.prototype.addStream = function(e3) {
            this._senders = this._senders || [], r2.apply(this, [e3]), e3.getTracks().forEach((e4) => {
              this._senders.push(t2(this, e4));
            });
          };
          const i2 = e2.RTCPeerConnection.prototype.removeStream;
          e2.RTCPeerConnection.prototype.removeStream = function(e3) {
            this._senders = this._senders || [], i2.apply(this, [e3]), e3.getTracks().forEach((e4) => {
              const t3 = this._senders.find((t4) => t4.track === e4);
              t3 && this._senders.splice(this._senders.indexOf(t3), 1);
            });
          };
        } else if (typeof e2 == "object" && e2.RTCPeerConnection && "getSenders" in e2.RTCPeerConnection.prototype && "createDTMFSender" in e2.RTCPeerConnection.prototype && e2.RTCRtpSender && !("dtmf" in e2.RTCRtpSender.prototype)) {
          const t2 = e2.RTCPeerConnection.prototype.getSenders;
          e2.RTCPeerConnection.prototype.getSenders = function() {
            const e3 = t2.apply(this, []);
            return e3.forEach((e4) => e4._pc = this), e3;
          }, Object.defineProperty(e2.RTCRtpSender.prototype, "dtmf", { get() {
            return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;
          } });
        }
      }
      function Ow(e2) {
        if (!e2.RTCPeerConnection)
          return;
        const t2 = e2.RTCPeerConnection.prototype.getStats;
        e2.RTCPeerConnection.prototype.getStats = function() {
          const [e3, r2, i2] = arguments;
          if (arguments.length > 0 && typeof e3 == "function")
            return t2.apply(this, arguments);
          if (t2.length === 0 && (arguments.length === 0 || typeof e3 != "function"))
            return t2.apply(this, []);
          const n2 = function(e4) {
            const t3 = {};
            return e4.result().forEach((e5) => {
              const r3 = { id: e5.id, timestamp: e5.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[e5.type] || e5.type };
              e5.names().forEach((t4) => {
                r3[t4] = e5.stat(t4);
              }), t3[r3.id] = r3;
            }), t3;
          }, o2 = function(e4) {
            return new Map(Object.keys(e4).map((t3) => [t3, e4[t3]]));
          };
          if (arguments.length >= 2) {
            const i3 = function(e4) {
              r2(o2(n2(e4)));
            };
            return t2.apply(this, [i3, e3]);
          }
          return new nR((e4, r3) => {
            t2.apply(this, [function(t3) {
              e4(o2(n2(t3)));
            }, r3]);
          }).then(r2, i2);
        };
      }
      function Nw(e2) {
        if (!(typeof e2 == "object" && e2.RTCPeerConnection && e2.RTCRtpSender && e2.RTCRtpReceiver))
          return;
        if (!("getStats" in e2.RTCRtpSender.prototype)) {
          const t3 = e2.RTCPeerConnection.prototype.getSenders;
          t3 && (e2.RTCPeerConnection.prototype.getSenders = function() {
            const e3 = t3.apply(this, []);
            return e3.forEach((e4) => e4._pc = this), e3;
          });
          const r2 = e2.RTCPeerConnection.prototype.addTrack;
          r2 && (e2.RTCPeerConnection.prototype.addTrack = function() {
            const e3 = r2.apply(this, arguments);
            return e3._pc = this, e3;
          }), e2.RTCRtpSender.prototype.getStats = function() {
            const e3 = this;
            return this._pc.getStats().then((t4) => jg(t4, e3.track, true));
          };
        }
        if (!("getStats" in e2.RTCRtpReceiver.prototype)) {
          const t3 = e2.RTCPeerConnection.prototype.getReceivers;
          t3 && (e2.RTCPeerConnection.prototype.getReceivers = function() {
            const e3 = t3.apply(this, []);
            return e3.forEach((e4) => e4._pc = this), e3;
          }), kg(e2, "track", (e3) => (e3.receiver._pc = e3.srcElement, e3)), e2.RTCRtpReceiver.prototype.getStats = function() {
            const e3 = this;
            return this._pc.getStats().then((t4) => jg(t4, e3.track, false));
          };
        }
        if (!("getStats" in e2.RTCRtpSender.prototype) || !("getStats" in e2.RTCRtpReceiver.prototype))
          return;
        const t2 = e2.RTCPeerConnection.prototype.getStats;
        e2.RTCPeerConnection.prototype.getStats = function() {
          if (arguments.length > 0 && arguments[0] instanceof e2.MediaStreamTrack) {
            const e3 = arguments[0];
            let t3, r2, i2;
            return this.getSenders().forEach((r3) => {
              r3.track === e3 && (t3 ? i2 = true : t3 = r3);
            }), this.getReceivers().forEach((t4) => (t4.track === e3 && (r2 ? i2 = true : r2 = t4), t4.track === e3)), i2 || t3 && r2 ? nR.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : t3 ? t3.getStats() : r2 ? r2.getStats() : nR.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
          }
          return t2.apply(this, arguments);
        };
      }
      function Dw(e2) {
        e2.RTCPeerConnection.prototype.getLocalStreams = function() {
          return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((e3) => this._shimmedLocalStreams[e3][0]);
        };
        const t2 = e2.RTCPeerConnection.prototype.addTrack;
        e2.RTCPeerConnection.prototype.addTrack = function(e3, r3) {
          if (!r3)
            return t2.apply(this, arguments);
          this._shimmedLocalStreams = this._shimmedLocalStreams || {};
          const i3 = t2.apply(this, arguments);
          return this._shimmedLocalStreams[r3.id] ? this._shimmedLocalStreams[r3.id].indexOf(i3) === -1 && this._shimmedLocalStreams[r3.id].push(i3) : this._shimmedLocalStreams[r3.id] = [r3, i3], i3;
        };
        const r2 = e2.RTCPeerConnection.prototype.addStream;
        e2.RTCPeerConnection.prototype.addStream = function(e3) {
          this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e3.getTracks().forEach((e4) => {
            if (this.getSenders().find((t4) => t4.track === e4))
              throw new DOMException("Track already exists.", "InvalidAccessError");
          });
          const t3 = this.getSenders();
          r2.apply(this, arguments);
          const i3 = this.getSenders().filter((e4) => t3.indexOf(e4) === -1);
          this._shimmedLocalStreams[e3.id] = [e3].concat(i3);
        };
        const i2 = e2.RTCPeerConnection.prototype.removeStream;
        e2.RTCPeerConnection.prototype.removeStream = function(e3) {
          return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e3.id], i2.apply(this, arguments);
        };
        const n2 = e2.RTCPeerConnection.prototype.removeTrack;
        e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
          return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e3 && Object.keys(this._shimmedLocalStreams).forEach((t3) => {
            const r3 = this._shimmedLocalStreams[t3].indexOf(e3);
            r3 !== -1 && this._shimmedLocalStreams[t3].splice(r3, 1), this._shimmedLocalStreams[t3].length === 1 && delete this._shimmedLocalStreams[t3];
          }), n2.apply(this, arguments);
        };
      }
      function Lw(e2, t2) {
        if (!e2.RTCPeerConnection)
          return;
        if (e2.RTCPeerConnection.prototype.addTrack && t2.version >= 65)
          return Dw(e2);
        const r2 = e2.RTCPeerConnection.prototype.getLocalStreams;
        e2.RTCPeerConnection.prototype.getLocalStreams = function() {
          const e3 = r2.apply(this);
          return this._reverseStreams = this._reverseStreams || {}, e3.map((e4) => this._reverseStreams[e4.id]);
        };
        const i2 = e2.RTCPeerConnection.prototype.addStream;
        e2.RTCPeerConnection.prototype.addStream = function(t3) {
          if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t3.getTracks().forEach((e3) => {
            if (this.getSenders().find((t4) => t4.track === e3))
              throw new DOMException("Track already exists.", "InvalidAccessError");
          }), !this._reverseStreams[t3.id]) {
            const r3 = new e2.MediaStream(t3.getTracks());
            this._streams[t3.id] = r3, this._reverseStreams[r3.id] = t3, t3 = r3;
          }
          i2.apply(this, [t3]);
        };
        const n2 = e2.RTCPeerConnection.prototype.removeStream;
        function o2(e3, t3) {
          let r3 = t3.sdp;
          return Object.keys(e3._reverseStreams || []).forEach((t4) => {
            const i3 = e3._reverseStreams[t4], n3 = e3._streams[i3.id];
            r3 = r3.replace(new RegExp(n3.id, "g"), i3.id);
          }), new RTCSessionDescription({ type: t3.type, sdp: r3 });
        }
        function s2(e3, t3) {
          let r3 = t3.sdp;
          return Object.keys(e3._reverseStreams || []).forEach((t4) => {
            const i3 = e3._reverseStreams[t4], n3 = e3._streams[i3.id];
            r3 = r3.replace(new RegExp(i3.id, "g"), n3.id);
          }), new RTCSessionDescription({ type: t3.type, sdp: r3 });
        }
        e2.RTCPeerConnection.prototype.removeStream = function(e3) {
          this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, n2.apply(this, [this._streams[e3.id] || e3]), delete this._reverseStreams[this._streams[e3.id] ? this._streams[e3.id].id : e3.id], delete this._streams[e3.id];
        }, e2.RTCPeerConnection.prototype.addTrack = function(t3, r3) {
          if (this.signalingState === "closed")
            throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
          const i3 = [].slice.call(arguments, 1);
          if (i3.length !== 1 || !i3[0].getTracks().find((e3) => e3 === t3))
            throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
          const n3 = this.getSenders().find((e3) => e3.track === t3);
          if (n3)
            throw new DOMException("Track already exists.", "InvalidAccessError");
          this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
          const o3 = this._streams[r3.id];
          if (o3)
            o3.addTrack(t3), nR.resolve().then(() => {
              this.dispatchEvent(new Event("negotiationneeded"));
            });
          else {
            const i4 = new e2.MediaStream([t3]);
            this._streams[r3.id] = i4, this._reverseStreams[i4.id] = r3, this.addStream(i4);
          }
          return this.getSenders().find((e3) => e3.track === t3);
        }, ["createOffer", "createAnswer"].forEach(function(t3) {
          const r3 = e2.RTCPeerConnection.prototype[t3], i3 = { [t3]() {
            const e3 = arguments;
            return arguments.length && typeof arguments[0] == "function" ? r3.apply(this, [(t4) => {
              const r4 = o2(this, t4);
              e3[0].apply(null, [r4]);
            }, (t4) => {
              e3[1] && e3[1].apply(null, t4);
            }, arguments[2]]) : r3.apply(this, arguments).then((e4) => o2(this, e4));
          } };
          e2.RTCPeerConnection.prototype[t3] = i3[t3];
        });
        const a2 = e2.RTCPeerConnection.prototype.setLocalDescription;
        e2.RTCPeerConnection.prototype.setLocalDescription = function() {
          return arguments.length && arguments[0].type ? (arguments[0] = s2(this, arguments[0]), a2.apply(this, arguments)) : a2.apply(this, arguments);
        };
        const c2 = Object.getOwnPropertyDescriptor(e2.RTCPeerConnection.prototype, "localDescription");
        Object.defineProperty(e2.RTCPeerConnection.prototype, "localDescription", { get() {
          const e3 = c2.get.apply(this);
          return e3.type === "" ? e3 : o2(this, e3);
        } }), e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
          if (this.signalingState === "closed")
            throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
          if (!e3._pc)
            throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
          if (!(e3._pc === this))
            throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
          let t3;
          this._streams = this._streams || {}, Object.keys(this._streams).forEach((r3) => {
            this._streams[r3].getTracks().find((t4) => e3.track === t4) && (t3 = this._streams[r3]);
          }), t3 && (t3.getTracks().length === 1 ? this.removeStream(this._reverseStreams[t3.id]) : t3.removeTrack(e3.track), this.dispatchEvent(new Event("negotiationneeded")));
        };
      }
      function Pw(e2, t2) {
        !e2.RTCPeerConnection && e2.webkitRTCPeerConnection && (e2.RTCPeerConnection = e2.webkitRTCPeerConnection), e2.RTCPeerConnection && t2.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(t3) {
          const r2 = e2.RTCPeerConnection.prototype[t3], i2 = { [t3]() {
            return arguments[0] = new (t3 === "addIceCandidate" ? e2.RTCIceCandidate : e2.RTCSessionDescription)(arguments[0]), r2.apply(this, arguments);
          } };
          e2.RTCPeerConnection.prototype[t3] = i2[t3];
        });
      }
      function kw(e2, t2) {
        kg(e2, "negotiationneeded", (e3) => {
          const r2 = e3.target;
          if (!(t2.version < 72 || r2.getConfiguration && r2.getConfiguration().sdpSemantics === "plan-b") || r2.signalingState === "stable")
            return e3;
        });
      }
      var Bw = Object.freeze({ __proto__: null, shimMediaStream: Tw, shimOnTrack: ww, shimGetSendersWithDtmf: bw, shimGetStats: Ow, shimSenderReceiverGetStats: Nw, shimAddTrackRemoveTrackWithNative: Dw, shimAddTrackRemoveTrack: Lw, shimPeerConnection: Pw, fixNegotiationNeeded: kw, shimGetUserMedia: yw, shimGetDisplayMedia: function(e2, t2) {
        e2.navigator.mediaDevices && "getDisplayMedia" in e2.navigator.mediaDevices || e2.navigator.mediaDevices && (typeof t2 == "function" ? e2.navigator.mediaDevices.getDisplayMedia = function(r2) {
          return t2(r2).then((t3) => {
            const i2 = r2.video && r2.video.width, n2 = r2.video && r2.video.height, o2 = r2.video && r2.video.frameRate;
            return r2.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: t3, maxFrameRate: o2 || 3 } }, i2 && (r2.video.mandatory.maxWidth = i2), n2 && (r2.video.mandatory.maxHeight = n2), e2.navigator.mediaDevices.getUserMedia(r2);
          });
        } : console.error("shimGetDisplayMedia: getSourceId argument is not a function"));
      } });
      var Mw = { exports: {} };
      !function(e2) {
        var t2 = { generateIdentifier: function() {
          return Math.random().toString(36).substr(2, 10);
        } };
        t2.localCName = t2.generateIdentifier(), t2.splitLines = function(e3) {
          return e3.trim().split("\n").map(function(e4) {
            return e4.trim();
          });
        }, t2.splitSections = function(e3) {
          return e3.split("\nm=").map(function(e4, t3) {
            return (t3 > 0 ? "m=" + e4 : e4).trim() + "\r\n";
          });
        }, t2.getDescription = function(e3) {
          var r2 = t2.splitSections(e3);
          return r2 && r2[0];
        }, t2.getMediaSections = function(e3) {
          var r2 = t2.splitSections(e3);
          return r2.shift(), r2;
        }, t2.matchPrefix = function(e3, r2) {
          return t2.splitLines(e3).filter(function(e4) {
            return e4.indexOf(r2) === 0;
          });
        }, t2.parseCandidate = function(e3) {
          for (var t3, r2 = { foundation: (t3 = e3.indexOf("a=candidate:") === 0 ? e3.substring(12).split(" ") : e3.substring(10).split(" "))[0], component: parseInt(t3[1], 10), protocol: t3[2].toLowerCase(), priority: parseInt(t3[3], 10), ip: t3[4], address: t3[4], port: parseInt(t3[5], 10), type: t3[7] }, i2 = 8; i2 < t3.length; i2 += 2)
            switch (t3[i2]) {
              case "raddr":
                r2.relatedAddress = t3[i2 + 1];
                break;
              case "rport":
                r2.relatedPort = parseInt(t3[i2 + 1], 10);
                break;
              case "tcptype":
                r2.tcpType = t3[i2 + 1];
                break;
              case "ufrag":
                r2.ufrag = t3[i2 + 1], r2.usernameFragment = t3[i2 + 1];
                break;
              default:
                r2[t3[i2]] = t3[i2 + 1];
            }
          return r2;
        }, t2.writeCandidate = function(e3) {
          var t3 = [];
          t3.push(e3.foundation), t3.push(e3.component), t3.push(e3.protocol.toUpperCase()), t3.push(e3.priority), t3.push(e3.address || e3.ip), t3.push(e3.port);
          var r2 = e3.type;
          return t3.push("typ"), t3.push(r2), r2 !== "host" && e3.relatedAddress && e3.relatedPort && (t3.push("raddr"), t3.push(e3.relatedAddress), t3.push("rport"), t3.push(e3.relatedPort)), e3.tcpType && e3.protocol.toLowerCase() === "tcp" && (t3.push("tcptype"), t3.push(e3.tcpType)), (e3.usernameFragment || e3.ufrag) && (t3.push("ufrag"), t3.push(e3.usernameFragment || e3.ufrag)), "candidate:" + t3.join(" ");
        }, t2.parseIceOptions = function(e3) {
          return e3.substr(14).split(" ");
        }, t2.parseRtpMap = function(e3) {
          var t3 = e3.substr(9).split(" "), r2 = { payloadType: parseInt(t3.shift(), 10) };
          return t3 = t3[0].split("/"), r2.name = t3[0], r2.clockRate = parseInt(t3[1], 10), r2.channels = t3.length === 3 ? parseInt(t3[2], 10) : 1, r2.numChannels = r2.channels, r2;
        }, t2.writeRtpMap = function(e3) {
          var t3 = e3.payloadType;
          e3.preferredPayloadType !== void 0 && (t3 = e3.preferredPayloadType);
          var r2 = e3.channels || e3.numChannels || 1;
          return "a=rtpmap:" + t3 + " " + e3.name + "/" + e3.clockRate + (r2 !== 1 ? "/" + r2 : "") + "\r\n";
        }, t2.parseExtmap = function(e3) {
          var t3 = e3.substr(9).split(" ");
          return { id: parseInt(t3[0], 10), direction: t3[0].indexOf("/") > 0 ? t3[0].split("/")[1] : "sendrecv", uri: t3[1] };
        }, t2.writeExtmap = function(e3) {
          return "a=extmap:" + (e3.id || e3.preferredId) + (e3.direction && e3.direction !== "sendrecv" ? "/" + e3.direction : "") + " " + e3.uri + "\r\n";
        }, t2.parseFmtp = function(e3) {
          for (var t3, r2 = {}, i2 = e3.substr(e3.indexOf(" ") + 1).split(";"), n2 = 0; n2 < i2.length; n2++)
            r2[(t3 = i2[n2].trim().split("="))[0].trim()] = t3[1];
          return r2;
        }, t2.writeFmtp = function(e3) {
          var t3 = "", r2 = e3.payloadType;
          if (e3.preferredPayloadType !== void 0 && (r2 = e3.preferredPayloadType), e3.parameters && Object.keys(e3.parameters).length) {
            var i2 = [];
            Object.keys(e3.parameters).forEach(function(t4) {
              e3.parameters[t4] ? i2.push(t4 + "=" + e3.parameters[t4]) : i2.push(t4);
            }), t3 += "a=fmtp:" + r2 + " " + i2.join(";") + "\r\n";
          }
          return t3;
        }, t2.parseRtcpFb = function(e3) {
          var t3 = e3.substr(e3.indexOf(" ") + 1).split(" ");
          return { type: t3.shift(), parameter: t3.join(" ") };
        }, t2.writeRtcpFb = function(e3) {
          var t3 = "", r2 = e3.payloadType;
          return e3.preferredPayloadType !== void 0 && (r2 = e3.preferredPayloadType), e3.rtcpFeedback && e3.rtcpFeedback.length && e3.rtcpFeedback.forEach(function(e4) {
            t3 += "a=rtcp-fb:" + r2 + " " + e4.type + (e4.parameter && e4.parameter.length ? " " + e4.parameter : "") + "\r\n";
          }), t3;
        }, t2.parseSsrcMedia = function(e3) {
          var t3 = e3.indexOf(" "), r2 = { ssrc: parseInt(e3.substr(7, t3 - 7), 10) }, i2 = e3.indexOf(":", t3);
          return i2 > -1 ? (r2.attribute = e3.substr(t3 + 1, i2 - t3 - 1), r2.value = e3.substr(i2 + 1)) : r2.attribute = e3.substr(t3 + 1), r2;
        }, t2.parseSsrcGroup = function(e3) {
          var t3 = e3.substr(13).split(" ");
          return { semantics: t3.shift(), ssrcs: t3.map(function(e4) {
            return parseInt(e4, 10);
          }) };
        }, t2.getMid = function(e3) {
          var r2 = t2.matchPrefix(e3, "a=mid:")[0];
          if (r2)
            return r2.substr(6);
        }, t2.parseFingerprint = function(e3) {
          var t3 = e3.substr(14).split(" ");
          return { algorithm: t3[0].toLowerCase(), value: t3[1] };
        }, t2.getDtlsParameters = function(e3, r2) {
          return { role: "auto", fingerprints: t2.matchPrefix(e3 + r2, "a=fingerprint:").map(t2.parseFingerprint) };
        }, t2.writeDtlsParameters = function(e3, t3) {
          var r2 = "a=setup:" + t3 + "\r\n";
          return e3.fingerprints.forEach(function(e4) {
            r2 += "a=fingerprint:" + e4.algorithm + " " + e4.value + "\r\n";
          }), r2;
        }, t2.getIceParameters = function(e3, r2) {
          var i2 = t2.splitLines(e3);
          return { usernameFragment: (i2 = i2.concat(t2.splitLines(r2))).filter(function(e4) {
            return e4.indexOf("a=ice-ufrag:") === 0;
          })[0].substr(12), password: i2.filter(function(e4) {
            return e4.indexOf("a=ice-pwd:") === 0;
          })[0].substr(10) };
        }, t2.writeIceParameters = function(e3) {
          return "a=ice-ufrag:" + e3.usernameFragment + "\r\na=ice-pwd:" + e3.password + "\r\n";
        }, t2.parseRtpParameters = function(e3) {
          for (var r2 = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, i2 = t2.splitLines(e3)[0].split(" "), n2 = 3; n2 < i2.length; n2++) {
            var o2 = i2[n2], s2 = t2.matchPrefix(e3, "a=rtpmap:" + o2 + " ")[0];
            if (s2) {
              var a2 = t2.parseRtpMap(s2), c2 = t2.matchPrefix(e3, "a=fmtp:" + o2 + " ");
              switch (a2.parameters = c2.length ? t2.parseFmtp(c2[0]) : {}, a2.rtcpFeedback = t2.matchPrefix(e3, "a=rtcp-fb:" + o2 + " ").map(t2.parseRtcpFb), r2.codecs.push(a2), a2.name.toUpperCase()) {
                case "RED":
                case "ULPFEC":
                  r2.fecMechanisms.push(a2.name.toUpperCase());
              }
            }
          }
          return t2.matchPrefix(e3, "a=extmap:").forEach(function(e4) {
            r2.headerExtensions.push(t2.parseExtmap(e4));
          }), r2;
        }, t2.writeRtpDescription = function(e3, r2) {
          var i2 = "";
          i2 += "m=" + e3 + " ", i2 += r2.codecs.length > 0 ? "9" : "0", i2 += " UDP/TLS/RTP/SAVPF ", i2 += r2.codecs.map(function(e4) {
            return e4.preferredPayloadType !== void 0 ? e4.preferredPayloadType : e4.payloadType;
          }).join(" ") + "\r\n", i2 += "c=IN IP4 0.0.0.0\r\n", i2 += "a=rtcp:9 IN IP4 0.0.0.0\r\n", r2.codecs.forEach(function(e4) {
            i2 += t2.writeRtpMap(e4), i2 += t2.writeFmtp(e4), i2 += t2.writeRtcpFb(e4);
          });
          var n2 = 0;
          return r2.codecs.forEach(function(e4) {
            e4.maxptime > n2 && (n2 = e4.maxptime);
          }), n2 > 0 && (i2 += "a=maxptime:" + n2 + "\r\n"), i2 += "a=rtcp-mux\r\n", r2.headerExtensions && r2.headerExtensions.forEach(function(e4) {
            i2 += t2.writeExtmap(e4);
          }), i2;
        }, t2.parseRtpEncodingParameters = function(e3) {
          var r2, i2 = [], n2 = t2.parseRtpParameters(e3), o2 = n2.fecMechanisms.indexOf("RED") !== -1, s2 = n2.fecMechanisms.indexOf("ULPFEC") !== -1, a2 = t2.matchPrefix(e3, "a=ssrc:").map(function(e4) {
            return t2.parseSsrcMedia(e4);
          }).filter(function(e4) {
            return e4.attribute === "cname";
          }), c2 = a2.length > 0 && a2[0].ssrc, d2 = t2.matchPrefix(e3, "a=ssrc-group:FID").map(function(e4) {
            return e4.substr(17).split(" ").map(function(e5) {
              return parseInt(e5, 10);
            });
          });
          d2.length > 0 && d2[0].length > 1 && d2[0][0] === c2 && (r2 = d2[0][1]), n2.codecs.forEach(function(e4) {
            if (e4.name.toUpperCase() === "RTX" && e4.parameters.apt) {
              var t3 = { ssrc: c2, codecPayloadType: parseInt(e4.parameters.apt, 10) };
              c2 && r2 && (t3.rtx = { ssrc: r2 }), i2.push(t3), o2 && ((t3 = JSON.parse(JSON.stringify(t3))).fec = { ssrc: c2, mechanism: s2 ? "red+ulpfec" : "red" }, i2.push(t3));
            }
          }), i2.length === 0 && c2 && i2.push({ ssrc: c2 });
          var u2 = t2.matchPrefix(e3, "b=");
          return u2.length && (u2 = u2[0].indexOf("b=TIAS:") === 0 ? parseInt(u2[0].substr(7), 10) : u2[0].indexOf("b=AS:") === 0 ? 1e3 * parseInt(u2[0].substr(5), 10) * 0.95 - 16e3 : void 0, i2.forEach(function(e4) {
            e4.maxBitrate = u2;
          })), i2;
        }, t2.parseRtcpParameters = function(e3) {
          var r2 = {}, i2 = t2.matchPrefix(e3, "a=ssrc:").map(function(e4) {
            return t2.parseSsrcMedia(e4);
          }).filter(function(e4) {
            return e4.attribute === "cname";
          })[0];
          i2 && (r2.cname = i2.value, r2.ssrc = i2.ssrc);
          var n2 = t2.matchPrefix(e3, "a=rtcp-rsize");
          r2.reducedSize = n2.length > 0, r2.compound = n2.length === 0;
          var o2 = t2.matchPrefix(e3, "a=rtcp-mux");
          return r2.mux = o2.length > 0, r2;
        }, t2.parseMsid = function(e3) {
          var r2, i2 = t2.matchPrefix(e3, "a=msid:");
          if (i2.length === 1)
            return { stream: (r2 = i2[0].substr(7).split(" "))[0], track: r2[1] };
          var n2 = t2.matchPrefix(e3, "a=ssrc:").map(function(e4) {
            return t2.parseSsrcMedia(e4);
          }).filter(function(e4) {
            return e4.attribute === "msid";
          });
          return n2.length > 0 ? { stream: (r2 = n2[0].value.split(" "))[0], track: r2[1] } : void 0;
        }, t2.generateSessionId = function() {
          return Math.random().toString().substr(2, 21);
        }, t2.writeSessionBoilerplate = function(e3, r2, i2) {
          var n2 = r2 !== void 0 ? r2 : 2;
          return "v=0\r\no=" + (i2 || "thisisadapterortc") + " " + (e3 || t2.generateSessionId()) + " " + n2 + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
        }, t2.writeMediaSection = function(e3, r2, i2, n2) {
          var o2 = t2.writeRtpDescription(e3.kind, r2);
          if (o2 += t2.writeIceParameters(e3.iceGatherer.getLocalParameters()), o2 += t2.writeDtlsParameters(e3.dtlsTransport.getLocalParameters(), i2 === "offer" ? "actpass" : "active"), o2 += "a=mid:" + e3.mid + "\r\n", e3.direction ? o2 += "a=" + e3.direction + "\r\n" : e3.rtpSender && e3.rtpReceiver ? o2 += "a=sendrecv\r\n" : e3.rtpSender ? o2 += "a=sendonly\r\n" : e3.rtpReceiver ? o2 += "a=recvonly\r\n" : o2 += "a=inactive\r\n", e3.rtpSender) {
            var s2 = "msid:" + n2.id + " " + e3.rtpSender.track.id + "\r\n";
            o2 += "a=" + s2, o2 += "a=ssrc:" + e3.sendEncodingParameters[0].ssrc + " " + s2, e3.sendEncodingParameters[0].rtx && (o2 += "a=ssrc:" + e3.sendEncodingParameters[0].rtx.ssrc + " " + s2, o2 += "a=ssrc-group:FID " + e3.sendEncodingParameters[0].ssrc + " " + e3.sendEncodingParameters[0].rtx.ssrc + "\r\n");
          }
          return o2 += "a=ssrc:" + e3.sendEncodingParameters[0].ssrc + " cname:" + t2.localCName + "\r\n", e3.rtpSender && e3.sendEncodingParameters[0].rtx && (o2 += "a=ssrc:" + e3.sendEncodingParameters[0].rtx.ssrc + " cname:" + t2.localCName + "\r\n"), o2;
        }, t2.getDirection = function(e3, r2) {
          for (var i2 = t2.splitLines(e3), n2 = 0; n2 < i2.length; n2++)
            switch (i2[n2]) {
              case "a=sendrecv":
              case "a=sendonly":
              case "a=recvonly":
              case "a=inactive":
                return i2[n2].substr(2);
            }
          return r2 ? t2.getDirection(r2) : "sendrecv";
        }, t2.getKind = function(e3) {
          return t2.splitLines(e3)[0].split(" ")[0].substr(2);
        }, t2.isRejected = function(e3) {
          return e3.split(" ", 2)[1] === "0";
        }, t2.parseMLine = function(e3) {
          var r2 = t2.splitLines(e3)[0].substr(2).split(" ");
          return { kind: r2[0], port: parseInt(r2[1], 10), protocol: r2[2], fmt: r2.slice(3).join(" ") };
        }, t2.parseOLine = function(e3) {
          var r2 = t2.matchPrefix(e3, "o=")[0].substr(2).split(" ");
          return { username: r2[0], sessionId: r2[1], sessionVersion: parseInt(r2[2], 10), netType: r2[3], addressType: r2[4], address: r2[5] };
        }, t2.isValidSDP = function(e3) {
          if (typeof e3 != "string" || e3.length === 0)
            return false;
          for (var r2 = t2.splitLines(e3), i2 = 0; i2 < r2.length; i2++)
            if (r2[i2].length < 2 || r2[i2].charAt(1) !== "=")
              return false;
          return true;
        }, e2.exports = t2;
      }(Mw);
      var Uw = Mw.exports;
      function Qw(e2, t2, r2, i2, n2) {
        var o2 = Uw.writeRtpDescription(e2.kind, t2);
        if (o2 += Uw.writeIceParameters(e2.iceGatherer.getLocalParameters()), o2 += Uw.writeDtlsParameters(e2.dtlsTransport.getLocalParameters(), r2 === "offer" ? "actpass" : n2 || "active"), o2 += "a=mid:" + e2.mid + "\r\n", e2.rtpSender && e2.rtpReceiver ? o2 += "a=sendrecv\r\n" : e2.rtpSender ? o2 += "a=sendonly\r\n" : e2.rtpReceiver ? o2 += "a=recvonly\r\n" : o2 += "a=inactive\r\n", e2.rtpSender) {
          var s2 = e2.rtpSender._initialTrackId || e2.rtpSender.track.id;
          e2.rtpSender._initialTrackId = s2;
          var a2 = "msid:" + (i2 ? i2.id : "-") + " " + s2 + "\r\n";
          o2 += "a=" + a2, o2 += "a=ssrc:" + e2.sendEncodingParameters[0].ssrc + " " + a2, e2.sendEncodingParameters[0].rtx && (o2 += "a=ssrc:" + e2.sendEncodingParameters[0].rtx.ssrc + " " + a2, o2 += "a=ssrc-group:FID " + e2.sendEncodingParameters[0].ssrc + " " + e2.sendEncodingParameters[0].rtx.ssrc + "\r\n");
        }
        return o2 += "a=ssrc:" + e2.sendEncodingParameters[0].ssrc + " cname:" + Uw.localCName + "\r\n", e2.rtpSender && e2.sendEncodingParameters[0].rtx && (o2 += "a=ssrc:" + e2.sendEncodingParameters[0].rtx.ssrc + " cname:" + Uw.localCName + "\r\n"), o2;
      }
      function xw(e2, t2) {
        var r2 = { codecs: [], headerExtensions: [], fecMechanisms: [] }, i2 = function(e3, t3) {
          e3 = parseInt(e3, 10);
          for (var r3 = 0; r3 < t3.length; r3++)
            if (t3[r3].payloadType === e3 || t3[r3].preferredPayloadType === e3)
              return t3[r3];
        }, n2 = function(e3, t3, r3, n3) {
          var o2 = i2(e3.parameters.apt, r3), s2 = i2(t3.parameters.apt, n3);
          return o2 && s2 && o2.name.toLowerCase() === s2.name.toLowerCase();
        };
        return e2.codecs.forEach(function(i3) {
          for (var o2 = 0; o2 < t2.codecs.length; o2++) {
            var s2 = t2.codecs[o2];
            if (i3.name.toLowerCase() === s2.name.toLowerCase() && i3.clockRate === s2.clockRate) {
              if (i3.name.toLowerCase() === "rtx" && i3.parameters && s2.parameters.apt && !n2(i3, s2, e2.codecs, t2.codecs))
                continue;
              (s2 = JSON.parse(JSON.stringify(s2))).numChannels = Math.min(i3.numChannels, s2.numChannels), r2.codecs.push(s2), s2.rtcpFeedback = s2.rtcpFeedback.filter(function(e3) {
                for (var t3 = 0; t3 < i3.rtcpFeedback.length; t3++)
                  if (i3.rtcpFeedback[t3].type === e3.type && i3.rtcpFeedback[t3].parameter === e3.parameter)
                    return true;
                return false;
              });
              break;
            }
          }
        }), e2.headerExtensions.forEach(function(e3) {
          for (var i3 = 0; i3 < t2.headerExtensions.length; i3++) {
            var n3 = t2.headerExtensions[i3];
            if (e3.uri === n3.uri) {
              r2.headerExtensions.push(n3);
              break;
            }
          }
        }), r2;
      }
      function Fw(e2, t2, r2) {
        return { offer: { setLocalDescription: ["stable", "have-local-offer"], setRemoteDescription: ["stable", "have-remote-offer"] }, answer: { setLocalDescription: ["have-remote-offer", "have-local-pranswer"], setRemoteDescription: ["have-local-offer", "have-remote-pranswer"] } }[t2][e2].indexOf(r2) !== -1;
      }
      function Vw(e2, t2) {
        var r2 = e2.getRemoteCandidates().find(function(e3) {
          return t2.foundation === e3.foundation && t2.ip === e3.ip && t2.port === e3.port && t2.priority === e3.priority && t2.protocol === e3.protocol && t2.type === e3.type;
        });
        return r2 || e2.addRemoteCandidate(t2), !r2;
      }
      function jw(e2, t2) {
        var r2 = new Error(t2);
        return r2.name = e2, r2.code = { NotSupportedError: 9, InvalidStateError: 11, InvalidAccessError: 15, TypeError: void 0, OperationError: void 0 }[e2], r2;
      }
      var Gw = function(e2, t2) {
        function r2(t3, r3) {
          r3.addTrack(t3), r3.dispatchEvent(new e2.MediaStreamTrackEvent("addtrack", { track: t3 }));
        }
        function i2(t3, r3, i3, n3) {
          var o3 = new Event("track");
          o3.track = r3, o3.receiver = i3, o3.transceiver = { receiver: i3 }, o3.streams = n3, e2.setTimeout(function() {
            t3._dispatchEvent("track", o3);
          });
        }
        var n2 = function(r3) {
          var i3 = this, n3 = document.createDocumentFragment();
          if (["addEventListener", "removeEventListener", "dispatchEvent"].forEach(function(e3) {
            i3[e3] = n3[e3].bind(n3);
          }), this.canTrickleIceCandidates = null, this.needNegotiation = false, this.localStreams = [], this.remoteStreams = [], this._localDescription = null, this._remoteDescription = null, this.signalingState = "stable", this.iceConnectionState = "new", this.connectionState = "new", this.iceGatheringState = "new", r3 = JSON.parse(JSON.stringify(r3 || {})), this.usingBundle = r3.bundlePolicy === "max-bundle", r3.rtcpMuxPolicy === "negotiate")
            throw jw("NotSupportedError", "rtcpMuxPolicy 'negotiate' is not supported");
          switch (r3.rtcpMuxPolicy || (r3.rtcpMuxPolicy = "require"), r3.iceTransportPolicy) {
            case "all":
            case "relay":
              break;
            default:
              r3.iceTransportPolicy = "all";
          }
          switch (r3.bundlePolicy) {
            case "balanced":
            case "max-compat":
            case "max-bundle":
              break;
            default:
              r3.bundlePolicy = "balanced";
          }
          if (r3.iceServers = function(e3, t3) {
            var r4 = false;
            return (e3 = JSON.parse(JSON.stringify(e3))).filter(function(e4) {
              if (e4 && (e4.urls || e4.url)) {
                var i4 = e4.urls || e4.url;
                e4.url && !e4.urls && console.warn("RTCIceServer.url is deprecated! Use urls instead.");
                var n4 = typeof i4 == "string";
                return n4 && (i4 = [i4]), i4 = i4.filter(function(e5) {
                  return e5.indexOf("turn:") !== 0 || e5.indexOf("transport=udp") === -1 || e5.indexOf("turn:[") !== -1 || r4 ? e5.indexOf("stun:") === 0 && t3 >= 14393 && e5.indexOf("?transport=udp") === -1 : (r4 = true, true);
                }), delete e4.url, e4.urls = n4 ? i4[0] : i4, !!i4.length;
              }
            });
          }(r3.iceServers || [], t2), this._iceGatherers = [], r3.iceCandidatePoolSize)
            for (var o3 = r3.iceCandidatePoolSize; o3 > 0; o3--)
              this._iceGatherers.push(new e2.RTCIceGatherer({ iceServers: r3.iceServers, gatherPolicy: r3.iceTransportPolicy }));
          else
            r3.iceCandidatePoolSize = 0;
          this._config = r3, this.transceivers = [], this._sdpSessionId = Uw.generateSessionId(), this._sdpSessionVersion = 0, this._dtlsRole = void 0, this._isClosed = false;
        };
        Object.defineProperty(n2.prototype, "localDescription", { configurable: true, get: function() {
          return this._localDescription;
        } }), Object.defineProperty(n2.prototype, "remoteDescription", { configurable: true, get: function() {
          return this._remoteDescription;
        } }), n2.prototype.onicecandidate = null, n2.prototype.onaddstream = null, n2.prototype.ontrack = null, n2.prototype.onremovestream = null, n2.prototype.onsignalingstatechange = null, n2.prototype.oniceconnectionstatechange = null, n2.prototype.onconnectionstatechange = null, n2.prototype.onicegatheringstatechange = null, n2.prototype.onnegotiationneeded = null, n2.prototype.ondatachannel = null, n2.prototype._dispatchEvent = function(e3, t3) {
          this._isClosed || (this.dispatchEvent(t3), typeof this["on" + e3] == "function" && this["on" + e3](t3));
        }, n2.prototype._emitGatheringStateChange = function() {
          var e3 = new Event("icegatheringstatechange");
          this._dispatchEvent("icegatheringstatechange", e3);
        }, n2.prototype.getConfiguration = function() {
          return this._config;
        }, n2.prototype.getLocalStreams = function() {
          return this.localStreams;
        }, n2.prototype.getRemoteStreams = function() {
          return this.remoteStreams;
        }, n2.prototype._createTransceiver = function(e3, t3) {
          var r3 = this.transceivers.length > 0, i3 = { track: null, iceGatherer: null, iceTransport: null, dtlsTransport: null, localCapabilities: null, remoteCapabilities: null, rtpSender: null, rtpReceiver: null, kind: e3, mid: null, sendEncodingParameters: null, recvEncodingParameters: null, stream: null, associatedRemoteMediaStreams: [], wantReceive: true };
          if (this.usingBundle && r3)
            i3.iceTransport = this.transceivers[0].iceTransport, i3.dtlsTransport = this.transceivers[0].dtlsTransport;
          else {
            var n3 = this._createIceAndDtlsTransports();
            i3.iceTransport = n3.iceTransport, i3.dtlsTransport = n3.dtlsTransport;
          }
          return t3 || this.transceivers.push(i3), i3;
        }, n2.prototype.addTrack = function(t3, r3) {
          if (this._isClosed)
            throw jw("InvalidStateError", "Attempted to call addTrack on a closed peerconnection.");
          var i3;
          if (this.transceivers.find(function(e3) {
            return e3.track === t3;
          }))
            throw jw("InvalidAccessError", "Track already exists.");
          for (var n3 = 0; n3 < this.transceivers.length; n3++)
            this.transceivers[n3].track || this.transceivers[n3].kind !== t3.kind || (i3 = this.transceivers[n3]);
          return i3 || (i3 = this._createTransceiver(t3.kind)), this._maybeFireNegotiationNeeded(), this.localStreams.indexOf(r3) === -1 && this.localStreams.push(r3), i3.track = t3, i3.stream = r3, i3.rtpSender = new e2.RTCRtpSender(t3, i3.dtlsTransport), i3.rtpSender;
        }, n2.prototype.addStream = function(e3) {
          var r3 = this;
          if (t2 >= 15025)
            e3.getTracks().forEach(function(t3) {
              r3.addTrack(t3, e3);
            });
          else {
            var i3 = e3.clone();
            e3.getTracks().forEach(function(e4, t3) {
              var r4 = i3.getTracks()[t3];
              e4.addEventListener("enabled", function(e5) {
                r4.enabled = e5.enabled;
              });
            }), i3.getTracks().forEach(function(e4) {
              r3.addTrack(e4, i3);
            });
          }
        }, n2.prototype.removeTrack = function(t3) {
          if (this._isClosed)
            throw jw("InvalidStateError", "Attempted to call removeTrack on a closed peerconnection.");
          if (!(t3 instanceof e2.RTCRtpSender))
            throw new TypeError("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.");
          var r3 = this.transceivers.find(function(e3) {
            return e3.rtpSender === t3;
          });
          if (!r3)
            throw jw("InvalidAccessError", "Sender was not created by this connection.");
          var i3 = r3.stream;
          r3.rtpSender.stop(), r3.rtpSender = null, r3.track = null, r3.stream = null, this.transceivers.map(function(e3) {
            return e3.stream;
          }).indexOf(i3) === -1 && this.localStreams.indexOf(i3) > -1 && this.localStreams.splice(this.localStreams.indexOf(i3), 1), this._maybeFireNegotiationNeeded();
        }, n2.prototype.removeStream = function(e3) {
          var t3 = this;
          e3.getTracks().forEach(function(e4) {
            var r3 = t3.getSenders().find(function(t4) {
              return t4.track === e4;
            });
            r3 && t3.removeTrack(r3);
          });
        }, n2.prototype.getSenders = function() {
          return this.transceivers.filter(function(e3) {
            return !!e3.rtpSender;
          }).map(function(e3) {
            return e3.rtpSender;
          });
        }, n2.prototype.getReceivers = function() {
          return this.transceivers.filter(function(e3) {
            return !!e3.rtpReceiver;
          }).map(function(e3) {
            return e3.rtpReceiver;
          });
        }, n2.prototype._createIceGatherer = function(t3, r3) {
          var i3 = this;
          if (r3 && t3 > 0)
            return this.transceivers[0].iceGatherer;
          if (this._iceGatherers.length)
            return this._iceGatherers.shift();
          var n3 = new e2.RTCIceGatherer({ iceServers: this._config.iceServers, gatherPolicy: this._config.iceTransportPolicy });
          return Object.defineProperty(n3, "state", { value: "new", writable: true }), this.transceivers[t3].bufferedCandidateEvents = [], this.transceivers[t3].bufferCandidates = function(e3) {
            var r4 = !e3.candidate || Object.keys(e3.candidate).length === 0;
            n3.state = r4 ? "completed" : "gathering", i3.transceivers[t3].bufferedCandidateEvents !== null && i3.transceivers[t3].bufferedCandidateEvents.push(e3);
          }, n3.addEventListener("localcandidate", this.transceivers[t3].bufferCandidates), n3;
        }, n2.prototype._gather = function(t3, r3) {
          var i3 = this, n3 = this.transceivers[r3].iceGatherer;
          if (!n3.onlocalcandidate) {
            var o3 = this.transceivers[r3].bufferedCandidateEvents;
            this.transceivers[r3].bufferedCandidateEvents = null, n3.removeEventListener("localcandidate", this.transceivers[r3].bufferCandidates), n3.onlocalcandidate = function(e3) {
              if (!(i3.usingBundle && r3 > 0)) {
                var o4 = new Event("icecandidate");
                o4.candidate = { sdpMid: t3, sdpMLineIndex: r3 };
                var s2 = e3.candidate, a2 = !s2 || Object.keys(s2).length === 0;
                if (a2)
                  n3.state !== "new" && n3.state !== "gathering" || (n3.state = "completed");
                else {
                  n3.state === "new" && (n3.state = "gathering"), s2.component = 1, s2.ufrag = n3.getLocalParameters().usernameFragment;
                  var c2 = Uw.writeCandidate(s2);
                  o4.candidate = Object.assign(o4.candidate, Uw.parseCandidate(c2)), o4.candidate.candidate = c2, o4.candidate.toJSON = function() {
                    return { candidate: o4.candidate.candidate, sdpMid: o4.candidate.sdpMid, sdpMLineIndex: o4.candidate.sdpMLineIndex, usernameFragment: o4.candidate.usernameFragment };
                  };
                }
                var d2 = Uw.getMediaSections(i3._localDescription.sdp);
                d2[o4.candidate.sdpMLineIndex] += a2 ? "a=end-of-candidates\r\n" : "a=" + o4.candidate.candidate + "\r\n", i3._localDescription.sdp = Uw.getDescription(i3._localDescription.sdp) + d2.join("");
                var u2 = i3.transceivers.every(function(e4) {
                  return e4.iceGatherer && e4.iceGatherer.state === "completed";
                });
                i3.iceGatheringState !== "gathering" && (i3.iceGatheringState = "gathering", i3._emitGatheringStateChange()), a2 || i3._dispatchEvent("icecandidate", o4), u2 && (i3._dispatchEvent("icecandidate", new Event("icecandidate")), i3.iceGatheringState = "complete", i3._emitGatheringStateChange());
              }
            }, e2.setTimeout(function() {
              o3.forEach(function(e3) {
                n3.onlocalcandidate(e3);
              });
            }, 0);
          }
        }, n2.prototype._createIceAndDtlsTransports = function() {
          var t3 = this, r3 = new e2.RTCIceTransport(null);
          r3.onicestatechange = function() {
            t3._updateIceConnectionState(), t3._updateConnectionState();
          };
          var i3 = new e2.RTCDtlsTransport(r3);
          return i3.ondtlsstatechange = function() {
            t3._updateConnectionState();
          }, i3.onerror = function() {
            Object.defineProperty(i3, "state", { value: "failed", writable: true }), t3._updateConnectionState();
          }, { iceTransport: r3, dtlsTransport: i3 };
        }, n2.prototype._disposeIceAndDtlsTransports = function(e3) {
          var t3 = this.transceivers[e3].iceGatherer;
          t3 && (delete t3.onlocalcandidate, delete this.transceivers[e3].iceGatherer);
          var r3 = this.transceivers[e3].iceTransport;
          r3 && (delete r3.onicestatechange, delete this.transceivers[e3].iceTransport);
          var i3 = this.transceivers[e3].dtlsTransport;
          i3 && (delete i3.ondtlsstatechange, delete i3.onerror, delete this.transceivers[e3].dtlsTransport);
        }, n2.prototype._transceive = function(e3, r3, i3) {
          var n3 = xw(e3.localCapabilities, e3.remoteCapabilities);
          r3 && e3.rtpSender && (n3.encodings = e3.sendEncodingParameters, n3.rtcp = { cname: Uw.localCName, compound: e3.rtcpParameters.compound }, e3.recvEncodingParameters.length && (n3.rtcp.ssrc = e3.recvEncodingParameters[0].ssrc), e3.rtpSender.send(n3)), i3 && e3.rtpReceiver && n3.codecs.length > 0 && (e3.kind === "video" && e3.recvEncodingParameters && t2 < 15019 && e3.recvEncodingParameters.forEach(function(e4) {
            delete e4.rtx;
          }), e3.recvEncodingParameters.length ? n3.encodings = e3.recvEncodingParameters : n3.encodings = [{}], n3.rtcp = { compound: e3.rtcpParameters.compound }, e3.rtcpParameters.cname && (n3.rtcp.cname = e3.rtcpParameters.cname), e3.sendEncodingParameters.length && (n3.rtcp.ssrc = e3.sendEncodingParameters[0].ssrc), e3.rtpReceiver.receive(n3));
        }, n2.prototype.setLocalDescription = function(e3) {
          var t3, r3, i3 = this;
          if (["offer", "answer"].indexOf(e3.type) === -1)
            return Promise.reject(jw("TypeError", 'Unsupported type "' + e3.type + '"'));
          if (!Fw("setLocalDescription", e3.type, i3.signalingState) || i3._isClosed)
            return Promise.reject(jw("InvalidStateError", "Can not set local " + e3.type + " in state " + i3.signalingState));
          if (e3.type === "offer")
            t3 = Uw.splitSections(e3.sdp), r3 = t3.shift(), t3.forEach(function(e4, t4) {
              var r4 = Uw.parseRtpParameters(e4);
              i3.transceivers[t4].localCapabilities = r4;
            }), i3.transceivers.forEach(function(e4, t4) {
              i3._gather(e4.mid, t4);
            });
          else if (e3.type === "answer") {
            t3 = Uw.splitSections(i3._remoteDescription.sdp), r3 = t3.shift();
            var n3 = Uw.matchPrefix(r3, "a=ice-lite").length > 0;
            t3.forEach(function(e4, t4) {
              var o3 = i3.transceivers[t4], s2 = o3.iceGatherer, a2 = o3.iceTransport, c2 = o3.dtlsTransport, d2 = o3.localCapabilities, u2 = o3.remoteCapabilities;
              if (!(Uw.isRejected(e4) && Uw.matchPrefix(e4, "a=bundle-only").length === 0) && !o3.rejected) {
                var A2 = Uw.getIceParameters(e4, r3), h2 = Uw.getDtlsParameters(e4, r3);
                n3 && (h2.role = "server"), i3.usingBundle && t4 !== 0 || (i3._gather(o3.mid, t4), a2.state === "new" && a2.start(s2, A2, n3 ? "controlling" : "controlled"), c2.state === "new" && c2.start(h2));
                var l2 = xw(d2, u2);
                i3._transceive(o3, l2.codecs.length > 0, false);
              }
            });
          }
          return i3._localDescription = { type: e3.type, sdp: e3.sdp }, e3.type === "offer" ? i3._updateSignalingState("have-local-offer") : i3._updateSignalingState("stable"), Promise.resolve();
        }, n2.prototype.setRemoteDescription = function(n3) {
          var o3 = this;
          if (["offer", "answer"].indexOf(n3.type) === -1)
            return Promise.reject(jw("TypeError", 'Unsupported type "' + n3.type + '"'));
          if (!Fw("setRemoteDescription", n3.type, o3.signalingState) || o3._isClosed)
            return Promise.reject(jw("InvalidStateError", "Can not set remote " + n3.type + " in state " + o3.signalingState));
          var s2 = {};
          o3.remoteStreams.forEach(function(e3) {
            s2[e3.id] = e3;
          });
          var a2 = [], c2 = Uw.splitSections(n3.sdp), d2 = c2.shift(), u2 = Uw.matchPrefix(d2, "a=ice-lite").length > 0, A2 = Uw.matchPrefix(d2, "a=group:BUNDLE ").length > 0;
          o3.usingBundle = A2;
          var h2 = Uw.matchPrefix(d2, "a=ice-options:")[0];
          return o3.canTrickleIceCandidates = !!h2 && h2.substr(14).split(" ").indexOf("trickle") >= 0, c2.forEach(function(i3, c3) {
            var h3 = Uw.splitLines(i3), l2 = Uw.getKind(i3), p2 = Uw.isRejected(i3) && Uw.matchPrefix(i3, "a=bundle-only").length === 0, g2 = h3[0].substr(2).split(" ")[2], f2 = Uw.getDirection(i3, d2), E2 = Uw.parseMsid(i3), I2 = Uw.getMid(i3) || Uw.generateIdentifier();
            if (p2 || l2 === "application" && (g2 === "DTLS/SCTP" || g2 === "UDP/DTLS/SCTP"))
              o3.transceivers[c3] = { mid: I2, kind: l2, protocol: g2, rejected: true };
            else {
              var m2, _2, C2, v2, S2, R2, y2, T2, w2;
              !p2 && o3.transceivers[c3] && o3.transceivers[c3].rejected && (o3.transceivers[c3] = o3._createTransceiver(l2, true));
              var b2, O2, N2 = Uw.parseRtpParameters(i3);
              p2 || (b2 = Uw.getIceParameters(i3, d2), (O2 = Uw.getDtlsParameters(i3, d2)).role = "client"), y2 = Uw.parseRtpEncodingParameters(i3);
              var D2 = Uw.parseRtcpParameters(i3), L2 = Uw.matchPrefix(i3, "a=end-of-candidates", d2).length > 0, P2 = Uw.matchPrefix(i3, "a=candidate:").map(function(e3) {
                return Uw.parseCandidate(e3);
              }).filter(function(e3) {
                return e3.component === 1;
              });
              if ((n3.type === "offer" || n3.type === "answer") && !p2 && A2 && c3 > 0 && o3.transceivers[c3] && (o3._disposeIceAndDtlsTransports(c3), o3.transceivers[c3].iceGatherer = o3.transceivers[0].iceGatherer, o3.transceivers[c3].iceTransport = o3.transceivers[0].iceTransport, o3.transceivers[c3].dtlsTransport = o3.transceivers[0].dtlsTransport, o3.transceivers[c3].rtpSender && o3.transceivers[c3].rtpSender.setTransport(o3.transceivers[0].dtlsTransport), o3.transceivers[c3].rtpReceiver && o3.transceivers[c3].rtpReceiver.setTransport(o3.transceivers[0].dtlsTransport)), n3.type !== "offer" || p2) {
                if (n3.type === "answer" && !p2) {
                  _2 = (m2 = o3.transceivers[c3]).iceGatherer, C2 = m2.iceTransport, v2 = m2.dtlsTransport, S2 = m2.rtpReceiver, R2 = m2.sendEncodingParameters, T2 = m2.localCapabilities, o3.transceivers[c3].recvEncodingParameters = y2, o3.transceivers[c3].remoteCapabilities = N2, o3.transceivers[c3].rtcpParameters = D2, P2.length && C2.state === "new" && (!u2 && !L2 || A2 && c3 !== 0 ? P2.forEach(function(e3) {
                    Vw(m2.iceTransport, e3);
                  }) : C2.setRemoteCandidates(P2)), A2 && c3 !== 0 || (C2.state === "new" && C2.start(_2, b2, "controlling"), v2.state === "new" && v2.start(O2)), !xw(m2.localCapabilities, m2.remoteCapabilities).codecs.filter(function(e3) {
                    return e3.name.toLowerCase() === "rtx";
                  }).length && m2.sendEncodingParameters[0].rtx && delete m2.sendEncodingParameters[0].rtx, o3._transceive(m2, f2 === "sendrecv" || f2 === "recvonly", f2 === "sendrecv" || f2 === "sendonly"), !S2 || f2 !== "sendrecv" && f2 !== "sendonly" ? delete m2.rtpReceiver : (w2 = S2.track, E2 ? (s2[E2.stream] || (s2[E2.stream] = new e2.MediaStream()), r2(w2, s2[E2.stream]), a2.push([w2, S2, s2[E2.stream]])) : (s2.default || (s2.default = new e2.MediaStream()), r2(w2, s2.default), a2.push([w2, S2, s2.default])));
                }
              } else {
                (m2 = o3.transceivers[c3] || o3._createTransceiver(l2)).mid = I2, m2.iceGatherer || (m2.iceGatherer = o3._createIceGatherer(c3, A2)), P2.length && m2.iceTransport.state === "new" && (!L2 || A2 && c3 !== 0 ? P2.forEach(function(e3) {
                  Vw(m2.iceTransport, e3);
                }) : m2.iceTransport.setRemoteCandidates(P2)), T2 = e2.RTCRtpReceiver.getCapabilities(l2), t2 < 15019 && (T2.codecs = T2.codecs.filter(function(e3) {
                  return e3.name !== "rtx";
                })), R2 = m2.sendEncodingParameters || [{ ssrc: 1001 * (2 * c3 + 2) }];
                var k2, B2 = false;
                if (f2 === "sendrecv" || f2 === "sendonly") {
                  if (B2 = !m2.rtpReceiver, S2 = m2.rtpReceiver || new e2.RTCRtpReceiver(m2.dtlsTransport, l2), B2)
                    w2 = S2.track, E2 && E2.stream === "-" || (E2 ? (s2[E2.stream] || (s2[E2.stream] = new e2.MediaStream(), Object.defineProperty(s2[E2.stream], "id", { get: function() {
                      return E2.stream;
                    } })), Object.defineProperty(w2, "id", { get: function() {
                      return E2.track;
                    } }), k2 = s2[E2.stream]) : (s2.default || (s2.default = new e2.MediaStream()), k2 = s2.default)), k2 && (r2(w2, k2), m2.associatedRemoteMediaStreams.push(k2)), a2.push([w2, S2, k2]);
                } else
                  m2.rtpReceiver && m2.rtpReceiver.track && (m2.associatedRemoteMediaStreams.forEach(function(t3) {
                    var r3 = t3.getTracks().find(function(e3) {
                      return e3.id === m2.rtpReceiver.track.id;
                    });
                    r3 && function(t4, r4) {
                      r4.removeTrack(t4), r4.dispatchEvent(new e2.MediaStreamTrackEvent("removetrack", { track: t4 }));
                    }(r3, t3);
                  }), m2.associatedRemoteMediaStreams = []);
                m2.localCapabilities = T2, m2.remoteCapabilities = N2, m2.rtpReceiver = S2, m2.rtcpParameters = D2, m2.sendEncodingParameters = R2, m2.recvEncodingParameters = y2, o3._transceive(o3.transceivers[c3], false, B2);
              }
            }
          }), o3._dtlsRole === void 0 && (o3._dtlsRole = n3.type === "offer" ? "active" : "passive"), o3._remoteDescription = { type: n3.type, sdp: n3.sdp }, n3.type === "offer" ? o3._updateSignalingState("have-remote-offer") : o3._updateSignalingState("stable"), Object.keys(s2).forEach(function(t3) {
            var r3 = s2[t3];
            if (r3.getTracks().length) {
              if (o3.remoteStreams.indexOf(r3) === -1) {
                o3.remoteStreams.push(r3);
                var n4 = new Event("addstream");
                n4.stream = r3, e2.setTimeout(function() {
                  o3._dispatchEvent("addstream", n4);
                });
              }
              a2.forEach(function(e3) {
                var t4 = e3[0], n5 = e3[1];
                r3.id === e3[2].id && i2(o3, t4, n5, [r3]);
              });
            }
          }), a2.forEach(function(e3) {
            e3[2] || i2(o3, e3[0], e3[1], []);
          }), e2.setTimeout(function() {
            o3 && o3.transceivers && o3.transceivers.forEach(function(e3) {
              e3.iceTransport && e3.iceTransport.state === "new" && e3.iceTransport.getRemoteCandidates().length > 0 && (console.warn("Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification"), e3.iceTransport.addRemoteCandidate({}));
            });
          }, 4e3), Promise.resolve();
        }, n2.prototype.close = function() {
          this.transceivers.forEach(function(e3) {
            e3.iceTransport && e3.iceTransport.stop(), e3.dtlsTransport && e3.dtlsTransport.stop(), e3.rtpSender && e3.rtpSender.stop(), e3.rtpReceiver && e3.rtpReceiver.stop();
          }), this._isClosed = true, this._updateSignalingState("closed");
        }, n2.prototype._updateSignalingState = function(e3) {
          this.signalingState = e3;
          var t3 = new Event("signalingstatechange");
          this._dispatchEvent("signalingstatechange", t3);
        }, n2.prototype._maybeFireNegotiationNeeded = function() {
          var t3 = this;
          this.signalingState === "stable" && this.needNegotiation !== true && (this.needNegotiation = true, e2.setTimeout(function() {
            if (t3.needNegotiation) {
              t3.needNegotiation = false;
              var e3 = new Event("negotiationneeded");
              t3._dispatchEvent("negotiationneeded", e3);
            }
          }, 0));
        }, n2.prototype._updateIceConnectionState = function() {
          var e3, t3 = { new: 0, closed: 0, checking: 0, connected: 0, completed: 0, disconnected: 0, failed: 0 };
          if (this.transceivers.forEach(function(e4) {
            e4.iceTransport && !e4.rejected && t3[e4.iceTransport.state]++;
          }), e3 = "new", t3.failed > 0 ? e3 = "failed" : t3.checking > 0 ? e3 = "checking" : t3.disconnected > 0 ? e3 = "disconnected" : t3.new > 0 ? e3 = "new" : t3.connected > 0 ? e3 = "connected" : t3.completed > 0 && (e3 = "completed"), e3 !== this.iceConnectionState) {
            this.iceConnectionState = e3;
            var r3 = new Event("iceconnectionstatechange");
            this._dispatchEvent("iceconnectionstatechange", r3);
          }
        }, n2.prototype._updateConnectionState = function() {
          var e3, t3 = { new: 0, closed: 0, connecting: 0, connected: 0, completed: 0, disconnected: 0, failed: 0 };
          if (this.transceivers.forEach(function(e4) {
            e4.iceTransport && e4.dtlsTransport && !e4.rejected && (t3[e4.iceTransport.state]++, t3[e4.dtlsTransport.state]++);
          }), t3.connected += t3.completed, e3 = "new", t3.failed > 0 ? e3 = "failed" : t3.connecting > 0 ? e3 = "connecting" : t3.disconnected > 0 ? e3 = "disconnected" : t3.new > 0 ? e3 = "new" : t3.connected > 0 && (e3 = "connected"), e3 !== this.connectionState) {
            this.connectionState = e3;
            var r3 = new Event("connectionstatechange");
            this._dispatchEvent("connectionstatechange", r3);
          }
        }, n2.prototype.createOffer = function() {
          var r3 = this;
          if (r3._isClosed)
            return Promise.reject(jw("InvalidStateError", "Can not call createOffer after close"));
          var i3 = r3.transceivers.filter(function(e3) {
            return e3.kind === "audio";
          }).length, n3 = r3.transceivers.filter(function(e3) {
            return e3.kind === "video";
          }).length, o3 = arguments[0];
          if (o3) {
            if (o3.mandatory || o3.optional)
              throw new TypeError("Legacy mandatory/optional constraints not supported.");
            o3.offerToReceiveAudio !== void 0 && (i3 = o3.offerToReceiveAudio === true ? 1 : o3.offerToReceiveAudio === false ? 0 : o3.offerToReceiveAudio), o3.offerToReceiveVideo !== void 0 && (n3 = o3.offerToReceiveVideo === true ? 1 : o3.offerToReceiveVideo === false ? 0 : o3.offerToReceiveVideo);
          }
          for (r3.transceivers.forEach(function(e3) {
            e3.kind === "audio" ? --i3 < 0 && (e3.wantReceive = false) : e3.kind === "video" && --n3 < 0 && (e3.wantReceive = false);
          }); i3 > 0 || n3 > 0; )
            i3 > 0 && (r3._createTransceiver("audio"), i3--), n3 > 0 && (r3._createTransceiver("video"), n3--);
          var s2 = Uw.writeSessionBoilerplate(r3._sdpSessionId, r3._sdpSessionVersion++);
          r3.transceivers.forEach(function(i4, n4) {
            var o4 = i4.track, s3 = i4.kind, a3 = i4.mid || Uw.generateIdentifier();
            i4.mid = a3, i4.iceGatherer || (i4.iceGatherer = r3._createIceGatherer(n4, r3.usingBundle));
            var c2 = e2.RTCRtpSender.getCapabilities(s3);
            t2 < 15019 && (c2.codecs = c2.codecs.filter(function(e3) {
              return e3.name !== "rtx";
            })), c2.codecs.forEach(function(e3) {
              e3.name === "H264" && e3.parameters["level-asymmetry-allowed"] === void 0 && (e3.parameters["level-asymmetry-allowed"] = "1"), i4.remoteCapabilities && i4.remoteCapabilities.codecs && i4.remoteCapabilities.codecs.forEach(function(t3) {
                e3.name.toLowerCase() === t3.name.toLowerCase() && e3.clockRate === t3.clockRate && (e3.preferredPayloadType = t3.payloadType);
              });
            }), c2.headerExtensions.forEach(function(e3) {
              (i4.remoteCapabilities && i4.remoteCapabilities.headerExtensions || []).forEach(function(t3) {
                e3.uri === t3.uri && (e3.id = t3.id);
              });
            });
            var d2 = i4.sendEncodingParameters || [{ ssrc: 1001 * (2 * n4 + 1) }];
            o4 && t2 >= 15019 && s3 === "video" && !d2[0].rtx && (d2[0].rtx = { ssrc: d2[0].ssrc + 1 }), i4.wantReceive && (i4.rtpReceiver = new e2.RTCRtpReceiver(i4.dtlsTransport, s3)), i4.localCapabilities = c2, i4.sendEncodingParameters = d2;
          }), r3._config.bundlePolicy !== "max-compat" && (s2 += "a=group:BUNDLE " + r3.transceivers.map(function(e3) {
            return e3.mid;
          }).join(" ") + "\r\n"), s2 += "a=ice-options:trickle\r\n", r3.transceivers.forEach(function(e3, t3) {
            s2 += Qw(e3, e3.localCapabilities, "offer", e3.stream, r3._dtlsRole), s2 += "a=rtcp-rsize\r\n", !e3.iceGatherer || r3.iceGatheringState === "new" || t3 !== 0 && r3.usingBundle || (e3.iceGatherer.getLocalCandidates().forEach(function(e4) {
              e4.component = 1, s2 += "a=" + Uw.writeCandidate(e4) + "\r\n";
            }), e3.iceGatherer.state === "completed" && (s2 += "a=end-of-candidates\r\n"));
          });
          var a2 = new e2.RTCSessionDescription({ type: "offer", sdp: s2 });
          return Promise.resolve(a2);
        }, n2.prototype.createAnswer = function() {
          var r3 = this;
          if (r3._isClosed)
            return Promise.reject(jw("InvalidStateError", "Can not call createAnswer after close"));
          if (r3.signalingState !== "have-remote-offer" && r3.signalingState !== "have-local-pranswer")
            return Promise.reject(jw("InvalidStateError", "Can not call createAnswer in signalingState " + r3.signalingState));
          var i3 = Uw.writeSessionBoilerplate(r3._sdpSessionId, r3._sdpSessionVersion++);
          r3.usingBundle && (i3 += "a=group:BUNDLE " + r3.transceivers.map(function(e3) {
            return e3.mid;
          }).join(" ") + "\r\n"), i3 += "a=ice-options:trickle\r\n";
          var n3 = Uw.getMediaSections(r3._remoteDescription.sdp).length;
          r3.transceivers.forEach(function(e3, o4) {
            if (!(o4 + 1 > n3)) {
              if (e3.rejected)
                return e3.kind === "application" ? e3.protocol === "DTLS/SCTP" ? i3 += "m=application 0 DTLS/SCTP 5000\r\n" : i3 += "m=application 0 " + e3.protocol + " webrtc-datachannel\r\n" : e3.kind === "audio" ? i3 += "m=audio 0 UDP/TLS/RTP/SAVPF 0\r\na=rtpmap:0 PCMU/8000\r\n" : e3.kind === "video" && (i3 += "m=video 0 UDP/TLS/RTP/SAVPF 120\r\na=rtpmap:120 VP8/90000\r\n"), void (i3 += "c=IN IP4 0.0.0.0\r\na=inactive\r\na=mid:" + e3.mid + "\r\n");
              var s2;
              if (e3.stream)
                e3.kind === "audio" ? s2 = e3.stream.getAudioTracks()[0] : e3.kind === "video" && (s2 = e3.stream.getVideoTracks()[0]), s2 && t2 >= 15019 && e3.kind === "video" && !e3.sendEncodingParameters[0].rtx && (e3.sendEncodingParameters[0].rtx = { ssrc: e3.sendEncodingParameters[0].ssrc + 1 });
              var a2 = xw(e3.localCapabilities, e3.remoteCapabilities);
              !a2.codecs.filter(function(e4) {
                return e4.name.toLowerCase() === "rtx";
              }).length && e3.sendEncodingParameters[0].rtx && delete e3.sendEncodingParameters[0].rtx, i3 += Qw(e3, a2, "answer", e3.stream, r3._dtlsRole), e3.rtcpParameters && e3.rtcpParameters.reducedSize && (i3 += "a=rtcp-rsize\r\n");
            }
          });
          var o3 = new e2.RTCSessionDescription({ type: "answer", sdp: i3 });
          return Promise.resolve(o3);
        }, n2.prototype.addIceCandidate = function(e3) {
          var t3, r3 = this;
          return e3 && e3.sdpMLineIndex === void 0 && !e3.sdpMid ? Promise.reject(new TypeError("sdpMLineIndex or sdpMid required")) : new Promise(function(i3, n3) {
            if (!r3._remoteDescription)
              return n3(jw("InvalidStateError", "Can not add ICE candidate without a remote description"));
            if (e3 && e3.candidate !== "") {
              var o3 = e3.sdpMLineIndex;
              if (e3.sdpMid) {
                for (var s2 = 0; s2 < r3.transceivers.length; s2++)
                  if (r3.transceivers[s2].mid === e3.sdpMid) {
                    o3 = s2;
                    break;
                  }
              }
              var a2 = r3.transceivers[o3];
              if (!a2)
                return n3(jw("OperationError", "Can not add ICE candidate"));
              if (a2.rejected)
                return i3();
              var c2 = Object.keys(e3.candidate).length > 0 ? Uw.parseCandidate(e3.candidate) : {};
              if (c2.protocol === "tcp" && (c2.port === 0 || c2.port === 9))
                return i3();
              if (c2.component && c2.component !== 1)
                return i3();
              if ((o3 === 0 || o3 > 0 && a2.iceTransport !== r3.transceivers[0].iceTransport) && !Vw(a2.iceTransport, c2))
                return n3(jw("OperationError", "Can not add ICE candidate"));
              var d2 = e3.candidate.trim();
              d2.indexOf("a=") === 0 && (d2 = d2.substr(2)), (t3 = Uw.getMediaSections(r3._remoteDescription.sdp))[o3] += "a=" + (c2.type ? d2 : "end-of-candidates") + "\r\n", r3._remoteDescription.sdp = Uw.getDescription(r3._remoteDescription.sdp) + t3.join("");
            } else
              for (var u2 = 0; u2 < r3.transceivers.length && (r3.transceivers[u2].rejected || (r3.transceivers[u2].iceTransport.addRemoteCandidate({}), (t3 = Uw.getMediaSections(r3._remoteDescription.sdp))[u2] += "a=end-of-candidates\r\n", r3._remoteDescription.sdp = Uw.getDescription(r3._remoteDescription.sdp) + t3.join(""), !r3.usingBundle)); u2++)
                ;
            i3();
          });
        }, n2.prototype.getStats = function(t3) {
          if (t3 && t3 instanceof e2.MediaStreamTrack) {
            var r3 = null;
            if (this.transceivers.forEach(function(e3) {
              e3.rtpSender && e3.rtpSender.track === t3 ? r3 = e3.rtpSender : e3.rtpReceiver && e3.rtpReceiver.track === t3 && (r3 = e3.rtpReceiver);
            }), !r3)
              throw jw("InvalidAccessError", "Invalid selector.");
            return r3.getStats();
          }
          var i3 = [];
          return this.transceivers.forEach(function(e3) {
            ["rtpSender", "rtpReceiver", "iceGatherer", "iceTransport", "dtlsTransport"].forEach(function(t4) {
              e3[t4] && i3.push(e3[t4].getStats());
            });
          }), Promise.all(i3).then(function(e3) {
            var t4 = /* @__PURE__ */ new Map();
            return e3.forEach(function(e4) {
              e4.forEach(function(e5) {
                t4.set(e5.id, e5);
              });
            }), t4;
          });
        };
        ["RTCRtpSender", "RTCRtpReceiver", "RTCIceGatherer", "RTCIceTransport", "RTCDtlsTransport"].forEach(function(t3) {
          var r3 = e2[t3];
          if (r3 && r3.prototype && r3.prototype.getStats) {
            var i3 = r3.prototype.getStats;
            r3.prototype.getStats = function() {
              return i3.apply(this).then(function(e3) {
                var t4 = /* @__PURE__ */ new Map();
                return Object.keys(e3).forEach(function(r4) {
                  var i4;
                  e3[r4].type = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[(i4 = e3[r4]).type] || i4.type, t4.set(r4, e3[r4]);
                }), t4;
              });
            };
          }
        });
        var o2 = ["createOffer", "createAnswer"];
        return o2.forEach(function(e3) {
          var t3 = n2.prototype[e3];
          n2.prototype[e3] = function() {
            var e4 = arguments;
            return typeof e4[0] == "function" || typeof e4[1] == "function" ? t3.apply(this, [arguments[2]]).then(function(t4) {
              typeof e4[0] == "function" && e4[0].apply(null, [t4]);
            }, function(t4) {
              typeof e4[1] == "function" && e4[1].apply(null, [t4]);
            }) : t3.apply(this, arguments);
          };
        }), (o2 = ["setLocalDescription", "setRemoteDescription", "addIceCandidate"]).forEach(function(e3) {
          var t3 = n2.prototype[e3];
          n2.prototype[e3] = function() {
            var e4 = arguments;
            return typeof e4[1] == "function" || typeof e4[2] == "function" ? t3.apply(this, arguments).then(function() {
              typeof e4[1] == "function" && e4[1].apply(null);
            }, function(t4) {
              typeof e4[2] == "function" && e4[2].apply(null, [t4]);
            }) : t3.apply(this, arguments);
          };
        }), ["getStats"].forEach(function(e3) {
          var t3 = n2.prototype[e3];
          n2.prototype[e3] = function() {
            var e4 = arguments;
            return typeof e4[1] == "function" ? t3.apply(this, arguments).then(function() {
              typeof e4[1] == "function" && e4[1].apply(null);
            }) : t3.apply(this, arguments);
          };
        }), n2;
      };
      function Kw(e2) {
        const t2 = e2 && e2.navigator, r2 = t2.mediaDevices.getUserMedia.bind(t2.mediaDevices);
        t2.mediaDevices.getUserMedia = function(e3) {
          return r2(e3).catch((e4) => nR.reject(function(e5) {
            return { name: { PermissionDeniedError: "NotAllowedError" }[e5.name] || e5.name, message: e5.message, constraint: e5.constraint, toString() {
              return this.name;
            } };
          }(e4)));
        };
      }
      function Hw(e2) {
        "getDisplayMedia" in e2.navigator && e2.navigator.mediaDevices && (e2.navigator.mediaDevices && "getDisplayMedia" in e2.navigator.mediaDevices || (e2.navigator.mediaDevices.getDisplayMedia = e2.navigator.getDisplayMedia.bind(e2.navigator)));
      }
      function Yw(e2, t2) {
        if (e2.RTCIceGatherer && (e2.RTCIceCandidate || (e2.RTCIceCandidate = function(e3) {
          return e3;
        }), e2.RTCSessionDescription || (e2.RTCSessionDescription = function(e3) {
          return e3;
        }), t2.version < 15025)) {
          const t3 = Object.getOwnPropertyDescriptor(e2.MediaStreamTrack.prototype, "enabled");
          Object.defineProperty(e2.MediaStreamTrack.prototype, "enabled", { set(e3) {
            t3.set.call(this, e3);
            const r3 = new Event("enabled");
            r3.enabled = e3, this.dispatchEvent(r3);
          } });
        }
        e2.RTCRtpSender && !("dtmf" in e2.RTCRtpSender.prototype) && Object.defineProperty(e2.RTCRtpSender.prototype, "dtmf", { get() {
          return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = new e2.RTCDtmfSender(this) : this.track.kind === "video" && (this._dtmf = null)), this._dtmf;
        } }), e2.RTCDtmfSender && !e2.RTCDTMFSender && (e2.RTCDTMFSender = e2.RTCDtmfSender);
        const r2 = Gw(e2, t2.version);
        e2.RTCPeerConnection = function(e3) {
          return e3 && e3.iceServers && (e3.iceServers = function(e4, t3) {
            let r3 = false;
            return (e4 = JSON.parse(JSON.stringify(e4))).filter((e5) => {
              if (e5 && (e5.urls || e5.url)) {
                let t4 = e5.urls || e5.url;
                e5.url && !e5.urls && Qg("RTCIceServer.url", "RTCIceServer.urls");
                const i2 = typeof t4 == "string";
                return i2 && (t4 = [t4]), t4 = t4.filter((e6) => {
                  if (e6.indexOf("stun:") === 0)
                    return false;
                  const t5 = e6.startsWith("turn") && !e6.startsWith("turn:[") && e6.includes("transport=udp");
                  return t5 && !r3 ? (r3 = true, true) : t5 && !r3;
                }), delete e5.url, e5.urls = i2 ? t4[0] : t4, !!t4.length;
              }
            });
          }(e3.iceServers, t2.version), Ug("ICE servers after filtering:", e3.iceServers)), new r2(e3);
        }, e2.RTCPeerConnection.prototype = r2.prototype;
      }
      function Ww(e2) {
        e2.RTCRtpSender && !("replaceTrack" in e2.RTCRtpSender.prototype) && (e2.RTCRtpSender.prototype.replaceTrack = e2.RTCRtpSender.prototype.setTrack);
      }
      var Jw = Object.freeze({ __proto__: null, shimPeerConnection: Yw, shimReplaceTrack: Ww, shimGetUserMedia: Kw, shimGetDisplayMedia: Hw }), qw = Gi, zw = Ki, Xw = n, Zw = K, $w = Q, eb = Uo, tb = Xs, rb = Ht.exports;
      if (qw({ target: "Promise", proto: true, real: true, forced: !!zw && Xw(function() {
        zw.prototype.finally.call({ then: function() {
        } }, function() {
        });
      }) }, { finally: function(e2) {
        var t2 = eb(this, Zw("Promise")), r2 = $w(e2);
        return this.then(r2 ? function(r3) {
          return tb(t2, e2()).then(function() {
            return r3;
          });
        } : e2, r2 ? function(r3) {
          return tb(t2, e2()).then(function() {
            throw r3;
          });
        } : e2);
      } }), $w(zw)) {
        var ib = Zw("Promise").prototype.finally;
        zw.prototype.finally !== ib && rb(zw.prototype, "finally", ib, { unsafe: true });
      }
      function nb(e2, t2) {
        const r2 = e2 && e2.navigator, i2 = e2 && e2.MediaStreamTrack;
        if (r2.getUserMedia = function(e3, t3, i3) {
          Qg("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), r2.mediaDevices.getUserMedia(e3).then(t3, i3);
        }, !(t2.version > 55 && "autoGainControl" in r2.mediaDevices.getSupportedConstraints())) {
          const e3 = function(e4, t4, r3) {
            t4 in e4 && !(r3 in e4) && (e4[r3] = e4[t4], delete e4[t4]);
          }, t3 = r2.mediaDevices.getUserMedia.bind(r2.mediaDevices);
          if (r2.mediaDevices.getUserMedia = function(r3) {
            return typeof r3 == "object" && typeof r3.audio == "object" && (r3 = JSON.parse(JSON.stringify(r3)), e3(r3.audio, "autoGainControl", "mozAutoGainControl"), e3(r3.audio, "noiseSuppression", "mozNoiseSuppression")), t3(r3);
          }, i2 && i2.prototype.getSettings) {
            const t4 = i2.prototype.getSettings;
            i2.prototype.getSettings = function() {
              const r3 = t4.apply(this, arguments);
              return e3(r3, "mozAutoGainControl", "autoGainControl"), e3(r3, "mozNoiseSuppression", "noiseSuppression"), r3;
            };
          }
          if (i2 && i2.prototype.applyConstraints) {
            const t4 = i2.prototype.applyConstraints;
            i2.prototype.applyConstraints = function(r3) {
              return this.kind === "audio" && typeof r3 == "object" && (r3 = JSON.parse(JSON.stringify(r3)), e3(r3, "autoGainControl", "mozAutoGainControl"), e3(r3, "noiseSuppression", "mozNoiseSuppression")), t4.apply(this, [r3]);
            };
          }
        }
      }
      function ob(e2) {
        typeof e2 == "object" && e2.RTCTrackEvent && "receiver" in e2.RTCTrackEvent.prototype && !("transceiver" in e2.RTCTrackEvent.prototype) && Object.defineProperty(e2.RTCTrackEvent.prototype, "transceiver", { get() {
          return { receiver: this.receiver };
        } });
      }
      function sb(e2, t2) {
        if (typeof e2 != "object" || !e2.RTCPeerConnection && !e2.mozRTCPeerConnection)
          return;
        !e2.RTCPeerConnection && e2.mozRTCPeerConnection && (e2.RTCPeerConnection = e2.mozRTCPeerConnection), t2.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(t3) {
          const r3 = e2.RTCPeerConnection.prototype[t3], i3 = { [t3]() {
            return arguments[0] = new (t3 === "addIceCandidate" ? e2.RTCIceCandidate : e2.RTCSessionDescription)(arguments[0]), r3.apply(this, arguments);
          } };
          e2.RTCPeerConnection.prototype[t3] = i3[t3];
        });
        const r2 = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, i2 = e2.RTCPeerConnection.prototype.getStats;
        e2.RTCPeerConnection.prototype.getStats = function() {
          const [e3, n2, o2] = arguments;
          return i2.apply(this, [e3 || null]).then((e4) => {
            if (t2.version < 53 && !n2)
              try {
                e4.forEach((e5) => {
                  e5.type = r2[e5.type] || e5.type;
                });
              } catch (t3) {
                if (t3.name !== "TypeError")
                  throw t3;
                e4.forEach((t4, i3) => {
                  e4.set(i3, Object.assign({}, t4, { type: r2[t4.type] || t4.type }));
                });
              }
            return e4;
          }).then(n2, o2);
        };
      }
      function ab(e2) {
        if (typeof e2 != "object" || !e2.RTCPeerConnection || !e2.RTCRtpSender)
          return;
        if (e2.RTCRtpSender && "getStats" in e2.RTCRtpSender.prototype)
          return;
        const t2 = e2.RTCPeerConnection.prototype.getSenders;
        t2 && (e2.RTCPeerConnection.prototype.getSenders = function() {
          const e3 = t2.apply(this, []);
          return e3.forEach((e4) => e4._pc = this), e3;
        });
        const r2 = e2.RTCPeerConnection.prototype.addTrack;
        r2 && (e2.RTCPeerConnection.prototype.addTrack = function() {
          const e3 = r2.apply(this, arguments);
          return e3._pc = this, e3;
        }), e2.RTCRtpSender.prototype.getStats = function() {
          return this.track ? this._pc.getStats(this.track) : nR.resolve(/* @__PURE__ */ new Map());
        };
      }
      function cb(e2) {
        if (typeof e2 != "object" || !e2.RTCPeerConnection || !e2.RTCRtpSender)
          return;
        if (e2.RTCRtpSender && "getStats" in e2.RTCRtpReceiver.prototype)
          return;
        const t2 = e2.RTCPeerConnection.prototype.getReceivers;
        t2 && (e2.RTCPeerConnection.prototype.getReceivers = function() {
          const e3 = t2.apply(this, []);
          return e3.forEach((e4) => e4._pc = this), e3;
        }), kg(e2, "track", (e3) => (e3.receiver._pc = e3.srcElement, e3)), e2.RTCRtpReceiver.prototype.getStats = function() {
          return this._pc.getStats(this.track);
        };
      }
      function db(e2) {
        e2.RTCPeerConnection && !("removeStream" in e2.RTCPeerConnection.prototype) && (e2.RTCPeerConnection.prototype.removeStream = function(e3) {
          Qg("removeStream", "removeTrack"), this.getSenders().forEach((t2) => {
            t2.track && e3.getTracks().includes(t2.track) && this.removeTrack(t2);
          });
        });
      }
      function ub(e2) {
        e2.DataChannel && !e2.RTCDataChannel && (e2.RTCDataChannel = e2.DataChannel);
      }
      function Ab(e2) {
        if (typeof e2 != "object" || !e2.RTCPeerConnection)
          return;
        const t2 = e2.RTCPeerConnection.prototype.addTransceiver;
        t2 && (e2.RTCPeerConnection.prototype.addTransceiver = function() {
          this.setParametersPromises = [];
          const e3 = arguments[1], r2 = e3 && "sendEncodings" in e3;
          r2 && e3.sendEncodings.forEach((e4) => {
            if ("rid" in e4) {
              if (!/^[a-z0-9]{0,16}$/i.test(e4.rid))
                throw new TypeError("Invalid RID value provided.");
            }
            if ("scaleResolutionDownBy" in e4 && !(parseFloat(e4.scaleResolutionDownBy) >= 1))
              throw new RangeError("scale_resolution_down_by must be >= 1.0");
            if ("maxFramerate" in e4 && !(parseFloat(e4.maxFramerate) >= 0))
              throw new RangeError("max_framerate must be >= 0.0");
          });
          const i2 = t2.apply(this, arguments);
          if (r2) {
            const { sender: t3 } = i2, r3 = t3.getParameters();
            (!("encodings" in r3) || r3.encodings.length === 1 && Object.keys(r3.encodings[0]).length === 0) && (r3.encodings = e3.sendEncodings, t3.sendEncodings = e3.sendEncodings, this.setParametersPromises.push(t3.setParameters(r3).then(() => {
              delete t3.sendEncodings;
            }).catch(() => {
              delete t3.sendEncodings;
            })));
          }
          return i2;
        });
      }
      function hb(e2) {
        if (typeof e2 != "object" || !e2.RTCRtpSender)
          return;
        const t2 = e2.RTCRtpSender.prototype.getParameters;
        t2 && (e2.RTCRtpSender.prototype.getParameters = function() {
          const e3 = t2.apply(this, arguments);
          return "encodings" in e3 || (e3.encodings = [].concat(this.sendEncodings || [{}])), e3;
        });
      }
      function lb(e2) {
        if (typeof e2 != "object" || !e2.RTCPeerConnection)
          return;
        const t2 = e2.RTCPeerConnection.prototype.createOffer;
        e2.RTCPeerConnection.prototype.createOffer = function() {
          return this.setParametersPromises && this.setParametersPromises.length ? nR.all(this.setParametersPromises).then(() => t2.apply(this, arguments)).finally(() => {
            this.setParametersPromises = [];
          }) : t2.apply(this, arguments);
        };
      }
      function pb(e2) {
        if (typeof e2 != "object" || !e2.RTCPeerConnection)
          return;
        const t2 = e2.RTCPeerConnection.prototype.createAnswer;
        e2.RTCPeerConnection.prototype.createAnswer = function() {
          return this.setParametersPromises && this.setParametersPromises.length ? nR.all(this.setParametersPromises).then(() => t2.apply(this, arguments)).finally(() => {
            this.setParametersPromises = [];
          }) : t2.apply(this, arguments);
        };
      }
      var gb = Object.freeze({ __proto__: null, shimOnTrack: ob, shimPeerConnection: sb, shimSenderGetStats: ab, shimReceiverGetStats: cb, shimRemoveStream: db, shimRTCDataChannel: ub, shimAddTransceiver: Ab, shimGetParameters: hb, shimCreateOffer: lb, shimCreateAnswer: pb, shimGetUserMedia: nb, shimGetDisplayMedia: function(e2, t2) {
        e2.navigator.mediaDevices && "getDisplayMedia" in e2.navigator.mediaDevices || e2.navigator.mediaDevices && (e2.navigator.mediaDevices.getDisplayMedia = function(r2) {
          if (!r2 || !r2.video) {
            const e3 = new DOMException("getDisplayMedia without video constraints is undefined");
            return e3.name = "NotFoundError", e3.code = 8, nR.reject(e3);
          }
          return r2.video === true ? r2.video = { mediaSource: t2 } : r2.video.mediaSource = t2, e2.navigator.mediaDevices.getUserMedia(r2);
        });
      } });
      function fb(e2) {
        if (typeof e2 == "object" && e2.RTCPeerConnection) {
          if ("getLocalStreams" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.getLocalStreams = function() {
            return this._localStreams || (this._localStreams = []), this._localStreams;
          }), !("addStream" in e2.RTCPeerConnection.prototype)) {
            const t2 = e2.RTCPeerConnection.prototype.addTrack;
            e2.RTCPeerConnection.prototype.addStream = function(e3) {
              this._localStreams || (this._localStreams = []), this._localStreams.includes(e3) || this._localStreams.push(e3), e3.getAudioTracks().forEach((r2) => t2.call(this, r2, e3)), e3.getVideoTracks().forEach((r2) => t2.call(this, r2, e3));
            }, e2.RTCPeerConnection.prototype.addTrack = function(e3) {
              for (var r2 = arguments.length, i2 = new Array(r2 > 1 ? r2 - 1 : 0), n2 = 1; n2 < r2; n2++)
                i2[n2 - 1] = arguments[n2];
              return i2 && i2.forEach((e4) => {
                this._localStreams ? this._localStreams.includes(e4) || this._localStreams.push(e4) : this._localStreams = [e4];
              }), t2.apply(this, arguments);
            };
          }
          "removeStream" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.removeStream = function(e3) {
            this._localStreams || (this._localStreams = []);
            const t2 = this._localStreams.indexOf(e3);
            if (t2 === -1)
              return;
            this._localStreams.splice(t2, 1);
            const r2 = e3.getTracks();
            this.getSenders().forEach((e4) => {
              r2.includes(e4.track) && this.removeTrack(e4);
            });
          });
        }
      }
      function Eb(e2) {
        if (typeof e2 == "object" && e2.RTCPeerConnection && ("getRemoteStreams" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.getRemoteStreams = function() {
          return this._remoteStreams ? this._remoteStreams : [];
        }), !("onaddstream" in e2.RTCPeerConnection.prototype))) {
          Object.defineProperty(e2.RTCPeerConnection.prototype, "onaddstream", { get() {
            return this._onaddstream;
          }, set(e3) {
            this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e3), this.addEventListener("track", this._onaddstreampoly = (e4) => {
              e4.streams.forEach((e5) => {
                if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(e5))
                  return;
                this._remoteStreams.push(e5);
                const t3 = new Event("addstream");
                t3.stream = e5, this.dispatchEvent(t3);
              });
            });
          } });
          const t2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
          e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
            const e3 = this;
            return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(t3) {
              t3.streams.forEach((t4) => {
                if (e3._remoteStreams || (e3._remoteStreams = []), e3._remoteStreams.indexOf(t4) >= 0)
                  return;
                e3._remoteStreams.push(t4);
                const r2 = new Event("addstream");
                r2.stream = t4, e3.dispatchEvent(r2);
              });
            }), t2.apply(e3, arguments);
          };
        }
      }
      function Ib(e2) {
        if (typeof e2 != "object" || !e2.RTCPeerConnection)
          return;
        const t2 = e2.RTCPeerConnection.prototype, r2 = t2.createOffer, i2 = t2.createAnswer, n2 = t2.setLocalDescription, o2 = t2.setRemoteDescription, s2 = t2.addIceCandidate;
        t2.createOffer = function(e3, t3) {
          const i3 = arguments.length >= 2 ? arguments[2] : arguments[0], n3 = r2.apply(this, [i3]);
          return t3 ? (n3.then(e3, t3), nR.resolve()) : n3;
        }, t2.createAnswer = function(e3, t3) {
          const r3 = arguments.length >= 2 ? arguments[2] : arguments[0], n3 = i2.apply(this, [r3]);
          return t3 ? (n3.then(e3, t3), nR.resolve()) : n3;
        };
        let a2 = function(e3, t3, r3) {
          const i3 = n2.apply(this, [e3]);
          return r3 ? (i3.then(t3, r3), nR.resolve()) : i3;
        };
        t2.setLocalDescription = a2, a2 = function(e3, t3, r3) {
          const i3 = o2.apply(this, [e3]);
          return r3 ? (i3.then(t3, r3), nR.resolve()) : i3;
        }, t2.setRemoteDescription = a2, a2 = function(e3, t3, r3) {
          const i3 = s2.apply(this, [e3]);
          return r3 ? (i3.then(t3, r3), nR.resolve()) : i3;
        }, t2.addIceCandidate = a2;
      }
      function mb(e2) {
        const t2 = e2 && e2.navigator;
        if (t2.mediaDevices && t2.mediaDevices.getUserMedia) {
          const e3 = t2.mediaDevices, r2 = e3.getUserMedia.bind(e3);
          t2.mediaDevices.getUserMedia = (e4) => r2(_b(e4));
        }
        !t2.getUserMedia && t2.mediaDevices && t2.mediaDevices.getUserMedia && (t2.getUserMedia = function(e3, r2, i2) {
          t2.mediaDevices.getUserMedia(e3).then(r2, i2);
        }.bind(t2));
      }
      function _b(e2) {
        return e2 && e2.video !== void 0 ? Object.assign({}, e2, { video: Vg(e2.video) }) : e2;
      }
      function Cb(e2) {
        if (!e2.RTCPeerConnection)
          return;
        const t2 = e2.RTCPeerConnection;
        e2.RTCPeerConnection = function(e3, r2) {
          if (e3 && e3.iceServers) {
            const t3 = [];
            for (let r3 = 0; r3 < e3.iceServers.length; r3++) {
              let i2 = e3.iceServers[r3];
              !i2.hasOwnProperty("urls") && i2.hasOwnProperty("url") ? (Qg("RTCIceServer.url", "RTCIceServer.urls"), i2 = JSON.parse(JSON.stringify(i2)), i2.urls = i2.url, delete i2.url, t3.push(i2)) : t3.push(e3.iceServers[r3]);
            }
            e3.iceServers = t3;
          }
          return new t2(e3, r2);
        }, e2.RTCPeerConnection.prototype = t2.prototype, "generateCertificate" in t2 && Object.defineProperty(e2.RTCPeerConnection, "generateCertificate", { get: () => t2.generateCertificate });
      }
      function vb(e2) {
        typeof e2 == "object" && e2.RTCTrackEvent && "receiver" in e2.RTCTrackEvent.prototype && !("transceiver" in e2.RTCTrackEvent.prototype) && Object.defineProperty(e2.RTCTrackEvent.prototype, "transceiver", { get() {
          return { receiver: this.receiver };
        } });
      }
      function Sb(e2) {
        const t2 = e2.RTCPeerConnection.prototype.createOffer;
        e2.RTCPeerConnection.prototype.createOffer = function(e3) {
          if (e3) {
            e3.offerToReceiveAudio !== void 0 && (e3.offerToReceiveAudio = !!e3.offerToReceiveAudio);
            const t3 = this.getTransceivers().find((e4) => e4.receiver.track.kind === "audio");
            e3.offerToReceiveAudio === false && t3 ? t3.direction === "sendrecv" ? t3.setDirection ? t3.setDirection("sendonly") : t3.direction = "sendonly" : t3.direction === "recvonly" && (t3.setDirection ? t3.setDirection("inactive") : t3.direction = "inactive") : e3.offerToReceiveAudio !== true || t3 || this.addTransceiver("audio"), e3.offerToReceiveVideo !== void 0 && (e3.offerToReceiveVideo = !!e3.offerToReceiveVideo);
            const r2 = this.getTransceivers().find((e4) => e4.receiver.track.kind === "video");
            e3.offerToReceiveVideo === false && r2 ? r2.direction === "sendrecv" ? r2.setDirection ? r2.setDirection("sendonly") : r2.direction = "sendonly" : r2.direction === "recvonly" && (r2.setDirection ? r2.setDirection("inactive") : r2.direction = "inactive") : e3.offerToReceiveVideo !== true || r2 || this.addTransceiver("video");
          }
          return t2.apply(this, arguments);
        };
      }
      function Rb(e2) {
        typeof e2 != "object" || e2.AudioContext || (e2.AudioContext = e2.webkitAudioContext);
      }
      var yb = Object.freeze({ __proto__: null, shimLocalStreamsAPI: fb, shimRemoteStreamsAPI: Eb, shimCallbacksAPI: Ib, shimGetUserMedia: mb, shimConstraints: _b, shimRTCIceServerUrls: Cb, shimTrackEventTransceiver: vb, shimCreateOfferLegacy: Sb, shimAudioContext: Rb }), Tb = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF", wb = pd, bb = hI, Ob = Bc("".replace), Nb = "[	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]", Db = RegExp("^" + Nb + Nb + "*"), Lb = RegExp(Nb + Nb + "*$"), Pb = function(e2) {
        return function(t2) {
          var r2 = bb(wb(t2));
          return 1 & e2 && (r2 = Ob(r2, Db, "")), 2 & e2 && (r2 = Ob(r2, Lb, "")), r2;
        };
      }, kb = { start: Pb(1), end: Pb(2), trim: Pb(3) }, Bb = Em.PROPER, Mb = bc, Ub = Tb, Qb = kb.trim;
      JA({ target: "String", proto: true, forced: function(e2) {
        return Mb(function() {
          return !!Ub[e2]() || "\u200B\x85\u180E"[e2]() !== "\u200B\x85\u180E" || Bb && Ub[e2].name !== e2;
        });
      }("trim") }, { trim: function() {
        return Qb(this);
      } });
      var xb = fh("String").trim, Fb = Mc, Vb = xb, jb = String.prototype, Gb = function(e2) {
        var t2 = e2.trim;
        return typeof e2 == "string" || e2 === jb || Fb(jb, e2) && t2 === jb.trim ? Vb : t2;
      }, Kb = d;
      Gi({ target: "URL", proto: true, enumerable: true }, { toJSON: function() {
        return Kb(URL.prototype.toString, this);
      } });
      var Hb = { exports: {} };
      !function(e2) {
        var t2 = { generateIdentifier: function() {
          return Math.random().toString(36).substr(2, 10);
        } };
        t2.localCName = t2.generateIdentifier(), t2.splitLines = function(e3) {
          return Gb(e3).call(e3).split("\n").map(function(e4) {
            return Gb(e4).call(e4);
          });
        }, t2.splitSections = function(e3) {
          return e3.split("\nm=").map(function(e4, t3) {
            var r2;
            return Gb(r2 = t3 > 0 ? "m=" + e4 : e4).call(r2) + "\r\n";
          });
        }, t2.getDescription = function(e3) {
          var r2 = t2.splitSections(e3);
          return r2 && r2[0];
        }, t2.getMediaSections = function(e3) {
          var r2 = t2.splitSections(e3);
          return r2.shift(), r2;
        }, t2.matchPrefix = function(e3, r2) {
          return t2.splitLines(e3).filter(function(e4) {
            return e4.indexOf(r2) === 0;
          });
        }, t2.parseCandidate = function(e3) {
          for (var t3, r2 = { foundation: (t3 = e3.indexOf("a=candidate:") === 0 ? e3.substring(12).split(" ") : e3.substring(10).split(" "))[0], component: parseInt(t3[1], 10), protocol: t3[2].toLowerCase(), priority: parseInt(t3[3], 10), ip: t3[4], address: t3[4], port: parseInt(t3[5], 10), type: t3[7] }, i2 = 8; i2 < t3.length; i2 += 2)
            switch (t3[i2]) {
              case "raddr":
                r2.relatedAddress = t3[i2 + 1];
                break;
              case "rport":
                r2.relatedPort = parseInt(t3[i2 + 1], 10);
                break;
              case "tcptype":
                r2.tcpType = t3[i2 + 1];
                break;
              case "ufrag":
                r2.ufrag = t3[i2 + 1], r2.usernameFragment = t3[i2 + 1];
                break;
              default:
                r2[t3[i2]] = t3[i2 + 1];
            }
          return r2;
        }, t2.writeCandidate = function(e3) {
          var t3 = [];
          t3.push(e3.foundation), t3.push(e3.component), t3.push(e3.protocol.toUpperCase()), t3.push(e3.priority), t3.push(e3.address || e3.ip), t3.push(e3.port);
          var r2 = e3.type;
          return t3.push("typ"), t3.push(r2), r2 !== "host" && e3.relatedAddress && e3.relatedPort && (t3.push("raddr"), t3.push(e3.relatedAddress), t3.push("rport"), t3.push(e3.relatedPort)), e3.tcpType && e3.protocol.toLowerCase() === "tcp" && (t3.push("tcptype"), t3.push(e3.tcpType)), (e3.usernameFragment || e3.ufrag) && (t3.push("ufrag"), t3.push(e3.usernameFragment || e3.ufrag)), "candidate:" + t3.join(" ");
        }, t2.parseIceOptions = function(e3) {
          return e3.substr(14).split(" ");
        }, t2.parseRtpMap = function(e3) {
          var t3 = e3.substr(9).split(" "), r2 = { payloadType: parseInt(t3.shift(), 10) };
          return t3 = t3[0].split("/"), r2.name = t3[0], r2.clockRate = parseInt(t3[1], 10), r2.channels = t3.length === 3 ? parseInt(t3[2], 10) : 1, r2.numChannels = r2.channels, r2;
        }, t2.writeRtpMap = function(e3) {
          var t3 = e3.payloadType;
          e3.preferredPayloadType !== void 0 && (t3 = e3.preferredPayloadType);
          var r2 = e3.channels || e3.numChannels || 1;
          return "a=rtpmap:" + t3 + " " + e3.name + "/" + e3.clockRate + (r2 !== 1 ? "/" + r2 : "") + "\r\n";
        }, t2.parseExtmap = function(e3) {
          var t3 = e3.substr(9).split(" ");
          return { id: parseInt(t3[0], 10), direction: t3[0].indexOf("/") > 0 ? t3[0].split("/")[1] : "sendrecv", uri: t3[1] };
        }, t2.writeExtmap = function(e3) {
          return "a=extmap:" + (e3.id || e3.preferredId) + (e3.direction && e3.direction !== "sendrecv" ? "/" + e3.direction : "") + " " + e3.uri + "\r\n";
        }, t2.parseFmtp = function(e3) {
          for (var t3, r2 = {}, i2 = e3.substr(e3.indexOf(" ") + 1).split(";"), n2 = 0; n2 < i2.length; n2++) {
            var o2, s2;
            t3 = Gb(o2 = i2[n2]).call(o2).split("="), r2[Gb(s2 = t3[0]).call(s2)] = t3[1];
          }
          return r2;
        }, t2.writeFmtp = function(e3) {
          var t3 = "", r2 = e3.payloadType;
          if (e3.preferredPayloadType !== void 0 && (r2 = e3.preferredPayloadType), e3.parameters && Object.keys(e3.parameters).length) {
            var i2 = [];
            Object.keys(e3.parameters).forEach(function(t4) {
              e3.parameters[t4] ? i2.push(t4 + "=" + e3.parameters[t4]) : i2.push(t4);
            }), t3 += "a=fmtp:" + r2 + " " + i2.join(";") + "\r\n";
          }
          return t3;
        }, t2.parseRtcpFb = function(e3) {
          var t3 = e3.substr(e3.indexOf(" ") + 1).split(" ");
          return { type: t3.shift(), parameter: t3.join(" ") };
        }, t2.writeRtcpFb = function(e3) {
          var t3 = "", r2 = e3.payloadType;
          return e3.preferredPayloadType !== void 0 && (r2 = e3.preferredPayloadType), e3.rtcpFeedback && e3.rtcpFeedback.length && e3.rtcpFeedback.forEach(function(e4) {
            t3 += "a=rtcp-fb:" + r2 + " " + e4.type + (e4.parameter && e4.parameter.length ? " " + e4.parameter : "") + "\r\n";
          }), t3;
        }, t2.parseSsrcMedia = function(e3) {
          var t3 = e3.indexOf(" "), r2 = { ssrc: parseInt(e3.substr(7, t3 - 7), 10) }, i2 = e3.indexOf(":", t3);
          return i2 > -1 ? (r2.attribute = e3.substr(t3 + 1, i2 - t3 - 1), r2.value = e3.substr(i2 + 1)) : r2.attribute = e3.substr(t3 + 1), r2;
        }, t2.parseSsrcGroup = function(e3) {
          var t3 = e3.substr(13).split(" ");
          return { semantics: t3.shift(), ssrcs: t3.map(function(e4) {
            return parseInt(e4, 10);
          }) };
        }, t2.getMid = function(e3) {
          var r2 = t2.matchPrefix(e3, "a=mid:")[0];
          if (r2)
            return r2.substr(6);
        }, t2.parseFingerprint = function(e3) {
          var t3 = e3.substr(14).split(" ");
          return { algorithm: t3[0].toLowerCase(), value: t3[1] };
        }, t2.getDtlsParameters = function(e3, r2) {
          return { role: "auto", fingerprints: t2.matchPrefix(e3 + r2, "a=fingerprint:").map(t2.parseFingerprint) };
        }, t2.writeDtlsParameters = function(e3, t3) {
          var r2 = "a=setup:" + t3 + "\r\n";
          return e3.fingerprints.forEach(function(e4) {
            r2 += "a=fingerprint:" + e4.algorithm + " " + e4.value + "\r\n";
          }), r2;
        }, t2.parseCryptoLine = function(e3) {
          var t3 = e3.substr(9).split(" ");
          return { tag: parseInt(t3[0], 10), cryptoSuite: t3[1], keyParams: t3[2], sessionParams: t3.slice(3) };
        }, t2.writeCryptoLine = function(e3) {
          return "a=crypto:" + e3.tag + " " + e3.cryptoSuite + " " + (typeof e3.keyParams == "object" ? t2.writeCryptoKeyParams(e3.keyParams) : e3.keyParams) + (e3.sessionParams ? " " + e3.sessionParams.join(" ") : "") + "\r\n";
        }, t2.parseCryptoKeyParams = function(e3) {
          if (e3.indexOf("inline:") !== 0)
            return null;
          var t3 = e3.substr(7).split("|");
          return { keyMethod: "inline", keySalt: t3[0], lifeTime: t3[1], mkiValue: t3[2] ? t3[2].split(":")[0] : void 0, mkiLength: t3[2] ? t3[2].split(":")[1] : void 0 };
        }, t2.writeCryptoKeyParams = function(e3) {
          return e3.keyMethod + ":" + e3.keySalt + (e3.lifeTime ? "|" + e3.lifeTime : "") + (e3.mkiValue && e3.mkiLength ? "|" + e3.mkiValue + ":" + e3.mkiLength : "");
        }, t2.getCryptoParameters = function(e3, r2) {
          return t2.matchPrefix(e3 + r2, "a=crypto:").map(t2.parseCryptoLine);
        }, t2.getIceParameters = function(e3, r2) {
          var i2 = t2.matchPrefix(e3 + r2, "a=ice-ufrag:")[0], n2 = t2.matchPrefix(e3 + r2, "a=ice-pwd:")[0];
          return i2 && n2 ? { usernameFragment: i2.substr(12), password: n2.substr(10) } : null;
        }, t2.writeIceParameters = function(e3) {
          return "a=ice-ufrag:" + e3.usernameFragment + "\r\na=ice-pwd:" + e3.password + "\r\n";
        }, t2.parseRtpParameters = function(e3) {
          for (var r2 = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, i2 = t2.splitLines(e3)[0].split(" "), n2 = 3; n2 < i2.length; n2++) {
            var o2 = i2[n2], s2 = t2.matchPrefix(e3, "a=rtpmap:" + o2 + " ")[0];
            if (s2) {
              var a2 = t2.parseRtpMap(s2), c2 = t2.matchPrefix(e3, "a=fmtp:" + o2 + " ");
              switch (a2.parameters = c2.length ? t2.parseFmtp(c2[0]) : {}, a2.rtcpFeedback = t2.matchPrefix(e3, "a=rtcp-fb:" + o2 + " ").map(t2.parseRtcpFb), r2.codecs.push(a2), a2.name.toUpperCase()) {
                case "RED":
                case "ULPFEC":
                  r2.fecMechanisms.push(a2.name.toUpperCase());
              }
            }
          }
          return t2.matchPrefix(e3, "a=extmap:").forEach(function(e4) {
            r2.headerExtensions.push(t2.parseExtmap(e4));
          }), r2;
        }, t2.writeRtpDescription = function(e3, r2) {
          var i2 = "";
          i2 += "m=" + e3 + " ", i2 += r2.codecs.length > 0 ? "9" : "0", i2 += " UDP/TLS/RTP/SAVPF ", i2 += r2.codecs.map(function(e4) {
            return e4.preferredPayloadType !== void 0 ? e4.preferredPayloadType : e4.payloadType;
          }).join(" ") + "\r\n", i2 += "c=IN IP4 0.0.0.0\r\n", i2 += "a=rtcp:9 IN IP4 0.0.0.0\r\n", r2.codecs.forEach(function(e4) {
            i2 += t2.writeRtpMap(e4), i2 += t2.writeFmtp(e4), i2 += t2.writeRtcpFb(e4);
          });
          var n2 = 0;
          return r2.codecs.forEach(function(e4) {
            e4.maxptime > n2 && (n2 = e4.maxptime);
          }), n2 > 0 && (i2 += "a=maxptime:" + n2 + "\r\n"), i2 += "a=rtcp-mux\r\n", r2.headerExtensions && r2.headerExtensions.forEach(function(e4) {
            i2 += t2.writeExtmap(e4);
          }), i2;
        }, t2.parseRtpEncodingParameters = function(e3) {
          var r2, i2 = [], n2 = t2.parseRtpParameters(e3), o2 = n2.fecMechanisms.indexOf("RED") !== -1, s2 = n2.fecMechanisms.indexOf("ULPFEC") !== -1, a2 = t2.matchPrefix(e3, "a=ssrc:").map(function(e4) {
            return t2.parseSsrcMedia(e4);
          }).filter(function(e4) {
            return e4.attribute === "cname";
          }), c2 = a2.length > 0 && a2[0].ssrc, d2 = t2.matchPrefix(e3, "a=ssrc-group:FID").map(function(e4) {
            return e4.substr(17).split(" ").map(function(e5) {
              return parseInt(e5, 10);
            });
          });
          d2.length > 0 && d2[0].length > 1 && d2[0][0] === c2 && (r2 = d2[0][1]), n2.codecs.forEach(function(e4) {
            if (e4.name.toUpperCase() === "RTX" && e4.parameters.apt) {
              var t3 = { ssrc: c2, codecPayloadType: parseInt(e4.parameters.apt, 10) };
              c2 && r2 && (t3.rtx = { ssrc: r2 }), i2.push(t3), o2 && ((t3 = JSON.parse(JSON.stringify(t3))).fec = { ssrc: c2, mechanism: s2 ? "red+ulpfec" : "red" }, i2.push(t3));
            }
          }), i2.length === 0 && c2 && i2.push({ ssrc: c2 });
          var u2 = t2.matchPrefix(e3, "b=");
          return u2.length && (u2 = u2[0].indexOf("b=TIAS:") === 0 ? parseInt(u2[0].substr(7), 10) : u2[0].indexOf("b=AS:") === 0 ? 1e3 * parseInt(u2[0].substr(5), 10) * 0.95 - 16e3 : void 0, i2.forEach(function(e4) {
            e4.maxBitrate = u2;
          })), i2;
        }, t2.parseRtcpParameters = function(e3) {
          var r2 = {}, i2 = t2.matchPrefix(e3, "a=ssrc:").map(function(e4) {
            return t2.parseSsrcMedia(e4);
          }).filter(function(e4) {
            return e4.attribute === "cname";
          })[0];
          i2 && (r2.cname = i2.value, r2.ssrc = i2.ssrc);
          var n2 = t2.matchPrefix(e3, "a=rtcp-rsize");
          r2.reducedSize = n2.length > 0, r2.compound = n2.length === 0;
          var o2 = t2.matchPrefix(e3, "a=rtcp-mux");
          return r2.mux = o2.length > 0, r2;
        }, t2.parseMsid = function(e3) {
          var r2, i2 = t2.matchPrefix(e3, "a=msid:");
          if (i2.length === 1)
            return { stream: (r2 = i2[0].substr(7).split(" "))[0], track: r2[1] };
          var n2 = t2.matchPrefix(e3, "a=ssrc:").map(function(e4) {
            return t2.parseSsrcMedia(e4);
          }).filter(function(e4) {
            return e4.attribute === "msid";
          });
          return n2.length > 0 ? { stream: (r2 = n2[0].value.split(" "))[0], track: r2[1] } : void 0;
        }, t2.parseSctpDescription = function(e3) {
          var r2, i2 = t2.parseMLine(e3), n2 = t2.matchPrefix(e3, "a=max-message-size:");
          n2.length > 0 && (r2 = parseInt(n2[0].substr(19), 10)), isNaN(r2) && (r2 = 65536);
          var o2 = t2.matchPrefix(e3, "a=sctp-port:");
          if (o2.length > 0)
            return { port: parseInt(o2[0].substr(12), 10), protocol: i2.fmt, maxMessageSize: r2 };
          if (t2.matchPrefix(e3, "a=sctpmap:").length > 0) {
            var s2 = t2.matchPrefix(e3, "a=sctpmap:")[0].substr(10).split(" ");
            return { port: parseInt(s2[0], 10), protocol: s2[1], maxMessageSize: r2 };
          }
        }, t2.writeSctpDescription = function(e3, t3) {
          var r2 = [];
          return r2 = e3.protocol !== "DTLS/SCTP" ? ["m=" + e3.kind + " 9 " + e3.protocol + " " + t3.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t3.port + "\r\n"] : ["m=" + e3.kind + " 9 " + e3.protocol + " " + t3.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t3.port + " " + t3.protocol + " 65535\r\n"], t3.maxMessageSize !== void 0 && r2.push("a=max-message-size:" + t3.maxMessageSize + "\r\n"), r2.join("");
        }, t2.generateSessionId = function() {
          return Math.random().toString().substr(2, 21);
        }, t2.writeSessionBoilerplate = function(e3, r2, i2) {
          var n2 = r2 !== void 0 ? r2 : 2;
          return "v=0\r\no=" + (i2 || "thisisadapterortc") + " " + (e3 || t2.generateSessionId()) + " " + n2 + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
        }, t2.writeMediaSection = function(e3, r2, i2, n2) {
          var o2 = t2.writeRtpDescription(e3.kind, r2);
          if (o2 += t2.writeIceParameters(e3.iceGatherer.getLocalParameters()), o2 += t2.writeDtlsParameters(e3.dtlsTransport.getLocalParameters(), i2 === "offer" ? "actpass" : "active"), o2 += "a=mid:" + e3.mid + "\r\n", e3.direction ? o2 += "a=" + e3.direction + "\r\n" : e3.rtpSender && e3.rtpReceiver ? o2 += "a=sendrecv\r\n" : e3.rtpSender ? o2 += "a=sendonly\r\n" : e3.rtpReceiver ? o2 += "a=recvonly\r\n" : o2 += "a=inactive\r\n", e3.rtpSender) {
            var s2 = "msid:" + n2.id + " " + e3.rtpSender.track.id + "\r\n";
            o2 += "a=" + s2, o2 += "a=ssrc:" + e3.sendEncodingParameters[0].ssrc + " " + s2, e3.sendEncodingParameters[0].rtx && (o2 += "a=ssrc:" + e3.sendEncodingParameters[0].rtx.ssrc + " " + s2, o2 += "a=ssrc-group:FID " + e3.sendEncodingParameters[0].ssrc + " " + e3.sendEncodingParameters[0].rtx.ssrc + "\r\n");
          }
          return o2 += "a=ssrc:" + e3.sendEncodingParameters[0].ssrc + " cname:" + t2.localCName + "\r\n", e3.rtpSender && e3.sendEncodingParameters[0].rtx && (o2 += "a=ssrc:" + e3.sendEncodingParameters[0].rtx.ssrc + " cname:" + t2.localCName + "\r\n"), o2;
        }, t2.getDirection = function(e3, r2) {
          for (var i2 = t2.splitLines(e3), n2 = 0; n2 < i2.length; n2++)
            switch (i2[n2]) {
              case "a=sendrecv":
              case "a=sendonly":
              case "a=recvonly":
              case "a=inactive":
                return i2[n2].substr(2);
            }
          return r2 ? t2.getDirection(r2) : "sendrecv";
        }, t2.getKind = function(e3) {
          return t2.splitLines(e3)[0].split(" ")[0].substr(2);
        }, t2.isRejected = function(e3) {
          return e3.split(" ", 2)[1] === "0";
        }, t2.parseMLine = function(e3) {
          var r2 = t2.splitLines(e3)[0].substr(2).split(" ");
          return { kind: r2[0], port: parseInt(r2[1], 10), protocol: r2[2], fmt: r2.slice(3).join(" ") };
        }, t2.parseOLine = function(e3) {
          var r2 = t2.matchPrefix(e3, "o=")[0].substr(2).split(" ");
          return { username: r2[0], sessionId: r2[1], sessionVersion: parseInt(r2[2], 10), netType: r2[3], addressType: r2[4], address: r2[5] };
        }, t2.isValidSDP = function(e3) {
          if (typeof e3 != "string" || e3.length === 0)
            return false;
          for (var r2 = t2.splitLines(e3), i2 = 0; i2 < r2.length; i2++)
            if (r2[i2].length < 2 || r2[i2].charAt(1) !== "=")
              return false;
          return true;
        }, e2.exports = t2;
      }(Hb);
      var Yb = Hb.exports;
      function Wb(e2) {
        if (!e2.RTCIceCandidate || e2.RTCIceCandidate && "foundation" in e2.RTCIceCandidate.prototype)
          return;
        const t2 = e2.RTCIceCandidate;
        e2.RTCIceCandidate = function(e3) {
          if (typeof e3 == "object" && e3.candidate && e3.candidate.indexOf("a=") === 0 && ((e3 = JSON.parse(JSON.stringify(e3))).candidate = e3.candidate.substr(2)), e3.candidate && e3.candidate.length) {
            const r2 = new t2(e3), i2 = Yb.parseCandidate(e3.candidate), n2 = Object.assign(r2, i2);
            return n2.toJSON = function() {
              return { candidate: n2.candidate, sdpMid: n2.sdpMid, sdpMLineIndex: n2.sdpMLineIndex, usernameFragment: n2.usernameFragment };
            }, n2;
          }
          return new t2(e3);
        }, e2.RTCIceCandidate.prototype = t2.prototype, kg(e2, "icecandidate", (t3) => (t3.candidate && Object.defineProperty(t3, "candidate", { value: new e2.RTCIceCandidate(t3.candidate), writable: "false" }), t3));
      }
      function Jb(e2, t2) {
        if (!e2.RTCPeerConnection)
          return;
        "sctp" in e2.RTCPeerConnection.prototype || Object.defineProperty(e2.RTCPeerConnection.prototype, "sctp", { get() {
          return this._sctp === void 0 ? null : this._sctp;
        } });
        const r2 = function(e3) {
          if (!e3 || !e3.sdp)
            return false;
          const t3 = Yb.splitSections(e3.sdp);
          return t3.shift(), t3.some((e4) => {
            const t4 = Yb.parseMLine(e4);
            return t4 && t4.kind === "application" && t4.protocol.indexOf("SCTP") !== -1;
          });
        }, i2 = function(e3) {
          const t3 = e3.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
          if (t3 === null || t3.length < 2)
            return -1;
          const r3 = parseInt(t3[1], 10);
          return r3 != r3 ? -1 : r3;
        }, n2 = function(e3) {
          let r3 = 65536;
          return t2.browser === "firefox" && (r3 = t2.version < 57 ? e3 === -1 ? 16384 : 2147483637 : t2.version < 60 ? t2.version === 57 ? 65535 : 65536 : 2147483637), r3;
        }, o2 = function(e3, r3) {
          let i3 = 65536;
          t2.browser === "firefox" && t2.version === 57 && (i3 = 65535);
          const n3 = Yb.matchPrefix(e3.sdp, "a=max-message-size:");
          return n3.length > 0 ? i3 = parseInt(n3[0].substr(19), 10) : t2.browser === "firefox" && r3 !== -1 && (i3 = 2147483637), i3;
        }, s2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
        e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
          if (this._sctp = null, t2.browser === "chrome" && t2.version >= 76) {
            const { sdpSemantics: e3 } = this.getConfiguration();
            e3 === "plan-b" && Object.defineProperty(this, "sctp", { get() {
              return this._sctp === void 0 ? null : this._sctp;
            }, enumerable: true, configurable: true });
          }
          if (r2(arguments[0])) {
            const e3 = i2(arguments[0]), t3 = n2(e3), r3 = o2(arguments[0], e3);
            let s3;
            s3 = t3 === 0 && r3 === 0 ? Number.POSITIVE_INFINITY : t3 === 0 || r3 === 0 ? Math.max(t3, r3) : Math.min(t3, r3);
            const a2 = {};
            Object.defineProperty(a2, "maxMessageSize", { get: () => s3 }), this._sctp = a2;
          }
          return s2.apply(this, arguments);
        };
      }
      function qb(e2) {
        if (!e2.RTCPeerConnection || !("createDataChannel" in e2.RTCPeerConnection.prototype))
          return;
        function t2(e3, t3) {
          const r3 = e3.send;
          e3.send = function() {
            const i2 = arguments[0], n2 = i2.length || i2.size || i2.byteLength;
            if (e3.readyState === "open" && t3.sctp && n2 > t3.sctp.maxMessageSize)
              throw new TypeError("Message too large (can send a maximum of " + t3.sctp.maxMessageSize + " bytes)");
            return r3.apply(e3, arguments);
          };
        }
        const r2 = e2.RTCPeerConnection.prototype.createDataChannel;
        e2.RTCPeerConnection.prototype.createDataChannel = function() {
          const e3 = r2.apply(this, arguments);
          return t2(e3, this), e3;
        }, kg(e2, "datachannel", (e3) => (t2(e3.channel, e3.target), e3));
      }
      function zb(e2) {
        if (!e2.RTCPeerConnection || "connectionState" in e2.RTCPeerConnection.prototype)
          return;
        const t2 = e2.RTCPeerConnection.prototype;
        Object.defineProperty(t2, "connectionState", { get() {
          return { completed: "connected", checking: "connecting" }[this.iceConnectionState] || this.iceConnectionState;
        }, enumerable: true, configurable: true }), Object.defineProperty(t2, "onconnectionstatechange", { get() {
          return this._onconnectionstatechange || null;
        }, set(e3) {
          this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), e3 && this.addEventListener("connectionstatechange", this._onconnectionstatechange = e3);
        }, enumerable: true, configurable: true }), ["setLocalDescription", "setRemoteDescription"].forEach((e3) => {
          const r2 = t2[e3];
          t2[e3] = function() {
            return this._connectionstatechangepoly || (this._connectionstatechangepoly = (e4) => {
              const t3 = e4.target;
              if (t3._lastConnectionState !== t3.connectionState) {
                t3._lastConnectionState = t3.connectionState;
                const r3 = new Event("connectionstatechange", e4);
                t3.dispatchEvent(r3);
              }
              return e4;
            }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), r2.apply(this, arguments);
          };
        });
      }
      function Xb(e2, t2) {
        if (!e2.RTCPeerConnection)
          return;
        if (t2.browser === "chrome" && t2.version >= 71)
          return;
        if (t2.browser === "safari" && t2.version >= 605)
          return;
        const r2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
        e2.RTCPeerConnection.prototype.setRemoteDescription = function(t3) {
          if (t3 && t3.sdp && t3.sdp.indexOf("\na=extmap-allow-mixed") !== -1) {
            const r3 = t3.sdp.split("\n").filter((e3) => Gb(e3).call(e3) !== "a=extmap-allow-mixed").join("\n");
            e2.RTCSessionDescription && t3 instanceof e2.RTCSessionDescription ? arguments[0] = new e2.RTCSessionDescription({ type: t3.type, sdp: r3 }) : t3.sdp = r3;
          }
          return r2.apply(this, arguments);
        };
      }
      function Zb(e2, t2) {
        if (!e2.RTCPeerConnection || !e2.RTCPeerConnection.prototype)
          return;
        const r2 = e2.RTCPeerConnection.prototype.addIceCandidate;
        r2 && r2.length !== 0 && (e2.RTCPeerConnection.prototype.addIceCandidate = function() {
          return arguments[0] ? (t2.browser === "chrome" && t2.version < 78 || t2.browser === "firefox" && t2.version < 68 || t2.browser === "safari") && arguments[0] && arguments[0].candidate === "" ? nR.resolve() : r2.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), nR.resolve());
        });
      }
      var $b = Object.freeze({ __proto__: null, shimRTCIceCandidate: Wb, shimMaxMessageSize: Jb, shimSendThrowTypeError: qb, shimConnectionState: zb, removeExtmapAllowMixed: Xb, shimAddIceCandidateNullOrEmpty: Zb });
      let eO, tO;
      !function() {
        let { window: e2 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { shimChrome: true, shimFirefox: true, shimEdge: true, shimSafari: true };
        const r2 = Ug, i2 = xg(e2), n2 = { browserDetails: i2, commonShim: $b, extractVersion: Pg, disableLog: Bg, disableWarnings: Mg };
        switch (i2.browser) {
          case "chrome":
            if (!Bw || !Pw || !t2.shimChrome)
              return r2("Chrome shim is not included in this adapter release."), n2;
            if (i2.version === null)
              return r2("Chrome shim can not determine version, not shimming."), n2;
            r2("adapter.js shimming chrome."), n2.browserShim = Bw, Zb(e2, i2), yw(e2, i2), Tw(e2), Pw(e2, i2), ww(e2), Lw(e2, i2), bw(e2), Ow(e2), Nw(e2), kw(e2, i2), Wb(e2), zb(e2), Jb(e2, i2), qb(e2), Xb(e2, i2);
            break;
          case "firefox":
            if (!gb || !sb || !t2.shimFirefox)
              return r2("Firefox shim is not included in this adapter release."), n2;
            r2("adapter.js shimming firefox."), n2.browserShim = gb, Zb(e2, i2), nb(e2, i2), sb(e2, i2), ob(e2), db(e2), ab(e2), cb(e2), ub(e2), Ab(e2), hb(e2), lb(e2), pb(e2), Wb(e2), zb(e2), Jb(e2, i2), qb(e2);
            break;
          case "edge":
            if (!Jw || !Yw || !t2.shimEdge)
              return r2("MS edge shim is not included in this adapter release."), n2;
            r2("adapter.js shimming edge."), n2.browserShim = Jw, Kw(e2), Hw(e2), Yw(e2, i2), Ww(e2), Jb(e2, i2), qb(e2);
            break;
          case "safari":
            if (!yb || !t2.shimSafari)
              return r2("Safari shim is not included in this adapter release."), n2;
            r2("adapter.js shimming safari."), n2.browserShim = yb, Zb(e2, i2), Cb(e2), Sb(e2), Ib(e2), fb(e2), Eb(e2), vb(e2), mb(e2), Rb(e2), Wb(e2), Jb(e2, i2), qb(e2), Xb(e2, i2);
            break;
          default:
            r2("Unsupported browser!");
        }
      }({ window: typeof window == "undefined" ? void 0 : window }), function(e2) {
        e2.WIN_10 = "Windows 10", e2.WIN_81 = "Windows 8.1", e2.WIN_8 = "Windows 8", e2.WIN_7 = "Windows 7", e2.WIN_VISTA = "Windows Vista", e2.WIN_SERVER_2003 = "Windows Server 2003", e2.WIN_XP = "Windows XP", e2.WIN_2000 = "Windows 2000", e2.ANDROID = "Android", e2.OPEN_BSD = "Open BSD", e2.SUN_OS = "Sun OS", e2.LINUX = "Linux", e2.IOS = "iOS", e2.MAC_OS = "Mac OS", e2.QNX = "QNX", e2.UNIX = "UNIX", e2.BEOS = "BeOS", e2.OS_2 = "OS/2", e2.SEARCH_BOT = "Search Bot";
      }(eO || (eO = {})), function(e2) {
        e2.CHROME = "Chrome", e2.SAFARI = "Safari", e2.EDGE = "Edge", e2.FIREFOX = "Firefox", e2.OPERA = "OPR", e2.QQ = "QQBrowser", e2.WECHAT = "MicroMessenger";
      }(tO || (tO = {}));
      var rO = { exports: {} };
      !function(t2, r2) {
        !function(e2, i2) {
          var n2 = "function", o2 = "object", s2 = "string", a2 = "model", c2 = "name", d2 = "type", u2 = "vendor", A2 = "version", h2 = "architecture", l2 = "console", p2 = "mobile", g2 = "tablet", f2 = "smarttv", E2 = "wearable", I2 = "embedded", m2 = { extend: function(e3, t3) {
            var r3 = {};
            for (var i3 in e3)
              t3[i3] && t3[i3].length % 2 == 0 ? r3[i3] = t3[i3].concat(e3[i3]) : r3[i3] = e3[i3];
            return r3;
          }, has: function(e3, t3) {
            return typeof e3 === s2 && t3.toLowerCase().indexOf(e3.toLowerCase()) !== -1;
          }, lowerize: function(e3) {
            return e3.toLowerCase();
          }, major: function(e3) {
            return typeof e3 === s2 ? e3.replace(/[^\d\.]/g, "").split(".")[0] : i2;
          }, trim: function(e3, t3) {
            return e3 = e3.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), t3 === void 0 ? e3 : e3.substring(0, 255);
          } }, _2 = { rgx: function(e3, t3) {
            for (var r3, s3, a3, c3, d3, u3, A3 = 0; A3 < t3.length && !d3; ) {
              var h3 = t3[A3], l3 = t3[A3 + 1];
              for (r3 = s3 = 0; r3 < h3.length && !d3; )
                if (d3 = h3[r3++].exec(e3))
                  for (a3 = 0; a3 < l3.length; a3++)
                    u3 = d3[++s3], typeof (c3 = l3[a3]) === o2 && c3.length > 0 ? c3.length == 2 ? typeof c3[1] == n2 ? this[c3[0]] = c3[1].call(this, u3) : this[c3[0]] = c3[1] : c3.length == 3 ? typeof c3[1] !== n2 || c3[1].exec && c3[1].test ? this[c3[0]] = u3 ? u3.replace(c3[1], c3[2]) : i2 : this[c3[0]] = u3 ? c3[1].call(this, u3, c3[2]) : i2 : c3.length == 4 && (this[c3[0]] = u3 ? c3[3].call(this, u3.replace(c3[1], c3[2])) : i2) : this[c3] = u3 || i2;
              A3 += 2;
            }
          }, str: function(e3, t3) {
            for (var r3 in t3)
              if (typeof t3[r3] === o2 && t3[r3].length > 0) {
                for (var n3 = 0; n3 < t3[r3].length; n3++)
                  if (m2.has(t3[r3][n3], e3))
                    return r3 === "?" ? i2 : r3;
              } else if (m2.has(t3[r3], e3))
                return r3 === "?" ? i2 : r3;
            return e3;
          } }, C2 = { browser: { oldSafari: { version: { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" } }, oldEdge: { version: { 0.1: "12.", 21: "13.", 31: "14.", 39: "15.", 41: "16.", 42: "17.", 44: "18." } } }, os: { windows: { version: { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" } } } }, v2 = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [A2, [c2, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [A2, [c2, "Edge"]], [/(opera\smini)\/([\w\.-]+)/i, /(opera\s[mobiletab]{3,6})\b.+version\/([\w\.-]+)/i, /(opera)(?:.+version\/|[\/\s]+)([\w\.]+)/i], [c2, A2], [/opios[\/\s]+([\w\.]+)/i], [A2, [c2, "Opera Mini"]], [/\sopr\/([\w\.]+)/i], [A2, [c2, "Opera"]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]*)/i, /(avant\s|iemobile|slim)(?:browser)?[\/\s]?([\w\.]*)/i, /(ba?idubrowser)[\/\s]?([\w\.]+)/i, /(?:ms|\()(ie)\s([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon)\/([\w\.-]+)/i, /(rekonq|puffin|brave|whale|qqbrowserlite|qq)\/([\w\.]+)/i, /(weibo)__([\d\.]+)/i], [c2, A2], [/(?:[\s\/]uc?\s?browser|(?:juc.+)ucweb)[\/\s]?([\w\.]+)/i], [A2, [c2, "UCBrowser"]], [/(?:windowswechat)?\sqbcore\/([\w\.]+)\b.*(?:windowswechat)?/i], [A2, [c2, "WeChat(Win) Desktop"]], [/micromessenger\/([\w\.]+)/i], [A2, [c2, "WeChat"]], [/konqueror\/([\w\.]+)/i], [A2, [c2, "Konqueror"]], [/trident.+rv[:\s]([\w\.]{1,9})\b.+like\sgecko/i], [A2, [c2, "IE"]], [/yabrowser\/([\w\.]+)/i], [A2, [c2, "Yandex"]], [/(avast|avg)\/([\w\.]+)/i], [[c2, /(.+)/, "$1 Secure Browser"], A2], [/focus\/([\w\.]+)/i], [A2, [c2, "Firefox Focus"]], [/opt\/([\w\.]+)/i], [A2, [c2, "Opera Touch"]], [/coc_coc_browser\/([\w\.]+)/i], [A2, [c2, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [A2, [c2, "Dolphin"]], [/coast\/([\w\.]+)/i], [A2, [c2, "Opera Coast"]], [/xiaomi\/miuibrowser\/([\w\.]+)/i], [A2, [c2, "MIUI Browser"]], [/fxios\/([\w\.-]+)/i], [A2, [c2, "Firefox"]], [/(qihu|qhbrowser|qihoobrowser|360browser)/i], [[c2, "360 Browser"]], [/(oculus|samsung|sailfish)browser\/([\w\.]+)/i], [[c2, /(.+)/, "$1 Browser"], A2], [/(comodo_dragon)\/([\w\.]+)/i], [[c2, /_/g, " "], A2], [/\s(electron)\/([\w\.]+)\ssafari/i, /(tesla)(?:\sqtcarbrowser|\/(20[12]\d\.[\w\.-]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\/\s]?([\w\.]+)/i], [c2, A2], [/(MetaSr)[\/\s]?([\w\.]+)/i, /(LBBROWSER)/i], [c2], [/;fbav\/([\w\.]+);/i], [A2, [c2, "Facebook"]], [/FBAN\/FBIOS|FB_IAB\/FB4A/i], [[c2, "Facebook"]], [/safari\s(line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(chromium|instagram)[\/\s]([\w\.-]+)/i], [c2, A2], [/\bgsa\/([\w\.]+)\s.*safari\//i], [A2, [c2, "GSA"]], [/headlesschrome(?:\/([\w\.]+)|\s)/i], [A2, [c2, "Chrome Headless"]], [/\swv\).+(chrome)\/([\w\.]+)/i], [[c2, "Chrome WebView"], A2], [/droid.+\sversion\/([\w\.]+)\b.+(?:mobile\ssafari|safari)/i], [A2, [c2, "Android Browser"]], [/(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i], [c2, A2], [/version\/([\w\.]+)\s.*mobile\/\w+\s(safari)/i], [A2, [c2, "Mobile Safari"]], [/version\/([\w\.]+)\s.*(mobile\s?safari|safari)/i], [A2, c2], [/webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i], [c2, [A2, _2.str, C2.browser.oldSafari.version]], [/(webkit|khtml)\/([\w\.]+)/i], [c2, A2], [/(navigator|netscape)\/([\w\.-]+)/i], [[c2, "Netscape"], A2], [/ile\svr;\srv:([\w\.]+)\).+firefox/i], [A2, [c2, "Firefox Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i, /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([\w\.-]+)$/i, /(firefox)\/([\w\.]+)\s[\w\s\-]+\/[\w\.]+$/i, /(mozilla)\/([\w\.]+)\s.+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i, /(links)\s\(([\w\.]+)/i, /(gobrowser)\/?([\w\.]*)/i, /(ice\s?browser)\/v?([\w\._]+)/i, /(mosaic)[\/\s]([\w\.]+)/i], [c2, A2]], cpu: [[/(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i], [[h2, "amd64"]], [/(ia32(?=;))/i], [[h2, m2.lowerize]], [/((?:i[346]|x)86)[;\)]/i], [[h2, "ia32"]], [/\b(aarch64|armv?8e?l?)\b/i], [[h2, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[h2, "armhf"]], [/windows\s(ce|mobile);\sppc;/i], [[h2, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i], [[h2, /ower/, "", m2.lowerize]], [/(sun4\w)[;\)]/i], [[h2, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?:64|(?=v(?:[1-7]|[5-7]1)l?|;|eabi))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[h2, m2.lowerize]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[pt]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus\s10)/i], [a2, [u2, "Samsung"], [d2, g2]], [/\b((?:s[cgp]h|gt|sm)-\w+|galaxy\snexus)/i, /\ssamsung[\s-]([\w-]+)/i, /sec-(sgh\w+)/i], [a2, [u2, "Samsung"], [d2, p2]], [/\((ip(?:hone|od)[\s\w]*);/i], [a2, [u2, "Apple"], [d2, p2]], [/\((ipad);[\w\s\),;-]+apple/i, /applecoremedia\/[\w\.]+\s\((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [a2, [u2, "Apple"], [d2, g2]], [/\b((?:agr|ags[23]|bah2?|sht?)-a?[lw]\d{2})/i], [a2, [u2, "Huawei"], [d2, g2]], [/d\/huawei([\w\s-]+)[;\)]/i, /\b(nexus\s6p|vog-[at]?l\d\d|ane-[at]?l[x\d]\d|eml-a?l\d\da?|lya-[at]?l\d[\dc]|clt-a?l\d\di?|ele-l\d\d)/i, /\b(\w{2,4}-[atu][ln][01259][019])[;\)\s]/i], [a2, [u2, "Huawei"], [d2, p2]], [/\b(poco[\s\w]+)(?:\sbuild|\))/i, /\b;\s(\w+)\sbuild\/hm\1/i, /\b(hm[\s\-_]?note?[\s_]?(?:\d\w)?)\sbuild/i, /\b(redmi[\s\-_]?(?:note|k)?[\w\s_]+)(?:\sbuild|\))/i, /\b(mi[\s\-_]?(?:a\d|one|one[\s_]plus|note lte)?[\s_]?(?:\d?\w?)[\s_]?(?:plus)?)\sbuild/i], [[a2, /_/g, " "], [u2, "Xiaomi"], [d2, p2]], [/\b(mi[\s\-_]?(?:pad)(?:[\w\s_]+))(?:\sbuild|\))/i], [[a2, /_/g, " "], [u2, "Xiaomi"], [d2, g2]], [/;\s(\w+)\sbuild.+\soppo/i, /\s(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007)\b/i], [a2, [u2, "OPPO"], [d2, p2]], [/\svivo\s(\w+)(?:\sbuild|\))/i, /\s(v[12]\d{3}\w?[at])(?:\sbuild|;)/i], [a2, [u2, "Vivo"], [d2, p2]], [/\s(rmx[12]\d{3})(?:\sbuild|;)/i], [a2, [u2, "Realme"], [d2, p2]], [/\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?:?(\s4g)?)\b[\w\s]+build\//i, /\smot(?:orola)?[\s-](\w*)/i, /((?:moto[\s\w\(\)]+|xt\d{3,4}|nexus\s6)(?=\sbuild|\)))/i], [a2, [u2, "Motorola"], [d2, p2]], [/\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i], [a2, [u2, "Motorola"], [d2, g2]], [/((?=lg)?[vl]k\-?\d{3})\sbuild|\s3\.[\s\w;-]{10}lg?-([06cv9]{3,4})/i], [a2, [u2, "LG"], [d2, g2]], [/(lm-?f100[nv]?|nexus\s[45])/i, /lg[e;\s\/-]+((?!browser|netcast)\w+)/i, /\blg(\-?[\d\w]+)\sbuild/i], [a2, [u2, "LG"], [d2, p2]], [/(ideatab[\w\-\s]+)/i, /lenovo\s?(s(?:5000|6000)(?:[\w-]+)|tab(?:[\s\w]+)|yt[\d\w-]{6}|tb[\d\w-]{6})/i], [a2, [u2, "Lenovo"], [d2, g2]], [/(?:maemo|nokia).*(n900|lumia\s\d+)/i, /nokia[\s_-]?([\w\.-]*)/i], [[a2, /_/g, " "], [u2, "Nokia"], [d2, p2]], [/droid.+;\s(pixel\sc)[\s)]/i], [a2, [u2, "Google"], [d2, g2]], [/droid.+;\s(pixel[\s\daxl]{0,6})(?:\sbuild|\))/i], [a2, [u2, "Google"], [d2, p2]], [/droid.+\s([c-g]\d{4}|so[-l]\w+|xq-a\w[4-7][12])(?=\sbuild\/|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [a2, [u2, "Sony"], [d2, p2]], [/sony\stablet\s[ps]\sbuild\//i, /(?:sony)?sgp\w+(?:\sbuild\/|\))/i], [[a2, "Xperia Tablet"], [u2, "Sony"], [d2, g2]], [/\s(kb2005|in20[12]5|be20[12][59])\b/i, /\ba000(1)\sbuild/i, /\boneplus\s(a\d{4})[\s)]/i], [a2, [u2, "OnePlus"], [d2, p2]], [/(alexa)webm/i, /(kf[a-z]{2}wi)(\sbuild\/|\))/i, /(kf[a-z]+)(\sbuild\/|\)).+silk\//i], [a2, [u2, "Amazon"], [d2, g2]], [/(sd|kf)[0349hijorstuw]+(\sbuild\/|\)).+silk\//i], [[a2, "Fire Phone"], [u2, "Amazon"], [d2, p2]], [/\((playbook);[\w\s\),;-]+(rim)/i], [a2, u2, [d2, g2]], [/((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10;\s(\w+)/i], [a2, [u2, "BlackBerry"], [d2, p2]], [/(?:\b|asus_)(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus\s7|padfone|p00[cj])/i], [a2, [u2, "ASUS"], [d2, g2]], [/\s(z[es]6[027][01][km][ls]|zenfone\s\d\w?)\b/i], [a2, [u2, "ASUS"], [d2, p2]], [/(nexus\s9)/i], [a2, [u2, "HTC"], [d2, g2]], [/(htc)[;_\s-]{1,2}([\w\s]+(?=\)|\sbuild)|\w+)/i, /(zte)-(\w*)/i, /(alcatel|geeksphone|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]*)/i], [u2, [a2, /_/g, " "], [d2, p2]], [/droid[x\d\.\s;]+\s([ab][1-7]\-?[0178a]\d\d?)/i], [a2, [u2, "Acer"], [d2, g2]], [/droid.+;\s(m[1-5]\snote)\sbuild/i, /\bmz-([\w-]{2,})/i], [a2, [u2, "Meizu"], [d2, p2]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\s_-]?([\w-]*)/i, /(hp)\s([\w\s]+\w)/i, /(asus)-?(\w+)/i, /(microsoft);\s(lumia[\s\w]+)/i, /(lenovo)[_\s-]?([\w-]+)/i, /linux;.+(jolla);/i, /droid.+;\s(oppo)\s?([\w\s]+)\sbuild/i], [u2, a2, [d2, p2]], [/(archos)\s(gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /\s(nook)[\w\s]+build\/(\w+)/i, /(dell)\s(strea[kpr\s\d]*[\dko])/i, /[;\/]\s?(le[\s\-]+pan)[\s\-]+(\w{1,9})\sbuild/i, /[;\/]\s?(trinity)[\-\s]*(t\d{3})\sbuild/i, /\b(gigaset)[\s\-]+(q\w{1,9})\sbuild/i, /\b(vodafone)\s([\w\s]+)(?:\)|\sbuild)/i], [u2, a2, [d2, g2]], [/\s(surface\sduo)\s/i], [a2, [u2, "Microsoft"], [d2, g2]], [/droid\s[\d\.]+;\s(fp\du?)\sbuild/i], [a2, [u2, "Fairphone"], [d2, p2]], [/\s(u304aa)\sbuild/i], [a2, [u2, "AT&T"], [d2, p2]], [/sie-(\w*)/i], [a2, [u2, "Siemens"], [d2, p2]], [/[;\/]\s?(rct\w+)\sbuild/i], [a2, [u2, "RCA"], [d2, g2]], [/[;\/\s](venue[\d\s]{2,7})\sbuild/i], [a2, [u2, "Dell"], [d2, g2]], [/[;\/]\s?(q(?:mv|ta)\w+)\sbuild/i], [a2, [u2, "Verizon"], [d2, g2]], [/[;\/]\s(?:barnes[&\s]+noble\s|bn[rt])([\w\s\+]*)\sbuild/i], [a2, [u2, "Barnes & Noble"], [d2, g2]], [/[;\/]\s(tm\d{3}\w+)\sbuild/i], [a2, [u2, "NuVision"], [d2, g2]], [/;\s(k88)\sbuild/i], [a2, [u2, "ZTE"], [d2, g2]], [/;\s(nx\d{3}j)\sbuild/i], [a2, [u2, "ZTE"], [d2, p2]], [/[;\/]\s?(gen\d{3})\sbuild.*49h/i], [a2, [u2, "Swiss"], [d2, p2]], [/[;\/]\s?(zur\d{3})\sbuild/i], [a2, [u2, "Swiss"], [d2, g2]], [/[;\/]\s?((zeki)?tb.*\b)\sbuild/i], [a2, [u2, "Zeki"], [d2, g2]], [/[;\/]\s([yr]\d{2})\sbuild/i, /[;\/]\s(dragon[\-\s]+touch\s|dt)(\w{5})\sbuild/i], [[u2, "Dragon Touch"], a2, [d2, g2]], [/[;\/]\s?(ns-?\w{0,9})\sbuild/i], [a2, [u2, "Insignia"], [d2, g2]], [/[;\/]\s?((nxa|Next)-?\w{0,9})\sbuild/i], [a2, [u2, "NextBook"], [d2, g2]], [/[;\/]\s?(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05]))\sbuild/i], [[u2, "Voice"], a2, [d2, p2]], [/[;\/]\s?(lvtel\-)?(v1[12])\sbuild/i], [[u2, "LvTel"], a2, [d2, p2]], [/;\s(ph-1)\s/i], [a2, [u2, "Essential"], [d2, p2]], [/[;\/]\s?(v(100md|700na|7011|917g).*\b)\sbuild/i], [a2, [u2, "Envizen"], [d2, g2]], [/[;\/]\s?(trio[\s\w\-\.]+)\sbuild/i], [a2, [u2, "MachSpeed"], [d2, g2]], [/[;\/]\s?tu_(1491)\sbuild/i], [a2, [u2, "Rotor"], [d2, g2]], [/(shield[\w\s]+)\sbuild/i], [a2, [u2, "Nvidia"], [d2, g2]], [/(sprint)\s(\w+)/i], [u2, a2, [d2, p2]], [/(kin\.[onetw]{3})/i], [[a2, /\./g, " "], [u2, "Microsoft"], [d2, p2]], [/droid\s[\d\.]+;\s(cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [a2, [u2, "Zebra"], [d2, g2]], [/droid\s[\d\.]+;\s(ec30|ps20|tc[2-8]\d[kx])\)/i], [a2, [u2, "Zebra"], [d2, p2]], [/\s(ouya)\s/i, /(nintendo)\s([wids3utch]+)/i], [u2, a2, [d2, l2]], [/droid.+;\s(shield)\sbuild/i], [a2, [u2, "Nvidia"], [d2, l2]], [/(playstation\s[345portablevi]+)/i], [a2, [u2, "Sony"], [d2, l2]], [/[\s\(;](xbox(?:\sone)?(?!;\sxbox))[\s\);]/i], [a2, [u2, "Microsoft"], [d2, l2]], [/smart-tv.+(samsung)/i], [u2, [d2, f2]], [/hbbtv.+maple;(\d+)/i], [[a2, /^/, "SmartTV"], [u2, "Samsung"], [d2, f2]], [/(?:linux;\snetcast.+smarttv|lg\snetcast\.tv-201\d)/i], [[u2, "LG"], [d2, f2]], [/(apple)\s?tv/i], [u2, [a2, "Apple TV"], [d2, f2]], [/crkey/i], [[a2, "Chromecast"], [u2, "Google"], [d2, f2]], [/droid.+aft([\w])(\sbuild\/|\))/i], [a2, [u2, "Amazon"], [d2, f2]], [/\(dtv[\);].+(aquos)/i], [a2, [u2, "Sharp"], [d2, f2]], [/hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i], [[u2, m2.trim], [a2, m2.trim], [d2, f2]], [/[\s\/\(](android\s|smart[-\s]?|opera\s)tv[;\)\s]/i], [[d2, f2]], [/((pebble))app\/[\d\.]+\s/i], [u2, a2, [d2, E2]], [/droid.+;\s(glass)\s\d/i], [a2, [u2, "Google"], [d2, E2]], [/droid\s[\d\.]+;\s(wt63?0{2,3})\)/i], [a2, [u2, "Zebra"], [d2, E2]], [/(tesla)(?:\sqtcarbrowser|\/20[12]\d\.[\w\.-]+)/i], [u2, [d2, I2]], [/droid .+?; ([^;]+?)(?: build|\) applewebkit).+? mobile safari/i], [a2, [d2, p2]], [/droid .+?;\s([^;]+?)(?: build|\) applewebkit).+?(?! mobile) safari/i], [a2, [d2, g2]], [/\s(tablet|tab)[;\/]/i, /\s(mobile)(?:[;\/]|\ssafari)/i], [[d2, m2.lowerize]], [/(android[\w\.\s\-]{0,9});.+build/i], [a2, [u2, "Generic"]], [/(phone)/i], [[d2, p2]]], engine: [[/windows.+\sedge\/([\w\.]+)/i], [A2, [c2, "EdgeHTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [A2, [c2, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i, /(icab)[\/\s]([23]\.[\d\.]+)/i], [c2, A2], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [A2, c2]], os: [[/microsoft\s(windows)\s(vista|xp)/i], [c2, A2], [/(windows)\snt\s6\.2;\s(arm)/i, /(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s\w]*)/i, /(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)(?!.+xbox)/i], [c2, [A2, _2.str, C2.os.windows.version]], [/(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i], [[c2, "Windows"], [A2, _2.str, C2.os.windows.version]], [/ip[honead]{2,4}\b(?:.*os\s([\w]+)\slike\smac|;\sopera)/i, /cfnetwork\/.+darwin/i], [[A2, /_/g, "."], [c2, "iOS"]], [/(mac\sos\sx)\s?([\w\s\.]*)/i, /(macintosh|mac(?=_powerpc)\s)(?!.+haiku)/i], [[c2, "Mac OS"], [A2, /_/g, "."]], [/(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|sailfish|contiki)[\/\s-]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/\s]([\w\.]+)/i, /\((series40);/i], [c2, A2], [/\(bb(10);/i], [A2, [c2, "BlackBerry"]], [/(?:symbian\s?os|symbos|s60(?=;)|series60)[\/\s-]?([\w\.]*)/i], [A2, [c2, "Symbian"]], [/mozilla.+\(mobile;.+gecko.+firefox/i], [[c2, "Firefox OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [A2, [c2, "webOS"]], [/crkey\/([\d\.]+)/i], [A2, [c2, "Chromecast"]], [/(cros)\s[\w]+\s([\w\.]+\w)/i], [[c2, "Chromium OS"], A2], [/(nintendo|playstation)\s([wids345portablevuch]+)/i, /(xbox);\s+xbox\s([^\);]+)/i, /(mint)[\/\s\(\)]?(\w*)/i, /(mageia|vectorlinux)[;\s]/i, /(joli|[kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?=\slinux)|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus|raspbian)(?:\sgnu\/linux)?(?:\slinux)?[\/\s-]?(?!chrom|package)([\w\.-]*)/i, /(hurd|linux)\s?([\w\.]*)/i, /(gnu)\s?([\w\.]*)/i, /\s([frentopc-]{0,4}bsd|dragonfly)\s?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku)\s(\w+)/i], [c2, A2], [/(sunos)\s?([\w\.\d]*)/i], [[c2, "Solaris"], A2], [/((?:open)?solaris)[\/\s-]?([\w\.]*)/i, /(aix)\s((\d)(?=\.|\)|\s)[\w\.])*/i, /(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms|fuchsia)/i, /(unix)\s?([\w\.]*)/i], [c2, A2]] }, S2 = function(t3, r3) {
            if (typeof t3 == "object" && (r3 = t3, t3 = i2), !(this instanceof S2))
              return new S2(t3, r3).getResult();
            var n3 = t3 || (e2 !== void 0 && e2.navigator && e2.navigator.userAgent ? e2.navigator.userAgent : ""), o3 = r3 ? m2.extend(v2, r3) : v2;
            return this.getBrowser = function() {
              var e3 = { name: i2, version: i2 };
              return _2.rgx.call(e3, n3, o3.browser), e3.major = m2.major(e3.version), e3;
            }, this.getCPU = function() {
              var e3 = { architecture: i2 };
              return _2.rgx.call(e3, n3, o3.cpu), e3;
            }, this.getDevice = function() {
              var e3 = { vendor: i2, model: i2, type: i2 };
              return _2.rgx.call(e3, n3, o3.device), e3;
            }, this.getEngine = function() {
              var e3 = { name: i2, version: i2 };
              return _2.rgx.call(e3, n3, o3.engine), e3;
            }, this.getOS = function() {
              var e3 = { name: i2, version: i2 };
              return _2.rgx.call(e3, n3, o3.os), e3;
            }, this.getResult = function() {
              return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
            }, this.getUA = function() {
              return n3;
            }, this.setUA = function(e3) {
              return n3 = typeof e3 === s2 && e3.length > 255 ? m2.trim(e3, 255) : e3, this;
            }, this.setUA(n3), this;
          };
          S2.VERSION = "0.7.28", S2.BROWSER = { NAME: c2, MAJOR: "major", VERSION: A2 }, S2.CPU = { ARCHITECTURE: h2 }, S2.DEVICE = { MODEL: a2, VENDOR: u2, TYPE: d2, CONSOLE: l2, MOBILE: p2, SMARTTV: f2, TABLET: g2, WEARABLE: E2, EMBEDDED: I2 }, S2.ENGINE = { NAME: c2, VERSION: A2 }, S2.OS = { NAME: c2, VERSION: A2 }, t2.exports && (r2 = t2.exports = S2), r2.UAParser = S2;
          var R2 = e2 !== void 0 && (e2.jQuery || e2.Zepto);
          if (R2 && !R2.ua) {
            var y2 = new S2();
            R2.ua = y2.getResult(), R2.ua.get = function() {
              return y2.getUA();
            }, R2.ua.set = function(e3) {
              y2.setUA(e3);
              var t3 = y2.getResult();
              for (var r3 in t3)
                R2.ua[r3] = t3[r3];
            };
          }
        }(typeof window == "object" ? window : e);
      }(rO, rO.exports);
      const iO = new (0, rO.exports)();
      let nO = iO.getResult();
      function oO(e2) {
        return e2 && iO.setUA(e2), nO = iO.getResult(), { name: sO(nO), version: aO(nO), os: cO(nO), osVersion: nO.os.version };
      }
      function sO(e2) {
        if (e2.engine.name === "Blink" && e2.browser.name !== "WeChat")
          return tO.CHROME;
        switch (e2.browser.name) {
          case "Chrome Headless":
          case "Chrome":
          case "Chromium":
            return tO.CHROME;
          case "Safari":
          case "Mobile Safari":
            return tO.SAFARI;
          case "Edge":
            return tO.EDGE;
          case "Firefox":
            return tO.FIREFOX;
          case "QQBrowser":
            return tO.QQ;
          case "Opera":
            return tO.OPERA;
          case "WeChat":
            return tO.WECHAT;
          default:
            return e2.browser.name || "";
        }
      }
      function aO(e2) {
        let t2;
        return t2 = e2.engine.name === "Blink" ? e2.engine.version || "" : e2.browser.version || "", t2.split(".")[0];
      }
      function cO(e2) {
        switch (e2.os.name) {
          case "Windows":
            return e2.os.version ? e2.os.name + " " + e2.os.version : e2.os.name;
          default:
            return e2.os.name || "";
        }
      }
      function dO() {
        return oO().os;
      }
      function uO() {
        const e2 = oO();
        return !!(nO.engine.name === "WebKit" && e2.os === eO.MAC_OS && navigator.maxTouchPoints && navigator.maxTouchPoints > 0 && e2.name !== tO.SAFARI || fO() && e2.name !== tO.SAFARI);
      }
      function AO() {
        const e2 = oO();
        if (uO()) {
          if (e2.os === eO.MAC_OS)
            return true;
          if (e2.os === eO.IOS) {
            const e3 = nO.os.version && nO.os.version.split(".");
            if (e3 && Number(e3[0]) === 14 && e3[1] && Number(e3[1]) >= 3)
              return true;
            if (e3 && Number(e3[0]) > 14)
              return true;
          }
        }
        return false;
      }
      function hO() {
        return nO.engine.name === "WebKit";
      }
      function lO() {
        return oO().name === tO.CHROME;
      }
      function pO() {
        return oO().name === tO.SAFARI;
      }
      function gO() {
        return oO().name === tO.FIREFOX;
      }
      function fO() {
        return oO().os === eO.IOS;
      }
      function EO() {
        const e2 = oO();
        if (e2.os !== eO.IOS || !e2.osVersion)
          return false;
        const t2 = e2.osVersion.split(".");
        return Number(t2[0]) === 13;
      }
      function IO() {
        const e2 = oO();
        if (e2.os !== eO.IOS || !e2.osVersion)
          return false;
        const t2 = e2.osVersion.split(".");
        return Number(t2[0]) === 15;
      }
      function mO() {
        const e2 = oO();
        if (e2.os !== eO.IOS || !e2.osVersion)
          return false;
        const t2 = e2.osVersion.split(".");
        return Number(t2[0]) === 15 && Number(t2[1]) === 0;
      }
      function _O() {
        const e2 = oO();
        if (e2.os !== eO.IOS || !e2.osVersion)
          return false;
        const t2 = e2.osVersion.split(".");
        return Number(t2[0]) === 15 && Number(t2[1]) >= 1;
      }
      function CO() {
        const e2 = oO();
        if (e2.os !== eO.IOS || !e2.osVersion)
          return false;
        const t2 = e2.osVersion.split(".");
        return Number(t2[0]) === 15 && Number(t2[1]) >= 2;
      }
      function vO() {
        return pO() && navigator.maxTouchPoints > 0;
      }
      function SO() {
        return oO().name === tO.WECHAT;
      }
      function RO() {
        return window.navigator.appVersion && window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./) !== null && window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)[1] <= 35;
      }
      function yO() {
        const e2 = oO();
        if (e2.name === tO.EDGE || e2.name === tO.SAFARI)
          return false;
        return !!navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]./i);
      }
      function TO() {
        return oO().os === eO.ANDROID;
      }
      var wO = { exports: {} }, bO = JA, OO = Yc, NO = fA.f;
      bO({ target: "Object", stat: true, forced: Object.defineProperty !== NO, sham: !OO }, { defineProperty: NO });
      var DO = _d.Object, LO = wO.exports = function(e2, t2, r2) {
        return DO.defineProperty(e2, t2, r2);
      };
      DO.defineProperty.sham && (LO.sham = true);
      var PO = wO.exports;
      function kO(e2, t2, r2) {
        return t2 in e2 ? PO(e2, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e2[t2] = r2, e2;
      }
      var BO = { exports: {} }, MO = function(e2, t2) {
        return function() {
          for (var r2 = new Array(arguments.length), i2 = 0; i2 < r2.length; i2++)
            r2[i2] = arguments[i2];
          return e2.apply(t2, r2);
        };
      }, UO = MO, QO = function(e2) {
        return e2 != null && e2.constructor != null && typeof e2.constructor.isBuffer == "function" && e2.constructor.isBuffer(e2);
      }, xO = Object.prototype.toString;
      function FO(e2) {
        return xO.call(e2) === "[object Array]";
      }
      function VO(e2) {
        return e2 !== null && typeof e2 == "object";
      }
      function jO(e2) {
        return xO.call(e2) === "[object Function]";
      }
      function GO(e2, t2) {
        if (e2 != null)
          if (typeof e2 != "object" && (e2 = [e2]), FO(e2))
            for (var r2 = 0, i2 = e2.length; r2 < i2; r2++)
              t2.call(null, e2[r2], r2, e2);
          else
            for (var n2 in e2)
              Object.prototype.hasOwnProperty.call(e2, n2) && t2.call(null, e2[n2], n2, e2);
      }
      var KO = { isArray: FO, isArrayBuffer: function(e2) {
        return xO.call(e2) === "[object ArrayBuffer]";
      }, isBuffer: QO, isFormData: function(e2) {
        return typeof FormData != "undefined" && e2 instanceof FormData;
      }, isArrayBufferView: function(e2) {
        return typeof ArrayBuffer != "undefined" && ArrayBuffer.isView ? ArrayBuffer.isView(e2) : e2 && e2.buffer && e2.buffer instanceof ArrayBuffer;
      }, isString: function(e2) {
        return typeof e2 == "string";
      }, isNumber: function(e2) {
        return typeof e2 == "number";
      }, isObject: VO, isUndefined: function(e2) {
        return e2 === void 0;
      }, isDate: function(e2) {
        return xO.call(e2) === "[object Date]";
      }, isFile: function(e2) {
        return xO.call(e2) === "[object File]";
      }, isBlob: function(e2) {
        return xO.call(e2) === "[object Blob]";
      }, isFunction: jO, isStream: function(e2) {
        return VO(e2) && jO(e2.pipe);
      }, isURLSearchParams: function(e2) {
        return typeof URLSearchParams != "undefined" && e2 instanceof URLSearchParams;
      }, isStandardBrowserEnv: function() {
        return (typeof navigator == "undefined" || navigator.product !== "ReactNative" && navigator.product !== "NativeScript" && navigator.product !== "NS") && (typeof window != "undefined" && typeof document != "undefined");
      }, forEach: GO, merge: function e2() {
        var t2 = {};
        function r2(r3, i3) {
          typeof t2[i3] == "object" && typeof r3 == "object" ? t2[i3] = e2(t2[i3], r3) : t2[i3] = r3;
        }
        for (var i2 = 0, n2 = arguments.length; i2 < n2; i2++)
          GO(arguments[i2], r2);
        return t2;
      }, deepMerge: function e2() {
        var t2 = {};
        function r2(r3, i3) {
          typeof t2[i3] == "object" && typeof r3 == "object" ? t2[i3] = e2(t2[i3], r3) : t2[i3] = typeof r3 == "object" ? e2({}, r3) : r3;
        }
        for (var i2 = 0, n2 = arguments.length; i2 < n2; i2++)
          GO(arguments[i2], r2);
        return t2;
      }, extend: function(e2, t2, r2) {
        return GO(t2, function(t3, i2) {
          e2[i2] = r2 && typeof t3 == "function" ? UO(t3, r2) : t3;
        }), e2;
      }, trim: function(e2) {
        return e2.replace(/^\s*/, "").replace(/\s*$/, "");
      } }, HO = KO;
      function YO(e2) {
        return encodeURIComponent(e2).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      }
      var WO = function(e2, t2, r2) {
        if (!t2)
          return e2;
        var i2;
        if (r2)
          i2 = r2(t2);
        else if (HO.isURLSearchParams(t2))
          i2 = t2.toString();
        else {
          var n2 = [];
          HO.forEach(t2, function(e3, t3) {
            e3 != null && (HO.isArray(e3) ? t3 += "[]" : e3 = [e3], HO.forEach(e3, function(e4) {
              HO.isDate(e4) ? e4 = e4.toISOString() : HO.isObject(e4) && (e4 = JSON.stringify(e4)), n2.push(YO(t3) + "=" + YO(e4));
            }));
          }), i2 = n2.join("&");
        }
        if (i2) {
          var o2 = e2.indexOf("#");
          o2 !== -1 && (e2 = e2.slice(0, o2)), e2 += (e2.indexOf("?") === -1 ? "?" : "&") + i2;
        }
        return e2;
      }, JO = KO;
      function qO() {
        this.handlers = [];
      }
      qO.prototype.use = function(e2, t2) {
        return this.handlers.push({ fulfilled: e2, rejected: t2 }), this.handlers.length - 1;
      }, qO.prototype.eject = function(e2) {
        this.handlers[e2] && (this.handlers[e2] = null);
      }, qO.prototype.forEach = function(e2) {
        JO.forEach(this.handlers, function(t2) {
          t2 !== null && e2(t2);
        });
      };
      var zO = qO, XO = KO, ZO = function(e2) {
        return !(!e2 || !e2.__CANCEL__);
      }, $O = KO, eN = function(e2, t2, r2, i2, n2) {
        return e2.config = t2, r2 && (e2.code = r2), e2.request = i2, e2.response = n2, e2.isAxiosError = true, e2.toJSON = function() {
          return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: this.config, code: this.code };
        }, e2;
      }, tN = function(e2, t2, r2, i2, n2) {
        var o2 = new Error(e2);
        return eN(o2, t2, r2, i2, n2);
      }, rN = tN, iN = KO, nN = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"], oN = KO, sN = oN.isStandardBrowserEnv() ? function() {
        var e2, t2 = /(msie|trident)/i.test(navigator.userAgent), r2 = document.createElement("a");
        function i2(e3) {
          var i3 = e3;
          return t2 && (r2.setAttribute("href", i3), i3 = r2.href), r2.setAttribute("href", i3), { href: r2.href, protocol: r2.protocol ? r2.protocol.replace(/:$/, "") : "", host: r2.host, search: r2.search ? r2.search.replace(/^\?/, "") : "", hash: r2.hash ? r2.hash.replace(/^#/, "") : "", hostname: r2.hostname, port: r2.port, pathname: r2.pathname.charAt(0) === "/" ? r2.pathname : "/" + r2.pathname };
        }
        return e2 = i2(window.location.href), function(t3) {
          var r3 = oN.isString(t3) ? i2(t3) : t3;
          return r3.protocol === e2.protocol && r3.host === e2.host;
        };
      }() : function() {
        return true;
      }, aN = KO, cN = aN.isStandardBrowserEnv() ? { write: function(e2, t2, r2, i2, n2, o2) {
        var s2 = [];
        s2.push(e2 + "=" + encodeURIComponent(t2)), aN.isNumber(r2) && s2.push("expires=" + new Date(r2).toGMTString()), aN.isString(i2) && s2.push("path=" + i2), aN.isString(n2) && s2.push("domain=" + n2), o2 === true && s2.push("secure"), document.cookie = s2.join("; ");
      }, read: function(e2) {
        var t2 = document.cookie.match(new RegExp("(^|;\\s*)(" + e2 + ")=([^;]*)"));
        return t2 ? decodeURIComponent(t2[3]) : null;
      }, remove: function(e2) {
        this.write(e2, "", Date.now() - 864e5);
      } } : { write: function() {
      }, read: function() {
        return null;
      }, remove: function() {
      } }, dN = KO, uN = function(e2, t2, r2) {
        var i2 = r2.config.validateStatus;
        !i2 || i2(r2.status) ? e2(r2) : t2(rN("Request failed with status code " + r2.status, r2.config, null, r2.request, r2));
      }, AN = WO, hN = function(e2) {
        var t2, r2, i2, n2 = {};
        return e2 ? (iN.forEach(e2.split("\n"), function(e3) {
          if (i2 = e3.indexOf(":"), t2 = iN.trim(e3.substr(0, i2)).toLowerCase(), r2 = iN.trim(e3.substr(i2 + 1)), t2) {
            if (n2[t2] && nN.indexOf(t2) >= 0)
              return;
            n2[t2] = t2 === "set-cookie" ? (n2[t2] ? n2[t2] : []).concat([r2]) : n2[t2] ? n2[t2] + ", " + r2 : r2;
          }
        }), n2) : n2;
      }, lN = sN, pN = tN, gN = function(e2) {
        return new Promise(function(t2, r2) {
          var i2 = e2.data, n2 = e2.headers;
          dN.isFormData(i2) && delete n2["Content-Type"];
          var o2 = new XMLHttpRequest();
          if (e2.auth) {
            var s2 = e2.auth.username || "", a2 = e2.auth.password || "";
            n2.Authorization = "Basic " + btoa(s2 + ":" + a2);
          }
          if (o2.open(e2.method.toUpperCase(), AN(e2.url, e2.params, e2.paramsSerializer), true), o2.timeout = e2.timeout, o2.onreadystatechange = function() {
            if (o2 && o2.readyState === 4 && (o2.status !== 0 || o2.responseURL && o2.responseURL.indexOf("file:") === 0)) {
              var i3 = "getAllResponseHeaders" in o2 ? hN(o2.getAllResponseHeaders()) : null, n3 = { data: e2.responseType && e2.responseType !== "text" ? o2.response : o2.responseText, status: o2.status, statusText: o2.statusText, headers: i3, config: e2, request: o2 };
              uN(t2, r2, n3), o2 = null;
            }
          }, o2.onabort = function() {
            o2 && (r2(pN("Request aborted", e2, "ECONNABORTED", o2)), o2 = null);
          }, o2.onerror = function() {
            r2(pN("Network Error", e2, null, o2)), o2 = null;
          }, o2.ontimeout = function() {
            r2(pN("timeout of " + e2.timeout + "ms exceeded", e2, "ECONNABORTED", o2)), o2 = null;
          }, dN.isStandardBrowserEnv()) {
            var c2 = cN, d2 = (e2.withCredentials || lN(e2.url)) && e2.xsrfCookieName ? c2.read(e2.xsrfCookieName) : void 0;
            d2 && (n2[e2.xsrfHeaderName] = d2);
          }
          if ("setRequestHeader" in o2 && dN.forEach(n2, function(e3, t3) {
            i2 === void 0 && t3.toLowerCase() === "content-type" ? delete n2[t3] : o2.setRequestHeader(t3, e3);
          }), e2.withCredentials && (o2.withCredentials = true), e2.responseType)
            try {
              o2.responseType = e2.responseType;
            } catch (t3) {
              if (e2.responseType !== "json")
                throw t3;
            }
          typeof e2.onDownloadProgress == "function" && o2.addEventListener("progress", e2.onDownloadProgress), typeof e2.onUploadProgress == "function" && o2.upload && o2.upload.addEventListener("progress", e2.onUploadProgress), e2.cancelToken && e2.cancelToken.promise.then(function(e3) {
            o2 && (o2.abort(), r2(e3), o2 = null);
          }), i2 === void 0 && (i2 = null), o2.send(i2);
        });
      }, fN = KO, EN = function(e2, t2) {
        $O.forEach(e2, function(r2, i2) {
          i2 !== t2 && i2.toUpperCase() === t2.toUpperCase() && (e2[t2] = r2, delete e2[i2]);
        });
      }, IN = { "Content-Type": "application/x-www-form-urlencoded" };
      function mN(e2, t2) {
        !fN.isUndefined(e2) && fN.isUndefined(e2["Content-Type"]) && (e2["Content-Type"] = t2);
      }
      var _N, CN = { adapter: ((typeof process != "undefined" && Object.prototype.toString.call(process) === "[object process]" || typeof XMLHttpRequest != "undefined") && (_N = gN), _N), transformRequest: [function(e2, t2) {
        return EN(t2, "Accept"), EN(t2, "Content-Type"), fN.isFormData(e2) || fN.isArrayBuffer(e2) || fN.isBuffer(e2) || fN.isStream(e2) || fN.isFile(e2) || fN.isBlob(e2) ? e2 : fN.isArrayBufferView(e2) ? e2.buffer : fN.isURLSearchParams(e2) ? (mN(t2, "application/x-www-form-urlencoded;charset=utf-8"), e2.toString()) : fN.isObject(e2) ? (mN(t2, "application/json;charset=utf-8"), JSON.stringify(e2)) : e2;
      }], transformResponse: [function(e2) {
        if (typeof e2 == "string")
          try {
            e2 = JSON.parse(e2);
          } catch (e3) {
          }
        return e2;
      }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, validateStatus: function(e2) {
        return e2 >= 200 && e2 < 300;
      } };
      CN.headers = { common: { Accept: "application/json, text/plain, */*" } }, fN.forEach(["delete", "get", "head"], function(e2) {
        CN.headers[e2] = {};
      }), fN.forEach(["post", "put", "patch"], function(e2) {
        CN.headers[e2] = fN.merge(IN);
      });
      var vN = CN, SN = KO, RN = function(e2, t2, r2) {
        return XO.forEach(r2, function(r3) {
          e2 = r3(e2, t2);
        }), e2;
      }, yN = ZO, TN = vN, wN = function(e2) {
        return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(e2);
      }, bN = function(e2, t2) {
        return t2 ? e2.replace(/\/+$/, "") + "/" + t2.replace(/^\/+/, "") : e2;
      };
      function ON(e2) {
        e2.cancelToken && e2.cancelToken.throwIfRequested();
      }
      var NN = KO, DN = function(e2, t2) {
        t2 = t2 || {};
        var r2 = {};
        return NN.forEach(["url", "method", "params", "data"], function(e3) {
          t2[e3] !== void 0 && (r2[e3] = t2[e3]);
        }), NN.forEach(["headers", "auth", "proxy"], function(i2) {
          NN.isObject(t2[i2]) ? r2[i2] = NN.deepMerge(e2[i2], t2[i2]) : t2[i2] !== void 0 ? r2[i2] = t2[i2] : NN.isObject(e2[i2]) ? r2[i2] = NN.deepMerge(e2[i2]) : e2[i2] !== void 0 && (r2[i2] = e2[i2]);
        }), NN.forEach(["baseURL", "transformRequest", "transformResponse", "paramsSerializer", "timeout", "withCredentials", "adapter", "responseType", "xsrfCookieName", "xsrfHeaderName", "onUploadProgress", "onDownloadProgress", "maxContentLength", "validateStatus", "maxRedirects", "httpAgent", "httpsAgent", "cancelToken", "socketPath"], function(i2) {
          t2[i2] !== void 0 ? r2[i2] = t2[i2] : e2[i2] !== void 0 && (r2[i2] = e2[i2]);
        }), r2;
      }, LN = KO, PN = WO, kN = zO, BN = function(e2) {
        return ON(e2), e2.baseURL && !wN(e2.url) && (e2.url = bN(e2.baseURL, e2.url)), e2.headers = e2.headers || {}, e2.data = RN(e2.data, e2.headers, e2.transformRequest), e2.headers = SN.merge(e2.headers.common || {}, e2.headers[e2.method] || {}, e2.headers || {}), SN.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function(t2) {
          delete e2.headers[t2];
        }), (e2.adapter || TN.adapter)(e2).then(function(t2) {
          return ON(e2), t2.data = RN(t2.data, t2.headers, e2.transformResponse), t2;
        }, function(t2) {
          return yN(t2) || (ON(e2), t2 && t2.response && (t2.response.data = RN(t2.response.data, t2.response.headers, e2.transformResponse))), Promise.reject(t2);
        });
      }, MN = DN;
      function UN(e2) {
        this.defaults = e2, this.interceptors = { request: new kN(), response: new kN() };
      }
      UN.prototype.request = function(e2) {
        typeof e2 == "string" ? (e2 = arguments[1] || {}).url = arguments[0] : e2 = e2 || {}, (e2 = MN(this.defaults, e2)).method = e2.method ? e2.method.toLowerCase() : "get";
        var t2 = [BN, void 0], r2 = Promise.resolve(e2);
        for (this.interceptors.request.forEach(function(e3) {
          t2.unshift(e3.fulfilled, e3.rejected);
        }), this.interceptors.response.forEach(function(e3) {
          t2.push(e3.fulfilled, e3.rejected);
        }); t2.length; )
          r2 = r2.then(t2.shift(), t2.shift());
        return r2;
      }, UN.prototype.getUri = function(e2) {
        return e2 = MN(this.defaults, e2), PN(e2.url, e2.params, e2.paramsSerializer).replace(/^\?/, "");
      }, LN.forEach(["delete", "get", "head", "options"], function(e2) {
        UN.prototype[e2] = function(t2, r2) {
          return this.request(LN.merge(r2 || {}, { method: e2, url: t2 }));
        };
      }), LN.forEach(["post", "put", "patch"], function(e2) {
        UN.prototype[e2] = function(t2, r2, i2) {
          return this.request(LN.merge(i2 || {}, { method: e2, url: t2, data: r2 }));
        };
      });
      var QN = UN;
      function xN(e2) {
        this.message = e2;
      }
      xN.prototype.toString = function() {
        return "Cancel" + (this.message ? ": " + this.message : "");
      }, xN.prototype.__CANCEL__ = true;
      var FN = xN, VN = FN;
      function jN(e2) {
        if (typeof e2 != "function")
          throw new TypeError("executor must be a function.");
        var t2;
        this.promise = new Promise(function(e3) {
          t2 = e3;
        });
        var r2 = this;
        e2(function(e3) {
          r2.reason || (r2.reason = new VN(e3), t2(r2.reason));
        });
      }
      jN.prototype.throwIfRequested = function() {
        if (this.reason)
          throw this.reason;
      }, jN.source = function() {
        var e2;
        return { token: new jN(function(t2) {
          e2 = t2;
        }), cancel: e2 };
      };
      var GN = jN, KN = KO, HN = MO, YN = QN, WN = DN;
      function JN(e2) {
        var t2 = new YN(e2), r2 = HN(YN.prototype.request, t2);
        return KN.extend(r2, YN.prototype, t2), KN.extend(r2, t2), r2;
      }
      var qN = JN(vN);
      qN.Axios = YN, qN.create = function(e2) {
        return JN(WN(qN.defaults, e2));
      }, qN.Cancel = FN, qN.CancelToken = GN, qN.isCancel = ZO, qN.all = function(e2) {
        return Promise.all(e2);
      }, qN.spread = function(e2) {
        return function(t2) {
          return e2.apply(null, t2);
        };
      }, BO.exports = qN, BO.exports.default = qN;
      var zN = BO.exports;
      class XN {
        constructor(e2) {
          kO(this, "logger", void 0), kO(this, "prefixLists", []), this.logger = e2;
        }
        debug() {
          for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
            t2[r2] = arguments[r2];
          this.logger.debug(...this.prefixLists, ...t2);
        }
        info() {
          for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
            t2[r2] = arguments[r2];
          this.logger.info(...this.prefixLists, ...t2);
        }
        warning() {
          for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
            t2[r2] = arguments[r2];
          this.logger.warning(...this.prefixLists, ...t2);
        }
        error() {
          for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
            t2[r2] = arguments[r2];
          this.logger.error(...this.prefixLists, ...t2);
        }
        prefix(e2) {
          return this.prefixLists.push(e2), this;
        }
        popPrefix() {
          return this.prefixLists.pop(), this;
        }
      }
      class ZN {
        constructor() {
          kO(this, "_events", {}), kO(this, "addListener", this.on);
        }
        getListeners(e2) {
          return this._events[e2] ? this._events[e2].map((e3) => e3.listener) : [];
        }
        on(e2, t2) {
          this._events[e2] || (this._events[e2] = []);
          const r2 = this._events[e2];
          this._indexOfListener(r2, t2) === -1 && r2.push({ listener: t2, once: false });
        }
        once(e2, t2) {
          this._events[e2] || (this._events[e2] = []);
          const r2 = this._events[e2];
          this._indexOfListener(r2, t2) === -1 && r2.push({ listener: t2, once: true });
        }
        off(e2, t2) {
          if (!this._events[e2])
            return;
          const r2 = this._events[e2], i2 = this._indexOfListener(r2, t2);
          i2 !== -1 && r2.splice(i2, 1), this._events[e2].length === 0 && delete this._events[e2];
        }
        removeAllListeners(e2) {
          e2 ? delete this._events[e2] : this._events = {};
        }
        emit(e2) {
          this._events[e2] || (this._events[e2] = []);
          const t2 = this._events[e2].map((e3) => e3);
          for (var r2 = arguments.length, i2 = new Array(r2 > 1 ? r2 - 1 : 0), n2 = 1; n2 < r2; n2++)
            i2[n2 - 1] = arguments[n2];
          for (let r3 = 0; r3 < t2.length; r3 += 1) {
            const n3 = t2[r3];
            n3.once && this.off(e2, n3.listener), n3.listener.apply(this, i2 || []);
          }
        }
        _indexOfListener(e2, t2) {
          let r2 = e2.length;
          for (; r2--; )
            if (e2[r2].listener === t2)
              return r2;
          return -1;
        }
      }
      const $N = new class extends ZN {
        reportLogUploadError(e2) {
          this.emit("REPORT_LOG_UPLOAD", e2);
        }
      }();
      let eD;
      !function(e2) {
        e2.UNEXPECTED_ERROR = "UNEXPECTED_ERROR", e2.UNEXPECTED_RESPONSE = "UNEXPECTED_RESPONSE", e2.TIMEOUT = "TIMEOUT", e2.INVALID_PARAMS = "INVALID_PARAMS", e2.NOT_READABLE = "NOT_READABLE", e2.NOT_SUPPORTED = "NOT_SUPPORTED", e2.INVALID_OPERATION = "INVALID_OPERATION", e2.OPERATION_ABORTED = "OPERATION_ABORTED", e2.WEB_SECURITY_RESTRICT = "WEB_SECURITY_RESTRICT", e2.EXCHANGE_SDP_FAILED = "EXCHANGE_SDP_FAILED", e2.NETWORK_ERROR = "NETWORK_ERROR", e2.NETWORK_TIMEOUT = "NETWORK_TIMEOUT", e2.NETWORK_RESPONSE_ERROR = "NETWORK_RESPONSE_ERROR", e2.API_INVOKE_TIMEOUT = "API_INVOKE_TIMEOUT", e2.ENUMERATE_DEVICES_FAILED = "ENUMERATE_DEVICES_FAILED", e2.DEVICE_NOT_FOUND = "DEVICE_NOT_FOUND", e2.ELECTRON_IS_NULL = "ELECTRON_IS_NULL", e2.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR = "ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR", e2.CHROME_PLUGIN_NO_RESPONSE = "CHROME_PLUGIN_NO_RESPONSE", e2.CHROME_PLUGIN_NOT_INSTALL = "CHROME_PLUGIN_NOT_INSTALL", e2.MEDIA_OPTION_INVALID = "MEDIA_OPTION_INVALID", e2.PERMISSION_DENIED = "PERMISSION_DENIED", e2.CONSTRAINT_NOT_SATISFIED = "CONSTRAINT_NOT_SATISFIED", e2.TRACK_IS_DISABLED = "TRACK_IS_DISABLED", e2.GET_VIDEO_ELEMENT_VISIBLE_ERROR = "GET_VIDEO_ELEMENT_VISIBLE_ERROR", e2.SHARE_AUDIO_NOT_ALLOWED = "SHARE_AUDIO_NOT_ALLOWED", e2.LOW_STREAM_ENCODING_ERROR = "LOW_STREAM_ENCODING_ERROR", e2.SET_ENCODING_PARAMETER_ERROR = "SET_ENCODING_PARAMETER_ERROR", e2.TRACK_STATE_UNREACHABLE = "TRACK_STATE_UNREACHABLE", e2.INVALID_UINT_UID_FROM_STRING_UID = "INVALID_UINT_UID_FROM_STRING_UID", e2.CAN_NOT_GET_PROXY_SERVER = "CAN_NOT_GET_PROXY_SERVER", e2.CAN_NOT_GET_GATEWAY_SERVER = "CAN_NOT_GET_GATEWAY_SERVER", e2.VOID_GATEWAY_ADDRESS = "VOID_GATEWAY_ADDRESS", e2.UID_CONFLICT = "UID_CONFLICT", e2.MULTI_UNILBS_RESPONSE_ERROR = "MULTI_UNILBS_RESPONSE_ERROR", e2.UPDATE_TICKET_FAILED = "UPDATE_TICKET_FAILED", e2.INVALID_LOCAL_TRACK = "INVALID_LOCAL_TRACK", e2.INVALID_TRACK = "INVALID_TRACK", e2.SENDER_NOT_FOUND = "SENDER_NOT_FOUND", e2.CREATE_OFFER_FAILED = "CREATE_OFFER_FAILED", e2.SET_ANSWER_FAILED = "SET_ANSWER_FAILED", e2.ICE_FAILED = "ICE_FAILED", e2.PC_CLOSED = "PC_CLOSED", e2.SENDER_REPLACE_FAILED = "SENDER_REPLACE_FAILED", e2.GET_LOCAL_CAPABILITIES_FAILED = "GET_LOCAL_CAPABILITIES_FAILED", e2.GET_LOCAL_CONNECTION_PARAMS_FAILED = "GET_LOCAL_CONNECTION_PARAMS_FAILED", e2.SUBSCRIBE_FAILED = "SUBSCRIBE_FAILED", e2.UNSUBSCRIBE_FAILED = "UNSUBSCRIBE_FAILED", e2.GATEWAY_P2P_LOST = "GATEWAY_P2P_LOST", e2.NO_ICE_CANDIDATE = "NO_ICE_CANDIDATE", e2.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS = "CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS", e2.EXIST_DISABLED_VIDEO_TRACK = "EXIST_DISABLED_VIDEO_TRACK", e2.INVALID_REMOTE_USER = "INVALID_REMOTE_USER", e2.REMOTE_USER_IS_NOT_PUBLISHED = "REMOTE_USER_IS_NOT_PUBLISHED", e2.CUSTOM_REPORT_SEND_FAILED = "CUSTOM_REPORT_SEND_FAILED", e2.CUSTOM_REPORT_FREQUENCY_TOO_HIGH = "CUSTOM_REPORT_FREQUENCY_TOO_HIGH", e2.FETCH_AUDIO_FILE_FAILED = "FETCH_AUDIO_FILE_FAILED", e2.READ_LOCAL_AUDIO_FILE_ERROR = "READ_LOCAL_AUDIO_FILE_ERROR", e2.DECODE_AUDIO_FILE_FAILED = "DECODE_AUDIO_FILE_FAILED", e2.WS_ABORT = "WS_ABORT", e2.WS_DISCONNECT = "WS_DISCONNECT", e2.WS_ERR = "WS_ERR", e2.LIVE_STREAMING_TASK_CONFLICT = "LIVE_STREAMING_TASK_CONFLICT", e2.LIVE_STREAMING_INVALID_ARGUMENT = "LIVE_STREAMING_INVALID_ARGUMENT", e2.LIVE_STREAMING_INTERNAL_SERVER_ERROR = "LIVE_STREAMING_INTERNAL_SERVER_ERROR", e2.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED = "LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED", e2.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED = "LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED", e2.LIVE_STREAMING_CDN_ERROR = "LIVE_STREAMING_CDN_ERROR", e2.LIVE_STREAMING_INVALID_RAW_STREAM = "LIVE_STREAMING_INVALID_RAW_STREAM", e2.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT = "LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT", e2.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE = "LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE", e2.LIVE_STREAMING_WARN_FREQUENT_REQUEST = "LIVE_STREAMING_WARN_FREQUENT_REQUEST", e2.WEBGL_INTERNAL_ERROR = "WEBGL_INTERNAL_ERROR", e2.BEAUTY_PROCESSOR_INTERNAL_ERROR = "BEAUTY_PROCESSOR_INTERNAL_ERROR", e2.CROSS_CHANNEL_WAIT_STATUS_ERROR = "CROSS_CHANNEL_WAIT_STATUS_ERROR", e2.CROSS_CHANNEL_FAILED_JOIN_SRC = "CROSS_CHANNEL_FAILED_JOIN_SEC", e2.CROSS_CHANNEL_FAILED_JOIN_DEST = "CROSS_CHANNEL_FAILED_JOIN_DEST", e2.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST = "CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST", e2.CROSS_CHANNEL_SERVER_ERROR_RESPONSE = "CROSS_CHANNEL_SERVER_ERROR_RESPONSE", e2.METADATA_OUT_OF_RANGE = "METADATA_OUT_OF_RANGE", e2.LOCAL_AEC_ERROR = "LOCAL_AEC_ERROR", e2.INVALID_PLUGIN = "INVALID_PLUGIN", e2.DISCONNECT_P2P = "DISCONNECT_P2P", e2.INIT_WEBSOCKET_TIMEOUT = "INIT_WEBSOCKET_TIMEOUT";
      }(eD || (eD = {}));
      class tD extends Error {
        constructor(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", r2 = arguments.length > 2 ? arguments[2] : void 0;
          super(t2), kO(this, "code", void 0), kO(this, "message", void 0), kO(this, "data", void 0), kO(this, "name", "AgoraRTCException"), this.code = e2, this.message = "AgoraRTCError ".concat(this.code, ": ").concat(t2), this.data = r2;
        }
        toString() {
          return this.data ? "data: ".concat(JSON.stringify(this.data), "\n").concat(this.stack) : "".concat(this.stack);
        }
        print() {
          let e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "error";
          return e2 === "error" && dD.error(this.toString()), e2 === "warning" && dD.warning(this.toString()), this;
        }
        throw() {
          throw this.print(), this;
        }
      }
      const rD = { timeout: 500, timeoutFactor: 1.5, maxRetryCount: 1 / 0, maxRetryTimeout: 1e4 };
      function iD(e2, t2) {
        const r2 = Math.floor(t2.timeout * Math.pow(t2.timeoutFactor, e2));
        return Math.min(t2.maxRetryTimeout, r2);
      }
      function nD(e2, t2, r2, i2) {
        const n2 = Object.assign({}, rD, i2);
        let o2 = n2.timeout;
        const s2 = async () => {
          await function(e3) {
            return new nR((t3) => {
              window.setTimeout(t3, e3);
            });
          }(o2), o2 *= n2.timeoutFactor, o2 = Math.min(n2.maxRetryTimeout, o2);
        };
        let a2 = false;
        const c2 = new nR(async (i3, o3) => {
          t2 = t2 || (() => false), r2 = r2 || (() => true);
          for (let c3 = 0; c3 < n2.maxRetryCount; c3 += 1) {
            if (a2)
              return o3(new tD(eD.OPERATION_ABORTED));
            try {
              const r3 = await e2();
              if (!t2(r3, c3))
                return i3(r3);
              if (c3 + 1 === n2.maxRetryCount)
                return i3(r3);
              await s2();
            } catch (e3) {
              if (!r2(e3, c3))
                return o3(e3);
              if (c3 + 1 === n2.maxRetryCount)
                return o3(e3);
              await s2();
            }
          }
        });
        return c2.cancel = () => a2 = true, c2;
      }
      function oD() {
        const e2 = new Date();
        return e2.toTimeString().split(" ")[0] + ":" + e2.getMilliseconds();
      }
      const sD = { DEBUG: 0, INFO: 1, WARNING: 2, ERROR: 3, NONE: 4 }, aD = Date.now(), cD = (e2) => {
        for (const t2 in sD)
          if (Object.prototype.hasOwnProperty.call(sD, t2) && sD[t2] === e2)
            return t2;
        return "DEFAULT";
      };
      const dD = new class {
        constructor() {
          kO(this, "proxyServerURL", void 0), kO(this, "logLevel", sD.DEBUG), kO(this, "uploadState", "collecting"), kO(this, "uploadLogWaitingList", []), kO(this, "uploadLogUploadingList", []), kO(this, "uploadErrorCount", 0), kO(this, "currentLogID", 0), kO(this, "url", void 0), kO(this, "extLog", (e2, t2) => {
            this.appendLogToWaitingList(e2, t2);
          });
        }
        debug() {
          for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
            t2[r2] = arguments[r2];
          const i2 = [sD.DEBUG].concat(t2);
          this.log.apply(this, i2);
        }
        info() {
          for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
            t2[r2] = arguments[r2];
          const i2 = [sD.INFO].concat(t2);
          this.log.apply(this, i2);
        }
        warning() {
          for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
            t2[r2] = arguments[r2];
          const i2 = [sD.WARNING].concat(t2);
          this.log.apply(this, i2);
        }
        error() {
          for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
            t2[r2] = arguments[r2];
          const i2 = [sD.ERROR].concat(t2);
          this.log.apply(this, i2);
        }
        upload() {
          for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
            t2[r2] = arguments[r2];
          const i2 = [sD.DEBUG].concat(t2);
          this.uploadLog.apply(this, i2);
        }
        setLogLevel(e2) {
          e2 = Math.min(Math.max(0, e2), 4), this.logLevel = e2;
        }
        enableLogUpload() {
          WD("UPLOAD_LOG", true);
        }
        disableLogUpload() {
          WD("UPLOAD_LOG", false), this.uploadLogUploadingList = [], this.uploadLogWaitingList = [];
        }
        setProxyServer(e2) {
          this.proxyServerURL = e2;
        }
        prefix(e2) {
          return new XN(this).prefix(e2);
        }
        log() {
          for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
            t2[r2] = arguments[r2];
          if (Date.now() - aD < 100)
            return void setTimeout(() => {
              this.log(...t2);
            }, Date.now() - aD);
          const i2 = Math.max(0, Math.min(4, t2[0]));
          if (t2[0] = oD() + " Agora-SDK [".concat(cD(i2), "]:"), this.appendLogToWaitingList(i2, t2), i2 < this.logLevel)
            return;
          const n2 = oD() + " %cAgora-SDK [".concat(cD(i2), "]:");
          let o2 = [];
          if (!JD("USE_NEW_LOG"))
            switch (i2) {
              case sD.DEBUG:
                o2 = [n2, "color: #64B5F6;"].concat(t2.slice(1)), console.log.apply(console, o2);
                break;
              case sD.INFO:
                o2 = [n2, "color: #1E88E5; font-weight: bold;"].concat(t2.slice(1)), console.log.apply(console, o2);
                break;
              case sD.WARNING:
                o2 = [n2, "color: #FB8C00; font-weight: bold;"].concat(t2.slice(1)), console.warn.apply(console, o2);
                break;
              case sD.ERROR:
                o2 = [n2, "color: #B00020; font-weight: bold;"].concat(t2.slice(1)), console.error.apply(console, o2);
            }
        }
        uploadLog() {
          for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
            t2[r2] = arguments[r2];
          if (Date.now() - aD < 100)
            return void setTimeout(() => {
              this.uploadLog(...t2);
            }, Date.now() - aD);
          const i2 = Math.max(0, Math.min(4, t2[0]));
          t2[0] = oD() + " Agora-SDK [".concat(cD(i2), "]:"), this.appendLogToWaitingList(i2, t2);
        }
        appendLogToWaitingList(e2) {
          if (!JD("UPLOAD_LOG"))
            return;
          let t2 = "";
          for (var r2 = arguments.length, i2 = new Array(r2 > 1 ? r2 - 1 : 0), n2 = 1; n2 < r2; n2++)
            i2[n2 - 1] = arguments[n2];
          i2.forEach((e3) => {
            typeof e3 == "object" && (e3 = JSON.stringify(e3)), t2 += "".concat(e3, " ");
          }), this.uploadLogWaitingList.push({ payload_str: t2, log_level: e2, log_item_id: this.currentLogID++ }), this.uploadState === "uploading" && this.uploadLogUploadingList.length === 0 && this.uploadLogInterval();
        }
        startUpload() {
          this.uploadState = "uploading", this.uploadLogUploadingList.length === 0 && this.uploadLogInterval();
        }
        async uploadLogs() {
          const e2 = this.uploadLogUploadingList, t2 = { sdk_version: MD, process_id: JD("PROCESS_ID"), payload: JSON.stringify(e2) };
          return nD(async () => {
            const e3 = await zN.post(this.url || (this.proxyServerURL ? "https://".concat(this.proxyServerURL, "/ls/?h=").concat(JD("LOG_UPLOAD_SERVER"), "&p=443&d=upload/v1") : "https://".concat(JD("LOG_UPLOAD_SERVER"), "/upload/v1")), t2, { responseType: "text" });
            if (e3.data !== "OK") {
              const t3 = new Error("unexpected upload log response");
              throw t3.response = e3, t3;
            }
          }, () => (this.uploadLogUploadingList = [], false), (e3) => (e3.response ? $N.reportLogUploadError({ status: e3.response.status, data: e3.response.data, headers: e3.response.headers, message: e3.message }) : e3.request ? $N.reportLogUploadError({ status: e3.request.status, message: e3.message }) : $N.reportLogUploadError({ status: -1, message: e3.message }), true), { timeout: 2e3, maxRetryTimeout: 2e4 });
        }
        uploadLogInterval() {
          this.uploadLogUploadingList.length === 0 && this.uploadLogWaitingList.length === 0 || (this.uploadLogUploadingList.length === 0 && (this.uploadLogUploadingList = this.uploadLogWaitingList.splice(0, 10)), this.uploadLogs().then(() => {
            this.uploadErrorCount = 0, this.uploadLogWaitingList.length > 0 && window.setTimeout(() => this.uploadLogInterval(), 3e3);
          }).catch((e2) => {
            this.uploadErrorCount += 1, this.uploadErrorCount < 2 ? window.setTimeout(() => this.uploadLogInterval(), 200) : window.setTimeout(() => this.uploadLogInterval(), 1e3);
          }));
        }
      }(), uD = { debug: console.log, info: console.log, warning: console.warn, error: console.error }, AD = { debug: "color: #64B5F6;", info: "color: #1E88E5; font-weight: bold;", warning: "color: #FB8C00; font-weight: bold;", error: "color: #B00020; font-weight: bold;" }, hD = { debug: 0, info: 1, warning: 2, error: 3 }, lD = [];
      let pD, gD = 0, fD = 0, ED = false;
      function ID() {
        const e2 = new Date();
        return [e2.getTime(), e2.toTimeString().split(" ")[0] + ":" + e2.getMilliseconds()];
      }
      function mD(e2) {
        if (!JD("UPLOAD_LOG"))
          return;
        let t2;
        switch (e2.type) {
          case cP.MISC:
            t2 = [e2.timestamp, e2.level, e2.type, e2.module, e2.instanceId, [e2.msg]];
            break;
          case cP.INTERNAL_EVENT:
          case cP.PUBLIC_EVENT:
          case cP.WEB_EVENT:
            t2 = [e2.timestamp, e2.level, e2.type, e2.module, e2.instanceId, [e2.event, e2.msg]];
            break;
          case cP.INTERNAL_API:
          case cP.PUBLIC_API:
          case cP.WEB_API:
            t2 = [e2.timestamp, e2.level, e2.type, e2.module, e2.instanceId, [e2.api, e2.args, e2.result]];
        }
        lD.push(t2);
      }
      function _D(e2, t2) {
        const [r2, i2] = ID(), n2 = "warning", o2 = "".concat(i2, " %cAgora-SDK [").concat(n2, "] [INTERNAL API]:"), s2 = { [cP.WEB_API]: "logWebAPI", [cP.PUBLIC_API]: "logPublicAPI", [cP.INTERNAL_API]: "logInternalAPI", [cP.WEB_EVENT]: "logWebEvent", [cP.PUBLIC_EVENT]: "logPublicEvent", [cP.INTERNAL_EVENT]: "logInternalEvent", [cP.MISC]: "logMisc" }[e2], a2 = [o2, AD.warning, "Log.".concat(s2), t2];
        JD("USE_NEW_LOG") && (vD(n2) && uD.warning.apply(console, a2), mD({ timestamp: r2, level: n2, module: "Log", instanceId: void 0, type: cP.INTERNAL_API, api: s2, args: void 0, result: t2.toString() }));
      }
      function CD(e2) {
        if (Array.isArray(e2)) {
          let [t3, r3] = e2;
          return t3 || (t3 = "Global"), { module: t3, instanceId: r3 };
        }
        let t2, r2;
        if (typeof e2.__moduleName != "string")
          throw new Error("Cannot get __moduleName from log instance.");
        t2 = e2.__moduleName;
        try {
          r2 = e2.__instanceId;
        } catch (e3) {
          throw new Error("Cannot get __instanceId from log instance.");
        }
        return { module: t2, instanceId: r2 };
      }
      function vD(e2) {
        return hD[e2] >= fD;
      }
      function SD(e2, t2, r2, i2, n2, o2) {
        if (e2 === cP.PUBLIC_API || e2 === cP.WEB_API || e2 === cP.INTERNAL_API)
          try {
            const { module: s2, instanceId: a2 } = CD(r2);
            n2 = n2 && JSON.stringify(n2), o2 = o2 instanceof Error ? o2.toString() : o2 && JSON.stringify(o2);
            const [c2, d2] = ID(), u2 = ["".concat(d2, " %cAgora-SDK [").concat(t2, "] [").concat({ [cP.PUBLIC_API]: "PUBLIC API", [cP.WEB_API]: "WEB API", [cP.INTERNAL_API]: "INTERNAL API" }[e2], "]:"), AD[t2], "".concat(s2).concat(a2 ? "<".concat(a2, ">") : "", ".").concat(i2), n2, o2];
            JD("USE_NEW_LOG") && (vD(t2) && uD[t2].apply(console, u2), mD({ timestamp: c2, level: t2, module: s2, instanceId: a2, type: e2, api: i2, args: n2, result: o2 }));
          } catch (t3) {
            _D(e2, t3);
          }
      }
      function RD(e2, t2, r2, i2, n2) {
        if (e2 === cP.WEB_EVENT || e2 === cP.INTERNAL_EVENT || e2 === cP.PUBLIC_EVENT)
          try {
            const { module: o2, instanceId: s2 } = CD(r2);
            typeof n2 != "string" && (n2 = n2 instanceof Error ? n2.toString() : JSON.stringify(n2));
            const [a2, c2] = ID(), d2 = ["".concat(c2, " %cAgora-SDK [").concat(t2, "] [").concat({ [cP.WEB_EVENT]: "WEB EVENT", [cP.PUBLIC_EVENT]: "PUBLIC EVENT", [cP.INTERNAL_EVENT]: "INTERNAL EVENT" }[e2], "]:"), AD[t2], "".concat(o2).concat(s2 ? "<".concat(s2, ">") : "", ".on(").concat(i2, ")"), n2 || ""];
            JD("USE_NEW_LOG") && (vD(t2) && uD[t2].apply(console, d2), mD({ timestamp: a2, level: t2, module: o2, instanceId: s2, type: e2, event: i2, msg: n2 }));
          } catch (t3) {
            _D(e2, t3);
          }
      }
      function yD(e2) {
        pD = e2;
      }
      function TD(e2, t2, r2) {
        try {
          const { module: i2, instanceId: n2 } = CD(t2), [o2, s2] = ID(), a2 = ["".concat(s2, " %cAgora-SDK [").concat(e2, "] [MISC]:"), AD[e2], "".concat(i2).concat(n2 ? "<".concat(n2, ">") : ""), '"'.concat(r2, '"')];
          JD("USE_NEW_LOG") && (vD(e2) && uD[e2].apply(console, a2), mD({ timestamp: o2, level: e2, module: i2, instanceId: n2, type: cP.MISC, msg: r2 }));
        } catch (e3) {
          ND("warning", ["log"], "logMisc", void 0, e3);
        }
      }
      function wD(e2, t2, r2, i2) {
        RD(cP.INTERNAL_EVENT, e2, t2, r2, i2);
      }
      function bD(e2, t2, r2, i2) {
        RD(cP.PUBLIC_EVENT, e2, t2, r2, i2);
      }
      function OD(e2, t2, r2, i2) {
        RD(cP.WEB_EVENT, e2, t2, r2, i2);
      }
      function ND(e2, t2, r2, i2, n2) {
        SD(cP.INTERNAL_API, e2, t2, r2, i2, n2);
      }
      function DD(e2, t2, r2, i2, n2) {
        SD(cP.WEB_API, e2, t2, r2, i2, n2);
      }
      function LD(e2, t2, r2, i2, n2) {
        SD(cP.PUBLIC_API, e2, t2, r2, i2, n2);
      }
      function PD(e2, t2) {
        return function(r2) {
          return class extends r2 {
            get __moduleName() {
              return e2;
            }
            get __instanceId() {
              if (t2) {
                if (typeof this[t2] == "function")
                  return this[t2]();
                {
                  const e3 = t2.split(".");
                  return e3.length > 0 ? vh(e3).call(e3, (e4, t3) => {
                    try {
                      return e4 ? e4[t3] : e4;
                    } catch (e5) {
                      return;
                    }
                  }, this) : this[t2];
                }
              }
            }
          };
        };
      }
      async function kD(e2) {
        if (!e2 && ED)
          return;
        if (ED = true, !JD("UPLOAD_LOG"))
          return void setTimeout(() => kD(true), 5e3);
        if (lD.length === 0)
          return void setTimeout(() => kD(true), 3e3);
        const t2 = lD.slice(0, 10), r2 = { sdk_version: MD, log_version: JD("LOG_VERSION"), process_id: JD("PROCESS_ID"), index: gD, logs: JSON.stringify(t2) };
        await nD(async () => {
          const e3 = await zN.post(pD ? "https://".concat(pD, "/ls/?h=").concat(JD("LOG_UPLOAD_SERVER"), "&p=443&d=upload/v1") : "https://".concat(JD("LOG_UPLOAD_SERVER"), "/upload/v1"), r2, { responseType: "text" });
          if (e3.data !== "OK")
            throw new Error("Log service response error ".concat(e3.data));
          return e3;
        }, void 0, void 0, { timeout: 3e3, maxRetryTimeout: 1e4 }), lD.splice(0, 10), gD += t2.length, setTimeout(() => kD(true), 3e3);
      }
      const BD = "v4.11.1-0-gcd0777ab(5/9/2022, 6:52:38 PM)", MD = function(e2) {
        if (e2.match(/[0-9]+\.[0-9]+\.[0-9]+$/))
          return e2;
        const t2 = e2.match(/([0-9]+\.[0-9]+\.[0-9]+)\-alpha\.([0-9]+)/);
        if (t2 && t2[1] && t2[2]) {
          const e3 = t2[1], r3 = t2[2];
          return "".concat(e3, ".").concat(r3);
        }
        const r2 = e2.match(/([0-9]+\.[0-9]+\.[0-9]+)\-special\.([0-9]+)/);
        if (r2 && r2[1] && r2[2]) {
          const e3 = r2[1], t3 = r2[2];
          return "".concat(e3, ".").concat(100 * (Number(t3) + 1));
        }
        return "4.0.0.999";
      }("4.11.1"), UD = function() {
        try {
          return JSON.parse("true") === true;
        } catch (e2) {
          return true;
        }
      }(), QD = { username: "test", password: "111111", turnServerURL: "", tcpport: 3433, udpport: 3478, forceturn: false };
      const xD = { "90p": ZD(160, 90), "90p_1": ZD(160, 90), "120p": ZD(160, 120, 15, 30, 65), "120p_1": ZD(160, 120, 15, 30, 65), "120p_3": ZD(120, 120, 15, 30, 50), "120p_4": ZD(212, 120), "180p": ZD(320, 180, 15, 30, 140), "180p_1": ZD(320, 180, 15, 30, 140), "180p_3": ZD(180, 180, 15, 30, 100), "180p_4": ZD(240, 180, 15, 30, 120), "240p": ZD(320, 240, 15, 40, 200), "240p_1": ZD(320, 240, 15, 40, 200), "240p_3": ZD(240, 240, 15, 40, 140), "240p_4": ZD(424, 240, 15, 40, 220), "360p": ZD(640, 360, 15, 80, 400), "360p_1": ZD(640, 360, 15, 80, 400), "360p_3": ZD(360, 360, 15, 80, 260), "360p_4": ZD(640, 360, 30, 80, 600), "360p_6": ZD(360, 360, 30, 80, 400), "360p_7": ZD(480, 360, 15, 80, 320), "360p_8": ZD(480, 360, 30, 80, 490), "360p_9": ZD(640, 360, 15, 80, 800), "360p_10": ZD(640, 360, 24, 80, 800), "360p_11": ZD(640, 360, 24, 80, 1e3), "480p": ZD(640, 480, 15, 100, 500), "480p_1": ZD(640, 480, 15, 100, 500), "480p_2": ZD(640, 480, 30, 100, 1e3), "480p_3": ZD(480, 480, 15, 100, 400), "480p_4": ZD(640, 480, 30, 100, 750), "480p_6": ZD(480, 480, 30, 100, 600), "480p_8": ZD(848, 480, 15, 100, 610), "480p_9": ZD(848, 480, 30, 100, 930), "480p_10": ZD(640, 480, 10, 100, 400), "720p": ZD(1280, 720, 15, 120, 1130), "720p_1": ZD(1280, 720, 15, 120, 1130), "720p_2": ZD(1280, 720, 30, 120, 2e3), "720p_3": ZD(1280, 720, 30, 120, 1710), "720p_5": ZD(960, 720, 15, 120, 910), "720p_6": ZD(960, 720, 30, 120, 1380), "1080p": ZD(1920, 1080, 15, 120, 2080), "1080p_1": ZD(1920, 1080, 15, 120, 2080), "1080p_2": ZD(1920, 1080, 30, 120, 3e3), "1080p_3": ZD(1920, 1080, 30, 120, 3150), "1080p_5": ZD(1920, 1080, 60, 120, 4780), "1440p": ZD(2560, 1440, 30, 120, 4850), "1440p_1": ZD(2560, 1440, 30, 120, 4850), "1440p_2": ZD(2560, 1440, 60, 120, 7350), "4k": ZD(3840, 2160, 30, 120, 8910), "4k_1": ZD(3840, 2160, 30, 120, 8910), "4k_3": ZD(3840, 2160, 60, 120, 13500) }, FD = { "480p": $D(640, 480, 5), "480p_1": $D(640, 480, 5), "480p_2": $D(640, 480, 30), "480p_3": $D(640, 480, 15), "720p": $D(1280, 720, 5), "720p_1": $D(1280, 720, 5), "720p_2": $D(1280, 720, 30), "720p_3": $D(1280, 720, 15), "1080p": $D(1920, 1080, 5), "1080p_1": $D(1920, 1080, 5), "1080p_2": $D(1920, 1080, 30), "1080p_3": $D(1920, 1080, 15) }, VD = { "1SL1TL": eL(1, 1), "3SL3TL": eL(3, 3), "2SL3TL": eL(2, 3) };
      function jD(e2) {
        return typeof e2 == "string" ? Object.assign({}, xD[e2]) : e2;
      }
      function GD(e2) {
        return typeof e2 == "string" ? Object.assign({}, FD[e2]) : e2;
      }
      function KD(e2) {
        return typeof e2 == "string" ? Object.assign({}, VD[e2]) : e2;
      }
      const HD = { speech_low_quality: XD(16e3, false), speech_standard: XD(32e3, false, 18), music_standard: XD(48e3, false), standard_stereo: XD(48e3, true, 56), high_quality: XD(48e3, false, 128), high_quality_stereo: XD(48e3, true, 192) };
      function YD(e2) {
        return typeof e2 == "string" ? Object.assign({}, HD[e2]) : e2;
      }
      function WD(e2, t2, r2) {
        Object.keys(qD).includes(e2) && (!r2 && Object.keys(zD).includes(e2) || (qD[e2] = t2));
      }
      function JD(e2) {
        return qD[e2];
      }
      const qD = { PROCESS_ID: "", ENCRYPT_AES: true, AREAS: ["CHINA", "GLOBAL"], WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io", "webrtc2-2.ap.sd-rtn.com"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io", "webrtc2-4.ap.sd-rtn.com"], PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], CDS_AP: ["cds-ap-web-1.agora.io", "cds-web-2.ap.sd-rtn.com", "cds-ap-web-3.agora.io", "cds-web-4.ap.sd-rtn.com"], ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-web-2.ap.sd-rtn.com", "sua-ap-web-3.agora.io", "sua-web-4.ap.sd-rtn.com"], UAP_AP: ["uap-ap-web-1.agora.io", "uap-web-2.ap.sd-rtn.com", "uap-ap-web-3.agora.io", "uap-web-4.ap.sd-rtn.com"], LOG_UPLOAD_SERVER: "logservice.agora.io", EVENT_REPORT_DOMAIN: "statscollector-1.agora.io", EVENT_REPORT_BACKUP_DOMAIN: "web-2.statscollector.sd-rtn.com", GATEWAY_ADDRESS: [], GATEWAY_WSS_ADDRESS: "", LIVE_STREAMING_ADDRESS: "", HTTP_CONNECT_TIMEOUT: 5e3, SIGNAL_REQUEST_TIMEOUT: 1e4, REPORT_STATS: true, UPLOAD_LOG: false, NOT_REPORT_EVENT: [], SUBSCRIBE_TCC: true, PING_PONG_TIME_OUT: 10, WEBSOCKET_TIMEOUT_MIN: 1e4, EVENT_REPORT_SEND_INTERVAL: 3e3, CONFIG_DISTRIBUTE_INTERVAL: 3e5, CANDIDATE_TIMEOUT: 5e3, SHOW_REPORT_INVOKER_LOG: false, JOIN_EXTEND: "", PUB_EXTEND: "", SUB_EXTEND: "", FORCE_TURN: false, TURN_ENABLE_TCP: true, TURN_ENABLE_UDP: true, MAX_UPLOAD_CACHE: 50, UPLOAD_CACHE_INTERVAL: 2e3, AJAX_REQUEST_CONCURRENT: 3, REPORT_APP_SCENARIO: void 0, GATEWAY_DOMAINS: ["edge.agora.io", "edge.sd-rtn.com"], WORKER_DOMAIN: "edge.agora.io", TURN_DOMAIN: "edge.agora.io", EVENT_REPORT_RETRY: true, CHROME_FORCE_PLAN_B: false, AUDIO_SOURCE_VOLUME_UPDATE_INTERVAL: 400, AUDIO_SOURCE_AVG_VOLUME_DURATION: 3e3, AUDIO_VOLUME_INDICATION_INTERVAL: 2e3, VOLUME_VOICE_WEIGHT: 10, NORMAL_EVENT_QUEUE_CAPACITY: 100, CUSTOM_REPORT: true, CUSTOM_REPORT_LIMIT: 20, PROXY_SERVER_TYPE2: "webnginx-proxy.agora.io", PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com", "webrtc-cloud-proxy.agora.io"], CUSTOM_PUB_ANSWER_MODIFIER: null, CUSTOM_SUB_ANSWER_MODIFIER: null, CUSTOM_PUB_OFFER_MODIFIER: null, CUSTOM_SUB_OFFER_MODIFIER: null, DSCP_TYPE: "high", REMOVE_NEW_CODECS: true, FRAGEMENT_LENGTH: 3, WEBSOCKET_COMPRESS: false, SIMULCAST: false, PRELOAD_MEDIA_COUNT: 0, USE_RTX: false, CHECK_VIDEO_VISIBLE_INTERVAL: 3e4, ENUMERATE_DEVICES_INTERVAL: false, ENUMERATE_DEVICES_INTERVAL_TIME: 1e4, USE_NEW_TOKEN: false, JOIN_WITH_FALLBACK_SIGNAL_PROXY: true, JOIN_WITH_FALLBACK_MEDIA_PROXY: true, JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE: false, JOIN_WITH_FALLBACK_PROXY_PENDING_DURATION: 2e3, USE_TURN_SERVER_OF_GATEWAY: false, H264_PROFILE_LEVEL_ID: "", USE_NEW_LOG: false, LOG_VERSION: 3, MEDIA_DEVICE_CONSTRAINTS: null, ENCRYPT_PROXY_USERNAME_AND_PSW: true, SDP_LOGGING: false, REMOTE_AUDIO_TRACK_USES_WEB_AUDIO: false, LOCAL_AUDIO_TRACK_USES_WEB_AUDIO: true, BITRATE_ADAPTER_TYPE: "STANDARD_BITRATE", AI_DENOISER_PARAMETERS: {}, ADJUST_3A_FROM_PLUGINS: true, RAISE_H264_BASELINE_PRIORITY: true, FILTER_SEND_H264_BASELINE: false, ENABLE_PUBLISHED_USER_LIST: true, MAX_SUBSCRIPTION: 50, ACCOUNT_REGISTER_RETRY_TIMEOUT: 1, ACCOUNT_REGISTER_RETRY_RATIO: 2, ACCOUNT_REGISTER_RETRY_TIMEOUT_MAX: 6e4, ACCOUNT_REGISTER_RETRY_COUNT_MAX: 1e5, AUDIO_CONTEXT: null, WEBCS_BACKUP_CONNECT_TIMEOUT: 6e3, PLAYER_STATE_DEFER: 2e3, SIGNAL_REQUEST_WATCH_INTERVAL: 1e3, FILEPATH_LENMAX: 255, DUALSTREAM_OPERATION_CHECK: true, MEDIA_ELEMENT_EXISTS_DEPTH: 3, SHIM_CANDIDATE: false, LEAVE_MSG_TIMEOUT: 2e3, STATS_FILTER: { transportId: true, googTrackId: true }, STATS_COLLECTOR_PORT: 443 }, zD = {};
      function XD(e2, t2, r2) {
        return { sampleRate: e2, stereo: t2, bitrate: r2 };
      }
      function ZD(e2, t2, r2, i2, n2) {
        return { width: e2, height: t2, frameRate: r2, bitrateMin: i2, bitrateMax: n2 };
      }
      function $D(e2, t2, r2, i2, n2) {
        return { width: { max: e2 }, height: { max: t2 }, frameRate: r2, bitrateMin: i2, bitrateMax: n2 };
      }
      function eL(e2, t2) {
        return { numSpatialLayers: e2, numTemporalLayers: t2 };
      }
      UD || (qD.WEBCS_DOMAIN = ["ap-web-1-oversea.agora.io", "ap-web-1-north-america.agora.io"], qD.WEBCS_DOMAIN_BACKUP_LIST = ["ap-web-2-oversea.agora.io", "ap-web-2-north-america.agora.io"], qD.PROXY_CS = ["proxy-ap-web-oversea.agora.io", "proxy-ap-web-america.agora.io"], qD.CDS_AP = ["cds-ap-web-oversea.agora.io", "cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"], qD.ACCOUNT_REGISTER = ["sua-ap-web-oversea.agora.io", "sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"], qD.UAP_AP = ["uap-ap-web-oversea.agora.io", "uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"], qD.LOG_UPLOAD_SERVER = "logservice-oversea.agora.io", qD.EVENT_REPORT_DOMAIN = "statscollector-1-oversea.agora.io", qD.EVENT_REPORT_BACKUP_DOMAIN = "statscollector-2-oversea.agora.io", qD.PROXY_SERVER_TYPE3 = "webrtc-cloud-proxy.agora.io", qD.AREAS = ["NORTH_AMERICA", "OVERSEA"]);
      const tL = [[0, 1, 2, 3, 4, 5, 5], [0, 2, 2, 3, 4, 5, 5], [0, 3, 3, 3, 4, 5, 5], [0, 4, 4, 4, 4, 5, 5], [0, 5, 5, 5, 5, 5, 5]], rL = [], iL = [];
      var nL = Vu, oL = fA, sL = rd, aL = function(e2, t2, r2) {
        var i2 = nL(t2);
        i2 in e2 ? oL.f(e2, i2, sL(0, r2)) : e2[i2] = r2;
      }, cL = ff, dL = th, uL = aL, AL = Qc.Array, hL = Math.max, lL = function(e2, t2, r2) {
        for (var i2 = dL(e2), n2 = cL(t2, i2), o2 = cL(r2 === void 0 ? i2 : r2, i2), s2 = AL(hL(o2 - n2, 0)), a2 = 0; n2 < o2; n2++, a2++)
          uL(s2, a2, e2[n2]);
        return s2.length = a2, s2;
      }, pL = lL, gL = Math.floor, fL = function(e2, t2) {
        var r2 = e2.length, i2 = gL(r2 / 2);
        return r2 < 8 ? EL(e2, t2) : IL(e2, fL(pL(e2, 0, i2), t2), fL(pL(e2, i2), t2), t2);
      }, EL = function(e2, t2) {
        for (var r2, i2, n2 = e2.length, o2 = 1; o2 < n2; ) {
          for (i2 = o2, r2 = e2[o2]; i2 && t2(e2[i2 - 1], r2) > 0; )
            e2[i2] = e2[--i2];
          i2 !== o2++ && (e2[i2] = r2);
        }
        return e2;
      }, IL = function(e2, t2, r2, i2) {
        for (var n2 = t2.length, o2 = r2.length, s2 = 0, a2 = 0; s2 < n2 || a2 < o2; )
          e2[s2 + a2] = s2 < n2 && a2 < o2 ? i2(t2[s2], r2[a2]) <= 0 ? t2[s2++] : r2[a2++] : s2 < n2 ? t2[s2++] : r2[a2++];
        return e2;
      }, mL = fL, _L = Td.match(/firefox\/(\d+)/i), CL = !!_L && +_L[1], vL = /MSIE|Trident/.test(Td), SL = Td.match(/AppleWebKit\/(\d+)\./), RL = !!SL && +SL[1], yL = JA, TL = Bc, wL = qd, bL = Au, OL = th, NL = hI, DL = bc, LL = mL, PL = uh, kL = CL, BL = vL, ML = Pd, UL = RL, QL = [], xL = TL(QL.sort), FL = TL(QL.push), VL = DL(function() {
        QL.sort(void 0);
      }), jL = DL(function() {
        QL.sort(null);
      }), GL = PL("sort"), KL = !DL(function() {
        if (ML)
          return ML < 70;
        if (!(kL && kL > 3)) {
          if (BL)
            return true;
          if (UL)
            return UL < 603;
          var e2, t2, r2, i2, n2 = "";
          for (e2 = 65; e2 < 76; e2++) {
            switch (t2 = String.fromCharCode(e2), e2) {
              case 66:
              case 69:
              case 70:
              case 72:
                r2 = 3;
                break;
              case 68:
              case 71:
                r2 = 4;
                break;
              default:
                r2 = 2;
            }
            for (i2 = 0; i2 < 47; i2++)
              QL.push({ k: t2 + i2, v: r2 });
          }
          for (QL.sort(function(e3, t3) {
            return t3.v - e3.v;
          }), i2 = 0; i2 < QL.length; i2++)
            t2 = QL[i2].k.charAt(0), n2.charAt(n2.length - 1) !== t2 && (n2 += t2);
          return n2 !== "DGBEFHACIJK";
        }
      });
      yL({ target: "Array", proto: true, forced: VL || !jL || !GL || !KL }, { sort: function(e2) {
        e2 !== void 0 && wL(e2);
        var t2 = bL(this);
        if (KL)
          return e2 === void 0 ? xL(t2) : xL(t2, e2);
        var r2, i2, n2 = [], o2 = OL(t2);
        for (i2 = 0; i2 < o2; i2++)
          i2 in t2 && FL(n2, t2[i2]);
        for (LL(n2, function(e3) {
          return function(t3, r3) {
            return r3 === void 0 ? -1 : t3 === void 0 ? 1 : e3 !== void 0 ? +e3(t3, r3) || 0 : NL(t3) > NL(r3) ? 1 : -1;
          };
        }(e2)), r2 = n2.length, i2 = 0; i2 < r2; )
          t2[i2] = n2[i2++];
        for (; i2 < o2; )
          delete t2[i2++];
        return t2;
      } });
      var HL = fh("Array").sort, YL = Mc, WL = HL, JL = Array.prototype, qL = function(e2) {
        var t2 = e2.sort;
        return e2 === JL || YL(JL, e2) && t2 === JL.sort ? WL : t2;
      };
      function zL(e2, t2) {
        if (typeof e2 != "boolean")
          throw new tD(eD.INVALID_PARAMS, "Invalid ".concat(t2, ": The value is of the boolean type."));
      }
      function XL(e2, t2, r2) {
        if (r2.includes(e2))
          return;
        throw new tD(eD.INVALID_PARAMS, "".concat(t2, " can only be set as ").concat(JSON.stringify(r2)));
      }
      function ZL(e2, t2) {
        let r2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, i2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1e4, n2 = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4];
        if (e2 < r2 || e2 > i2 || n2 && !oP(e2)) {
          throw new tD(eD.INVALID_PARAMS, "invalid ".concat(t2, ": the value range is [").concat(r2, ", ").concat(i2, "]. integer only"));
        }
      }
      function $L(e2, t2) {
        let r2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, i2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 255, n2 = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4];
        if (e2 == null)
          throw new tD(eD.INVALID_PARAMS, "".concat(t2 || "param", " cannot be empty"));
        if (!nP(e2, r2, i2, n2))
          throw new tD(eD.INVALID_PARAMS, "Invalid ".concat(t2 || "string param", ": Length of the string: [").concat(r2, ",").concat(i2, "].").concat(n2 ? " ASCII characters only." : ""));
      }
      function eP(e2, t2) {
        if (!Array.isArray(e2))
          throw new tD(eD.INVALID_PARAMS, "".concat(t2, " should be an array"));
      }
      function tP(e2) {
        if (typeof e2 != "string" || !/^[a-zA-Z0-9 \!\#\$\%\&\(\)\+\-\:\;\<\=\.\>\?\@\[\]\^\_\{\}\|\~\,]{1,64}$/.test(e2))
          throw dD.error("Invalid Channel Name ".concat(e2)), new tD(eD.INVALID_PARAMS, "The length must be within 64 bytes. The supported characters: a-z,A-Z,0-9,space,!, #, $, %, &, (, ), +, -, :, ;, <, =, ., >, ?, @, [, ], ^, _,  {, }, |, ~, ,");
      }
      function rP(e2) {
        if (!(t2 = e2, typeof t2 == "number" && Math.floor(t2) === t2 && 0 <= t2 && t2 <= 4294967295 || nP(e2, 1, 255)))
          throw dD.error("Invalid UID ".concat(e2, " ").concat(typeof e2)), new tD(eD.INVALID_PARAMS, "[String uid] Length of the string: [1,255]. ASCII characters only. [Number uid] The value range is [0,10000]");
        var t2;
        typeof e2 == "string" && dD.warning("You input a string as the user ID, to ensure better end-user experience, Agora highly suggests not using a string as the user ID.");
      }
      function iP(e2) {
        return e2 == null;
      }
      function nP(e2) {
        let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, r2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 255, i2 = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3];
        return typeof e2 == "string" && e2.length <= r2 && e2.length >= t2 && (!i2 || sP(e2));
      }
      function oP(e2) {
        return typeof e2 == "number" && e2 % 1 == 0;
      }
      function sP(e2) {
        if (typeof e2 != "string")
          return false;
        for (let t2 = 0; t2 < e2.length; t2 += 1) {
          const r2 = e2.charCodeAt(t2);
          if (r2 < 0 || r2 > 255)
            return false;
        }
        return true;
      }
      let aP, cP, dP;
      !function(e2) {
        e2.FREE = "free", e2.UPLOADING = "uploading";
      }(aP || (aP = {})), function(e2) {
        e2[e2.MISC = 0] = "MISC", e2[e2.INTERNAL_EVENT = 1] = "INTERNAL_EVENT", e2[e2.PUBLIC_EVENT = 2] = "PUBLIC_EVENT", e2[e2.WEB_EVENT = 3] = "WEB_EVENT", e2[e2.INTERNAL_API = 4] = "INTERNAL_API", e2[e2.WEB_API = 5] = "WEB_API", e2[e2.PUBLIC_API = 6] = "PUBLIC_API";
      }(cP || (cP = {})), function(e2) {
        e2.NONE = "none", e2.INIT = "init", e2.CANPLAY = "canplay", e2.PLAYING = "playing", e2.PAUSED = "paused", e2.SUSPEND = "suspend", e2.STALLED = "stalled", e2.WAITING = "waiting", e2.ERROR = "error", e2.DESTROYED = "destroyed", e2.ABORT = "abort", e2.ENDED = "ended", e2.EMPTIED = "emptied", e2.LOADEDDATA = "loadeddata";
      }(dP || (dP = {}));
      const uP = { uninit: 100, none: 110, init: 120, loadeddata: 130, canplay: 200, playing: 210, paused: 220, suspend: 300, stalled: 310, waiting: 320, error: 330, destroyed: 340, abort: 350, ended: 360, emptied: 370 };
      function AP(e2) {
        return $L(e2.reportId, "params.reportId", 0, 100, false), $L(e2.category, "params.category", 0, 100, false), $L(e2.event, "params.event", 0, 100, false), $L(e2.label, "params.label", 0, 100, false), ZL(e2.value, "params.value", Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, false), true;
      }
      const hP = { sid: "", lts: 0, success: null, cname: null, uid: null, peer: null, cid: null, elapse: null, extend: null, vid: 0 };
      let lP, pP, gP, fP, EP, IP, mP, _P, CP, vP, SP, RP, yP, TP, wP, bP, OP, NP, DP, LP, PP, kP, BP;
      function MP(e2) {
        return ZL(e2.timeout, "config.timeout", 0, 1e5), ZL(e2.timeoutFactor, "config.timeoutFactor", 0, 100, false), ZL(e2.maxRetryCount, "config.maxRetryConfig", 0, 1 / 0), ZL(e2.maxRetryTimeout, "config.maxRetryTimeout", 0, 1 / 0), true;
      }
      function UP(e2) {
        return XL(e2.codec, "config.codec", ["vp8", "vp9", "av1", "h264"]), XL(e2.mode, "config.mode", ["rtc", "live"]), e2.audioCodec !== void 0 && XL(e2.audioCodec, "config.audioCodec", ["opus", "pcmu", "pcma", "g722"]), e2.proxyServer !== void 0 && $L(e2.proxyServer, "config.proxyServer", 1, 1e4), e2.turnServer !== void 0 && xP(e2.turnServer), e2.httpRetryConfig !== void 0 && MP(e2.httpRetryConfig), e2.websocketRetryConfig !== void 0 && MP(e2.websocketRetryConfig), true;
      }
      function QP(e2) {
        if (!Array.isArray(e2) || e2.length < 1)
          return false;
        try {
          e2.forEach((e3) => {
            if (!e3.urls)
              throw Error();
          });
        } catch (e3) {
          return false;
        }
        return true;
      }
      function xP(e2) {
        return $L(e2.turnServerURL, "turnServerURL"), $L(e2.username, "username"), $L(e2.password, "password"), e2.udpport && ZL(e2.udpport, "udpport", 1, 99999, true), e2.forceturn && zL(e2.forceturn, "forceturn"), e2.security && zL(e2.security, "security"), e2.tcpport && ZL(e2.tcpport, "tcpport", 1, 99999, true), true;
      }
      function FP(e2) {
        return e2.level !== void 0 && XL(e2.level, "level", [1, 2, 3]), true;
      }
      !function(e2) {
        e2.PUBLISH = "publish", e2.SUBSCRIBE = "subscribe", e2.WS_COMPRESSOR_INIT = "ws_compressor_init", e2.SESSION_INIT = "session_init", e2.JOIN_CHOOSE_SERVER = "join_choose_server", e2.REQ_USER_ACCOUNT = "req_user_account", e2.JOIN_GATEWAY = "join_gateway", e2.REJOIN_GATEWAY = "rejoin_gateway", e2.STREAM_SWITCH = "stream_switch", e2.REQUEST_PROXY_WORKER_MANAGER = "request_proxy_worker_manager", e2.REQUEST_PROXY_APPCENTER = "request_proxy_appcenter", e2.FIRST_VIDEO_RECEIVED = "first_video_received", e2.FIRST_AUDIO_RECEIVED = "first_audio_received", e2.FIRST_VIDEO_DECODE = "first_video_decode", e2.FIRST_AUDIO_DECODE = "first_audio_decode", e2.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", e2.ON_ADD_VIDEO_STREAM = "on_add_video_stream", e2.ON_UPDATE_STREAM = "on_update_stream", e2.ON_REMOVE_STREAM = "on_remove_stream", e2.USER_ANALYTICS = "req_user_analytics";
      }(lP || (lP = {})), function(e2) {
        e2.SESSION = "io.agora.pb.Wrtc.Session", e2.JOIN_CHOOSE_SERVER = "io.agora.pb.Wrtc.JoinChooseServer", e2.REQ_USER_ACCOUNT = "io.agora.pb.Wrtc.ReqUserAccount", e2.JOIN_GATEWAT = "io.agora.pb.Wrtc.JoinGateway", e2.RE_JOIN_GATEWAY = "io.agora.pb.Wrtc.ReJoinGateway", e2.PUBLISH = "io.agora.pb.Wrtc.Publish", e2.SUBSCRIBE = "io.agora.pb.Wrtc.Subscribe", e2.WS_COMPRESSOR_INIT = "io.agora.pb.Wrtc.WsCompressorInit", e2.STREAM_SWITCH = "io.agora.pb.Wrtc.StreamSwitch", e2.AUDIO_SENDING_STOPPED = "io.agora.pb.Wrtc.AudioSendingStopped", e2.VIDEO_SENDING_STOPPED = "io.agora.pb.Wrtc.VideoSendingStopped", e2.REQUEST_PROXY_APPCENTER = "io.agora.pb.Wrtc.RequestProxyAppCenter", e2.REQUEST_PROXY_WORKER_MANAGER = "io.agora.pb.Wrtc.RequestProxyWorkerManager", e2.API_INVOKE = "io.agora.pb.Wrtc.ApiInvoke", e2.FIRST_VIDEO_RECEIVED = "io.agora.pb.Wrtc.FirstVideoReceived", e2.FIRST_AUDIO_RECEIVED = "io.agora.pb.Wrtc.FirstAudioReceived", e2.FIRST_VIDEO_DECODE = "io.agora.pb.Wrtc.FirstVideoDecode", e2.FIRST_AUDIO_DECODE = "io.agora.pb.Wrtc.FirstAudioDecode", e2.ON_ADD_AUDIO_STREAM = "io.agora.pb.Wrtc.OnAddAudioStream", e2.ON_ADD_VIDEO_STREAM = "io.agora.pb.Wrtc.OnAddVideoStream", e2.ON_UPDATE_STREAM = "io.agora.pb.Wrtc.OnUpdateStream", e2.ON_REMOVE_STREAM = "io.agora.pb.Wrtc.OnRemoveStream", e2.JOIN_CHANNEL_TIMEOUT = "io.agora.pb.Wrtc.JoinChannelTimeout", e2.PEER_PUBLISH_STATUS = "io.agora.pb.Wrtc.PeerPublishStatus", e2.WORKER_EVENT = "io.agora.pb.Wrtc.WorkerEvent", e2.AP_WORKER_EVENT = "io.agora.pb.Wrtc.APWorkerEvent", e2.JOIN_WEB_PROXY_AP = "io.agora.pb.Wrtc.JoinWebProxyAP", e2.WEBSOCKET_QUIT = "io.agora.pb.Wrtc.WebSocketQuit", e2.USER_ANALYTICS = "io.agora.pb.Wrtc.UserAnalytics", e2.AUTOPLAY_FAILED = "io.agora.pb.Wrtc.AutoplayFailed";
      }(pP || (pP = {})), function(e2) {
        e2[e2.WORKER_EVENT = 156] = "WORKER_EVENT", e2[e2.AP_WORKER_EVENT = 160] = "AP_WORKER_EVENT";
      }(gP || (gP = {})), function(e2) {
        e2.CREATE_CLIENT = "createClient", e2.CHECK_SYSTEM_REQUIREMENTS = "checkSystemRequirements", e2.SET_AREA = "setArea", e2.CHECK_VIDEO_TRACK_IS_ACTIVE = "checkVideoTrackIsActive", e2.CHECK_AUDIO_TRACK_IS_ACTIVE = "checkAudioTrackIsActive", e2.CREATE_MIC_AUDIO_TRACK = "createMicrophoneAudioTrack", e2.CREATE_CUSTOM_AUDIO_TRACK = "createCustomAudioTrack", e2.CREATE_BUFFER_AUDIO_TRACK = "createBufferSourceAudioTrack", e2.CREATE_CAM_VIDEO_TRACK = "createCameraVideoTrack", e2.CREATE_CUSTOM_VIDEO_TRACK = "createCustomVideoTrack", e2.CREATE_MIC_AND_CAM_TRACKS = "createMicrophoneAndCameraTracks", e2.CREATE_SCREEN_VIDEO_TRACK = "createScreenVideoTrack", e2.SET_ENCRYPTION_CONFIG = "Client.setEncryptionConfig", e2.START_PROXY_SERVER = "Client.startProxyServer", e2.STOP_PROXY_SERVER = "Client.stopProxyServer", e2.SET_PROXY_SERVER = "Client.setProxyServer", e2.SET_TURN_SERVER = "Client.setTurnServer", e2.SET_CLIENT_ROLE = "Client.setClientRole", e2.SET_LOW_STREAM_PARAMETER = "Client.setLowStreamParameter", e2.ENABLE_DUAL_STREAM = "Client.enableDualStream", e2.DISABLE_DUAL_STREAM = "Client.disableDualStream", e2.JOIN = "Client.join", e2.LEAVE = "Client.leave", e2.PUBLISH = "Client.publish", e2.UNPUBLISH = "Client.unpublish", e2.SUBSCRIBE = "Client.subscribe", e2.MASS_SUBSCRIBE = "Client.massSubscribe", e2.MASS_UNSUBSCRIBE = "Client.massUnsubscribe", e2.UNSUBSCRIBE = "Client.unsubscribe", e2.RENEW_TOKEN = "Client.renewToken", e2.SET_REMOTE_VIDEO_STREAM_TYPE = "Client.setRemoteVideoStreamType", e2.SET_STREAM_FALLBACK_OPTION = "Client.setStreamFallbackOption", e2.ENABLE_AUDIO_VOLUME_INDICATOR = "Client.enableAudioVolumeIndicator", e2.SEND_CUSTOM_REPORT_MESSAGE = "Client.sendCustomReportMessage", e2.JOIN_FALLBACK_TO_PROXY = "Client._joinFallbackToProxy", e2.ON_LIVE_STREAM_WARNING = "Client.onLiveStreamWarning", e2.ON_LIVE_STREAM_ERROR = "Client.onLiveStreamingError", e2.START_LIVE_STREAMING = "Client.startLiveStreaming", e2.SET_LIVE_TRANSCODING = "Client.setLiveTranscoding", e2.STOP_LIVE_STREAMING = "Client.stopLiveStreaming", e2.ADD_INJECT_STREAM_URL = "Client.addInjectStreamUrl", e2.REMOVE_INJECT_STREAM_URL = "Client.removeInjectStreamUrl", e2.START_CHANNEL_MEDIA_RELAY = "Client.startChannelMediaRelay", e2.UPDATE_CHANNEL_MEDIA_RELAY = "Client.updateChannelMediaRelay", e2.STOP_CHANNEL_MEDIA_RELAY = "Client.stopChannelMediaRelay", e2.REQUEST_CONFIG_DISTRIBUTE = "_config-distribute-request", e2.SET_CONFIG_DISTRIBUTE = "_configDistribute", e2.LOCAL_TRACK_SET_MUTED = "LocalTrack.setMute", e2.LOCAL_AUDIO_TRACK_PLAY = "LocalAudioTrack.play", e2.LOCAL_AUDIO_TRACK_PLAY_IN_ELEMENT = "LocalAudioTrack.playInElement", e2.LOCAL_AUDIO_TRACK_STOP = "LocalAudioTrack.stop", e2.LOCAL_AUDIO_TRACK_SET_VOLUME = "LocalAudioTrack.setVolume", e2.MIC_AUDIO_TRACK_SET_DEVICE = "MicrophoneAudioTrack.setDevice", e2.BUFFER_AUDIO_TRACK_START = "BufferSourceAudioTrack.startProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_STOP = "BufferSourceAudioTrack.stopProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_PAUSE = "BufferSourceAudioTrack.pauseProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_RESUME = "BufferSourceAudioTrack.resumeProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_SEEK = "BufferSourceAudioTrack.seekAudioBuffer", e2.LOCAL_VIDEO_TRACK_PLAY = "LocalVideoTrack.play", e2.LOCAL_VIDEO_TRACK_STOP = "LocalVideoTrack.stop", e2.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE = "LocalVideoTrack.getVideoElementVisibleStatus", e2.LOCAL_VIDEO_TRACK_BEAUTY = "LocalVideoTrack.setBeautyEffect", e2.CAM_VIDEO_TRACK_SET_DEVICE = "CameraVideoTrack.setDevice", e2.CAM_VIDEO_TRACK_SET_ENCODER_CONFIG = "CameraVideoTrack.setEncoderConfiguration", e2.REMOTE_VIDEO_TRACK_PLAY = "RemoteVideoTrack.play", e2.REMOTE_VIDEO_TRACK_STOP = "RemoteVideoTrack.stop", e2.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE = "RemoteVideoTrack.getVideoElementVisibleStatus", e2.REMOTE_AUDIO_TRACK_PLAY = "RemoteAudioTrack.play", e2.REMOTE_AUDIO_TRACK_STOP = "RemoteAudioTrack.stop", e2.REMOTE_AUDIO_SET_VOLUME = "RemoteAudioTrack.setVolume", e2.REMOTE_AUDIO_SET_OUTPUT_DEVICE = "RemoteAudioTrack.setOutputDevice", e2.GET_MEDIA_STREAM_TRACK = "Track.getMediaStreamTrack", e2.STREAM_TYPE_CHANGE = "streamTypeChange", e2.CONNECTION_STATE_CHANGE = "connectionStateChange", e2.LOAD_CONFIG_FROM_LOCALSTORAGE = "loadConfigFromLocalStorage";
      }(fP || (fP = {})), function(e2) {
        e2.TRACER = "tracer";
      }(EP || (EP = {})), function(e2) {
        e2.IDLE = "IDLE", e2.INITING = "INITING", e2.INITEND = "INITEND";
      }(IP || (IP = {})), function(e2) {
        e2.STATE_CHANGE = "state_change", e2.RECORDING_DEVICE_CHANGED = "recordingDeviceChanged", e2.PLAYOUT_DEVICE_CHANGED = "playoutDeviceChanged", e2.CAMERA_DEVICE_CHANGED = "cameraDeviceChanged";
      }(mP || (mP = {})), function(e2) {
        e2[e2.ACCESS_POINT = 101] = "ACCESS_POINT", e2[e2.UNILBS = 201] = "UNILBS", e2[e2.STRING_UID_ALLOCATOR = 901] = "STRING_UID_ALLOCATOR";
      }(_P || (_P = {})), function(e2) {
        e2[e2.IIIEGAL_APPID = 1] = "IIIEGAL_APPID", e2[e2.IIIEGAL_UID = 2] = "IIIEGAL_UID", e2[e2.INTERNAL_ERROR = 3] = "INTERNAL_ERROR";
      }(CP || (CP = {})), function(e2) {
        e2[e2.INVALID_VENDOR_KEY = 5] = "INVALID_VENDOR_KEY", e2[e2.INVALID_CHANNEL_NAME = 7] = "INVALID_CHANNEL_NAME", e2[e2.INTERNAL_ERROR = 8] = "INTERNAL_ERROR", e2[e2.NO_AUTHORIZED = 9] = "NO_AUTHORIZED", e2[e2.DYNAMIC_KEY_TIMEOUT = 10] = "DYNAMIC_KEY_TIMEOUT", e2[e2.NO_ACTIVE_STATUS = 11] = "NO_ACTIVE_STATUS", e2[e2.DYNAMIC_KEY_EXPIRED = 13] = "DYNAMIC_KEY_EXPIRED", e2[e2.STATIC_USE_DYNAMIC_KEY = 14] = "STATIC_USE_DYNAMIC_KEY", e2[e2.DYNAMIC_USE_STATIC_KEY = 15] = "DYNAMIC_USE_STATIC_KEY", e2[e2.USER_OVERLOAD = 16] = "USER_OVERLOAD", e2[e2.FORBIDDEN_REGION = 18] = "FORBIDDEN_REGION", e2[e2.CANNOT_MEET_AREA_DEMAND = 19] = "CANNOT_MEET_AREA_DEMAND";
      }(vP || (vP = {})), function(e2) {
        e2[e2.NO_FLAG_SET = 100] = "NO_FLAG_SET", e2[e2.FLAG_SET_BUT_EMPTY = 101] = "FLAG_SET_BUT_EMPTY", e2[e2.INVALID_FALG_SET = 102] = "INVALID_FALG_SET", e2[e2.FLAG_SET_BUT_NO_RE = 103] = "FLAG_SET_BUT_NO_RE", e2[e2.INVALID_SERVICE_ID = 104] = "INVALID_SERVICE_ID", e2[e2.NO_SERVICE_AVAILABLE = 200] = "NO_SERVICE_AVAILABLE", e2[e2.NO_SERVICE_AVAILABLE_P2P = 201] = "NO_SERVICE_AVAILABLE_P2P", e2[e2.NO_SERVICE_AVAILABLE_VOICE = 202] = "NO_SERVICE_AVAILABLE_VOICE", e2[e2.NO_SERVICE_AVAILABLE_WEBRTC = 203] = "NO_SERVICE_AVAILABLE_WEBRTC", e2[e2.NO_SERVICE_AVAILABLE_CDS = 204] = "NO_SERVICE_AVAILABLE_CDS", e2[e2.NO_SERVICE_AVAILABLE_CDN = 205] = "NO_SERVICE_AVAILABLE_CDN", e2[e2.NO_SERVICE_AVAILABLE_TDS = 206] = "NO_SERVICE_AVAILABLE_TDS", e2[e2.NO_SERVICE_AVAILABLE_REPORT = 207] = "NO_SERVICE_AVAILABLE_REPORT", e2[e2.NO_SERVICE_AVAILABLE_APP_CENTER = 208] = "NO_SERVICE_AVAILABLE_APP_CENTER", e2[e2.NO_SERVICE_AVAILABLE_ENV0 = 209] = "NO_SERVICE_AVAILABLE_ENV0", e2[e2.NO_SERVICE_AVAILABLE_VOET = 210] = "NO_SERVICE_AVAILABLE_VOET", e2[e2.NO_SERVICE_AVAILABLE_STRING_UID = 211] = "NO_SERVICE_AVAILABLE_STRING_UID", e2[e2.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS = 212] = "NO_SERVICE_AVAILABLE_WEBRTC_UNILBS", e2[e2.NO_SERVICE_AVAILABLE_UNILBS_FLV = 213] = "NO_SERVICE_AVAILABLE_UNILBS_FLV";
      }(SP || (SP = {})), function(e2) {
        e2[e2.K_TIMESTAMP_EXPIRED = 2] = "K_TIMESTAMP_EXPIRED", e2[e2.K_CHANNEL_PERMISSION_INVALID = 3] = "K_CHANNEL_PERMISSION_INVALID", e2[e2.K_CERTIFICATE_INVALID = 4] = "K_CERTIFICATE_INVALID", e2[e2.K_CHANNEL_NAME_EMPTY = 5] = "K_CHANNEL_NAME_EMPTY", e2[e2.K_CHANNEL_NOT_FOUND = 6] = "K_CHANNEL_NOT_FOUND", e2[e2.K_TICKET_INVALID = 7] = "K_TICKET_INVALID", e2[e2.K_CHANNEL_CONFLICTED = 8] = "K_CHANNEL_CONFLICTED", e2[e2.K_SERVICE_NOT_READY = 9] = "K_SERVICE_NOT_READY", e2[e2.K_SERVICE_TOO_HEAVY = 10] = "K_SERVICE_TOO_HEAVY", e2[e2.K_UID_BANNED = 14] = "K_UID_BANNED", e2[e2.K_IP_BANNED = 15] = "K_IP_BANNED", e2[e2.K_CHANNEL_BANNED = 16] = "K_CHANNEL_BANNED", e2[e2.WARN_NO_AVAILABLE_CHANNEL = 103] = "WARN_NO_AVAILABLE_CHANNEL", e2[e2.WARN_LOOKUP_CHANNEL_TIMEOUT = 104] = "WARN_LOOKUP_CHANNEL_TIMEOUT", e2[e2.WARN_LOOKUP_CHANNEL_REJECTED = 105] = "WARN_LOOKUP_CHANNEL_REJECTED", e2[e2.WARN_OPEN_CHANNEL_TIMEOUT = 106] = "WARN_OPEN_CHANNEL_TIMEOUT", e2[e2.WARN_OPEN_CHANNEL_REJECTED = 107] = "WARN_OPEN_CHANNEL_REJECTED", e2[e2.WARN_REQUEST_DEFERRED = 108] = "WARN_REQUEST_DEFERRED", e2[e2.ERR_DYNAMIC_KEY_TIMEOUT = 109] = "ERR_DYNAMIC_KEY_TIMEOUT", e2[e2.ERR_NO_AUTHORIZED = 110] = "ERR_NO_AUTHORIZED", e2[e2.ERR_VOM_SERVICE_UNAVAILABLE = 111] = "ERR_VOM_SERVICE_UNAVAILABLE", e2[e2.ERR_NO_CHANNEL_AVAILABLE_CODE = 112] = "ERR_NO_CHANNEL_AVAILABLE_CODE", e2[e2.ERR_MASTER_VOCS_UNAVAILABLE = 114] = "ERR_MASTER_VOCS_UNAVAILABLE", e2[e2.ERR_INTERNAL_ERROR = 115] = "ERR_INTERNAL_ERROR", e2[e2.ERR_NO_ACTIVE_STATUS = 116] = "ERR_NO_ACTIVE_STATUS", e2[e2.ERR_INVALID_UID = 117] = "ERR_INVALID_UID", e2[e2.ERR_DYNAMIC_KEY_EXPIRED = 118] = "ERR_DYNAMIC_KEY_EXPIRED", e2[e2.ERR_STATIC_USE_DYANMIC_KE = 119] = "ERR_STATIC_USE_DYANMIC_KE", e2[e2.ERR_DYNAMIC_USE_STATIC_KE = 120] = "ERR_DYNAMIC_USE_STATIC_KE", e2[e2.ERR_NO_VOCS_AVAILABLE = 2e3] = "ERR_NO_VOCS_AVAILABLE", e2[e2.ERR_NO_VOS_AVAILABLE = 2001] = "ERR_NO_VOS_AVAILABLE", e2[e2.ERR_JOIN_CHANNEL_TIMEOUT = 2002] = "ERR_JOIN_CHANNEL_TIMEOUT", e2[e2.ERR_REPEAT_JOIN_CHANNEL = 2003] = "ERR_REPEAT_JOIN_CHANNEL", e2[e2.ERR_JOIN_BY_MULTI_IP = 2004] = "ERR_JOIN_BY_MULTI_IP", e2[e2.ERR_NOT_JOINED = 2011] = "ERR_NOT_JOINED", e2[e2.ERR_REPEAT_JOIN_REQUEST = 2012] = "ERR_REPEAT_JOIN_REQUEST", e2[e2.ERR_INVALID_VENDOR_KEY = 2013] = "ERR_INVALID_VENDOR_KEY", e2[e2.ERR_INVALID_CHANNEL_NAME = 2014] = "ERR_INVALID_CHANNEL_NAME", e2[e2.ERR_INVALID_STRINGUID = 2015] = "ERR_INVALID_STRINGUID", e2[e2.ERR_TOO_MANY_USERS = 2016] = "ERR_TOO_MANY_USERS", e2[e2.ERR_SET_CLIENT_ROLE_TIMEOUT = 2017] = "ERR_SET_CLIENT_ROLE_TIMEOUT", e2[e2.ERR_SET_CLIENT_ROLE_NO_PERMISSION = 2018] = "ERR_SET_CLIENT_ROLE_NO_PERMISSION", e2[e2.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE = 2019] = "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE", e2[e2.ERR_PUBLISH_REQUEST_INVALID = 2020] = "ERR_PUBLISH_REQUEST_INVALID", e2[e2.ERR_SUBSCRIBE_REQUEST_INVALID = 2021] = "ERR_SUBSCRIBE_REQUEST_INVALID", e2[e2.ERR_NOT_SUPPORTED_MESSAGE = 2022] = "ERR_NOT_SUPPORTED_MESSAGE", e2[e2.ERR_ILLEAGAL_PLUGIN = 2023] = "ERR_ILLEAGAL_PLUGIN", e2[e2.ERR_REJOIN_TOKEN_INVALID = 2024] = "ERR_REJOIN_TOKEN_INVALID", e2[e2.ERR_REJOIN_USER_NOT_JOINED = 2025] = "ERR_REJOIN_USER_NOT_JOINED", e2[e2.ERR_INVALID_OPTIONAL_INFO = 2027] = "ERR_INVALID_OPTIONAL_INFO", e2[e2.ILLEGAL_AES_PASSWORD = 2028] = "ILLEGAL_AES_PASSWORD", e2[e2.ILLEGAL_CLIENT_ROLE_LEVEL = 2029] = "ILLEGAL_CLIENT_ROLE_LEVEL", e2[e2.ERR_TOO_MANY_BROADCASTERS = 2031] = "ERR_TOO_MANY_BROADCASTERS", e2[e2.ERR_TOO_MANY_SUBSCRIBERS = 2032] = "ERR_TOO_MANY_SUBSCRIBERS", e2[e2.ERR_TEST_RECOVER = 9e3] = "ERR_TEST_RECOVER", e2[e2.ERR_TEST_TRYNEXT = 9001] = "ERR_TEST_TRYNEXT", e2[e2.ERR_TEST_RETRY = 9002] = "ERR_TEST_RETRY";
      }(RP || (RP = {})), function(e2) {
        e2[e2.AUDIENCE_LEVEL_LOW_LATENCY = 1] = "AUDIENCE_LEVEL_LOW_LATENCY", e2[e2.AUDIENCE_LEVEL_ULTRA_LOW_LATENCY = 2] = "AUDIENCE_LEVEL_ULTRA_LOW_LATENCY", e2[e2.AUDIENCE_LEVEL_SYNC_LATENCY = 3] = "AUDIENCE_LEVEL_SYNC_LATENCY";
      }(yP || (yP = {})), function(e2) {
        e2.LEAVE = "LEAVE", e2.NETWORK_ERROR = "NETWORK_ERROR", e2.SERVER_ERROR = "SERVER_ERROR", e2.UID_BANNED = "UID_BANNED", e2.IP_BANNED = "IP_BANNED", e2.CHANNEL_BANNED = "CHANNEL_BANNED", e2.FALLBACK = "FALLBACK";
      }(TP || (TP = {})), function(e2) {
        e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.MEDIA_RECONNECT_START = "media-reconnect-start", e2.MEDIA_RECONNECT_END = "media-reconnect-end", e2.IS_USING_CLOUD_PROXY = "is-using-cloud-proxy", e2.USER_JOINED = "user-joined", e2.USER_LEAVED = "user-left", e2.USER_PUBLISHED = "user-published", e2.USER_UNPUBLISHED = "user-unpublished", e2.USER_INFO_UPDATED = "user-info-updated", e2.CLIENT_BANNED = "client-banned", e2.CHANNEL_MEDIA_RELAY_STATE = "channel-media-relay-state", e2.CHANNEL_MEDIA_RELAY_EVENT = "channel-media-relay-event", e2.VOLUME_INDICATOR = "volume-indicator", e2.CRYPT_ERROR = "crypt-error", e2.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "token-privilege-will-expire", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "token-privilege-did-expire", e2.NETWORK_QUALITY = "network-quality", e2.STREAM_TYPE_CHANGED = "stream-type-changed", e2.STREAM_FALLBACK = "stream-fallback", e2.RECEIVE_METADATA = "receive-metadata", e2.STREAM_MESSAGE = "stream-message", e2.LIVE_STREAMING_ERROR = "live-streaming-error", e2.LIVE_STREAMING_WARNING = "live-streaming-warning", e2.INJECT_STREAM_STATUS = "stream-inject-status", e2.EXCEPTION = "exception", e2.ERROR = "error", e2.P2P_LOST = "p2p_lost", e2.JOIN_FALLBACK_TO_PROXY = "join-fallback-to-proxy", e2.MEDIA_CONNECTION_TYPE_CHANGE = "media-connection-type-change", e2.PUBLISHED_USER_LIST = "published-user-list";
      }(wP || (wP = {})), function(e2) {
        e2.NETWORK_ERROR = "NETWORK_ERROR", e2.SERVER_ERROR = "SERVER_ERROR", e2.MULTI_IP = "MULTI_IP", e2.TIMEOUT = "TIMEOUT", e2.OFFLINE = "OFFLINE", e2.LEAVE = "LEAVE", e2.P2P_FAILED = "P2P_FAILED", e2.FALLBACK = "FALLBACK";
      }(bP || (bP = {})), function(e2) {
        e2.CONNECTING = "connecting", e2.CONNECTED = "connected", e2.RECONNECTING = "reconnecting", e2.CLOSED = "closed";
      }(OP || (OP = {})), function(e2) {
        e2.WS_CONNECTED = "ws_connected", e2.WS_RECONNECTING = "ws_reconnecting", e2.WS_CLOSED = "ws_closed", e2.WS_RECONNECT_WAITTING_FINISH = "ws_reconnect_waitting_finish", e2.WS_RECONNECT_CREATE_CONNECTION = "ws_reconnect_create_connection", e2.ON_BINARY_DATA = "on_binary_data", e2.REQUEST_RECOVER = "request_recover", e2.REQUEST_JOIN_INFO = "request_join_info", e2.REQUEST_REJOIN_INFO = "req_rejoin_info", e2.IS_P2P_DISCONNECTED = "is_p2p_dis", e2.DISCONNECT_P2P = "dis_p2p", e2.ABORT_P2P_EXECUTION = "abort_p2p_execution", e2.NEED_RENEW_SESSION = "need-sid", e2.REPORT_JOIN_GATEWAY = "report_join_gateway", e2.REQUEST_TIMEOUT = "request_timeout", e2.REQUEST_SUCCESS = "request_success", e2.JOIN_RESPONSE = "join_response";
      }(NP || (NP = {})), function(e2) {
        e2.PING = "ping", e2.PING_BACK = "ping_back", e2.JOIN = "join_v3", e2.REJOIN = "rejoin_v3", e2.LEAVE = "leave", e2.SET_CLIENT_ROLE = "set_client_role", e2.PUBLISH = "publish", e2.UNPUBLISH = "unpublish", e2.SUBSCRIBE = "subscribe", e2.SUBSCRIBE_STREAMS = "subscribe_streams", e2.UNSUBSCRIBE = "unsubscribe", e2.UNSUBSCRIBE_STREAMS = "unsubscribe_streams", e2.SUBSCRIBE_CHANGE = "subscribe_change", e2.TRAFFIC_STATS = "traffic_stats", e2.RENEW_TOKEN = "renew_token", e2.SWITCH_VIDEO_STREAM = "switch_video_stream", e2.DEFAULT_VIDEO_STREAM = "default_video_stream", e2.SET_FALLBACK_OPTION = "set_fallback_option", e2.GATEWAY_INFO = "gateway_info", e2.CONTROL = "control", e2.SEND_METADATA = "send_metadata", e2.DATA_STREAM = "data_stream", e2.PICK_SVC_LAYER = "pick_svc_layer", e2.RESTART_ICE = "restart_ice", e2.CONNECT_PC = "connect_pc", e2.SET_VIDEO_PROFILE = "set_video_profile";
      }(DP || (DP = {})), function(e2) {
        e2.PUBLISH_STATS = "publish_stats", e2.PUBLISH_RELATED_STATS = "publish_related_stats", e2.SUBSCRIBE_STATS = "subscribe_stats", e2.SUBSCRIBE_RELATED_STATS = "subscribe_related_stats", e2.WS_INFLATE_DATA_LENGTH = "ws_inflate_data_length", e2.DENOISER_STATS = "denoiser_stats", e2.TRANSPORT_STATS = "transport_stats";
      }(LP || (LP = {})), function(e2) {
        e2.ON_USER_ONLINE = "on_user_online", e2.ON_USER_OFFLINE = "on_user_offline", e2.ON_STREAM_FALLBACK_UPDATE = "on_stream_fallback_update", e2.ON_PUBLISH_STREAM = "on_publish_stream", e2.ON_UPLINK_STATS = "on_uplink_stats", e2.ON_P2P_LOST = "on_p2p_lost", e2.ON_REMOVE_STREAM = "on_remove_stream", e2.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", e2.ON_ADD_VIDEO_STREAM = "on_add_video_stream", e2.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "on_token_privilege_will_expire", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "on_token_privilege_did_expire", e2.ON_USER_BANNED = "on_user_banned", e2.ON_NOTIFICATION = "on_notification", e2.ON_CRYPT_ERROR = "on_crypt_error", e2.MUTE_AUDIO = "mute_audio", e2.MUTE_VIDEO = "mute_video", e2.UNMUTE_AUDIO = "unmute_audio", e2.UNMUTE_VIDEO = "unmute_video", e2.ON_P2P_OK = "on_p2p_ok", e2.RECEIVE_METADATA = "receive_metadata", e2.ON_DATA_STREAM = "on_data_stream", e2.ENABLE_LOCAL_VIDEO = "enable_local_video", e2.DISABLE_LOCAL_VIDEO = "disable_local_video", e2.ENABLE_LOCAL_AUDIO = "enable_local_audio", e2.DISABLE_LOCAL_AUDIO = "disable_local_audio", e2.ON_PUBLISHED_USER_LIST = "on_published_user_list";
      }(PP || (PP = {})), function(e2) {
        e2.CONNECTION_STATE_CHANGE = "CONNECTION_STATE_CHANGE", e2.NEED_ANSWER = "NEED_ANSWER", e2.NEED_RENEGOTIATE = "NEED_RENEGOTIATE", e2.P2P_LOST = "P2P_LOST", e2.GATEWAY_P2P_LOST = "GATEWAY_P2P_LOST", e2.NEED_UNPUB = "NEED_UNPUB", e2.NEED_UNSUB = "NEED_UNSUB", e2.NEED_UPLOAD = "NEED_UPLOAD", e2.NEED_CONTROL = "NEED_CONTROL", e2.START_RECONNECT = "START_RECONNECT", e2.END_RECONNECT = "END_RECONNECT", e2.NEED_SIGNAL_RTT = "NEED_SIGNAL_RTT";
      }(kP || (kP = {})), function(e2) {
        e2.AUDIO_SOURCE_STATE_CHANGE = "audio_source_state_change", e2.RECEIVE_TRACK_BUFFER = "receive_track_buffer", e2.ON_AUDIO_BUFFER = "on_audio_buffer", e2.UPDATE_SOURCE = "update_source";
      }(BP || (BP = {}));
      const VP = { sendVolumeLevel: 0, sendBitrate: 0, sendBytes: 0, sendPackets: 0, sendPacketsLost: 0, currentPacketLossRate: 0 }, jP = { sendBytes: 0, sendBitrate: 0, sendPackets: 0, sendPacketsLost: 0, sendResolutionHeight: 0, sendResolutionWidth: 0, captureResolutionHeight: 0, captureResolutionWidth: 0, targetSendBitrate: 0, totalDuration: 0, totalFreezeTime: 0, currentPacketLossRate: 0 }, GP = { transportDelay: 0, end2EndDelay: 0, receiveBitrate: 0, receiveLevel: 0, receiveBytes: 0, receiveDelay: 0, receivePackets: 0, receivePacketsLost: 0, totalDuration: 0, totalFreezeTime: 0, freezeRate: 0, packetLossRate: 0, currentPacketLossRate: 0, publishDuration: -1 }, KP = { uplinkNetworkQuality: 0, downlinkNetworkQuality: 0 }, HP = { transportDelay: 0, end2EndDelay: 0, receiveBitrate: 0, receiveBytes: 0, receiveDelay: 0, receivePackets: 0, receivePacketsLost: 0, receiveResolutionHeight: 0, receiveResolutionWidth: 0, totalDuration: 0, totalFreezeTime: 0, freezeRate: 0, packetLossRate: 0, currentPacketLossRate: 0, publishDuration: -1 };
      let YP, WP, JP;
      !function(e2) {
        e2.CONNECTED = "websocket:connected", e2.RECONNECTING = "websocket:reconnecting", e2.WILL_RECONNECT = "websocket:will_reconnect", e2.CLOSED = "websocket:closed", e2.FAILED = "websocket:failed", e2.ON_MESSAGE = "websocket:on_message", e2.REQUEST_NEW_URLS = "websocket:request_new_urls", e2.RECONNECT_WAITTING_FINISH = "websocket:reconnect_waitting_finish", e2.RECONNECT_CREATE_CONNECTION = "websocket:reconnect_create_connection";
      }(YP || (YP = {})), function(e2) {
        e2.TRANSCODE = "mix_streaming", e2.RAW = "raw_streaming", e2.INJECT = "inject_streaming";
      }(WP || (WP = {})), function(e2) {
        e2[e2.INJECT_STREAM_STATUS_START_SUCCESS = 0] = "INJECT_STREAM_STATUS_START_SUCCESS", e2[e2.INJECT_STREAM_STATUS_START_ALREADY_EXISTS = 1] = "INJECT_STREAM_STATUS_START_ALREADY_EXISTS", e2[e2.INJECT_STREAM_STATUS_START_UNAUTHORIZED = 2] = "INJECT_STREAM_STATUS_START_UNAUTHORIZED", e2[e2.INJECT_STREAM_STATUS_START_TIMEOUT = 3] = "INJECT_STREAM_STATUS_START_TIMEOUT", e2[e2.INJECT_STREAM_STATUS_START_FAILED = 4] = "INJECT_STREAM_STATUS_START_FAILED", e2[e2.INJECT_STREAM_STATUS_STOP_SUCCESS = 5] = "INJECT_STREAM_STATUS_STOP_SUCCESS", e2[e2.INJECT_STREAM_STATUS_STOP_NOT_FOUND = 6] = "INJECT_STREAM_STATUS_STOP_NOT_FOUND", e2[e2.INJECT_STREAM_STATUS_STOP_UNAUTHORIZED = 7] = "INJECT_STREAM_STATUS_STOP_UNAUTHORIZED", e2[e2.INJECT_STREAM_STATUS_STOP_TIMEOUT = 8] = "INJECT_STREAM_STATUS_STOP_TIMEOUT", e2[e2.INJECT_STREAM_STATUS_STOP_FAILED = 9] = "INJECT_STREAM_STATUS_STOP_FAILED", e2[e2.INJECT_STREAM_STATUS_BROKEN = 10] = "INJECT_STREAM_STATUS_BROKEN";
      }(JP || (JP = {}));
      const qP = { alpha: 1, height: 640, width: 360, x: 0, y: 0, zOrder: 0, audioChannel: 0 }, zP = { x: 0, y: 0, width: 160, height: 160, zOrder: 255, alpha: 1 };
      function XP(e2, t2) {
        $L(e2.url, "".concat(t2, ".url"), 1, 1e3, false), iP(e2.x) || ZL(e2.x, "".concat(t2, ".x"), 0, 1e4), iP(e2.y) || ZL(e2.y, "".concat(t2, ".y"), 0, 1e4), iP(e2.width) || ZL(e2.width, "".concat(t2, ".width"), 0, 1e4), iP(e2.height) || ZL(e2.height, "".concat(t2, ".height"), 0, 1e4), iP(e2.zOrder) || ZL(e2.zOrder, "".concat(t2, ".zOrder"), 0, 255), iP(e2.alpha) || ZL(e2.alpha, "".concat(t2, ".alpha"), 0, 1, false);
      }
      const ZP = { audioBitrate: 48, audioChannels: 1, audioSampleRate: 48e3, backgroundColor: 0, height: 360, lowLatency: false, videoBitrate: 400, videoCodecProfile: 100, videoCodecType: 1, videoFrameRate: 15, videoGop: 30, width: 640, images: [], userConfigs: [], userConfigExtraInfo: "" }, $P = { audioBitrate: 48, audioChannels: 2, audioVolume: 100, audioSampleRate: 48e3, height: 0, width: 0, videoBitrate: 400, videoFramerate: 15, videoGop: 30 };
      let ek, tk, rk, ik, nk, ok, sk, ak, ck, dk, uk, Ak, hk, lk, pk, gk, fk, Ek;
      function Ik(e2) {
        if (!e2.channelName)
          throw new tD(eD.INVALID_PARAMS, "invalid channelName in info");
        if (!e2.uid || typeof e2.uid != "number")
          throw new tD(eD.INVALID_PARAMS, "invalid uid in info, uid must be a number");
        return e2.token && $L(e2.token, "info.token", 1, 2047), rP(e2.uid), tP(e2.channelName), true;
      }
      function mk(e2) {
        return XL(e2, "mediaSource", ["screen", "window", "application"]), true;
      }
      !function(e2) {
        e2.WARNING = "@live_uap-warning", e2.ERROR = "@line_uap-error", e2.PUBLISH_STREAM_STATUS = "@live_uap-publish-status", e2.INJECT_STREAM_STATUS = "@live_uap-inject-status", e2.WORKER_STATUS = "@live_uap-worker-status", e2.REQUEST_NEW_ADDRESS = "@live_uap-request-address";
      }(ek || (ek = {})), function(e2) {
        e2.REQUEST_WORKER_MANAGER_LIST = "@live_req_worker_manager";
      }(tk || (tk = {})), function(e2) {
        e2[e2.LIVE_STREAM_RESPONSE_SUCCEED = 200] = "LIVE_STREAM_RESPONSE_SUCCEED", e2[e2.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM = 454] = "LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM", e2[e2.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR = 450] = "LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR", e2[e2.LIVE_STREAM_RESPONSE_BAD_STREAM = 451] = "LIVE_STREAM_RESPONSE_BAD_STREAM", e2[e2.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR = 400] = "LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR", e2[e2.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST = 404] = "LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST", e2[e2.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED = 456] = "LIVE_STREAM_RESPONSE_NOT_AUTHORIZED", e2[e2.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE = 457] = "LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE", e2[e2.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN = 429] = "LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN", e2[e2.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH = 452] = "LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH", e2[e2.LIVE_STREAM_RESPONSE_NOT_SUPPORTED = 453] = "LIVE_STREAM_RESPONSE_NOT_SUPPORTED", e2[e2.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM = 455] = "LIVE_STREAM_RESPONSE_MAX_STREAM_NUM", e2[e2.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR = 500] = "LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR", e2[e2.LIVE_STREAM_RESPONSE_WORKER_LOST = 501] = "LIVE_STREAM_RESPONSE_WORKER_LOST", e2[e2.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT = 502] = "LIVE_STREAM_RESPONSE_RESOURCE_LIMIT", e2[e2.LIVE_STREAM_RESPONSE_WORKER_QUIT = 503] = "LIVE_STREAM_RESPONSE_WORKER_QUIT", e2[e2.ERROR_FAIL_SEND_MESSAGE = 504] = "ERROR_FAIL_SEND_MESSAGE", e2[e2.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE = 30] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE", e2[e2.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT = 31] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT", e2[e2.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH = 32] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH", e2[e2.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN = 33] = "PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN";
      }(rk || (rk = {})), function(e2) {
        e2.CONNECT_FAILED = "connect failed", e2.CONNECT_TIMEOUT = "connect timeout", e2.WS_DISCONNECTED = "websocket disconnected", e2.REQUEST_TIMEOUT = "request timeout", e2.REQUEST_FAILED = "request failed", e2.WAIT_STATUS_TIMEOUT = "wait status timeout", e2.WAIT_STATUS_ERROR = "wait status error", e2.BAD_STATE = "bad state", e2.WS_ABORT = "ws abort", e2.AP_REQUEST_TIMEOUT = "AP request timeout", e2.AP_JSON_PARSE_ERROR = "AP json parse error", e2.AP_REQUEST_ERROR = "AP request error", e2.AP_REQUEST_ABORT = "AP request abort";
      }(ik || (ik = {})), function(e2) {
        e2[e2.SetSdkProfile = 0] = "SetSdkProfile", e2[e2.SetSourceChannel = 1] = "SetSourceChannel", e2[e2.SetSourceUserId = 2] = "SetSourceUserId", e2[e2.SetDestChannel = 3] = "SetDestChannel", e2[e2.StartPacketTransfer = 4] = "StartPacketTransfer", e2[e2.StopPacketTransfer = 5] = "StopPacketTransfer", e2[e2.UpdateDestChannel = 6] = "UpdateDestChannel", e2[e2.Reconnect = 7] = "Reconnect", e2[e2.SetVideoProfile = 8] = "SetVideoProfile";
      }(nk || (nk = {})), function(e2) {
        e2.NETWORK_DISCONNECTED = "NETWORK_DISCONNECTED", e2.NETWORK_CONNECTED = "NETWORK_CONNECTED", e2.PACKET_JOINED_SRC_CHANNEL = "PACKET_JOINED_SRC_CHANNEL", e2.PACKET_JOINED_DEST_CHANNEL = "PACKET_JOINED_DEST_CHANNEL", e2.PACKET_SENT_TO_DEST_CHANNEL = "PACKET_SENT_TO_DEST_CHANNEL", e2.PACKET_RECEIVED_VIDEO_FROM_SRC = "PACKET_RECEIVED_VIDEO_FROM_SRC", e2.PACKET_RECEIVED_AUDIO_FROM_SRC = "PACKET_RECEIVED_AUDIO_FROM_SRC", e2.PACKET_UPDATE_DEST_CHANNEL = "PACKET_UPDATE_DEST_CHANNEL", e2.PACKET_UPDATE_DEST_CHANNEL_REFUSED = "PACKET_UPDATE_DEST_CHANNEL_REFUSED", e2.PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE = "PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE";
      }(ok || (ok = {})), function(e2) {
        e2.RELAY_STATE_IDLE = "RELAY_STATE_IDLE", e2.RELAY_STATE_CONNECTING = "RELAY_STATE_CONNECTING", e2.RELAY_STATE_RUNNING = "RELAY_STATE_RUNNING", e2.RELAY_STATE_FAILURE = "RELAY_STATE_FAILURE";
      }(sk || (sk = {})), function(e2) {
        e2.RELAY_OK = "RELAY_OK", e2.SERVER_CONNECTION_LOST = "SERVER_CONNECTION_LOST", e2.SRC_TOKEN_EXPIRED = "SRC_TOKEN_EXPIRED", e2.DEST_TOKEN_EXPIRED = "DEST_TOKEN_EXPIRED";
      }(ak || (ak = {})), function(e2) {
        e2.High = "high", e2.Low = "low", e2.Audio = "audio", e2.Screen = "screen", e2.ScreenLow = "screen_low";
      }(ck || (ck = {})), function(e2) {
        e2.DISCONNECT = "disconnect", e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.NETWORK_QUALITY = "network-quality", e2.STREAM_TYPE_CHANGE = "stream-type-change", e2.IS_P2P_DISCONNECTED = "is-p2p-dis", e2.DISCONNECT_P2P = "dis-p2p", e2.REQUEST_NEW_GATEWAY_LIST = "req-gate-url", e2.NEED_RENEW_SESSION = "need-sid", e2.REQUEST_P2P_CONNECTION_PARAMS = "request-p2p-connection-params", e2.JOIN_RESPONSE = "join-response";
      }(dk || (dk = {})), function(e2) {
        e2[e2.Nothing = 0] = "Nothing", e2[e2.Audio = 1] = "Audio", e2[e2.LwoVideo = 2] = "LwoVideo", e2[e2.Video = 4] = "Video", e2[e2.Data = 8] = "Data";
      }(uk || (uk = {})), function(e2) {
        e2.NEED_RENEGOTIATE = "@need_renegotiate", e2.NEED_REPLACE_TRACK = "@need_replace_track", e2.NEED_CLOSE = "@need_close", e2.NEED_ENABLE_TRACK = "@need_enable_track", e2.NEED_DISABLE_TRACK = "@need_disable_track", e2.NEED_SESSION_ID = "@need_sid", e2.SET_OPTIMIZATION_MODE = "@set_optimization_mode", e2.GET_STATS = "@get_stats", e2.GET_LOW_VIDEO_TRACK = "@get_low_video_track", e2.NEED_RESET_REMOTE_SDP = "@need_reset_remote_sdp", e2.NEED_UPDATE_VIDEO_ENCODER = "@need_update_video_encoder", e2.NEED_MUTE_TRACK = "@need_mute_track", e2.NEED_UNMUTE_TRACK = "@need_unmute_track";
      }(Ak || (Ak = {})), function(e2) {
        e2.SCREEN_TRACK = "screen_track", e2.LOW_STREAM = "low_stream";
      }(hk || (hk = {})), function(e2) {
        e2[e2.HIGH_STREAM = 0] = "HIGH_STREAM", e2[e2.LOW_STREAM = 1] = "LOW_STREAM";
      }(lk || (lk = {})), function(e2) {
        e2[e2.DISABLE = 0] = "DISABLE", e2[e2.LOW_STREAM = 1] = "LOW_STREAM", e2[e2.AUDIO_ONLY = 2] = "AUDIO_ONLY";
      }(pk || (pk = {})), function(e2) {
        e2.SOURCE_STATE_CHANGE = "source-state-change", e2.TRACK_ENDED = "track-ended", e2.BEAUTY_EFFECT_OVERLOAD = "beauty-effect-overload", e2.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status", e2.CLOSED = "closed";
      }(gk || (gk = {})), function(e2) {
        e2.FIRST_FRAME_DECODED = "first-frame-decoded", e2.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status";
      }(fk || (fk = {})), function(e2) {
        e2.CHINA = "CHINA", e2.ASIA = "ASIA", e2.NORTH_AMERICA = "NORTH_AMERICA", e2.EUROPE = "EUROPE", e2.JAPAN = "JAPAN", e2.INDIA = "INDIA", e2.KOREA = "KOREA", e2.HKMC = "HKMC", e2.US = "US", e2.OCEANIA = "OCEANIA", e2.SOUTH_AMERICA = "SOUTH_AMERICA", e2.AFRICA = "AFRICA", e2.OVERSEA = "OVERSEA", e2.GLOBAL = "GLOBAL";
      }(Ek || (Ek = {}));
      const _k = [Ek.AFRICA, Ek.ASIA, Ek.CHINA, Ek.EUROPE, Ek.GLOBAL, Ek.INDIA, Ek.JAPAN, Ek.NORTH_AMERICA, Ek.OCEANIA, Ek.OVERSEA, Ek.SOUTH_AMERICA];
      let Ck;
      !function(e2) {
        e2.CHINA = "CN", e2.ASIA = "AS", e2.NORTH_AMERICA = "NA", e2.EUROPE = "EU", e2.JAPAN = "JP", e2.INDIA = "IN", e2.KOREA = "KR", e2.HKMC = "HK", e2.US = "US", e2.OCEANIA = "OC", e2.SOUTH_AMERICA = "SA", e2.AFRICA = "AF", e2.OVERSEA = "OVERSEA", e2.GLOBAL = "GLOBAL";
      }(Ck || (Ck = {}));
      const vk = { CHINA: {}, ASIA: { CODE: Ck.ASIA, WEBCS_DOMAIN: ["ap-web-1-asia.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-asia.agora.io"], PROXY_CS: ["proxy-ap-web-asia.agora.io"], CDS_AP: ["cds-ap-web-asia.agora.io", "cds-ap-web-asia2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-asia.agora.io", "sua-ap-web-asia2.agora.io"], UAP_AP: ["uap-ap-web-asia.agora.io", "uap-ap-web-asia2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-asia.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-asia.agora.io"], LOG_UPLOAD_SERVER: ["logservice-asia.agora.io"], PROXY_SERVER_TYPE3: ["southeast-asia.webrtc-cloud-proxy.sd-rtn.com"] }, NORTH_AMERICA: { CODE: Ck.NORTH_AMERICA, WEBCS_DOMAIN: ["ap-web-1-north-america.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-north-america.agora.io"], PROXY_CS: ["proxy-ap-web-america.agora.io"], CDS_AP: ["cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"], UAP_AP: ["uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-north-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-north-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-north-america.agora.io"], PROXY_SERVER_TYPE3: ["east-usa.webrtc-cloud-proxy.sd-rtn.com"] }, EUROPE: { CODE: Ck.EUROPE, WEBCS_DOMAIN: ["ap-web-1-europe.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-europe.agora.io"], PROXY_CS: ["proxy-ap-web-europe.agora.io"], CDS_AP: ["cds-ap-web-europe.agora.io", "cds-ap-web-europe2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-europe.agora.io", "sua-ap-web-europe.agora.io"], UAP_AP: ["uap-ap-web-europe.agora.io", "uap-ap-web-europe2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-europe.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-europe.agora.io"], LOG_UPLOAD_SERVER: ["logservice-europe.agora.io"], PROXY_SERVER_TYPE3: ["europe.webrtc-cloud-proxy.sd-rtn.com"] }, JAPAN: { CODE: Ck.JAPAN, WEBCS_DOMAIN: ["ap-web-1-japan.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-japan.agora.io"], PROXY_CS: ["proxy-ap-web-japan.agora.io"], CDS_AP: ["cds-ap-web-japan.agora.io", "cds-ap-web-japan2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-japan.agora.io", "sua-ap-web-japan2.agora.io"], UAP_AP: ["uap-ap-web-japan.agora.io", "	uap-ap-web-japan2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-japan.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-japan.agora.io"], LOG_UPLOAD_SERVER: ["logservice-japan.agora.io"], PROXY_SERVER_TYPE3: ["japan.webrtc-cloud-proxy.sd-rtn.com"] }, INDIA: { CODE: Ck.INDIA, WEBCS_DOMAIN: ["ap-web-1-india.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-india.agora.io"], PROXY_CS: ["proxy-ap-web-india.agora.io"], CDS_AP: ["cds-ap-web-india.agora.io", "cds-ap-web-india2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-india.agora.io", "sua-ap-web-india2.agora.io"], UAP_AP: ["uap-ap-web-india.agora.io", "uap-ap-web-india2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-india.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-india.agora.io"], LOG_UPLOAD_SERVER: ["logservice-india.agora.io"], PROXY_SERVER_TYPE3: ["india.webrtc-cloud-proxy.sd-rtn.com"] }, KOREA: { CODE: Ck.KOREA, WEBCS_DOMAIN: ["ap-web-1-korea.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-korea.agora.io"], PROXY_CS: ["proxy-ap-web-korea.agora.io"], CDS_AP: ["cds-ap-web-korea.agora.io", "cds-ap-web-korea2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-korea.agora.io", "sua-ap-web-korea2.agora.io"], UAP_AP: ["uap-ap-web-korea.agora.io", "uap-ap-web-korea2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-korea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-korea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-korea.agora.io"], PROXY_SERVER_TYPE3: ["korea.webrtc-cloud-proxy.sd-rtn.com"] }, HKMC: { CODE: Ck.HKMC, WEBCS_DOMAIN: ["ap-web-1-hkmc.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-hkmc.agora.io"], PROXY_CS: ["proxy-ap-web-hkmc.agora.io"], CDS_AP: ["cds-ap-web-hkmc.agora.io", "cds-ap-web-hkmc2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-hkmc.agora.io", "sua-ap-web-hkmc2.agora.io"], UAP_AP: ["uap-ap-web-hkmc.agora.io", "uap-ap-web-hkmc2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-hkmc.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-hkmc.agora.io"], LOG_UPLOAD_SERVER: ["logservice-hkmc.agora.io"], PROXY_SERVER_TYPE3: ["hkmc.webrtc-cloud-proxy.sd-rtn.com"] }, US: { CODE: Ck.US, WEBCS_DOMAIN: ["ap-web-1-us.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-us.agora.io"], PROXY_CS: ["proxy-ap-web-us.agora.io"], CDS_AP: ["cds-ap-web-us.agora.io", "cds-ap-web-us2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-us.agora.io", "sua-ap-web-us2.agora.io"], UAP_AP: ["uap-ap-web-us.agora.io", "uap-ap-web-us2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-us.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-us.agora.io"], LOG_UPLOAD_SERVER: ["logservice-us.agora.io"], PROXY_SERVER_TYPE3: ["us.webrtc-cloud-proxy.sd-rtn.com"] }, OVERSEA: { CODE: Ck.OVERSEA, WEBCS_DOMAIN: ["ap-web-1-oversea.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oversea.agora.io"], PROXY_CS: ["proxy-ap-web-oversea.agora.io"], CDS_AP: ["cds-ap-web-oversea.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-oversea.agora.io"], UAP_AP: ["uap-ap-web-oversea.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oversea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oversea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oversea.agora.io"], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.agora.io"] }, GLOBAL: { CODE: Ck.GLOBAL, WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io"], PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], CDS_AP: ["cds-ap-web-1.agora.io", "cds-ap-web-3.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-ap-web-3.agora.io"], UAP_AP: ["uap-ap-web-1.agora.io", "uap-ap-web-3.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2.agora.io"], LOG_UPLOAD_SERVER: ["logservice.agora.io"], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com"] }, OCEANIA: { CODE: Ck.OCEANIA, WEBCS_DOMAIN: ["ap-web-1-oceania.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oceania.agora.io"], PROXY_CS: ["proxy-ap-web-oceania.agora.io"], CDS_AP: ["cds-ap-web-oceania.agora.io", "cds-ap-web-oceania2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-oceania.agora.io", "sua-ap-web-oceania2.agora.io"], UAP_AP: ["uap-ap-web-oceania.agora.io", "uap-ap-web-oceania2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oceania.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oceania.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oceania.agora.io"], PROXY_SERVER_TYPE3: ["oceania.webrtc-cloud-proxy.sd-rtn.com"] }, SOUTH_AMERICA: { CODE: Ck.SOUTH_AMERICA, WEBCS_DOMAIN: ["ap-web-1-south-america.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-south-america.agora.io"], PROXY_CS: ["proxy-ap-web-south-america.agora.io"], CDS_AP: ["cds-ap-web-south-america.agora.io", "cds-ap-web-south-america2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-south-america.agora.io", "sua-ap-web-south-america2.agora.io"], UAP_AP: ["uap-ap-web-south-america.agora.io", "uap-ap-web-south-america2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-south-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-south-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-america.agora.io"], PROXY_SERVER_TYPE3: ["south-america.webrtc-cloud-proxy.sd-rtn.com"] }, AFRICA: { CODE: Ck.AFRICA, WEBCS_DOMAIN: ["ap-web-1-africa.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-africa.agora.io"], PROXY_CS: ["proxy-ap-web-africa.agora.io"], CDS_AP: ["cds-ap-web-africa.agora.io", "cds-ap-web-africa2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-africa.agora.io", "sua-ap-web-africa2.agora.io"], UAP_AP: ["uap-ap-web-africa.agora.io", "uap-ap-web-africa2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-africa.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-africa.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-africa.agora.io"], PROXY_SERVER_TYPE3: ["africa.webrtc-cloud-proxy.sd-rtn.com"] } };
      let Sk, Rk, yk, Tk, wk, bk, Ok, Nk;
      UD && (vk.CHINA = { CODE: Ck.CHINA, WEBCS_DOMAIN: ["webrtc2-2.ap.sd-rtn.com"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-4.ap.sd-rtn.com"], PROXY_CS: ["proxy-web.ap.sd-rtn.com"], CDS_AP: ["cds-web-2.ap.sd-rtn.com", "cds-web-4.ap.sd-rtn.com"], ACCOUNT_REGISTER: ["sua-web-2.ap.sd-rtn.com", "sua-web-4.ap.sd-rtn.com"], UAP_AP: ["uap-web-2.ap.sd-rtn.com", "uap-web-4.ap.sd-rtn.com"], EVENT_REPORT_DOMAIN: ["web-3.statscollector.sd-rtn.com"], EVENT_REPORT_BACKUP_DOMAIN: ["web-4.statscollector.sd-rtn.com"], LOG_UPLOAD_SERVER: ["logservice-china.agora.io"], PROXY_SERVER_TYPE3: ["east-cn.webrtc-cloud-proxy.sd-rtn.com"] }), function(e2) {
        e2.UPDATE_BITRATE_LIMIT = "update_bitrate_limit";
      }(Sk || (Sk = {}));
      class Dk extends ZN {
        constructor(e2, t2) {
          super(), kO(this, "onICEConnectionStateChange", void 0), kO(this, "onConnectionStateChange", void 0), kO(this, "onDTLSTransportStateChange", void 0), kO(this, "onDTLSTransportError", void 0), kO(this, "onICETransportStateChange", void 0), kO(this, "onFirstAudioReceived", void 0), kO(this, "onFirstVideoReceived", void 0), kO(this, "onFirstAudioDecoded", void 0), kO(this, "onFirstVideoDecoded", void 0), kO(this, "onSelectedLocalCandidateChanged", void 0), kO(this, "onSelectedRemoteCandidateChanged", void 0);
        }
      }
      !function(e2) {
        e2.SEND = "sendonly", e2.RECV = "recvonly", e2.SENDRECV = "sendrecv", e2.INACTIVE = "inactive";
      }(Rk || (Rk = {})), function(e2) {
        e2.VIDEO = "video", e2.AUDIO = "audio";
      }(yk || (yk = {})), function(e2) {
        e2.LocalVideoTrack = "videoTrack", e2.LocalAudioTrack = "audioTrack", e2.LocalVideoLowTrack = "videoLowTrack";
      }(Tk || (Tk = {})), function(e2) {
        e2.New = "new", e2.Connected = "connected", e2.Reconnecting = "reconnecting", e2.Disconnected = "disconnected";
      }(wk || (wk = {})), function(e2) {
        e2.StateChange = "stateChange", e2.IceConnectionStateChange = "iceConnectionStateChange", e2.RequestMuteLocal = "requestMuteLocal", e2.RequestUnmuteLocal = "requestUnmuteLocal", e2.RequestRePublish = "requestRePublish", e2.RequestReSubscribe = "requestReSubscribe", e2.RequestUploadStats = "requestUploadStats", e2.MediaReconnectStart = "MediaReconnectStart", e2.MediaReconnectEnd = "MediaReconnectEnd", e2.NeedSignalRTT = "NeedSignalRTT", e2.RequestRestartICE = "RequestRestartIce", e2.PeerConnectionStateChange = "PeerConnectionStateChange", e2.RequestReconnect = "RequestReconnect", e2.RequestReconnectPC = "RequestReconnectPC", e2.RequestUnpublishForReconnectPC = "RequestUnpublishForReconnectPC", e2.P2PLost = "P2PLost", e2.UpdateVideoEncoder = "UpdateVideoEncoder", e2.ConnectionTypeChange = "ConnectionTypeChange";
      }(bk || (bk = {})), function(e2) {
        e2.ONLINE = "ONLINE", e2.OFFLINE = "OFFLINE";
      }(Ok || (Ok = {})), function(e2) {
        e2.NETWORK_STATE_CHANGE = "NETWORK_STATE_CHANGE", e2.ONLINE = "ONLINE", e2.OFFLINE = "OFFLINE";
      }(Nk || (Nk = {}));
      const Lk = { join: ["startJoin", "startRequestAp", "startJoinGateway", "finishJoin"], publish: ["startPublish"] };
      let Pk, kk;
      !function(e2) {
        e2.ON_TRACK = "on_track", e2.ON_NODE = "on_node";
      }(Pk || (Pk = {})), function(e2) {
        e2.REQUEST_UPDATE_CONSTRAINTS = "request_update_constraints", e2.REQUEST_CONSTRAINTS = "request_constraints";
      }(kk || (kk = {}));
      const Bk = { getDisplayMedia: false, getStreamFromExtension: false, supportUnifiedPlan: false, supportMinBitrate: false, supportSetRtpSenderParameters: false, supportDualStream: true, webAudioMediaStreamDest: false, supportReplaceTrack: false, supportWebGL: false, webAudioWithAEC: false, supportRequestFrame: false, supportShareAudio: false, supportDualStreamEncoding: false };
      function Mk() {
        return Bk;
      }
      var Uk = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined", Qk = Hr, xk = Zr, Fk = r.RangeError, Vk = function(e2) {
        if (e2 === void 0)
          return 0;
        var t2 = Qk(e2), r2 = xk(t2);
        if (t2 !== r2)
          throw Fk("Wrong length or index");
        return r2;
      }, jk = r.Array, Gk = Math.abs, Kk = Math.pow, Hk = Math.floor, Yk = Math.log, Wk = Math.LN2, Jk = { pack: function(e2, t2, r2) {
        var i2, n2, o2, s2 = jk(r2), a2 = 8 * r2 - t2 - 1, c2 = (1 << a2) - 1, d2 = c2 >> 1, u2 = t2 === 23 ? Kk(2, -24) - Kk(2, -77) : 0, A2 = e2 < 0 || e2 === 0 && 1 / e2 < 0 ? 1 : 0, h2 = 0;
        for ((e2 = Gk(e2)) != e2 || e2 === 1 / 0 ? (n2 = e2 != e2 ? 1 : 0, i2 = c2) : (i2 = Hk(Yk(e2) / Wk), e2 * (o2 = Kk(2, -i2)) < 1 && (i2--, o2 *= 2), (e2 += i2 + d2 >= 1 ? u2 / o2 : u2 * Kk(2, 1 - d2)) * o2 >= 2 && (i2++, o2 /= 2), i2 + d2 >= c2 ? (n2 = 0, i2 = c2) : i2 + d2 >= 1 ? (n2 = (e2 * o2 - 1) * Kk(2, t2), i2 += d2) : (n2 = e2 * Kk(2, d2 - 1) * Kk(2, t2), i2 = 0)); t2 >= 8; )
          s2[h2++] = 255 & n2, n2 /= 256, t2 -= 8;
        for (i2 = i2 << t2 | n2, a2 += t2; a2 > 0; )
          s2[h2++] = 255 & i2, i2 /= 256, a2 -= 8;
        return s2[--h2] |= 128 * A2, s2;
      }, unpack: function(e2, t2) {
        var r2, i2 = e2.length, n2 = 8 * i2 - t2 - 1, o2 = (1 << n2) - 1, s2 = o2 >> 1, a2 = n2 - 7, c2 = i2 - 1, d2 = e2[c2--], u2 = 127 & d2;
        for (d2 >>= 7; a2 > 0; )
          u2 = 256 * u2 + e2[c2--], a2 -= 8;
        for (r2 = u2 & (1 << -a2) - 1, u2 >>= -a2, a2 += t2; a2 > 0; )
          r2 = 256 * r2 + e2[c2--], a2 -= 8;
        if (u2 === 0)
          u2 = 1 - s2;
        else {
          if (u2 === o2)
            return r2 ? NaN : d2 ? -1 / 0 : 1 / 0;
          r2 += Kk(2, t2), u2 -= s2;
        }
        return (d2 ? -1 : 1) * r2 * Kk(2, u2 - t2);
      } }, qk = Le, zk = qr, Xk = ei, Zk = ct, $k = Rt, eB = f, tB = qr, rB = ei, iB = function(e2, t2, r2) {
        var i2 = Zk(t2);
        i2 in e2 ? $k.f(e2, i2, eB(0, r2)) : e2[i2] = r2;
      }, nB = r.Array, oB = Math.max, sB = function(e2, t2, r2) {
        for (var i2 = rB(e2), n2 = tB(t2, i2), o2 = tB(r2 === void 0 ? i2 : r2, i2), s2 = nB(oB(o2 - n2, 0)), a2 = 0; n2 < o2; n2++, a2++)
          iB(s2, a2, e2[n2]);
        return s2.length = a2, s2;
      }, aB = r, cB = v, dB = o, uB = Uk, AB = Dr, hB = Kt, lB = Yi, pB = n, gB = ln, fB = Hr, EB = Zr, IB = Vk, mB = Jk, _B = Hl, CB = en, vB = jr.f, SB = Rt.f, RB = function(e2) {
        for (var t2 = qk(this), r2 = Xk(t2), i2 = arguments.length, n2 = zk(i2 > 1 ? arguments[1] : void 0, r2), o2 = i2 > 2 ? arguments[2] : void 0, s2 = o2 === void 0 ? r2 : zk(o2, r2); s2 > n2; )
          t2[n2++] = e2;
        return t2;
      }, yB = sB, TB = on, wB = AB.PROPER, bB = AB.CONFIGURABLE, OB = yr.get, NB = yr.set, DB = "ArrayBuffer", LB = "DataView", PB = "Wrong index", kB = aB.ArrayBuffer, BB = kB, MB = BB && BB.prototype, UB = aB.DataView, QB = UB && UB.prototype, xB = Object.prototype, FB = aB.Array, VB = aB.RangeError, jB = cB(RB), GB = cB([].reverse), KB = mB.pack, HB = mB.unpack, YB = function(e2) {
        return [255 & e2];
      }, WB = function(e2) {
        return [255 & e2, e2 >> 8 & 255];
      }, JB = function(e2) {
        return [255 & e2, e2 >> 8 & 255, e2 >> 16 & 255, e2 >> 24 & 255];
      }, qB = function(e2) {
        return e2[3] << 24 | e2[2] << 16 | e2[1] << 8 | e2[0];
      }, zB = function(e2) {
        return KB(e2, 23, 4);
      }, XB = function(e2) {
        return KB(e2, 52, 8);
      }, ZB = function(e2, t2) {
        SB(e2.prototype, t2, { get: function() {
          return OB(this)[t2];
        } });
      }, $B = function(e2, t2, r2, i2) {
        var n2 = IB(r2), o2 = OB(e2);
        if (n2 + t2 > o2.byteLength)
          throw VB(PB);
        var s2 = OB(o2.buffer).bytes, a2 = n2 + o2.byteOffset, c2 = yB(s2, a2, a2 + t2);
        return i2 ? c2 : GB(c2);
      }, eM = function(e2, t2, r2, i2, n2, o2) {
        var s2 = IB(r2), a2 = OB(e2);
        if (s2 + t2 > a2.byteLength)
          throw VB(PB);
        for (var c2 = OB(a2.buffer).bytes, d2 = s2 + a2.byteOffset, u2 = i2(+n2), A2 = 0; A2 < t2; A2++)
          c2[d2 + A2] = u2[o2 ? A2 : t2 - A2 - 1];
      };
      if (uB) {
        var tM = wB && kB.name !== DB;
        if (pB(function() {
          kB(1);
        }) && pB(function() {
          new kB(-1);
        }) && !pB(function() {
          return new kB(), new kB(1.5), new kB(NaN), tM && !bB;
        }))
          tM && bB && hB(kB, "name", DB);
        else {
          (BB = function(e2) {
            return gB(this, MB), new kB(IB(e2));
          }).prototype = MB;
          for (var rM, iM = vB(kB), nM = 0; iM.length > nM; )
            (rM = iM[nM++]) in BB || hB(BB, rM, kB[rM]);
          MB.constructor = BB;
        }
        CB && _B(QB) !== xB && CB(QB, xB);
        var oM = new UB(new BB(2)), sM = cB(QB.setInt8);
        oM.setInt8(0, 2147483648), oM.setInt8(1, 2147483649), !oM.getInt8(0) && oM.getInt8(1) || lB(QB, { setInt8: function(e2, t2) {
          sM(this, e2, t2 << 24 >> 24);
        }, setUint8: function(e2, t2) {
          sM(this, e2, t2 << 24 >> 24);
        } }, { unsafe: true });
      } else
        MB = (BB = function(e2) {
          gB(this, MB);
          var t2 = IB(e2);
          NB(this, { bytes: jB(FB(t2), 0), byteLength: t2 }), dB || (this.byteLength = t2);
        }).prototype, QB = (UB = function(e2, t2, r2) {
          gB(this, QB), gB(e2, MB);
          var i2 = OB(e2).byteLength, n2 = fB(t2);
          if (n2 < 0 || n2 > i2)
            throw VB("Wrong offset");
          if (n2 + (r2 = r2 === void 0 ? i2 - n2 : EB(r2)) > i2)
            throw VB("Wrong length");
          NB(this, { buffer: e2, byteLength: r2, byteOffset: n2 }), dB || (this.buffer = e2, this.byteLength = r2, this.byteOffset = n2);
        }).prototype, dB && (ZB(BB, "byteLength"), ZB(UB, "buffer"), ZB(UB, "byteLength"), ZB(UB, "byteOffset")), lB(QB, { getInt8: function(e2) {
          return $B(this, 1, e2)[0] << 24 >> 24;
        }, getUint8: function(e2) {
          return $B(this, 1, e2)[0];
        }, getInt16: function(e2) {
          var t2 = $B(this, 2, e2, arguments.length > 1 ? arguments[1] : void 0);
          return (t2[1] << 8 | t2[0]) << 16 >> 16;
        }, getUint16: function(e2) {
          var t2 = $B(this, 2, e2, arguments.length > 1 ? arguments[1] : void 0);
          return t2[1] << 8 | t2[0];
        }, getInt32: function(e2) {
          return qB($B(this, 4, e2, arguments.length > 1 ? arguments[1] : void 0));
        }, getUint32: function(e2) {
          return qB($B(this, 4, e2, arguments.length > 1 ? arguments[1] : void 0)) >>> 0;
        }, getFloat32: function(e2) {
          return HB($B(this, 4, e2, arguments.length > 1 ? arguments[1] : void 0), 23);
        }, getFloat64: function(e2) {
          return HB($B(this, 8, e2, arguments.length > 1 ? arguments[1] : void 0), 52);
        }, setInt8: function(e2, t2) {
          eM(this, 1, e2, YB, t2);
        }, setUint8: function(e2, t2) {
          eM(this, 1, e2, YB, t2);
        }, setInt16: function(e2, t2) {
          eM(this, 2, e2, WB, t2, arguments.length > 2 ? arguments[2] : void 0);
        }, setUint16: function(e2, t2) {
          eM(this, 2, e2, WB, t2, arguments.length > 2 ? arguments[2] : void 0);
        }, setInt32: function(e2, t2) {
          eM(this, 4, e2, JB, t2, arguments.length > 2 ? arguments[2] : void 0);
        }, setUint32: function(e2, t2) {
          eM(this, 4, e2, JB, t2, arguments.length > 2 ? arguments[2] : void 0);
        }, setFloat32: function(e2, t2) {
          eM(this, 4, e2, zB, t2, arguments.length > 2 ? arguments[2] : void 0);
        }, setFloat64: function(e2, t2) {
          eM(this, 8, e2, XB, t2, arguments.length > 2 ? arguments[2] : void 0);
        } });
      TB(BB, DB), TB(UB, LB);
      var aM = { ArrayBuffer: BB, DataView: UB }, cM = Gi, dM = v, uM = n, AM = Nt, hM = qr, lM = Zr, pM = Uo, gM = aM.ArrayBuffer, fM = aM.DataView, EM = fM.prototype, IM = dM(gM.prototype.slice), mM = dM(EM.getUint8), _M = dM(EM.setUint8);
      cM({ target: "ArrayBuffer", proto: true, unsafe: true, forced: uM(function() {
        return !new gM(2).slice(1, void 0).byteLength;
      }) }, { slice: function(e2, t2) {
        if (IM && t2 === void 0)
          return IM(AM(this), e2);
        for (var r2 = AM(this).byteLength, i2 = hM(e2, r2), n2 = hM(t2 === void 0 ? r2 : t2, r2), o2 = new (pM(this, gM))(lM(n2 - i2)), s2 = new fM(this), a2 = new fM(o2), c2 = 0; i2 < n2; )
          _M(a2, c2++, mM(s2, i2++));
        return o2;
      } });
      var CM, vM, SM, RM = { exports: {} }, yM = Uk, TM = o, wM = r, bM = Q, OM = F, NM = Be, DM = Dn, LM = Ae, PM = Kt, kM = Ht.exports, BM = Rt.f, MM = H, UM = Hl, QM = en, xM = Xe, FM = Fe, VM = wM.Int8Array, jM = VM && VM.prototype, GM = wM.Uint8ClampedArray, KM = GM && GM.prototype, HM = VM && UM(VM), YM = jM && UM(jM), WM = Object.prototype, JM = wM.TypeError, qM = xM("toStringTag"), zM = FM("TYPED_ARRAY_TAG"), XM = FM("TYPED_ARRAY_CONSTRUCTOR"), ZM = yM && !!QM && DM(wM.opera) !== "Opera", $M = false, eU = { Int8Array: 1, Uint8Array: 1, Uint8ClampedArray: 1, Int16Array: 2, Uint16Array: 2, Int32Array: 4, Uint32Array: 4, Float32Array: 4, Float64Array: 8 }, tU = { BigInt64Array: 8, BigUint64Array: 8 }, rU = function(e2) {
        if (!OM(e2))
          return false;
        var t2 = DM(e2);
        return NM(eU, t2) || NM(tU, t2);
      };
      for (CM in eU)
        (SM = (vM = wM[CM]) && vM.prototype) ? PM(SM, XM, vM) : ZM = false;
      for (CM in tU)
        (SM = (vM = wM[CM]) && vM.prototype) && PM(SM, XM, vM);
      if ((!ZM || !bM(HM) || HM === Function.prototype) && (HM = function() {
        throw JM("Incorrect invocation");
      }, ZM))
        for (CM in eU)
          wM[CM] && QM(wM[CM], HM);
      if ((!ZM || !YM || YM === WM) && (YM = HM.prototype, ZM))
        for (CM in eU)
          wM[CM] && QM(wM[CM].prototype, YM);
      if (ZM && UM(KM) !== YM && QM(KM, YM), TM && !NM(YM, qM))
        for (CM in $M = true, BM(YM, qM, { get: function() {
          return OM(this) ? this[zM] : void 0;
        } }), eU)
          wM[CM] && PM(wM[CM], zM, CM);
      var iU = { NATIVE_ARRAY_BUFFER_VIEWS: ZM, TYPED_ARRAY_CONSTRUCTOR: XM, TYPED_ARRAY_TAG: $M && zM, aTypedArray: function(e2) {
        if (rU(e2))
          return e2;
        throw JM("Target is not a typed array");
      }, aTypedArrayConstructor: function(e2) {
        if (bM(e2) && (!QM || MM(HM, e2)))
          return e2;
        throw JM(LM(e2) + " is not a typed array constructor");
      }, exportTypedArrayMethod: function(e2, t2, r2, i2) {
        if (TM) {
          if (r2)
            for (var n2 in eU) {
              var o2 = wM[n2];
              if (o2 && NM(o2.prototype, e2))
                try {
                  delete o2.prototype[e2];
                } catch (r3) {
                  try {
                    o2.prototype[e2] = t2;
                  } catch (e3) {
                  }
                }
            }
          YM[e2] && !r2 || kM(YM, e2, r2 ? t2 : ZM && jM[e2] || t2, i2);
        }
      }, exportTypedArrayStaticMethod: function(e2, t2, r2) {
        var i2, n2;
        if (TM) {
          if (QM) {
            if (r2) {
              for (i2 in eU)
                if ((n2 = wM[i2]) && NM(n2, e2))
                  try {
                    delete n2[e2];
                  } catch (e3) {
                  }
            }
            if (HM[e2] && !r2)
              return;
            try {
              return kM(HM, e2, r2 ? t2 : ZM && HM[e2] || t2);
            } catch (e3) {
            }
          }
          for (i2 in eU)
            !(n2 = wM[i2]) || n2[e2] && !r2 || kM(n2, e2, t2);
        }
      }, isView: function(e2) {
        if (!OM(e2))
          return false;
        var t2 = DM(e2);
        return t2 === "DataView" || NM(eU, t2) || NM(tU, t2);
      }, isTypedArray: rU, TypedArray: HM, TypedArrayPrototype: YM }, nU = r, oU = n, sU = Ao, aU = iU.NATIVE_ARRAY_BUFFER_VIEWS, cU = nU.ArrayBuffer, dU = nU.Int8Array, uU = !aU || !oU(function() {
        dU(1);
      }) || !oU(function() {
        new dU(-1);
      }) || !sU(function(e2) {
        new dU(), new dU(null), new dU(1.5), new dU(e2);
      }, true) || oU(function() {
        return new dU(new cU(2), 1, void 0).length !== 1;
      }), AU = F, hU = Math.floor, lU = Number.isInteger || function(e2) {
        return !AU(e2) && isFinite(e2) && hU(e2) === e2;
      }, pU = Hr, gU = r.RangeError, fU = function(e2) {
        var t2 = pU(e2);
        if (t2 < 0)
          throw gU("The argument can't be less than 0");
        return t2;
      }, EU = r.RangeError, IU = function(e2, t2) {
        var r2 = fU(e2);
        if (r2 % t2)
          throw EU("Wrong offset");
        return r2;
      }, mU = En, _U = d, CU = Po, vU = Le, SU = ei, RU = Gn, yU = Mn, TU = vn, wU = iU.aTypedArrayConstructor, bU = T, OU = r, NU = Array.isArray || function(e2) {
        return bU(e2) == "Array";
      }, DU = Oo, LU = F, PU = Xe("species"), kU = OU.Array, BU = function(e2) {
        var t2;
        return NU(e2) && (t2 = e2.constructor, (DU(t2) && (t2 === kU || NU(t2.prototype)) || LU(t2) && (t2 = t2[PU]) === null) && (t2 = void 0)), t2 === void 0 ? kU : t2;
      }, MU = En, UU = L, QU = Le, xU = ei, FU = function(e2, t2) {
        return new (BU(e2))(t2 === 0 ? 0 : t2);
      }, VU = v([].push), jU = function(e2) {
        var t2 = e2 == 1, r2 = e2 == 2, i2 = e2 == 3, n2 = e2 == 4, o2 = e2 == 6, s2 = e2 == 7, a2 = e2 == 5 || o2;
        return function(c2, d2, u2, A2) {
          for (var h2, l2, p2 = QU(c2), g2 = UU(p2), f2 = MU(d2, u2), E2 = xU(g2), I2 = 0, m2 = A2 || FU, _2 = t2 ? m2(c2, E2) : r2 || s2 ? m2(c2, 0) : void 0; E2 > I2; I2++)
            if ((a2 || I2 in g2) && (l2 = f2(h2 = g2[I2], I2, p2), e2))
              if (t2)
                _2[I2] = l2;
              else if (l2)
                switch (e2) {
                  case 3:
                    return true;
                  case 5:
                    return h2;
                  case 6:
                    return I2;
                  case 2:
                    VU(_2, h2);
                }
              else
                switch (e2) {
                  case 4:
                    return false;
                  case 7:
                    VU(_2, h2);
                }
          return o2 ? -1 : i2 || n2 ? n2 : _2;
        };
      }, GU = { forEach: jU(0), map: jU(1), filter: jU(2), some: jU(3), every: jU(4), find: jU(5), findIndex: jU(6), filterReject: jU(7) }, KU = Gi, HU = r, YU = d, WU = o, JU = uU, qU = iU, zU = aM, XU = ln, ZU = f, $U = Kt, eQ = lU, tQ = Zr, rQ = Vk, iQ = IU, nQ = ct, oQ = Be, sQ = Dn, aQ = F, cQ = de, dQ = tl, uQ = H, AQ = en, hQ = jr.f, lQ = function(e2) {
        var t2, r2, i2, n2, o2, s2, a2 = CU(this), c2 = vU(e2), d2 = arguments.length, u2 = d2 > 1 ? arguments[1] : void 0, A2 = u2 !== void 0, h2 = yU(c2);
        if (h2 && !TU(h2))
          for (s2 = (o2 = RU(c2, h2)).next, c2 = []; !(n2 = _U(s2, o2)).done; )
            c2.push(n2.value);
        for (A2 && d2 > 2 && (u2 = mU(u2, arguments[2])), r2 = SU(c2), i2 = new (wU(a2))(r2), t2 = 0; r2 > t2; t2++)
          i2[t2] = A2 ? u2(c2[t2], t2) : c2[t2];
        return i2;
      }, pQ = GU.forEach, gQ = un, fQ = Rt, EQ = i, IQ = eg, mQ = yr.get, _Q = yr.set, CQ = fQ.f, vQ = EQ.f, SQ = Math.round, RQ = HU.RangeError, yQ = zU.ArrayBuffer, TQ = yQ.prototype, wQ = zU.DataView, bQ = qU.NATIVE_ARRAY_BUFFER_VIEWS, OQ = qU.TYPED_ARRAY_CONSTRUCTOR, NQ = qU.TYPED_ARRAY_TAG, DQ = qU.TypedArray, LQ = qU.TypedArrayPrototype, PQ = qU.aTypedArrayConstructor, kQ = qU.isTypedArray, BQ = "BYTES_PER_ELEMENT", MQ = "Wrong length", UQ = function(e2, t2) {
        PQ(e2);
        for (var r2 = 0, i2 = t2.length, n2 = new e2(i2); i2 > r2; )
          n2[r2] = t2[r2++];
        return n2;
      }, QQ = function(e2, t2) {
        CQ(e2, t2, { get: function() {
          return mQ(this)[t2];
        } });
      }, xQ = function(e2) {
        var t2;
        return uQ(TQ, e2) || (t2 = sQ(e2)) == "ArrayBuffer" || t2 == "SharedArrayBuffer";
      }, FQ = function(e2, t2) {
        return kQ(e2) && !cQ(t2) && t2 in e2 && eQ(+t2) && t2 >= 0;
      }, VQ = function(e2, t2) {
        return t2 = nQ(t2), FQ(e2, t2) ? ZU(2, e2[t2]) : vQ(e2, t2);
      }, jQ = function(e2, t2, r2) {
        return t2 = nQ(t2), !(FQ(e2, t2) && aQ(r2) && oQ(r2, "value")) || oQ(r2, "get") || oQ(r2, "set") || r2.configurable || oQ(r2, "writable") && !r2.writable || oQ(r2, "enumerable") && !r2.enumerable ? CQ(e2, t2, r2) : (e2[t2] = r2.value, e2);
      };
      WU ? (bQ || (EQ.f = VQ, fQ.f = jQ, QQ(LQ, "buffer"), QQ(LQ, "byteOffset"), QQ(LQ, "byteLength"), QQ(LQ, "length")), KU({ target: "Object", stat: true, forced: !bQ }, { getOwnPropertyDescriptor: VQ, defineProperty: jQ }), RM.exports = function(e2, t2, r2) {
        var i2 = e2.match(/\d+$/)[0] / 8, n2 = e2 + (r2 ? "Clamped" : "") + "Array", o2 = "get" + e2, s2 = "set" + e2, a2 = HU[n2], c2 = a2, d2 = c2 && c2.prototype, u2 = {}, A2 = function(e3, t3) {
          CQ(e3, t3, { get: function() {
            return function(e4, t4) {
              var r3 = mQ(e4);
              return r3.view[o2](t4 * i2 + r3.byteOffset, true);
            }(this, t3);
          }, set: function(e4) {
            return function(e5, t4, n3) {
              var o3 = mQ(e5);
              r2 && (n3 = (n3 = SQ(n3)) < 0 ? 0 : n3 > 255 ? 255 : 255 & n3), o3.view[s2](t4 * i2 + o3.byteOffset, n3, true);
            }(this, t3, e4);
          }, enumerable: true });
        };
        bQ ? JU && (c2 = t2(function(e3, t3, r3, n3) {
          return XU(e3, d2), IQ(aQ(t3) ? xQ(t3) ? n3 !== void 0 ? new a2(t3, iQ(r3, i2), n3) : r3 !== void 0 ? new a2(t3, iQ(r3, i2)) : new a2(t3) : kQ(t3) ? UQ(c2, t3) : YU(lQ, c2, t3) : new a2(rQ(t3)), e3, c2);
        }), AQ && AQ(c2, DQ), pQ(hQ(a2), function(e3) {
          e3 in c2 || $U(c2, e3, a2[e3]);
        }), c2.prototype = d2) : (c2 = t2(function(e3, t3, r3, n3) {
          XU(e3, d2);
          var o3, s3, a3, u3 = 0, h2 = 0;
          if (aQ(t3)) {
            if (!xQ(t3))
              return kQ(t3) ? UQ(c2, t3) : YU(lQ, c2, t3);
            o3 = t3, h2 = iQ(r3, i2);
            var l2 = t3.byteLength;
            if (n3 === void 0) {
              if (l2 % i2)
                throw RQ(MQ);
              if ((s3 = l2 - h2) < 0)
                throw RQ(MQ);
            } else if ((s3 = tQ(n3) * i2) + h2 > l2)
              throw RQ(MQ);
            a3 = s3 / i2;
          } else
            a3 = rQ(t3), o3 = new yQ(s3 = a3 * i2);
          for (_Q(e3, { buffer: o3, byteOffset: h2, byteLength: s3, length: a3, view: new wQ(o3) }); u3 < a3; )
            A2(e3, u3++);
        }), AQ && AQ(c2, DQ), d2 = c2.prototype = dQ(LQ)), d2.constructor !== c2 && $U(d2, "constructor", c2), $U(d2, OQ, c2), NQ && $U(d2, NQ, n2), u2[n2] = c2, KU({ global: true, forced: c2 != a2, sham: !bQ }, u2), BQ in c2 || $U(c2, BQ, i2), BQ in d2 || $U(d2, BQ, i2), gQ(n2);
      }) : RM.exports = function() {
      }, (0, RM.exports)("Uint8", function(e2) {
        return function(t2, r2, i2) {
          return e2(this, t2, r2, i2);
        };
      });
      var GQ = ei, KQ = Hr, HQ = iU.aTypedArray;
      (0, iU.exportTypedArrayMethod)("at", function(e2) {
        var t2 = HQ(this), r2 = GQ(t2), i2 = KQ(e2), n2 = i2 >= 0 ? i2 : r2 + i2;
        return n2 < 0 || n2 >= r2 ? void 0 : t2[n2];
      });
      var YQ = r, WQ = d, JQ = iU, qQ = ei, zQ = IU, XQ = Le, ZQ = n, $Q = YQ.RangeError, ex = YQ.Int8Array, tx = ex && ex.prototype, rx = tx && tx.set, ix = JQ.aTypedArray, nx = JQ.exportTypedArrayMethod, ox = !ZQ(function() {
        var e2 = new Uint8ClampedArray(2);
        return WQ(rx, e2, { length: 1, 0: 3 }, 1), e2[1] !== 3;
      }), sx = ox && JQ.NATIVE_ARRAY_BUFFER_VIEWS && ZQ(function() {
        var e2 = new ex(2);
        return e2.set(1), e2.set("2", 1), e2[0] !== 0 || e2[1] !== 2;
      });
      nx("set", function(e2) {
        ix(this);
        var t2 = zQ(arguments.length > 1 ? arguments[1] : void 0, 1), r2 = XQ(e2);
        if (ox)
          return WQ(rx, this, r2, t2);
        var i2 = this.length, n2 = qQ(r2), o2 = 0;
        if (n2 + t2 > i2)
          throw $Q("Wrong length");
        for (; o2 < n2; )
          this[t2 + o2] = r2[o2++];
      }, !ox || sx);
      var ax = sB, cx = Math.floor, dx = function(e2, t2) {
        var r2 = e2.length, i2 = cx(r2 / 2);
        return r2 < 8 ? ux(e2, t2) : Ax(e2, dx(ax(e2, 0, i2), t2), dx(ax(e2, i2), t2), t2);
      }, ux = function(e2, t2) {
        for (var r2, i2, n2 = e2.length, o2 = 1; o2 < n2; ) {
          for (i2 = o2, r2 = e2[o2]; i2 && t2(e2[i2 - 1], r2) > 0; )
            e2[i2] = e2[--i2];
          i2 !== o2++ && (e2[i2] = r2);
        }
        return e2;
      }, Ax = function(e2, t2, r2, i2) {
        for (var n2 = t2.length, o2 = r2.length, s2 = 0, a2 = 0; s2 < n2 || a2 < o2; )
          e2[s2 + a2] = s2 < n2 && a2 < o2 ? i2(t2[s2], r2[a2]) <= 0 ? t2[s2++] : r2[a2++] : s2 < n2 ? t2[s2++] : r2[a2++];
        return e2;
      }, hx = dx, lx = Y.match(/firefox\/(\d+)/i), px = !!lx && +lx[1], gx = /MSIE|Trident/.test(Y), fx = Y.match(/AppleWebKit\/(\d+)\./), Ex = !!fx && +fx[1], Ix = r, mx = v, _x = n, Cx = ge, vx = hx, Sx = iU, Rx = px, yx = gx, Tx = $, wx = Ex, bx = Ix.Array, Ox = Sx.aTypedArray, Nx = Sx.exportTypedArrayMethod, Dx = Ix.Uint16Array, Lx = Dx && mx(Dx.prototype.sort), Px = !(!Lx || _x(function() {
        Lx(new Dx(2), null);
      }) && _x(function() {
        Lx(new Dx(2), {});
      })), kx = !!Lx && !_x(function() {
        if (Tx)
          return Tx < 74;
        if (Rx)
          return Rx < 67;
        if (yx)
          return true;
        if (wx)
          return wx < 602;
        var e2, t2, r2 = new Dx(516), i2 = bx(516);
        for (e2 = 0; e2 < 516; e2++)
          t2 = e2 % 4, r2[e2] = 515 - e2, i2[e2] = e2 - 2 * t2 + 3;
        for (Lx(r2, function(e3, t3) {
          return (e3 / 4 | 0) - (t3 / 4 | 0);
        }), e2 = 0; e2 < 516; e2++)
          if (r2[e2] !== i2[e2])
            return true;
      });
      Nx("sort", function(e2) {
        return e2 !== void 0 && Cx(e2), kx ? Lx(this, e2) : vx(Ox(this), function(e3) {
          return function(t2, r2) {
            return e3 !== void 0 ? +e3(t2, r2) || 0 : r2 != r2 ? -1 : t2 != t2 ? 1 : t2 === 0 && r2 === 0 ? 1 / t2 > 0 && 1 / r2 < 0 ? 1 : -1 : t2 > r2;
          };
        }(e2));
      }, !kx || Px);
      var Bx = un, Mx = "ArrayBuffer", Ux = aM.ArrayBuffer;
      let Qx;
      Gi({ global: true, forced: r.ArrayBuffer !== Ux }, { ArrayBuffer: Ux }), Bx(Mx), function(e2) {
        e2[e2.CHOOSE_SERVER = 11] = "CHOOSE_SERVER", e2[e2.CLOUD_PROXY = 18] = "CLOUD_PROXY", e2[e2.CLOUD_PROXY_5 = 20] = "CLOUD_PROXY_5", e2[e2.CLOUD_PROXY_FALLBACK = 26] = "CLOUD_PROXY_FALLBACK";
      }(Qx || (Qx = {}));
      var xx = sd, Fx = Array.isArray || function(e2) {
        return xx(e2) == "Array";
      }, Vx = Qc, jx = Fx, Gx = K_, Kx = md, Hx = Nu("species"), Yx = Vx.Array, Wx = function(e2) {
        var t2;
        return jx(e2) && (t2 = e2.constructor, (Gx(t2) && (t2 === Yx || jx(t2.prototype)) || Kx(t2) && (t2 = t2[Hx]) === null) && (t2 = void 0)), t2 === void 0 ? Yx : t2;
      }, Jx = function(e2, t2) {
        return new (Wx(e2))(t2 === 0 ? 0 : t2);
      }, qx = gA, zx = hd, Xx = Au, Zx = th, $x = Jx, eF = Bc([].push), tF = function(e2) {
        var t2 = e2 == 1, r2 = e2 == 2, i2 = e2 == 3, n2 = e2 == 4, o2 = e2 == 6, s2 = e2 == 7, a2 = e2 == 5 || o2;
        return function(c2, d2, u2, A2) {
          for (var h2, l2, p2 = Xx(c2), g2 = zx(p2), f2 = qx(d2, u2), E2 = Zx(g2), I2 = 0, m2 = A2 || $x, _2 = t2 ? m2(c2, E2) : r2 || s2 ? m2(c2, 0) : void 0; E2 > I2; I2++)
            if ((a2 || I2 in g2) && (l2 = f2(h2 = g2[I2], I2, p2), e2))
              if (t2)
                _2[I2] = l2;
              else if (l2)
                switch (e2) {
                  case 3:
                    return true;
                  case 5:
                    return h2;
                  case 6:
                    return I2;
                  case 2:
                    eF(_2, h2);
                }
              else
                switch (e2) {
                  case 4:
                    return false;
                  case 7:
                    eF(_2, h2);
                }
          return o2 ? -1 : i2 || n2 ? n2 : _2;
        };
      }, rF = { forEach: tF(0), map: tF(1), filter: tF(2), some: tF(3), every: tF(4), find: tF(5), findIndex: tF(6), filterReject: tF(7) }, iF = rF.forEach, nF = uh("forEach") ? [].forEach : function(e2) {
        return iF(this, e2, arguments.length > 1 ? arguments[1] : void 0);
      };
      JA({ target: "Array", proto: true, forced: [].forEach != nF }, { forEach: nF });
      var oF = fh("Array").forEach, sF = PE, aF = pu, cF = Mc, dF = oF, uF = Array.prototype, AF = { DOMTokenList: true, NodeList: true }, hF = function(e2) {
        var t2 = e2.forEach;
        return e2 === uF || cF(uF, e2) && t2 === uF.forEach || aF(AF, sF(e2)) ? dF : t2;
      }, lF = Au, pF = Yf;
      JA({ target: "Object", stat: true, forced: bc(function() {
        pF(1);
      }) }, { keys: function(e2) {
        return pF(lF(e2));
      } });
      var gF = _d.Object.keys, fF = Ch, EF = JA, IF = Fx, mF = Bc([].reverse), _F = [1, 2];
      EF({ target: "Array", proto: true, forced: String(_F) === String(_F.reverse()) }, { reverse: function() {
        return IF(this) && (this.length = this.length), mF(this);
      } });
      var CF = fh("Array").reverse, vF = Mc, SF = CF, RF = Array.prototype, yF = function(e2) {
        var t2 = e2.reverse;
        return e2 === RF || vF(RF, e2) && t2 === RF.reverse ? SF : t2;
      }, TF = bc, wF = Pd, bF = Nu("species"), OF = function(e2) {
        return wF >= 51 || !TF(function() {
          var t2 = [];
          return (t2.constructor = {})[bF] = function() {
            return { foo: 1 };
          }, t2[e2](Boolean).foo !== 1;
        });
      }, NF = JA, DF = Qc, LF = Fx, PF = K_, kF = md, BF = ff, MF = th, UF = Ed, QF = aL, xF = Nu, FF = Z_, VF = OF("slice"), jF = xF("species"), GF = DF.Array, KF = Math.max;
      NF({ target: "Array", proto: true, forced: !VF }, { slice: function(e2, t2) {
        var r2, i2, n2, o2 = UF(this), s2 = MF(o2), a2 = BF(e2, s2), c2 = BF(t2 === void 0 ? s2 : t2, s2);
        if (LF(o2) && (r2 = o2.constructor, (PF(r2) && (r2 === GF || LF(r2.prototype)) || kF(r2) && (r2 = r2[jF]) === null) && (r2 = void 0), r2 === GF || r2 === void 0))
          return FF(o2, a2, c2);
        for (i2 = new (r2 === void 0 ? GF : r2)(KF(c2 - a2, 0)), n2 = 0; a2 < c2; a2++, n2++)
          a2 in o2 && QF(i2, n2, o2[a2]);
        return i2.length = n2, i2;
      } });
      var HF = fh("Array").slice, YF = Mc, WF = HF, JF = Array.prototype, qF = function(e2) {
        var t2 = e2.slice;
        return e2 === JF || YF(JF, e2) && t2 === JF.slice ? WF : t2;
      };
      function zF(e2, t2, r2, i2, n2) {
        var o2, s2, a2, c2 = {};
        return hF(o2 = gF(i2)).call(o2, function(e3) {
          c2[e3] = i2[e3];
        }), c2.enumerable = !!c2.enumerable, c2.configurable = !!c2.configurable, ("value" in c2 || c2.initializer) && (c2.writable = true), c2 = fF(s2 = yF(a2 = qF(r2).call(r2)).call(a2)).call(s2, function(r3, i3) {
          return i3(e2, t2, r3) || r3;
        }, c2), n2 && c2.initializer !== void 0 && (c2.value = c2.initializer ? c2.initializer.call(n2) : void 0, c2.initializer = void 0), c2.initializer === void 0 && (PO(e2, t2, c2), c2 = null), c2;
      }
      var XF = fh("Array").values, ZF = PE, $F = pu, eV = Mc, tV = XF, rV = Array.prototype, iV = { DOMTokenList: true, NodeList: true }, nV = function(e2) {
        var t2 = e2.values;
        return e2 === rV || eV(rV, e2) && t2 === rV.values || $F(iV, ZF(e2)) ? tV : t2;
      }, oV = fh("Array").keys, sV = PE, aV = pu, cV = Mc, dV = oV, uV = Array.prototype, AV = { DOMTokenList: true, NodeList: true }, hV = function(e2) {
        var t2 = e2.keys;
        return e2 === uV || cV(uV, e2) && t2 === uV.keys || aV(AV, sV(e2)) ? dV : t2;
      };
      function lV(e2, t2) {
        var r2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          t2 && (i2 = i2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), r2.push.apply(r2, i2);
        }
        return r2;
      }
      function pV(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r2 = arguments[t2] != null ? arguments[t2] : {};
          t2 % 2 ? lV(Object(r2), true).forEach(function(t3) {
            kO(e2, t3, r2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : lV(Object(r2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
          });
        }
        return e2;
      }
      let gV = 0, fV = 0;
      function EV(e2, t2, r2) {
        return new nR((i2, n2) => {
          t2.timeout = t2.timeout || JD("HTTP_CONNECT_TIMEOUT"), t2.responseType = t2.responseType || "json", t2.data && !r2 ? (t2.data = JSON.stringify(t2.data), gV += _G(t2.data)) : r2 && (t2.data.size ? gV += t2.data.size : t2.data instanceof FormData ? gV += function(e3) {
            let t3 = 0;
            /DingTalk/i.test(navigator.userAgent) && e3.realFormData && (e3 = e3.realFormData);
            return e3.forEach((e4) => {
              t3 += typeof e4 == "string" ? _G(e4) : e4.size;
            }), t3 + 138;
          }(t2.data) : gV += _G(JSON.stringify(t2.data))), t2.headers = t2.headers || {}, t2.headers["Content-Type"] = t2.headers["Content-Type"] || "application/json", t2.method = "POST", t2.url = e2, zN.request(t2).then((e3) => {
            typeof e3.data == "string" ? fV += _G(e3.data) : e3.data instanceof ArrayBuffer || e3.data instanceof Uint8Array ? fV += e3.data.byteLength : fV += _G(JSON.stringify(e3.data)), i2(e3.data);
          }).catch((e3) => {
            zN.isCancel(e3) ? n2(new tD(eD.OPERATION_ABORTED, "cancel token canceled")) : e3.code === "ECONNABORTED" ? n2(new tD(eD.NETWORK_TIMEOUT, e3.message)) : e3.response ? n2(new tD(eD.NETWORK_RESPONSE_ERROR, e3.response.status)) : n2(new tD(eD.NETWORK_ERROR, e3.message));
          });
        });
      }
      async function IV(e2, t2) {
        const r2 = new Blob([t2.data], { type: "buffer" });
        return await EV(e2, pV(pV({}, t2), {}, { data: r2, headers: { "Content-Type": "application/octet-stream" } }), true);
      }
      const mV = new class extends ZN {
        set networkState(e2) {
          dD.info("[".concat(this._moduleName, "]") + "network state changed, " + this._networkState + " -> " + e2), this.emit(Nk.NETWORK_STATE_CHANGE, e2, this._networkState), e2 === Ok.ONLINE ? this.emit(Nk.ONLINE) : e2 === Ok.OFFLINE && (this.onlineWaiter = new nR((e3) => {
            this.once(Nk.ONLINE, () => {
              this.onlineWaiter = void 0, e3(Ok.ONLINE);
            });
          }), this.emit(Nk.OFFLINE)), this._networkState = e2;
        }
        get networkState() {
          return this._networkState;
        }
        constructor() {
          super(), kO(this, "_moduleName", "network-indicator"), kO(this, "_networkState", Ok.ONLINE), kO(this, "onlineWaiter", void 0), window.addEventListener("online", () => {
            this.networkState = Ok.ONLINE;
          }), window.addEventListener("offline", () => {
            this.networkState = Ok.OFFLINE;
          });
        }
      }();
      let _V = false;
      const CV = new class extends ZN {
        constructor() {
          super(...arguments), kO(this, "onAutoplayFailed", void 0), kO(this, "onAudioAutoplayFailed", void 0);
        }
      }();
      function vV() {
        const e2 = oO();
        if (!_V) {
          const t2 = (r2) => {
            r2.preventDefault(), _V = false, e2.os !== "Android" || e2.name !== "Chrome" && e2.name !== tO.WECHAT ? (document.body.removeEventListener("touchstart", t2, true), document.body.removeEventListener("mousedown", t2, true)) : document.body.removeEventListener("click", t2, true);
          };
          _V = true, e2.os !== "Android" || e2.name !== "Chrome" && e2.name !== tO.WECHAT ? (document.body.addEventListener("touchstart", t2, true), document.body.addEventListener("mousedown", t2, true)) : document.body.addEventListener("click", t2, true), dD.info("detect media autoplay failed, document: https://docs.agora.io/cn/Voice/autoplay_policy_web_ng?platform=Web"), CV.onAutoplayFailed ? CV.onAutoplayFailed() : CV.onAudioAutoplayFailed ? dD.warning("AgoraRTC.onAudioAutoplayFailed has been deprecated in favor of AgoraRTC.onAutoplayFailed.\n\n  Please refer to the Agora document to migrate the newer API, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web .") : dD.warning("We have detected a media autoplay failed event, and found out that you haven't implemented AgoraRTC.onAutoplayFailed callback yet.\n\n  It will cause audio/video element not playing automatically on some browsers without user interaction, possibly hurting user experiences.\n\n  Please refer to the Agora document to properly handle autoplay failed event, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web ."), CV.emit("autoplay-failed");
        }
      }
      var SV;
      function RV(e2, t2) {
        var r2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          t2 && (i2 = i2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), r2.push.apply(r2, i2);
        }
        return r2;
      }
      function yV(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r2 = arguments[t2] != null ? arguments[t2] : {};
          t2 % 2 ? RV(Object(r2), true).forEach(function(t3) {
            kO(e2, t3, r2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : RV(Object(r2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
          });
        }
        return e2;
      }
      function TV() {
        let e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { report: bV };
        return function(t2, r2, i2) {
          const n2 = t2[r2];
          if (typeof n2 == "function") {
            const o2 = t2.constructor.name === "AgoraRTCClient" ? "Client" : t2.constructor.name;
            i2.value = function() {
              for (var t3 = arguments.length, i3 = new Array(t3), s2 = 0; s2 < t3; s2++)
                i3[s2] = arguments[s2];
              const a2 = e2.report.reportApiInvoke(this._sessionId || null, { name: "".concat(o2, ".").concat(r2), options: i3, tag: EP.TRACER, reportResult: e2.reportResult });
              try {
                const t4 = n2.apply(this, i3);
                return a2.onSuccess(e2.reportResult && t4), t4;
              } catch (e3) {
                throw a2.onError(e3), e3;
              }
            };
          }
          return i2;
        };
      }
      function wV() {
        let e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { report: bV };
        return function(t2, r2, i2) {
          const n2 = t2[r2];
          if (typeof n2 == "function") {
            const o2 = t2.constructor.name === "AgoraRTCClient" ? "Client" : t2.constructor.name;
            i2.value = async function() {
              for (var t3 = arguments.length, i3 = new Array(t3), s2 = 0; s2 < t3; s2++)
                i3[s2] = arguments[s2];
              const a2 = e2.report.reportApiInvoke(this._sessionId || null, { name: "".concat(o2, ".").concat(r2), options: i3, tag: EP.TRACER });
              try {
                const e3 = await n2.apply(this, i3);
                return a2.onSuccess(), e3;
              } catch (e3) {
                throw a2.onError(e3), e3;
              }
            };
          }
          return i2;
        };
      }
      const bV = new (PD("AgoraRTCEventReport")(SV = class {
        constructor() {
          kO(this, "baseInfoMap", /* @__PURE__ */ new Map()), kO(this, "proxyServer", void 0), kO(this, "clientList", rL), kO(this, "eventUploadTimer", void 0), kO(this, "setSessionIdTimer", void 0), kO(this, "url", void 0), kO(this, "backupUrl", void 0), kO(this, "keyEventUploadPendingItems", []), kO(this, "normalEventUploadPendingItems", []), kO(this, "apiInvokeUploadPendingItems", []), kO(this, "apiInvokeCount", 0), kO(this, "ltsList", []), kO(this, "lastSendNormalEventTime", Date.now()), kO(this, "customReportCounterTimer", void 0), kO(this, "customReportCount", 0), kO(this, "extApiInvoke", async (e2) => {
            for (const t2 of e2) {
              const e3 = yV(yV({}, t2), {}, { sid: null, invokeId: ++this.apiInvokeCount, tag: EP.TRACER });
              this.sendApiInvoke(e3);
            }
          }), this.eventUploadTimer = window.setInterval(this.doSend.bind(this), JD("EVENT_REPORT_SEND_INTERVAL")), this.setSessionIdTimer = window.setInterval(this.appendSessionId.bind(this), JD("EVENT_REPORT_SEND_INTERVAL"));
        }
        adjustSessionStartTime(e2) {
          if (!this.baseInfoMap.has(e2) && !this.baseInfoMap.get(e2))
            return dD.error("adjust session ".concat(e2, " start time, sid is not exist or info is undefined")), void ND("error", this, "adjustSessionStartTime", "adjust session ".concat(e2, " start time, sid is not exist or info is undefined"));
          const t2 = this.baseInfoMap.get(e2), r2 = Date.now(), i2 = t2.startTime;
          t2.startTime = r2, dD.debug("rewrite session ".concat(e2, " startTime: ").concat(r2, " , ").concat(r2 - i2, "ms")), ND("debug", this, "adjustSessionStartTime", void 0, "rewrite session ".concat(e2, " startTime: ").concat(r2, " , ").concat(r2 - i2, "ms")), this.baseInfoMap.set(e2, t2);
        }
        reportApiInvoke(e2, t2, r2) {
          t2.timeout = t2.timeout || 6e4, t2.reportResult = t2.reportResult === void 0 || t2.reportResult;
          const i2 = Date.now();
          this.apiInvokeCount += 1;
          const n2 = this.apiInvokeCount, o2 = () => ({ tag: t2.tag, invokeId: n2, sid: e2, name: t2.name, apiInvokeTime: i2, options: t2.options, states: t2.states || null }), s2 = !!JD("SHOW_REPORT_INVOKER_LOG");
          s2 && dD.info("".concat(t2.name, " start"), t2.options);
          let a2 = false;
          CG(t2.timeout).then(() => {
            a2 || (this.sendApiInvoke(yV(yV({}, o2()), {}, { error: eD.API_INVOKE_TIMEOUT, success: false })), dD.debug("".concat(t2.name, " timeout")));
          });
          const c2 = new tD(eD.UNEXPECTED_ERROR, "".concat(t2.name, ": this api invoke is end"));
          return { onSuccess: (e3) => {
            const i3 = () => {
              if (a2)
                throw c2;
              return a2 = true, this.sendApiInvoke(yV(yV({}, o2()), {}, { success: true }, t2.reportResult && { result: e3 })), s2 && dD.info("".concat(t2.name, " onSuccess")), e3;
            };
            return r2 ? VG(i3, t2.name + "Success", r2, () => a2 = true) : i3();
          }, onError: (e3) => {
            const i3 = () => {
              if (a2)
                throw e3;
              a2 = true, this.sendApiInvoke(yV(yV({}, o2()), {}, { success: false, error: e3.toString() })), s2 && dD.info("".concat(t2.name, " onFailure"), e3.toString());
            };
            return r2 ? VG(i3, t2.name + "Error", r2, () => a2 = true) : i3();
          } };
        }
        sessionInit(e2, t2) {
          if (this.baseInfoMap.has(e2))
            return;
          const r2 = Date.now(), i2 = this.createBaseInfo(e2, r2);
          i2.cname = t2.cname;
          const n2 = Object.assign({}, { willUploadConsoleLog: JD("UPLOAD_LOG"), maxTouchPoints: navigator.maxTouchPoints, areaVersion: UD ? "global" : "oversea", areas: JD("AREAS") && JD("AREAS").join(",") }, t2.extend), o2 = Date.now(), s2 = yV(yV({}, i2), {}, { eventType: lP.SESSION_INIT, appid: t2.appid, browser: navigator.userAgent, build: BD, lts: o2, elapse: o2 - r2, extend: JSON.stringify(n2), mode: t2.mode, process: JD("PROCESS_ID"), success: true, version: MD });
          this.send({ type: pP.SESSION, data: s2 }, true);
        }
        joinChooseServer(e2, t2) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2)
            return;
          const i2 = r2.info, n2 = Date.now(), o2 = yV(yV({}, i2), {}, { eventType: lP.JOIN_CHOOSE_SERVER, lts: n2, eventElapse: n2 - t2.lts, chooseServerAddr: t2.csAddr, errorCode: t2.ec, elapse: n2 - r2.startTime, success: t2.succ, chooseServerAddrList: JSON.stringify(t2.serverList), uid: t2.uid ? parseInt(t2.uid) : null, cid: t2.cid ? parseInt(t2.cid) : null, chooseServerIp: t2.csIp || "", opid: t2.opid, unilbsServerIds: t2.unilbsServerIds, extend: t2.extend || void 0 });
          this.send({ type: pP.JOIN_CHOOSE_SERVER, data: o2 }, true);
        }
        reqUserAccount(e2, t2) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2)
            return;
          const i2 = r2.info, n2 = Date.now(), o2 = yV(yV({}, i2), {}, { eventType: lP.REQ_USER_ACCOUNT, lts: n2, success: t2.success, serverAddress: t2.serverAddr, stringUid: t2.stringUid, uid: t2.uid, errorCode: t2.errorCode, elapse: n2 - r2.startTime, eventElapse: n2 - t2.lts, extend: JSON.stringify(t2.extend) });
          this.send({ type: pP.REQ_USER_ACCOUNT, data: o2 }, true);
        }
        joinGateway(e2, t2) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2)
            return;
          const i2 = r2.info;
          t2.vid && (i2.vid = t2.vid), i2.uid = t2.uid, i2.cid = t2.cid;
          const n2 = Date.now(), { firstSuccess: o2, avoidJoinStartTime: s2, isProxy: a2, addr: c2 } = t2, d2 = n2 - (o2 && s2 ? s2 : r2.startTime), u2 = yV(yV({}, i2), {}, { eventType: lP.JOIN_GATEWAY, lts: n2, gatewayAddr: t2.addr, success: t2.succ, errorCode: t2.ec, elapse: d2, eventElapse: n2 - t2.lts, firstSuccess: o2 }), A2 = u2.success ? 1 : 0;
          if (t2.succ && (r2.lastJoinSuccessTime = n2), o2)
            this.send({ type: pP.JOIN_GATEWAT, data: u2 }, true);
          else {
            let e3;
            if (c2)
              if (a2) {
                const t4 = c2.match(/h=(\d{1,3}-){3}\d{1,3}/g), r3 = c2.match(/p=[0-9]{1,6}/g);
                e3 = { isSuccess: A2, gatewayIp: t4 && t4.length ? t4[0].split("=")[1].replace(/-/g, ".") : "", port: r3 && r3.length ? r3[0].split("=")[1] : "", isProxy: a2 ? 1 : 0 };
              } else {
                const t4 = c2.match(/wss:\/\/(\d{1,3}-){3}\d{1,3}/g), r3 = c2.match(/:[0-9]{1,6}/g);
                e3 = { isSuccess: A2, gatewayIp: t4 && t4.length ? t4[0].split("//")[1].replace(/-/g, ".") : "", port: r3 && r3.length ? r3[0].split(":")[1] : "", isProxy: a2 ? 1 : 0 };
              }
            else
              e3 = { isSuccess: A2, gatewayIp: "", port: "", isProxy: a2 ? 1 : 0 };
            delete u2.success, delete u2.eventType, delete u2.firstSuccess, u2.vid = Number(u2.vid);
            const t3 = Object.assign({}, u2, e3, { eventType: lP.REJOIN_GATEWAY });
            this.send({ type: pP.RE_JOIN_GATEWAY, data: t3 }, true);
          }
        }
        joinChannelTimeout(e2, t2) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2)
            return;
          const i2 = Date.now(), n2 = yV(yV({}, r2.info), {}, { lts: i2, timeout: t2, elapse: i2 - r2.startTime });
          this.send({ type: pP.JOIN_CHANNEL_TIMEOUT, data: n2 }, true);
        }
        publish(e2, t2) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2)
            return;
          const i2 = r2.info, n2 = Date.now(), o2 = yV(yV({}, i2), {}, { eventType: lP.PUBLISH, lts: n2, eventElapse: t2.eventElapse, elapse: n2 - r2.startTime, success: t2.succ, errorCode: t2.ec, videoName: t2.videoName, audioName: t2.audioName, screenName: t2.screenName, screenshare: t2.screenshare, audio: t2.audio, video: t2.video, p2pid: t2.p2pid, publishRequestid: t2.publishRequestid });
          this.send({ type: pP.PUBLISH, data: o2 }, true);
        }
        subscribe(e2, t2, r2) {
          const i2 = this.baseInfoMap.get(e2);
          if (!i2)
            return;
          const n2 = i2.info, o2 = Date.now(), s2 = yV(yV({}, n2), {}, { eventType: lP.SUBSCRIBE, lts: o2, eventElapse: t2.eventElapse, elapse: o2 - i2.startTime, success: t2.succ, errorCode: t2.ec, video: t2.video, audio: t2.audio, subscribeRequestid: t2.subscribeRequestid, p2pid: t2.p2pid }, r2 && { extend: JSON.stringify({ isMassSubscribe: true }) });
          typeof t2.peerid == "string" ? s2.peerSuid = t2.peerid : s2.peer = t2.peerid, this.send({ type: pP.SUBSCRIBE, data: s2 }, true);
        }
        wsCompressorInit(e2) {
          var t2;
          const r2 = [...hV(t2 = this.baseInfoMap).call(t2)], i2 = r2.length ? r2[0] : "UnableToGetSid", n2 = this.baseInfoMap.get(i2);
          if (!n2)
            return;
          const o2 = n2.info, s2 = Date.now(), a2 = yV(yV({}, o2), {}, { eventType: lP.WS_COMPRESSOR_INIT, lts: s2, eventElapse: e2.eventElapse, elapse: s2 - n2.startTime, status: e2.status ? 1 : 2 });
          this.send({ type: pP.WS_COMPRESSOR_INIT, data: a2 }, true);
        }
        firstRemoteFrame(e2, t2, r2, i2) {
          const n2 = this.baseInfoMap.get(e2);
          if (!n2)
            return;
          const o2 = n2.info, s2 = Date.now(), a2 = yV(yV(yV({}, o2), i2), {}, { elapse: s2 - n2.startTime, eventType: t2, lts: s2 });
          this.send({ type: r2, data: a2 }, true);
        }
        onGatewayStream(e2, t2, r2, i2) {
          const n2 = this.baseInfoMap.get(e2);
          if (!n2)
            return;
          const o2 = n2.info, s2 = Date.now(), a2 = yV(yV(yV({}, o2), i2), {}, { eventType: t2, lts: s2 });
          this.send({ type: r2, data: a2 }, true);
        }
        streamSwitch(e2, t2) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2)
            return;
          const i2 = r2.info, n2 = Date.now(), o2 = yV(yV({}, i2), {}, { eventType: lP.STREAM_SWITCH, lts: n2, isDual: t2.isdual, elapse: n2 - r2.startTime, success: t2.succ });
          this.send({ type: pP.STREAM_SWITCH, data: o2 }, true);
        }
        requestProxyAppCenter(e2, t2) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2)
            return;
          const i2 = r2.info, n2 = Date.now(), o2 = yV(yV({}, i2), {}, { eventType: lP.REQUEST_PROXY_APPCENTER, lts: n2, eventElapse: n2 - t2.lts, elapse: n2 - r2.startTime, APAddr: t2.APAddr, workerManagerList: t2.workerManagerList, response: t2.response, errorCode: t2.ec, success: t2.succ });
          this.send({ type: pP.REQUEST_PROXY_APPCENTER, data: o2 }, true);
        }
        requestProxyWorkerManager(e2, t2) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2)
            return;
          const i2 = r2.info, n2 = Date.now(), o2 = yV(yV({}, i2), {}, { eventType: lP.REQUEST_PROXY_WORKER_MANAGER, lts: n2, eventElapse: n2 - t2.lts, elapse: n2 - r2.startTime, workerManagerAddr: t2.workerManagerAddr, response: t2.response, errorCode: t2.ec, success: t2.succ });
          this.send({ type: pP.REQUEST_PROXY_WORKER_MANAGER, data: o2 }, true);
        }
        setProxyServer(e2) {
          this.proxyServer = e2, e2 ? dD.debug("reportProxyServerurl: ".concat(e2)) : dD.debug("disable reportProxyServerurl: ".concat(e2)), ND("debug", this, "setProxyServer", e2);
        }
        peerPublishStatus(e2, t2) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2)
            return;
          const i2 = r2.info, n2 = Date.now(), o2 = yV(yV({}, i2), {}, { subscribeElapse: t2.subscribeElapse, peer: t2.peer, peerPublishDuration: Math.max(t2.audioPublishDuration, t2.videoPublishDuration), audiotag: t2.audioPublishDuration > 0 ? 1 : -1, videotag: t2.videoPublishDuration > 0 ? 1 : -1, lts: n2, elapse: n2 - r2.startTime, joinChannelSuccessElapse: n2 - (r2.lastJoinSuccessTime || n2) });
          this.send({ type: pP.PEER_PUBLISH_STATUS, data: o2 }, true);
        }
        workerEvent(e2, t2) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2)
            return;
          const i2 = r2.info, n2 = Date.now();
          (function(e3, t3, r3) {
            const i3 = e3[t3];
            if (!i3 || typeof i3 != "string")
              return [e3];
            e3[t3] = "";
            const n3 = _G(JSON.stringify(e3));
            let o2 = 0;
            const s2 = [];
            let a2 = 0;
            for (let c2 = 0; c2 < i3.length; c2++)
              a2 += i3.charCodeAt(c2) <= 127 ? 1 : 3, a2 <= r3 - n3 || (s2[s2.length] = mG(mG({}, e3), {}, { [t3]: i3.substring(o2, c2) }), o2 = c2, a2 = i3.charCodeAt(c2) <= 127 ? 1 : 3);
            o2 !== i3.length - 1 && (s2[s2.length] = mG(mG({}, e3), {}, { [t3]: i3.substring(o2) }));
            return s2;
          })(yV(yV(yV({}, i2), t2), {}, { elapse: n2 - r2.startTime, lts: n2, productType: "WebRTC" }), "payload", 1300).forEach((e3) => this.send({ type: pP.WORKER_EVENT, data: e3 }, true));
        }
        apworkerEvent(e2, t2) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2)
            return;
          const i2 = r2.info, n2 = Date.now(), o2 = yV(yV(yV({}, i2), t2), {}, { elapse: n2 - r2.startTime, lts: n2 });
          this.send({ type: pP.AP_WORKER_EVENT, data: o2 }, true);
        }
        joinWebProxyAP(e2, t2) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2)
            return;
          const i2 = r2.info, n2 = Date.now(), o2 = yV(yV(yV({}, i2), t2), {}, { elapse: n2 - r2.startTime, lts: n2, extend: t2.extend || void 0 });
          this.send({ type: pP.JOIN_WEB_PROXY_AP, data: o2 }, true);
        }
        WebSocketQuit(e2, t2) {
          const r2 = this.baseInfoMap.get(e2);
          if (!r2)
            return;
          const i2 = r2.info, n2 = Date.now(), o2 = yV(yV(yV({}, i2), t2), {}, { elapse: n2 - r2.startTime, lts: n2 });
          this.send({ type: pP.WEBSOCKET_QUIT, data: o2 }, true);
        }
        async sendCustomReportMessage(e2, t2) {
          if (this.customReportCount += t2.length, this.customReportCount > JD("CUSTOM_REPORT_LIMIT"))
            throw new tD(eD.CUSTOM_REPORT_FREQUENCY_TOO_HIGH);
          this.customReportCounterTimer || (this.customReportCounterTimer = window.setInterval(() => {
            this.customReportCount = 0;
          }, 5e3));
          const r2 = t2.map((t3) => ({ type: pP.USER_ANALYTICS, data: yV({ sid: e2 }, t3) })), i2 = { msgType: "EventMessages", sentTs: Math.round(Date.now() / 1e3), payloads: r2.map((e3) => JSON.stringify(e3)) };
          try {
            await this.postDataToStatsCollector(i2);
          } catch (e3) {
            throw dD.error("send custom report message failed", e3.toString()), new tD(eD.CUSTOM_REPORT_SEND_FAILED, e3.message);
          }
        }
        autoplayFailed(e2, t2, r2, i2) {
          if (!e2)
            return;
          const n2 = this.baseInfoMap.get(e2);
          if (!n2)
            return;
          const o2 = n2.info, s2 = Date.now(), a2 = yV(yV({}, o2), {}, { vid: o2.vid === void 0 ? 0 : Number(o2.vid), lts: s2, elapse: s2 - n2.startTime, cbRegistered: CV.onAutoplayFailed || CV.onAudioAutoplayFailed ? 1 : -1, errorMsg: r2, mediaType: t2, trackId: i2, extend: void 0 });
          this.send({ type: pP.AUTOPLAY_FAILED, data: a2 }, true);
        }
        sendApiInvoke(e2) {
          const t2 = JD("NOT_REPORT_EVENT");
          if (e2.tag && t2.includes && t2.includes(e2.tag))
            return false;
          if (e2.sid === null)
            return this.apiInvokeUploadPendingItems.push(e2), false;
          const r2 = this.baseInfoMap.get(e2.sid);
          if (!r2)
            return this.apiInvokeUploadPendingItems.push(e2), false;
          const { cname: i2, uid: n2, cid: o2 } = r2.info;
          e2.lts = e2.lts || Date.now();
          const s2 = { invokeId: e2.invokeId, sid: e2.sid, cname: i2, cid: o2, uid: n2, lts: e2.lts, success: e2.success, elapse: e2.lts - r2.startTime, execElapse: e2.lts - e2.apiInvokeTime, apiName: e2.name, options: e2.options ? JSON.stringify(e2.options) : void 0, execStates: e2.states ? JSON.stringify(e2.states) : void 0, execResult: e2.result ? JSON.stringify(e2.result) : void 0, errorCode: e2.error ? JSON.stringify(e2.error) : void 0 };
          return this.send({ type: pP.API_INVOKE, data: s2 }, false), true;
        }
        appendSessionId() {
          this.clientList.forEach((e2) => {
            if (e2._sessionId) {
              const t2 = this.apiInvokeUploadPendingItems.length;
              for (let r2 = 0; r2 < t2; r2++) {
                const t3 = this.apiInvokeUploadPendingItems.shift();
                t3 && (t3.sid = e2._sessionId, this.sendApiInvoke(Object.assign({}, t3)));
              }
            }
          });
        }
        send(e2, t2) {
          if (t2)
            return this.keyEventUploadPendingItems.push(e2), void this.sendItems(this.keyEventUploadPendingItems, true);
          this.normalEventUploadPendingItems.push(e2), this.normalEventUploadPendingItems.length > JD("NORMAL_EVENT_QUEUE_CAPACITY") && this.normalEventUploadPendingItems.splice(0, 1), this.normalEventUploadPendingItems.length >= 10 && this.sendItems(this.normalEventUploadPendingItems, false);
        }
        doSend() {
          this.keyEventUploadPendingItems.length > 0 && this.sendItems(this.keyEventUploadPendingItems, true), this.normalEventUploadPendingItems.length > 0 && Date.now() - this.lastSendNormalEventTime >= 5e3 && this.sendItems(this.normalEventUploadPendingItems, false);
        }
        sendItems(e2, t2) {
          const r2 = [], i2 = [];
          for (; e2.length; ) {
            const t3 = e2.shift();
            r2.length < 20 ? r2.push(t3) : i2.push(t3);
          }
          e2.push(...i2);
          for (const e3 of [...r2]) {
            var n2;
            if (this.ltsList.indexOf(e3.data.lts) !== -1)
              e3.data.lts = this.ltsList[this.ltsList.length - 1] + 1, this.ltsList.push(e3.data.lts);
            else
              this.ltsList.push(e3.data.lts), qL(n2 = this.ltsList).call(n2, (e4, t3) => e4 - t3);
          }
          t2 || (this.lastSendNormalEventTime = Date.now());
          const o2 = { msgType: "EventMessages", sentTs: Math.round(Date.now() / 1e3), payloads: r2.map((e3) => JSON.stringify(e3)), vid: ((e3) => {
            const t3 = e3 && e3.data.sid && this.baseInfoMap.get(e3.data.sid);
            return t3 && t3.info.vid && +t3.info.vid || 0;
          })(r2[0]) };
          return r2.length && this.postDataToStatsCollector(o2).catch(((e3) => (r3) => {
            JD("EVENT_REPORT_RETRY") && (t2 ? this.keyEventUploadPendingItems = this.keyEventUploadPendingItems.concat(e3) : (this.normalEventUploadPendingItems = this.normalEventUploadPendingItems.concat(e3), this.normalEventUploadPendingItems.length > JD("NORMAL_EVENT_QUEUE_CAPACITY") && (this.normalEventUploadPendingItems.splice(0, this.normalEventUploadPendingItems.length - JD("NORMAL_EVENT_QUEUE_CAPACITY")), dD.warning("report: drop normal events"))));
          })(r2)), e2;
        }
        async postDataToStatsCollector(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
          mV.networkState === Ok.OFFLINE && await nR.race([mV.onlineWaiter, CG(2 * rD.maxRetryTimeout)]);
          const r2 = t2 ? "/events/proto-raws" : "/events/messages";
          let i2 = this.url || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(JD("EVENT_REPORT_DOMAIN"), "&p=").concat(JD("STATS_COLLECTOR_PORT"), "&d=").concat(r2) : "https://".concat(JD("EVENT_REPORT_DOMAIN"), ":").concat(JD("STATS_COLLECTOR_PORT")).concat(r2));
          for (let n2 = 0; n2 < 2; n2 += 1) {
            n2 === 1 && (i2 = this.backupUrl || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(JD("EVENT_REPORT_BACKUP_DOMAIN"), "&p=").concat(JD("STATS_COLLECTOR_PORT"), "&d=").concat(r2) : "https://".concat(JD("EVENT_REPORT_BACKUP_DOMAIN"), ":").concat(JD("STATS_COLLECTOR_PORT")).concat(r2)));
            try {
              t2 ? await IV(i2, { timeout: 1e4, data: e2 }) : await EV(i2, { timeout: 1e4, data: e2 });
            } catch (e3) {
              if (n2 === 1)
                throw e3;
              continue;
            }
            return;
          }
        }
        createBaseInfo(e2, t2) {
          const r2 = Object.assign({}, hP);
          return r2.sid = e2, this.baseInfoMap.set(e2, { info: r2, startTime: t2 }), r2;
        }
        reportResourceTiming(e2, t2) {
          const r2 = performance.getEntriesByName(e2), i2 = r2[r2.length - 1];
          i2 && this.reportApiInvoke(t2, { name: "Client.resourceTiming", options: i2, tag: EP.TRACER }).onSuccess();
        }
      }) || SV)();
      $N.on("REPORT_LOG_UPLOAD", (e2) => {
        e2.networkState = mV.networkState, bV.reportApiInvoke(null, { name: "logUploadError", options: e2, tag: EP.TRACER });
      });
      class OV extends ZN {
        constructor(e2, t2) {
          super(), kO(this, "trackMediaType", void 0), kO(this, "_ID", void 0), kO(this, "_hints", []), kO(this, "_isClosed", false), kO(this, "_originMediaStreamTrack", void 0), kO(this, "_mediaStreamTrack", void 0), kO(this, "_external", {}), this._ID = t2 || SG(8, "track-"), this._originMediaStreamTrack = e2, this._mediaStreamTrack = e2, function(e3) {
            iL.includes(e3) || iL.push(e3);
          }(this);
        }
        toString() {
          return this._ID;
        }
        getTrackId() {
          return this._ID;
        }
        getMediaStreamTrack(e2) {
          if (!e2) {
            const e3 = bV.reportApiInvoke(null, { name: fP.GET_MEDIA_STREAM_TRACK, options: [], tag: EP.TRACER });
            this._mediaStreamTrack && typeof this._mediaStreamTrack.label == "string" ? e3.onSuccess(this._mediaStreamTrack.label) : e3.onSuccess("");
          }
          return this._mediaStreamTrack;
        }
        getMediaStreamTrackSettings() {
          return this.getMediaStreamTrack(true).getSettings();
        }
        close() {
          this._isClosed = true, function(e2) {
            const t2 = iL.indexOf(e2);
            t2 !== -1 && iL.splice(t2, 1);
          }(this), this.emit(gk.CLOSED);
        }
      }
      let NV, DV, LV, PV = 1;
      class kV {
        constructor(e2) {
          kO(this, "lockingPromise", nR.resolve()), kO(this, "locks", 0), kO(this, "name", ""), kO(this, "lockId", void 0), this.lockId = PV++, e2 && (this.name = e2), dD.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is created."));
        }
        get isLocked() {
          return this.locks > 0;
        }
        lock(e2) {
          let t2;
          this.locks += 1, dD.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is locked, current queue ").concat(this.locks, ". ").concat(typeof e2 == "string" ? e2 : ""));
          const r2 = new nR((r3) => {
            t2 = () => {
              this.locks -= 1, dD.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is not locked, current queue ").concat(this.locks, ". ").concat(typeof e2 == "string" ? e2 : "")), r3();
            };
          }), i2 = this.lockingPromise.then(() => t2);
          return this.lockingPromise = this.lockingPromise.then(() => r2), i2;
        }
      }
      function BV(e2, t2) {
        return function(r2, i2, n2) {
          const o2 = r2[i2];
          if (typeof o2 != "function")
            throw new Error("Cannot use mutex on object property.");
          return n2.value = async function() {
            const r3 = this[t2];
            if (!r3)
              throw new Error("mutex property key ".concat(t2, " doesn't exist on ").concat(e2));
            const n3 = await r3.lock("From ".concat(e2, ".").concat(i2));
            try {
              for (var s2 = arguments.length, a2 = new Array(s2), c2 = 0; c2 < s2; c2++)
                a2[c2] = arguments[c2];
              return await o2.apply(this, a2);
            } finally {
              n3();
            }
          }, n2;
        };
      }
      class MV extends OV {
        get muted() {
          return this._muted;
        }
        get enabled() {
          return this._enabled;
        }
        constructor(e2, t2) {
          super(e2, t2), kO(this, "_enabled", true), kO(this, "_muted", false), kO(this, "_isClosed", false), kO(this, "_trackProcessors", []), kO(this, "_enabledMutex", void 0), kO(this, "processor", void 0), kO(this, "processorContext", void 0), kO(this, "_handleTrackEnded", () => {
            this.onTrackEnded();
          }), this._enabledMutex = new kV("".concat(t2)), e2.addEventListener("ended", this._handleTrackEnded);
        }
        getTrackLabel() {
          return this._originMediaStreamTrack.label;
        }
        close() {
          this._isClosed || (this.stop(), this._trackProcessors.forEach((e2) => e2.destroy()), this._trackProcessors = [], this._originMediaStreamTrack.stop(), this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack.stop(), this._mediaStreamTrack = null), this._originMediaStreamTrack = null, this._enabledMutex = null, dD.debug("[".concat(this.getTrackId(), "] close")), ND("debug", this, "close"), this.emit(Ak.NEED_CLOSE), super.close());
        }
        async _registerTrackProcessor(e2) {
          if (this._trackProcessors.indexOf(e2) !== -1)
            return;
          const t2 = this._trackProcessors[this._trackProcessors.length - 1];
          this._trackProcessors.push(e2), e2.onOutputChange = async () => {
            const t3 = e2.output || this._originMediaStreamTrack;
            this._mediaStreamTrack = t3, this._updatePlayerSource(), await OG(this, Ak.NEED_REPLACE_TRACK, this);
          }, t2 ? (t2.onOutputChange = async () => {
            t2.output && await e2.setInput(t2.output);
          }, await e2.setInput(t2.output || t2.input || this._originMediaStreamTrack)) : await e2.setInput(this._originMediaStreamTrack);
        }
        _getOutputFromProcessors() {
          if (this._trackProcessors.length === 0)
            return this._originMediaStreamTrack;
          const e2 = this._trackProcessors[this._trackProcessors.length - 1];
          return e2.output || e2.input || this._originMediaStreamTrack;
        }
        async _updateOriginMediaStreamTrack(e2, t2) {
          if (e2 !== this._originMediaStreamTrack) {
            if (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), t2 && this._originMediaStreamTrack.stop(), e2.addEventListener("ended", this._handleTrackEnded), this._originMediaStreamTrack = e2, this._trackProcessors.length > 0) {
              await this._trackProcessors[0].setInput(e2);
              const t3 = this._getOutputFromProcessors();
              this._mediaStreamTrack = t3;
            } else
              this._mediaStreamTrack = this._originMediaStreamTrack;
            this._updatePlayerSource(), await OG(this, Ak.NEED_REPLACE_TRACK, this), this.processor && this.processor.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext });
          }
        }
        _getDefaultPlayerConfig() {
          return {};
        }
        onTrackEnded() {
          dD.debug("[".concat(this.getTrackId(), "] track ended")), OD("debug", ["MediaStreamTrack", this.getTrackId()], "ended"), this.emit(gk.TRACK_ENDED);
        }
        stateCheck(e2, t2) {
          if (dD.debug("check track state, [muted: ".concat(this._muted, ", enabled: ").concat(this._enabled, "] to [").concat(e2, ": ").concat(t2, "]")), ND("debug", this, "stateCheck", { stateName: e2, state: t2, muted: this._muted, enabled: this._enabled }), zL(t2, e2), this._enabled && this._muted && e2 === "enabled" && t2 === false)
            throw new tD(eD.TRACK_STATE_UNREACHABLE, "cannot set enabled while the track is muted").print();
          if (!this._enabled && !this._muted && e2 === "muted" && t2 === true)
            throw new tD(eD.TRACK_STATE_UNREACHABLE, "cannot set muted while the track is disabled").print();
        }
        getProcessorStats() {
          return this.processorContext.gatherStats();
        }
      }
      !function(e2) {
        e2.IOS_15_INTERRUPTION_START = "ios15-interruption-start", e2.IOS_15_INTERRUPTION_END = "ios15-interruption-end", e2.IOS_INTERRUPTION_START = "ios-interruption-start", e2.IOS_INTERRUPTION_END = "ios-interruption-end", e2.STATE_CHANGE = "state-change";
      }(NV || (NV = {})), function(e2) {
        e2.AUDIO_CONTEXT_CREATED = "audio_context_created";
      }(DV || (DV = {})), function(e2) {
        e2.AIDenoiser = "AIDenoiser";
      }(LV || (LV = {}));
      const UV = { audioContextInitOptions: {} };
      const QV = new class extends ZN {
        constructor() {
          super(), kO(this, "registeredPlugins", []);
        }
        setOptions(e2, t2) {
          UV[e2] && (UV[e2] = t2);
        }
        getOptions(e2) {
          return UV[e2];
        }
        installPlugin(e2) {
          e2 instanceof Object && e2.name && this.registeredPlugins.push(e2.name);
        }
      }(), xV = window.AudioContext || window.webkitAudioContext;
      let FV = null;
      const VV = new class extends ZN {
        constructor() {
          super(...arguments), kO(this, "prevState", void 0), kO(this, "curState", void 0), kO(this, "interruptDetectorTrack", void 0), kO(this, "onLocalAudioTrackMute", () => {
            dD.info("ios15-interruption-start"), wD("info", ["WebAudio"], "ios15-interruption-start"), this.emit(NV.IOS_15_INTERRUPTION_START);
          }), kO(this, "onLocalAudioTrackUnmute", async () => {
            dD.info("ios15-interruption-end"), wD("info", ["WebAudio"], "ios15-interruption-end"), this.curState !== "running" || this.duringInterruption ? dD.info("ios15-interruption-end-canceled") : (FV && await FV.suspend(), this.emit(NV.IOS_15_INTERRUPTION_END));
          });
        }
        get duringInterruption() {
          return this.prevState === "running" && this.curState === "interrupted";
        }
        bindInterruptDetectorTrack(e2) {
          dD.debug("webaudio bindInterruptDetectorTrack ".concat(e2.getTrackId())), ND("debug", ["WebAudio"], "bindInterruptDetectorTrack", e2.getTrackId()), this.interruptDetectorTrack || (this.interruptDetectorTrack = e2, this.interruptDetectorTrack._mediaStreamTrack.onmute = this.onLocalAudioTrackMute, this.interruptDetectorTrack._mediaStreamTrack.onunmute = this.onLocalAudioTrackUnmute);
        }
        unbindInterruptDetectorTrack(e2) {
          dD.debug("webaudio unbindInterruptDetectorTrack ".concat(e2.getTrackId())), ND("debug", ["WebAudio"], "unbindInterruptDetectorTrack", e2.getTrackId()), this.interruptDetectorTrack && this.interruptDetectorTrack === e2 && (this.interruptDetectorTrack._mediaStreamTrack && (this.interruptDetectorTrack._mediaStreamTrack.onmute = null, this.interruptDetectorTrack._mediaStreamTrack.onunmute = null), this.interruptDetectorTrack = void 0);
        }
      }();
      function jV() {
        if (!xV)
          return dD.error("your browser is not support web audio"), void TD("error", ["WebAudio"], "your browser is not support web audio");
        dD.info("create audio context"), DD("info", ["WebAudio"], "WebAudioContext");
        const e2 = QV.getOptions("audioContextInitOptions");
        dD.debug("audio content init option:", JSON.stringify(e2)), FV = new xV(e2), QV.emit(DV.AUDIO_CONTEXT_CREATED, FV), VV.curState = FV.state, FV.onstatechange = () => {
          VV.prevState = VV.curState, VV.curState = FV ? FV.state : void 0, (fO() || vO()) && VV.prevState === "running" && VV.curState === "interrupted" && (dD.info("ios-interruption-start"), wD("info", ["AudioState"], "ios-interruption-start"), VV.emit(NV.IOS_INTERRUPTION_START)), (fO() || vO()) && VV.prevState === "interrupted" && VV.curState === "running" && (dD.info("ios-interruption-end"), wD("info", ["AudioState"], "ios-interruption-end"), VV.emit(NV.IOS_INTERRUPTION_END)), VV.prevState !== VV.curState && (dD.debug("AudioContext State Change", "".concat(VV.prevState, "=>").concat(VV.curState)), OD("debug", ["AudioContext", void 0], "statechange", "".concat(VV.prevState, "=>").concat(VV.curState)), VV.emit(NV.STATE_CHANGE));
        }, async function(e3) {
          const t2 = ["click", "contextmenu", "auxclick", "dblclick", "mousedown", "mouseup", "touchend", "keydown", "keyup"];
          let r2, i2 = false, n2 = false, o2 = false;
          function s2(t3) {
            e3.state === "running" ? a2(false) : fO() || vO() ? e3.state === "suspended" && (a2(true), t3 && e3.resume().then(d2, d2)) : e3.state !== "closed" && (a2(true), t3 && e3.resume().then(d2, d2));
          }
          function a2(e4) {
            if (i2 !== e4) {
              i2 = e4;
              for (let r3 = 0, i3 = t2; r3 < i3.length; r3 += 1) {
                const t3 = i3[r3];
                e4 ? window.addEventListener(t3, u2, { capture: true, passive: true }) : window.removeEventListener(t3, u2, { capture: true, passive: true });
              }
            }
          }
          function c2() {
            s2(true);
          }
          function d2() {
            s2(false);
          }
          function u2() {
            s2(true);
          }
          function A2(e4) {
            if (!o2)
              if (r2.paused)
                if (e4) {
                  h2(false), o2 = true;
                  let e5 = void 0;
                  try {
                    e5 = r2.play(), e5 ? e5.then(l2, l2) : (r2.addEventListener("playing", l2), r2.addEventListener("abort", l2), r2.addEventListener("error", l2));
                  } catch (e6) {
                    l2();
                  }
                } else
                  h2(true);
              else
                h2(false);
          }
          function h2(e4) {
            if (n2 !== e4) {
              n2 = e4;
              for (let r3 = 0, i3 = t2; r3 < i3.length; r3++) {
                const t3 = i3[r3];
                e4 ? window.addEventListener(t3, p2, { capture: true, passive: true }) : window.removeEventListener(t3, p2, { capture: true, passive: true });
              }
            }
          }
          function l2() {
            r2.removeEventListener("playing", l2), r2.removeEventListener("abort", l2), r2.removeEventListener("error", l2), o2 = false, A2(false);
          }
          function p2() {
            A2(true);
          }
          if (fO()) {
            const t3 = e3.createMediaStreamDestination(), i3 = document.createElement("div");
            i3.innerHTML = "<audio x-webkit-airplay='deny'></audio>", r2 = i3.children.item(0), r2.controls = false, r2.disableRemotePlayback = true, r2.preload = "auto", r2.srcObject = t3.stream, A2(true);
          }
          VV.on(NV.STATE_CHANGE, c2), s2(false);
        }(FV);
      }
      function GV() {
        if (!FV) {
          if (jV(), !FV)
            throw new tD(eD.NOT_SUPPORTED, "can not create audio context");
          return FV;
        }
        return FV;
      }
      function KV(e2) {
        if (function() {
          if (HV !== null)
            return HV;
          const e3 = GV(), t3 = e3.createBufferSource(), r3 = e3.createGain(), i2 = e3.createGain();
          t3.connect(r3), t3.connect(i2), t3.disconnect(r3);
          let n2 = false;
          try {
            t3.disconnect(r3);
          } catch (e4) {
            n2 = true;
          }
          return t3.disconnect(), HV = n2, n2;
        }())
          return;
        ND("debug", ["WebAudio"], "polyfillAudioNode");
        const t2 = e2.connect, r2 = e2.disconnect;
        e2.connect = (r3, i2, n2) => (e2._inputNodes || (e2._inputNodes = []), e2._inputNodes.includes(r3) || (r3 instanceof AudioNode ? (e2._inputNodes.push(r3), t2.call(e2, r3, i2, n2)) : t2.call(e2, r3, i2)), e2), e2.disconnect = (i2, n2, o2) => {
          r2.call(e2), i2 ? LG(e2._inputNodes, i2) : e2._inputNodes = [];
          for (const r3 of e2._inputNodes)
            t2.call(e2, r3);
        };
      }
      let HV = null;
      function YV(e2, t2) {
        const r2 = 1 / t2, i2 = GV();
        let n2 = i2.createGain();
        n2.gain.value = 0, n2.connect(i2.destination);
        let o2 = false;
        const s2 = () => {
          if (o2)
            return void (n2 = null);
          const t3 = i2.createOscillator();
          t3.onended = s2, t3.connect(n2), t3.start(0), t3.stop(i2.currentTime + r2), e2(i2.currentTime);
        };
        return s2(), () => {
          o2 = true;
        };
      }
      const WV = dD.prefix("[inject-node]");
      class JV {
        constructor() {
          kO(this, "nodeLists", []), kO(this, "prevNode", void 0), kO(this, "nextNode", void 0);
        }
        get firstNode() {
          return this.nodeLists[0];
        }
        get lastNode() {
          return this.nodeLists[this.nodeLists.length - 1];
        }
        get isActive() {
          return !!this.nodeLists.length;
        }
        get isConnected() {
          return !(!this.prevNode || !this.nextNode);
        }
        connect(e2, t2) {
          WV.debug("connect audio node, current list:" + this.nodeLists.length), this.nodeLists.length ? (this.prevNode && this.prevNode.disconnect(), e2.connect(this.firstNode), this.nextNode && this.lastNode && this.lastNode.disconnect(), this.lastNode.connect(t2), this.nodeLists.forEach((e3, t3) => {
            const r2 = this.nodeLists[t3 + 1];
            r2 && e3.connect(r2);
          })) : e2.connect(t2), this.nextNode = t2, this.prevNode = e2;
        }
        disconnect() {
          var e2;
          WV.debug("disconnect audio node, current list:" + this.nodeLists.length), this.nodeLists.forEach((e3) => {
            e3.disconnect();
          }), (e2 = this.prevNode) === null || e2 === void 0 || e2.disconnect(), this.prevNode = void 0, this.nextNode = void 0;
        }
        addNode(e2) {
          WV.debug("add node in inject node, current list:", this.nodeLists.length), this.prevNode && this.nextNode ? (this.firstNode || (WV.debug("new node is the first node"), this.prevNode.disconnect(), this.prevNode.connect(e2), e2.connect(this.nextNode)), this.nextNode && this.lastNode && (this.lastNode.disconnect(this.nextNode), this.lastNode.connect(e2), e2.connect(this.nextNode)), this.nodeLists.push(e2)) : WV.debug("add node is called before inject node connected");
        }
        removeNode(e2) {
          WV.debug("remove node in inject node, current list:", this.nodeLists.length);
          const t2 = this.nodeLists.indexOf(e2);
          if (t2 === -1)
            return void WV.debug("$[inject-node] cannot find the node to be removed");
          const r2 = this.nodeLists[t2 + 1], i2 = this.nodeLists[t2 - 1];
          t2 === 0 && this.prevNode && this.nextNode && (this.prevNode.disconnect(e2), r2 ? this.prevNode.connect(r2) : this.prevNode.connect(this.nextNode)), t2 === this.nodeLists.length - 1 && this.nextNode && i2 && (i2.disconnect(e2), i2.connect(this.nextNode)), t2 !== 0 && t2 !== this.nodeLists.length - 1 && (i2.disconnect(e2), i2.connect(r2)), WV.debug("remove node in inject node success, current list:", this.nodeLists.length);
        }
      }
      class qV extends ZN {
        get processSourceNode() {
          return this.sourceNode;
        }
        set processedNode(e2) {
          var t2;
          if (!this.isDestroyed && this._processedNode !== e2) {
            try {
              var r2;
              (r2 = this.sourceNode) === null || r2 === void 0 || r2.disconnect(this.outputNode);
            } catch (e3) {
            }
            (t2 = this._processedNode) === null || t2 === void 0 || t2.disconnect(), this._processedNode = e2, this.connect();
          }
        }
        get processedNode() {
          return this._processedNode;
        }
        constructor() {
          super(), kO(this, "outputNode", void 0), kO(this, "outputTrack", void 0), kO(this, "isPlayed", false), kO(this, "sourceNode", void 0), kO(this, "analyserNode", void 0), kO(this, "context", void 0), kO(this, "audioBufferNode", void 0), kO(this, "destNode", void 0), kO(this, "injectNode", void 0), kO(this, "audioOutputLevel", 0), kO(this, "_processedNode", void 0), kO(this, "playNode", void 0), kO(this, "isDestroyed", false), kO(this, "onNoAudioInput", void 0), kO(this, "isNoAudioInput", false), kO(this, "_noAudioInputCount", 0), this.context = GV(), this.playNode = this.context.destination, this.outputNode = this.context.createGain(), KV(this.outputNode), this.analyserNode = this.context.createAnalyser(), this.analyserNode.smoothingTimeConstant = 0.4, this.analyserNode.fftSize = 2048, this.injectNode = new JV();
        }
        startGetAudioBuffer(e2) {
          this.audioBufferNode || (this.audioBufferNode = this.context.createScriptProcessor(e2), this.outputNode.connect(this.audioBufferNode), this.audioBufferNode.connect(this.context.destination), this.audioBufferNode.onaudioprocess = (e3) => {
            this.emit(BP.ON_AUDIO_BUFFER, function(e4) {
              for (let t2 = 0; t2 < e4.outputBuffer.numberOfChannels; t2 += 1) {
                const r2 = e4.outputBuffer.getChannelData(t2);
                for (let e5 = 0; e5 < r2.length; e5 += 1)
                  r2[e5] = 0;
              }
              return e4.inputBuffer;
            }(e3));
          });
        }
        stopGetAudioBuffer() {
          this.audioBufferNode && (this.audioBufferNode.onaudioprocess = null, this.outputNode.disconnect(this.audioBufferNode), this.audioBufferNode = void 0);
        }
        createOutputTrack() {
          if (!Mk().webAudioMediaStreamDest)
            throw new tD(eD.NOT_SUPPORTED, "your browser is not support audio processor");
          return this.destNode && this.outputTrack || (this.destNode = this.context.createMediaStreamDestination(), this.outputNode.connect(this.destNode), this.outputTrack = this.destNode.stream.getAudioTracks()[0]), this.outputTrack;
        }
        play(e2) {
          this.context.state !== "running" && kG(() => {
            VV.emit("autoplay-failed");
          }), this.isPlayed = true, this.playNode = e2 || this.context.destination, this.outputNode.connect(this.playNode);
        }
        stop() {
          if (this.isPlayed)
            try {
              this.outputNode.disconnect(this.playNode);
            } catch (e2) {
            }
          this.isPlayed = false;
        }
        getAccurateVolumeLevel() {
          if (!this.context || fO() || vO() || this.context.state !== "running" && this.context.resume(), !this.analyserNode)
            return 0;
          const e2 = new Uint8Array(this.analyserNode.frequencyBinCount);
          this.analyserNode.getByteFrequencyData(e2);
          let t2 = 0;
          for (let r2 = 0; r2 < e2.length; r2++)
            t2 += r2 < 64 ? Math.abs(10 * e2[r2]) : Math.abs(6 * e2[r2] / 15);
          return t2 / e2.length / 255;
        }
        async checkHasAudioInput() {
          let e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          if (e2 > 5)
            return this.isNoAudioInput = true, this.onNoAudioInput && this.onNoAudioInput(), false;
          if (fO() || vO() ? this.context.state === "suspended" && this.context.resume() : this.context.state !== "running" && this.context.resume(), !this.analyserNode)
            return false;
          const t2 = new Uint8Array(this.analyserNode.frequencyBinCount);
          this.analyserNode.getByteFrequencyData(t2);
          let r2 = false;
          for (let e3 = 0; e3 < t2.length; e3++)
            t2[e3] !== 0 && (r2 = true);
          return r2 ? (this.isNoAudioInput = false, true) : (await CG(200), await this.checkHasAudioInput(e2 ? e2 + 1 : 1) && r2);
        }
        getAudioVolume() {
          return this.outputNode.gain.value;
        }
        setVolume(e2) {
          this.outputNode.gain.setValueAtTime(e2, this.context.currentTime);
        }
        destroy() {
          this.disconnect(), this.stop(), this.isDestroyed = true, this.onNoAudioInput = void 0;
        }
        injectAudioNode(e2) {
          this.injectNode.addNode(e2);
        }
        removeAudioNode(e2) {
          this.injectNode.removeNode(e2);
        }
        disconnect() {
          var e2, t2;
          (e2 = this.processedNode) === null || e2 === void 0 || e2.disconnect(), (t2 = this.sourceNode) === null || t2 === void 0 || t2.disconnect(), this.outputNode && this.outputNode.disconnect();
        }
        connect() {
          var e2;
          this.processedNode ? (e2 = this.processedNode) === null || e2 === void 0 || e2.connect(this.outputNode) : this.sourceNode && this.sourceNode.connect(this.outputNode);
          this.outputNode.connect(this.analyserNode);
        }
      }
      class zV extends qV {
        get isFreeze() {
          return false;
        }
        constructor(e2, t2) {
          var r2;
          if (super(), kO(this, "sourceNode", void 0), kO(this, "track", void 0), kO(this, "audioElement", void 0), kO(this, "isCurrentTrackCloned", false), kO(this, "isRemoteTrack", false), kO(this, "rebuildWebAudio", async () => {
            if (dD.debug("ready to rebuild web audio, state:", this.context.state), this.isNoAudioInput && await this.checkHasAudioInput(), !this.isNoAudioInput || this.isDestroyed)
              return document.body.removeEventListener("click", this.rebuildWebAudio, true), void dD.debug("rebuild web audio success, current volume status", this.getAccurateVolumeLevel());
            this.context.resume().then(() => dD.info("resume success")), dD.debug("rebuild web audio because of ios 12 bugs"), this.disconnect();
            const e3 = this.track;
            this.track = this.track.clone(), this.isCurrentTrackCloned ? e3.stop() : this.isCurrentTrackCloned = true;
            const t3 = new MediaStream([this.track]);
            this.sourceNode = this.context.createMediaStreamSource(t3), KV(this.sourceNode), this.analyserNode = this.context.createAnalyser();
            const r3 = this.outputNode.gain.value;
            this.outputNode = this.context.createGain(), this.outputNode.gain.setValueAtTime(r3, this.context.currentTime), KV(this.outputNode), this.emit(BP.UPDATE_SOURCE), this.connect(), this.audioElement.srcObject = t3, this.isPlayed && this.play(this.playNode), this.checkHasAudioInput();
          }), e2.kind !== "audio")
            throw new tD(eD.UNEXPECTED_ERROR);
          this.track = e2;
          const i2 = new MediaStream([this.track]);
          this.isRemoteTrack = !!t2, this.sourceNode = this.context.createMediaStreamSource(i2), KV(this.sourceNode), this.connect(), this.audioElement = document.createElement("audio"), this.audioElement.srcObject = i2;
          const n2 = oO();
          t2 && n2.os === eO.IOS && Number((r2 = n2.osVersion) === null || r2 === void 0 ? void 0 : r2.split(".")[0]) < 15 && (VV.on(NV.STATE_CHANGE, () => {
            this.context.state === "suspended" ? document.body.addEventListener("click", this.rebuildWebAudio, true) : this.context.state === "running" && this.rebuildWebAudio();
          }), this.checkHasAudioInput().then((e3) => {
            e3 || document.body.addEventListener("click", this.rebuildWebAudio, true);
          }));
        }
        updateTrack(e2) {
          this.sourceNode.disconnect(), this.track = e2, this.isCurrentTrackCloned = false;
          const t2 = new MediaStream([e2]);
          this.sourceNode = this.context.createMediaStreamSource(t2), KV(this.sourceNode), this.processedNode || this.sourceNode.connect(this.outputNode), this.emit(BP.UPDATE_SOURCE), this.audioElement.srcObject = t2;
        }
        destroy() {
          this.audioElement.srcObject = null, this.audioElement.remove(), VV.off("state-change", this.rebuildWebAudio), super.destroy();
        }
      }
      async function XV(e2, t2) {
        const r2 = (e3, t3) => e3 ? typeof e3 != "number" ? e3.max || e3.exact || e3.ideal || e3.min || t3 : e3 : t3, i2 = { audio: false, video: { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: e2, maxHeight: r2(t2.height, 1080), maxWidth: r2(t2.width, 1920) } } };
        return t2.frameRate && typeof t2.frameRate != "number" ? (i2.video.mandatory.maxFrameRate = t2.frameRate.max, i2.video.mandatory.minFrameRate = t2.frameRate.min) : typeof t2.frameRate == "number" && (i2.video.mandatory.maxFrameRate = t2.frameRate), await navigator.mediaDevices.getUserMedia(i2);
      }
      async function ZV(e2) {
        const t2 = await $V(e2.mediaSource), r2 = await function(e3) {
          return new nR((t3, r3) => {
            const i2 = document.createElement("div");
            i2.innerText = "share screen", i2.setAttribute("style", "text-align: center; height: 25px; line-height: 25px; border-radius: 4px 4px 0 0; background: #D4D2D4; border-bottom:  solid 1px #B9B8B9;");
            const n2 = document.createElement("div");
            n2.setAttribute("style", "width: 100%; height: 500px; padding: 15px 25px ; box-sizing: border-box;");
            const o2 = document.createElement("div");
            o2.innerText = "Agora Web Screensharing wants to share the contents of your screen with webdemo.agorabeckon.com. Choose what you'd like to share.", o2.setAttribute("style", "height: 12%;");
            const s2 = document.createElement("div");
            s2.setAttribute("style", "width: 100%; height: 80%; background: #FFF; border:  solid 1px #CBCBCB; display: flex; flex-wrap: wrap; justify-content: space-around; overflow-y: scroll; padding: 0 15px; box-sizing: border-box;");
            const a2 = document.createElement("div");
            a2.setAttribute("style", "text-align: right; padding: 16px 0;");
            const c2 = document.createElement("button");
            c2.innerHTML = "cancel", c2.setAttribute("style", "width: 85px;"), c2.onclick = () => {
              document.body.removeChild(d2);
              const e4 = new Error("NotAllowedError");
              e4.name = "NotAllowedError", r3(e4);
            }, a2.appendChild(c2), n2.appendChild(o2), n2.appendChild(s2), n2.appendChild(a2);
            const d2 = document.createElement("div");
            d2.setAttribute("style", "position: fixed; z-index: 99999999; top: 50%; left: 50%; width: 620px; height: 525px; background: #ECECEC; border-radius: 4px; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);"), d2.appendChild(i2), d2.appendChild(n2), document.body.appendChild(d2), e3.map((e4) => {
              if (e4.id) {
                const r4 = document.createElement("div");
                r4.setAttribute("style", "width: 30%; height: 160px; padding: 20px 0; text-align: center;box-sizing: content-box;");
                let i3 = e4.thumbnail;
                const { width: n3 } = i3.getSize();
                n3 > 1920 && (i3 = i3.resize({ width: 1920 })), r4.innerHTML = '<div style="height: 120px; display: table-cell; vertical-align: middle;"><img style="width: 100%; background: #333333; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.2);" src=' + i3.toDataURL() + ' /></div><span style="	height: 40px; line-height: 40px; display: inline-block; width: 70%; word-break: keep-all; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + (e4.name.replace(/[\u00A0-\u9999<>\&]/g, function(e5) {
                  return "&#" + e5.charCodeAt(0) + ";";
                }) + "</span>"), r4.onclick = () => {
                  document.body.removeChild(d2), t3(e4.id);
                }, s2.appendChild(r4);
              }
            });
          });
        }(t2);
        return await XV(r2, e2);
      }
      async function $V(e2) {
        let t2 = ["window", "screen"];
        e2 !== "application" && e2 !== "window" || (t2 = ["window"]), e2 === "screen" && (t2 = ["screen"]);
        const r2 = tj();
        if (!r2)
          throw new tD(eD.ELECTRON_IS_NULL);
        let i2 = null;
        try {
          i2 = r2.desktopCapturer.getSources({ types: t2 });
        } catch (e3) {
          i2 = null;
        }
        i2 && i2.then || (i2 = new nR((e3, i3) => {
          r2.desktopCapturer.getSources({ types: t2 }, (t3, r3) => {
            t3 ? i3(t3) : e3(r3);
          });
        }));
        try {
          return await i2;
        } catch (e3) {
          throw new tD(eD.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR, e3.toString());
        }
      }
      let ej = null;
      function tj() {
        if (ej)
          return ej;
        try {
          return ej = window.require("electron"), ej;
        } catch (e2) {
          return null;
        }
      }
      const rj = new kV("safari");
      let ij = false, nj = false;
      async function oj(e2, t2) {
        let r2 = 0, i2 = null;
        for (; r2 < 2; )
          try {
            i2 = await sj(e2, t2, r2 > 0);
            break;
          } catch (i3) {
            if (i3 instanceof tD)
              throw dD.error("[".concat(t2, "] ").concat(i3.toString())), ND("error", [], "getLocalStream", { config: e2, id: t2 }, i3.toString()), i3;
            const n2 = aj(i3.name || i3.code || i3, i3.message);
            if (n2.code === eD.MEDIA_OPTION_INVALID) {
              dD.debug("[".concat(t2, "] detect media option invalid, retry")), TD("debug", [], "[".concat(t2, "] detect media option invalid, retry")), r2 += 1, await CG(500);
              continue;
            }
            throw dD.error("[".concat(t2, "] ").concat(n2.toString())), ND("error", [], "getLocalStream", { config: e2, id: t2 }, n2.toString()), n2;
          }
        if (!i2)
          throw new tD(eD.UNEXPECTED_ERROR, "can not find stream after getUserMedia");
        return i2;
      }
      async function sj(e2, t2, r2) {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)
          throw new tD(eD.NOT_SUPPORTED, "can not find getUserMedia");
        r2 && (e2.video && (delete e2.video.width, delete e2.video.height), e2.screen && (delete e2.screen.width, delete e2.screen.height));
        const i2 = Mk(), n2 = new MediaStream();
        if (e2.audioSource && n2.addTrack(e2.audioSource), e2.videoSource && n2.addTrack(e2.videoSource), !e2.audio && !e2.video && !e2.screen)
          return dD.debug("Using Video Source/ Audio Source"), TD("debug", [], "Using Video Source/ Audio Source"), n2;
        if (e2.screen)
          if (tj())
            if (e2.screen.sourceId) {
              cj(n2, await XV(e2.screen.sourceId, e2.screen));
            } else {
              cj(n2, await ZV(e2.screen));
            }
          else if (lO() && e2.screen.extensionId && e2.screen.mandatory) {
            if (!i2.getStreamFromExtension)
              throw new tD(eD.NOT_SUPPORTED, "This browser does not support screen sharing");
            dD.debug("[".concat(t2, '] Screen access on chrome stable, looking for extension"')), TD("debug", [], "[".concat(t2, '] Screen access on chrome stable, looking for extension"'));
            const r3 = await (o2 = e2.screen.extensionId, s2 = t2, new nR((e3, t3) => {
              try {
                chrome.runtime.sendMessage(o2, { getStream: true }, (r4) => {
                  if (!r4 || !r4.streamId)
                    return dD.error("[".concat(s2, "] No response from Chrome Plugin. Plugin not installed properly"), r4), ND("error", [], "getSourceIdFromExtension", { extensionId: o2, streamId: s2 }, "No response from Chrome Plugin. Plugin not installed properly, ".concat(r4)), void t3(new tD(eD.CHROME_PLUGIN_NO_RESPONSE, "No response from Chrome Plugin. Plugin not installed properly"));
                  e3(r4.streamId);
                });
              } catch (e4) {
                dD.error("[".concat(s2, "] AgoraRTC screensharing plugin is not accessible(").concat(o2, ")"), e4.toString()), ND("error", [], "getSourceIdFromExtension", { extensionId: o2, streamId: s2 }, "AgoraRTC screensharing plugin is not accessible(".concat(o2, "), ").concat(e4.toString())), t3(new tD(eD.CHROME_PLUGIN_NOT_INSTALL));
              }
            }));
            e2.screen.mandatory.chromeMediaSourceId = r3;
            cj(n2, await navigator.mediaDevices.getUserMedia({ video: { mandatory: e2.screen.mandatory } }));
          } else if (i2.getDisplayMedia) {
            e2.screen.mediaSource && mk(e2.screen.mediaSource);
            const r3 = { width: e2.screen.width, height: e2.screen.height, frameRate: e2.screen.frameRate, displaySurface: e2.screen.mediaSource === "screen" ? "monitor" : e2.screen.mediaSource };
            dD.debug("[".concat(t2, "] getDisplayMedia:"), JSON.stringify({ video: r3, audio: !!e2.screenAudio })), DD("debug", ["mediaDevices", t2], "getDisplayMedia", { video: r3, audio: !!e2.screenAudio, trackId: t2 });
            cj(n2, await navigator.mediaDevices.getDisplayMedia({ video: r3, audio: !!e2.screenAudio }));
          } else {
            if (!gO())
              throw dD.error("[".concat(t2, "] This browser does not support screenSharing")), new tD(eD.NOT_SUPPORTED, "This browser does not support screen sharing");
            {
              e2.screen.mediaSource && mk(e2.screen.mediaSource);
              const r3 = { video: { mediaSource: e2.screen.mediaSource, width: e2.screen.width, height: e2.screen.height, frameRate: e2.screen.frameRate } };
              dD.debug("[".concat(t2, "] getUserMedia: ").concat(JSON.stringify(r3))), DD("debug", ["mediaDevices", t2], "getUserMedia", r3);
              cj(n2, await navigator.mediaDevices.getUserMedia(r3));
            }
          }
        var o2, s2;
        if (!e2.video && !e2.audio)
          return n2;
        let a2 = { video: e2.video, audio: e2.audio }, c2 = JD("MEDIA_DEVICE_CONSTRAINTS");
        if (c2)
          try {
            typeof c2 == "string" && (c2 = JSON.parse(c2)), a2 = function e3(t3, r3) {
              if (!GG(t3) || !GG(r3))
                return r3;
              if (Array.isArray(t3) && !Array.isArray(r3) || !Array.isArray(t3) && Array.isArray(r3))
                return r3;
              if (Array.isArray(r3) && Array.isArray(t3)) {
                const i3 = [...t3];
                for (let n3 = 0; n3 < r3.length; n3++)
                  i3[n3] = e3(t3[n3], r3[n3]);
                return i3;
              }
              {
                const i3 = mG({}, t3);
                for (const n3 in r3)
                  Object.prototype.hasOwnProperty.call(r3, n3) && (Object.prototype.hasOwnProperty.call(t3, n3) ? i3[n3] = e3(t3[n3], r3[n3]) : i3[n3] = r3[n3]);
                return i3;
              }
            }(a2, c2), TD("debug", ["mediaDevices", t2], "merge configConstraints ".concat(JSON.stringify(c2)));
          } catch (e3) {
          }
        dD.debug("[".concat(t2, "] GetUserMedia"), JSON.stringify(a2)), DD("debug", ["mediaDevices", t2], "getUserMedia", a2), oO();
        let d2, u2 = null;
        (pO() || fO() || uO()) && (u2 = await rj.lock());
        try {
          d2 = await navigator.mediaDevices.getUserMedia(a2);
        } catch (e3) {
          throw u2 && u2(), e3;
        }
        return a2.audio && (ij = true), a2.video && (nj = true), cj(n2, d2), u2 && u2(), n2;
      }
      function aj(e2, t2) {
        switch (e2) {
          case "Starting video failed":
          case "OverconstrainedError":
          case "TrackStartError":
            return new tD(eD.MEDIA_OPTION_INVALID, "".concat(e2, ": ").concat(t2));
          case "NotFoundError":
          case "DevicesNotFoundError":
            return new tD(eD.DEVICE_NOT_FOUND, "".concat(e2, ": ").concat(t2));
          case "NotSupportedError":
            return new tD(eD.NOT_SUPPORTED, "".concat(e2, ": ").concat(t2));
          case "NotReadableError":
            return new tD(eD.NOT_READABLE, "".concat(e2, ": ").concat(t2));
          case "InvalidStateError":
          case "NotAllowedError":
          case "PERMISSION_DENIED":
          case "PermissionDeniedError":
            return new tD(eD.PERMISSION_DENIED, "".concat(e2, ": ").concat(t2));
          case "ConstraintNotSatisfiedError":
            return new tD(eD.CONSTRAINT_NOT_SATISFIED, "".concat(e2, ": ").concat(t2));
          default:
            return dD.error("getUserMedia unexpected error", e2), ND("error", [], "handleGetUserMediaError", void 0, e2), new tD(eD.UNEXPECTED_ERROR, "".concat(e2, ": ").concat(t2));
        }
      }
      function cj(e2, t2) {
        const r2 = e2.getVideoTracks()[0], i2 = e2.getAudioTracks()[0], n2 = t2.getVideoTracks()[0], o2 = t2.getAudioTracks()[0];
        o2 && (i2 && e2.removeTrack(i2), e2.addTrack(o2)), n2 && (r2 && e2.removeTrack(r2), e2.addTrack(n2));
      }
      const dj = new class extends ZN {
        get state() {
          return this._state;
        }
        set state(e2) {
          e2 !== this._state && (this.emit(mP.STATE_CHANGE, e2), this._state = e2);
        }
        constructor() {
          super(), kO(this, "_state", IP.IDLE), kO(this, "isAccessMicrophonePermission", false), kO(this, "isAccessCameraPermission", false), kO(this, "lastAccessMicrophonePermission", false), kO(this, "lastAccessCameraPermission", false), kO(this, "checkdeviceMatched", false), kO(this, "deviceInfoMap", /* @__PURE__ */ new Map()), this.init().then(() => {
            navigator.mediaDevices.addEventListener && navigator.mediaDevices.addEventListener("devicechange", this.updateDevicesInfo.bind(this)), window.setInterval(() => {
              (JD("ENUMERATE_DEVICES_INTERVAL") || TO() && yO()) && this.updateDevicesInfo();
            }, JD("ENUMERATE_DEVICES_INTERVAL_TIME"));
          }).catch((e2) => dD.error(e2.toString()));
        }
        async enumerateDevices(e2, t2) {
          let r2 = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
          if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
            return new tD(eD.NOT_SUPPORTED, "enumerateDevices() not supported.").throw();
          }
          const i2 = await navigator.mediaDevices.enumerateDevices(), n2 = this.checkMediaDeviceInfoIsOk(i2);
          let o2 = !this.isAccessMicrophonePermission && e2, s2 = !this.isAccessCameraPermission && t2;
          n2.audio && (o2 = false), n2.video && (s2 = false);
          let a2 = null, c2 = null, d2 = null;
          if (!r2 && (o2 || s2)) {
            if (rj.isLocked) {
              dD.debug("[device manager] wait GUM lock");
              (await rj.lock())(), dD.debug("[device manager] GUM unlock");
            }
            if (ij && (o2 = false, this.isAccessMicrophonePermission = true), nj && (s2 = false, this.isAccessCameraPermission = true), dD.debug("[device manager] check media device permissions", e2, t2, o2, s2), o2 && s2) {
              try {
                d2 = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
              } catch (e3) {
                const t3 = aj(e3.name || e3.code || e3, e3.message);
                if (t3.code === eD.PERMISSION_DENIED)
                  throw t3;
                dD.warning("getUserMedia failed in getDevices", t3);
              }
              this.isAccessCameraPermission = true, this.isAccessMicrophonePermission = true;
            } else if (o2) {
              try {
                a2 = await navigator.mediaDevices.getUserMedia({ audio: e2 });
              } catch (e3) {
                const t3 = aj(e3.name || e3.code || e3, e3.message);
                if (t3.code === eD.PERMISSION_DENIED)
                  throw t3;
                dD.warning("getUserMedia failed in getDevices", t3);
              }
              this.isAccessMicrophonePermission = true;
            } else if (s2) {
              try {
                c2 = await navigator.mediaDevices.getUserMedia({ video: t2 });
              } catch (e3) {
                const t3 = aj(e3.name || e3.code || e3, e3.message);
                if (t3.code === eD.PERMISSION_DENIED)
                  throw t3;
                dD.warning("getUserMedia failed in getDevices", t3);
              }
              this.isAccessCameraPermission = true;
            }
            dD.debug("[device manager] mic permission", e2, "cam permission", t2);
          }
          try {
            const e3 = await navigator.mediaDevices.enumerateDevices();
            return a2 && a2.getTracks().forEach((e4) => e4.stop()), c2 && c2.getTracks().forEach((e4) => e4.stop()), d2 && d2.getTracks().forEach((e4) => e4.stop()), a2 = null, c2 = null, d2 = null, e3;
          } catch (e3) {
            a2 && a2.getTracks().forEach((e4) => e4.stop()), c2 && c2.getTracks().forEach((e4) => e4.stop()), d2 && d2.getTracks().forEach((e4) => e4.stop()), a2 = null, c2 = null, d2 = null;
            return new tD(eD.ENUMERATE_DEVICES_FAILED, e3.toString()).throw();
          }
        }
        async getRecordingDevices() {
          let e2 = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
          return (await this.enumerateDevices(true, false, e2)).filter((e3) => e3.kind === "audioinput");
        }
        async getCamerasDevices() {
          let e2 = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
          return (await this.enumerateDevices(false, true, e2)).filter((e3) => e3.kind === "videoinput");
        }
        async getSpeakers() {
          let e2 = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
          return (await this.enumerateDevices(true, false, e2)).filter((e3) => e3.kind === "audiooutput");
        }
        searchDeviceIdByName(e2) {
          let t2 = null;
          return this.deviceInfoMap.forEach((r2) => {
            r2.device.label === e2 && (t2 = r2.device.deviceId);
          }), t2;
        }
        async getDeviceById(e2) {
          const t2 = (await this.enumerateDevices(true, true, true)).find((t3) => t3.deviceId === e2);
          if (!t2)
            throw new tD(eD.DEVICE_NOT_FOUND, "deviceId: ".concat(e2));
          return t2;
        }
        async init() {
          this.state = IP.INITING;
          try {
            await this.updateDevicesInfo(), this.state = IP.INITEND;
          } catch (e2) {
            if (dD.warning("Device Detection functionality cannot start properly.", e2.toString()), this.state = IP.IDLE, !function() {
              if (typeof isSecureContext == "boolean")
                return isSecureContext;
              return location.protocol === "https:" || location.protocol === "file:" || location.hostname === "localhost" || location.hostname === "127.0.0.1" || location.hostname === "::1";
            }()) {
              new tD(eD.WEB_SECURITY_RESTRICT, "Your context is limited by web security, please try using https protocol or localhost.").throw();
            }
            throw e2;
          }
        }
        async updateDevicesInfo() {
          const e2 = await this.enumerateDevices(true, true, true), t2 = Date.now(), r2 = [];
          if (e2[0] && e2[0].label && this.checkdeviceMatched === false) {
            this.checkdeviceMatched = true;
            const t3 = e2.find((e3) => e3.kind === "audioinput" && e3.deviceId === "default"), r3 = e2.find((e3) => e3.kind === "audiooutput" && e3.deviceId === "default");
            t3 && r3 ? r3.groupId === t3.groupId ? dD.debug("[device-check] default input ".concat(t3.label, " and output ").concat(r3.label, " is the same group")) : dD.warning("[device-check] default input ".concat(t3.label, " and output ").concat(r3.label, " is not the same group")) : dD.debug("[device-check] default input or output not found");
          }
          const i2 = this.checkMediaDeviceInfoIsOk(e2);
          if (e2.forEach((e3) => {
            if (!e3.deviceId)
              return;
            const i3 = this.deviceInfoMap.get("".concat(e3.kind, "_").concat(e3.deviceId));
            if ((i3 ? i3.state : "INACTIVE") !== "ACTIVE") {
              const i4 = { initAt: t2, updateAt: t2, device: e3, state: "ACTIVE" };
              this.deviceInfoMap.set("".concat(e3.kind, "_").concat(e3.deviceId), i4), r2.push(i4);
            }
            i3 && (i3.updateAt = t2);
          }), this.deviceInfoMap.forEach((e3, i3) => {
            e3.state === "ACTIVE" && e3.updateAt !== t2 && (e3.state = "INACTIVE", r2.push(e3));
          }), this.state !== IP.INITEND)
            return i2.audio && (this.lastAccessMicrophonePermission = true, this.isAccessMicrophonePermission = true), void (i2.video && (this.lastAccessCameraPermission = true, this.isAccessCameraPermission = true));
          r2.forEach((e3) => {
            switch (e3.device.kind) {
              case "audioinput":
                this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(mP.RECORDING_DEVICE_CHANGED, e3);
                break;
              case "videoinput":
                this.lastAccessCameraPermission && this.isAccessCameraPermission && this.emit(mP.CAMERA_DEVICE_CHANGED, e3);
                break;
              case "audiooutput":
                this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(mP.PLAYOUT_DEVICE_CHANGED, e3);
            }
          }), i2.audio && (this.lastAccessMicrophonePermission = true, this.isAccessMicrophonePermission = true), i2.video && (this.lastAccessCameraPermission = true, this.isAccessCameraPermission = true);
        }
        checkMediaDeviceInfoIsOk(e2) {
          const t2 = e2.filter((e3) => e3.kind === "audioinput"), r2 = e2.filter((e3) => e3.kind === "videoinput"), i2 = { audio: false, video: false };
          for (const e3 of t2)
            if (e3.label && e3.deviceId) {
              i2.audio = true;
              break;
            }
          for (const e3 of r2)
            if (e3.label && e3.deviceId) {
              i2.video = true;
              break;
            }
          return i2;
        }
      }();
      var uj;
      let Aj = PD("AudioElementPlayCenter")(uj = class {
        constructor() {
          kO(this, "onAutoplayFailed", void 0), kO(this, "elementMap", /* @__PURE__ */ new Map()), kO(this, "elementStateMap", /* @__PURE__ */ new Map()), kO(this, "elementsNeedToResume", []), kO(this, "sinkIdMap", /* @__PURE__ */ new Map()), kO(this, "autoResumeAfterInterruption", () => {
            Array.from(this.elementMap.entries()).forEach((e2) => {
              let [t2, r2] = e2;
              const i2 = this.elementStateMap.get(t2), n2 = r2.srcObject.getAudioTracks()[0];
              IO() ? n2 && n2.readyState === "live" && VV.curState === "running" && (dD.debug("auto resume after interruption for iOS 15"), TD("debug", ["AudioElementPlayCenter", t2], "auto resume after interruption for iOS15"), r2.pause(), r2.play()) : i2 && i2 === "paused" && n2 && n2.readyState === "live" && VV.curState === "running" && (dD.debug("auto resume after interruption for iOS"), TD("debug", ["AudioElementPlayCenter", t2], "auto resume after interruption for iOS"), r2.play());
            });
          }), kO(this, "autoResumeAfterInterruptionOnIOS15", () => {
            Array.from(this.elementMap.entries()).forEach((e2) => {
              let [t2, r2] = e2;
              const i2 = r2.srcObject.getAudioTracks()[0];
              i2 && i2.readyState === "live" && (dD.debug("auto resume after interruption inside autoResumeAfterInterruptionOnIOS15"), ND("debug", ["AudioElementPlayCenter", t2], "autoResumeAfterInterruptionOnIOS15"), r2.pause(), r2.play());
            });
          }), this.autoResumeAudioElement(), VV.on(NV.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), VV.on(NV.IOS_15_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15), VV.on(NV.STATE_CHANGE, () => {
            fO() && VV.prevState === "suspended" && VV.curState === "running" && this.autoResumeAfterInterruption();
          });
        }
        async setSinkID(e2, t2) {
          const r2 = this.elementMap.get(e2);
          if (this.sinkIdMap.set(e2, t2), r2)
            try {
              await r2.setSinkId(t2);
            } catch (e3) {
              throw new tD(eD.PERMISSION_DENIED, "can not set sink id: " + e3.toString());
            }
        }
        play(e2, t2, r2, i2) {
          if (this.elementMap.has(t2))
            return;
          const n2 = document.createElement("audio");
          n2.autoplay = true, n2.srcObject = new MediaStream([e2]), this.bindAudioElementEvents(t2, n2), this.elementMap.set(t2, n2), this.elementStateMap.set(t2, dP.INIT), this.setVolume(t2, r2);
          const o2 = this.sinkIdMap.get(t2);
          if (o2)
            try {
              n2.setSinkId(o2).catch((e3) => {
                dD.warning("[".concat(t2, "] set sink id failed"), e3.toString()), DD("warning", ["HTMLAudioElement", t2], "setSinkId", e3.toString());
              });
            } catch (e3) {
              dD.warning("[".concat(t2, "] set sink id failed"), e3.toString());
            }
          const s2 = n2.play();
          s2 && s2.then && s2.catch((e3) => {
            i2 && bV.autoplayFailed(i2, "audio", e3.message, t2), dD.warning("audio element play warning", e3.toString()), DD("warning", ["HTMLAudioElement", t2], "play", e3.toString()), this.elementMap.has(t2) && e3.name === "NotAllowedError" && (dD.warning("detected audio element autoplay failed"), ND("warning", ["AudioElementPlayCenter", t2], "play", e3.toString()), this.elementsNeedToResume.push(n2), kG(() => {
              this.onAutoplayFailed && this.onAutoplayFailed(), vV();
            }));
          });
        }
        updateTrack(e2, t2) {
          const r2 = this.elementMap.get(e2);
          r2 && (r2.srcObject = new MediaStream([t2]));
        }
        isPlaying(e2) {
          return this.elementMap.has(e2);
        }
        setVolume(e2, t2) {
          const r2 = this.elementMap.get(e2);
          r2 && (t2 = Math.max(0, Math.min(100, t2)), r2.volume = t2 / 100);
        }
        stop(e2) {
          const t2 = this.elementMap.get(e2);
          if (this.sinkIdMap.delete(e2), !t2)
            return;
          const r2 = this.elementsNeedToResume.indexOf(t2);
          this.elementsNeedToResume.splice(r2, 1), t2.srcObject = null, t2.remove(), this.elementMap.delete(e2), this.elementStateMap.delete(e2);
        }
        bindAudioElementEvents(e2, t2) {
          hj.forEach((r2) => {
            t2.addEventListener(r2, (t3) => {
              const r3 = this.elementStateMap.get(e2), i2 = t3.type === "pause" ? "paused" : t3.type;
              dD.debug("[".concat(e2, "] audio-element-status change ").concat(r3, " => ").concat(i2)), OD("debug", ["HTMLAudioElement", e2], "statusChange", "".concat(r3, " => ").concat(i2)), this.elementStateMap.set(e2, i2);
            });
          });
        }
        getPlayerState(e2) {
          return this.elementStateMap.get(e2) || "uninit";
        }
        autoResumeAudioElement() {
          const e2 = () => {
            this.elementsNeedToResume.forEach((e3) => {
              e3.play().then((e4) => {
                dD.debug("Auto resume audio element success"), ND("debug", ["AudioElementPlayCenter"], "autoResumeAudioElement");
              }).catch((e4) => {
                dD.warning("Auto resume audio element failed!", e4), ND("warning", ["AudioElementPlayCenter"], "autoResumeAudioElement", e4.toString());
              });
            }), this.elementsNeedToResume = [];
          };
          new nR((e3) => {
            document.body ? e3() : window.addEventListener("load", () => e3());
          }).then(() => {
            const t2 = oO();
            t2.os !== "Android" || t2.name !== "Chrome" && t2.name !== tO.WECHAT ? (document.body.addEventListener("touchstart", e2, true), document.body.addEventListener("mousedown", e2, true)) : document.body.addEventListener("click", e2, true);
          });
        }
      }) || uj;
      const hj = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended"], lj = new Aj();
      function pj() {
        return function(e2, t2, r2) {
          const i2 = e2[t2];
          typeof i2 == "function" && (r2.value = function() {
            this._isClosed && new tD(eD.INVALID_OPERATION, "[".concat(this.getTrackId(), "] cannot operate a closed track")).print("warning");
            for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++)
              t3[r3] = arguments[r3];
            const n2 = i2.apply(this, t3);
            return n2 instanceof nR ? new nR((e4, t4) => {
              n2.then(e4).catch(t4);
            }) : n2;
          });
        };
      }
      var gj, fj, Ej, Ij, mj, _j, Cj, vj, Sj, Rj, yj, Tj, wj, bj, Oj, Nj, Dj, Lj, Pj, kj, Bj, Mj, Uj, Qj, xj, Fj, Vj, jj;
      function Gj(e2, t2) {
        var r2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          t2 && (i2 = i2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), r2.push.apply(r2, i2);
        }
        return r2;
      }
      function Kj(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r2 = arguments[t2] != null ? arguments[t2] : {};
          t2 % 2 ? Gj(Object(r2), true).forEach(function(t3) {
            kO(e2, t3, r2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : Gj(Object(r2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
          });
        }
        return e2;
      }
      let Hj = (gj = PD("LocalAudioTrack", "getTrackId"), fj = pj(), Ej = BV("LocalAudioTrack", "_enabledMutex"), Ij = pj(), mj = BV("LocalAudioTrack", "_enabledMutex"), _j = pj(), Cj = wV({ report: bV }), vj = pj(), Sj = pj(), Rj = pj(), yj = pj(), gj((zF((wj = class extends MV {
        get isPlaying() {
          return this._useAudioElement ? lj.isPlaying(this.getTrackId()) : this._source.isPlayed;
        }
        constructor(e2, t2, r2) {
          super(e2, r2), kO(this, "trackMediaType", "audio"), kO(this, "_encoderConfig", void 0), kO(this, "_source", void 0), kO(this, "_enabled", true), kO(this, "_volume", 100), kO(this, "_useAudioElement", false), kO(this, "_bypassWebAudio", false), kO(this, "processor", void 0), kO(this, "processorContext", void 0), kO(this, "processorDestination", void 0), this._encoderConfig = t2, this._source = new zV(e2), JD("LOCAL_AUDIO_TRACK_USES_WEB_AUDIO") || (this._useAudioElement = true), this.processorContext = new zj(this._source.context, this.getTrackId()), this.processorDestination = new qj(this.processorContext), this.bindProcessorDestinationEvents(), this._source.on(BP.UPDATE_SOURCE, () => {
            this.processor && this.processor.updateInput({ node: this._source.processSourceNode, context: this.processorContext });
          });
        }
        setVolume(e2) {
          ZL(e2, "volume", 0, 1e3);
          const t2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.LOCAL_AUDIO_TRACK_SET_VOLUME, options: [this.getTrackId(), e2] }, 300);
          this._volume = e2, this._source.setVolume(e2 / 100), this._useAudioElement && lj.setVolume(this.getTrackId(), e2);
          try {
            if (this._bypassWebAudio)
              return dD.debug("[".concat(this.getTrackId(), "] setVolume returned because no pass through WebAudio.")), void t2.onSuccess();
            const e3 = this._source.createOutputTrack();
            this._mediaStreamTrack !== e3 && (this._mediaStreamTrack = e3, OG(this, Ak.NEED_REPLACE_TRACK, this).then(() => {
              dD.debug("[".concat(this.getTrackId(), "] replace web audio track success")), TD("debug", this, "replace web audio track success");
            }).catch((e4) => {
              dD.warning("[".concat(this.getTrackId(), "] replace web audio track failed"), e4), TD("warning", this, "replace web audio track failed ".concat(e4.toString()));
            }));
          } catch (e3) {
          }
          t2.onSuccess();
        }
        getVolumeLevel() {
          return this._source.getAccurateVolumeLevel();
        }
        async setPlaybackDevice(e2) {
          const t2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.REMOTE_AUDIO_SET_OUTPUT_DEVICE, options: [this.getTrackId(), e2] });
          if (!this._useAudioElement)
            throw new tD(eD.NOT_SUPPORTED, "your browser does not support setting the audio output device");
          try {
            await lj.setSinkID(this.getTrackId(), e2);
          } catch (e3) {
            throw t2.onError(e3), e3;
          }
          t2.onSuccess();
        }
        async setEnabled(e2, t2, r2) {
          if (!r2) {
            if (e2 === this._enabled)
              return;
            this.stateCheck("enabled", e2);
          }
          if (dD.info("[".concat(this.getTrackId(), "] start setEnabled"), e2), ND("info", this, "setEnabled", e2), e2) {
            this._originMediaStreamTrack.enabled = true;
            try {
              r2 || (this._enabled = true), await OG(this, Ak.NEED_ENABLE_TRACK, this), dD.info("[".concat(this.getTrackId(), "] setEnabled to ").concat(e2, " success")), ND("info", this, "setEnabled", e2, "success");
            } catch (t3) {
              throw r2 || (this._enabled = false), dD.error("[".concat(this.getTrackId(), "] setEnabled to true error"), t3.toString()), ND("error", this, "setEnabled", e2, t3.toString()), t3;
            }
          } else {
            this._originMediaStreamTrack.enabled = false, r2 || (this._enabled = false);
            try {
              await OG(this, Ak.NEED_DISABLE_TRACK, this);
            } catch (t3) {
              throw r2 || (this._enabled = true), dD.error("[".concat(this.getTrackId(), "] setEnabled to false error"), t3.toString()), ND("info", this, "setEnabled", e2, t3.toString()), t3;
            }
          }
        }
        async setMuted(e2) {
          e2 !== this._muted && (this.stateCheck("muted", e2), this._muted = e2, this._mediaStreamTrack.enabled = !e2, dD.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(e2)), ND("debug", this, "setMuted", e2), e2 ? await OG(this, Ak.NEED_MUTE_TRACK, this) : await OG(this, Ak.NEED_UNMUTE_TRACK, this));
        }
        getStats() {
          UG(() => {
            dD.warning("[deprecated] LocalAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalAudioStats instead"), TD("warning", this, "LocalAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalAudioStats instead");
          }, "localAudioTrackGetStatsWarning");
          const e2 = NG(this, Ak.GET_STATS);
          return e2 || Kj({}, VP);
        }
        setAudioFrameCallback(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4096;
          if (!e2)
            return this._source.removeAllListeners(BP.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();
          this._source.startGetAudioBuffer(t2), this._source.removeAllListeners(BP.ON_AUDIO_BUFFER), this._source.on(BP.ON_AUDIO_BUFFER, (t3) => e2(t3));
        }
        play() {
          const e2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.LOCAL_AUDIO_TRACK_PLAY, options: [this.getTrackId()] });
          dD.debug("[".concat(this.getTrackId(), "] start audio playback")), ND("debug", this, "play"), this._useAudioElement ? (dD.debug("[".concat(this.getTrackId(), "] start audio playback in element")), TD("debug", this, "start audio playback in element"), lj.play(this._mediaStreamTrack, this.getTrackId(), this._volume)) : this._source.play(), e2.onSuccess();
        }
        stop() {
          const e2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.LOCAL_AUDIO_TRACK_STOP, options: [this.getTrackId()] });
          dD.debug("[".concat(this.getTrackId(), "] stop audio playback")), ND("debug", this, "stop"), this._useAudioElement ? lj.stop(this.getTrackId()) : this._source.stop(), e2.onSuccess();
        }
        close() {
          super.close(), this.unbindProcessorDestinationEvents(), this.unbindProcessorContextEvents(), this.unpipe(), this.processorDestination._source && this.processorDestination._source.unpipe(), this._source.destroy();
        }
        _updatePlayerSource() {
          dD.debug("[".concat(this.getTrackId(), "] update player source track")), ND("debug", this, "_updatePlayerSource"), this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && lj.updateTrack(this.getTrackId(), this._mediaStreamTrack);
        }
        async _updateOriginMediaStreamTrack(e2, t2) {
          this._originMediaStreamTrack !== e2 && (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), e2.addEventListener("ended", this._handleTrackEnded), t2 && this._originMediaStreamTrack.stop(), this._originMediaStreamTrack = e2, this.processor && this.processor.updateInput({ track: e2, context: this.processorContext }), this._mediaStreamTrack !== this._source.outputTrack ? (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await OG(this, Ak.NEED_REPLACE_TRACK, this)) : this._source.updateTrack(this._originMediaStreamTrack));
        }
        renewMediaStreamTrack(e2) {
          return nR.resolve(void 0);
        }
        pipe(e2) {
          if (this._bypassWebAudio)
            throw new tD(eD.INVALID_OPERATION, "Can not process AudioTrack when bypassWebAudio set to true.");
          if (this.processor === e2)
            return e2;
          if (e2._source)
            throw new tD(eD.INVALID_OPERATION, "Processor ".concat(e2.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e2, this.processor._source = this, e2.updateInput({ track: this._originMediaStreamTrack, node: this._source.processSourceNode, context: this.processorContext }), e2;
        }
        unpipe() {
          var e2;
          if (!this.processor)
            return;
          const t2 = this.processor;
          (e2 = this._source.processSourceNode) === null || e2 === void 0 || e2.disconnect(), this.processor._source = false, this.processor = void 0, t2.reset();
        }
        bindProcessorDestinationEvents() {
          this.processorDestination.on(Pk.ON_TRACK, async (e2) => {
            e2 ? e2 !== this._mediaStreamTrack && (this._mediaStreamTrack = e2, this._updatePlayerSource(), await OG(this, Ak.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await OG(this, Ak.NEED_REPLACE_TRACK, this));
          }), this.processorDestination.on(Pk.ON_NODE, (e2) => {
            this._source.processedNode = e2;
          });
        }
        unbindProcessorDestinationEvents() {
          this.processorDestination.removeAllListeners(Pk.ON_TRACK), this.processorDestination.removeAllListeners(Pk.ON_NODE);
        }
        unbindProcessorContextEvents() {
          this.processorContext.removeAllListeners(kk.REQUEST_UPDATE_CONSTRAINTS), this.processorContext.removeAllListeners(kk.REQUEST_CONSTRAINTS);
        }
      }).prototype, "setPlaybackDevice", [fj], Object.getOwnPropertyDescriptor(wj.prototype, "setPlaybackDevice"), wj.prototype), zF(wj.prototype, "setEnabled", [Ej, Ij], Object.getOwnPropertyDescriptor(wj.prototype, "setEnabled"), wj.prototype), zF(wj.prototype, "setMuted", [mj, _j, Cj], Object.getOwnPropertyDescriptor(wj.prototype, "setMuted"), wj.prototype), zF(wj.prototype, "getStats", [vj], Object.getOwnPropertyDescriptor(wj.prototype, "getStats"), wj.prototype), zF(wj.prototype, "setAudioFrameCallback", [Sj], Object.getOwnPropertyDescriptor(wj.prototype, "setAudioFrameCallback"), wj.prototype), zF(wj.prototype, "play", [Rj], Object.getOwnPropertyDescriptor(wj.prototype, "play"), wj.prototype), zF(wj.prototype, "stop", [yj], Object.getOwnPropertyDescriptor(wj.prototype, "stop"), wj.prototype), Tj = wj)) || Tj), Yj = (bj = PD("MicrophoneAudioTrack", "getTrackId"), Oj = pj(), Nj = BV("MicrophoneAudioTrack", "_enabledMutex"), Dj = pj(), bj((zF((Pj = class extends Hj {
        constructor(e2, t2, r2, i2) {
          super(e2, t2.encoderConfig ? YD(t2.encoderConfig) : {}, i2), kO(this, "_config", void 0), kO(this, "_deviceName", "default"), kO(this, "_constraints", void 0), kO(this, "_originalConstraints", void 0), kO(this, "_enabled", true), LD("info", this, "constructor", { trackId: i2, deviceId: e2.label, constraints: r2 }), this._config = t2, this._constraints = r2, this._originalConstraints = r2, this._deviceName = e2.label, typeof t2.bypassWebAudio == "boolean" && (this._bypassWebAudio = t2.bypassWebAudio), IO() && VV.bindInterruptDetectorTrack(this), this.bindProcessorContextEvents();
        }
        async setDevice(e2) {
          const t2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.MIC_AUDIO_TRACK_SET_DEVICE, options: [this.getTrackId(), e2] });
          if (dD.info("[".concat(this.getTrackId(), "] start set device to ").concat(e2)), ND("info", this, "setDevice", e2), this._enabled)
            try {
              const t3 = await dj.getDeviceById(e2), r2 = {};
              r2.audio = Kj({}, this._constraints), r2.audio.deviceId = { exact: e2 }, this._originMediaStreamTrack.stop();
              let i2 = null;
              try {
                i2 = await oj(r2, this.getTrackId());
              } catch (t4) {
                throw dD.error("[".concat(this.getTrackId(), "] setDevice failed"), t4.toString()), ND("error", this, "setDevice", e2, t4.toString()), i2 = await oj({ video: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(i2.getAudioTracks()[0], false), t4;
              }
              await this._updateOriginMediaStreamTrack(i2.getAudioTracks()[0], false), this._deviceName = t3.label, this._config.microphoneId = e2, this._constraints.deviceId = { exact: e2 };
            } catch (r2) {
              throw t2.onError(r2), dD.error("[".concat(this.getTrackId(), "] setDevice error"), r2.toString()), ND("error", this, "setDevice", e2, r2.toString()), r2;
            }
          else
            try {
              const t3 = await dj.getDeviceById(e2);
              this._deviceName = t3.label, this._config.microphoneId = e2, this._constraints.deviceId = { exact: e2 };
            } catch (r2) {
              throw t2.onError(r2), dD.error("[".concat(this.getTrackId(), "] setDevice error"), r2.toString()), ND("error", this, "setDevice", e2, r2.toString()), r2;
            }
          t2.onSuccess(), dD.info("[".concat(this.getTrackId(), "] set device to ").concat(e2, " success")), ND("info", this, "setDevice", e2, "success");
        }
        async setEnabled(e2, t2, r2) {
          if (t2)
            return dD.debug("[".concat(this.getTrackId, "] setEnabled false (do not close microphone)")), TD("debug", this, "setEnabled false (do not close microphone)"), await super.setEnabled(e2);
          if (!r2) {
            if (e2 === this._enabled)
              return;
            this.stateCheck("enabled", e2);
          }
          if (dD.info("[".concat(this.getTrackId(), "] start setEnabled"), e2), ND("info", this, "setEnabled", e2), !e2) {
            this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop(), r2 || (this._enabled = false);
            try {
              await OG(this, Ak.NEED_DISABLE_TRACK, this);
            } catch (t3) {
              throw dD.error("[".concat(this.getTrackId(), "] setEnabled false failed"), t3.toString()), ND("error", this, "setEnabled", e2, t3.toString()), t3;
            }
            return;
          }
          const i2 = Kj({}, this._constraints), n2 = dj.searchDeviceIdByName(this._deviceName);
          n2 && !i2.deviceId && (i2.deviceId = n2);
          try {
            r2 || (this._enabled = true);
            const e3 = await oj({ audio: this._constraints }, this.getTrackId());
            await this._updateOriginMediaStreamTrack(e3.getAudioTracks()[0], false), await OG(this, Ak.NEED_ENABLE_TRACK, this);
          } catch (t3) {
            throw r2 || (this._enabled = false), dD.error("[".concat(this.getTrackId(), "] setEnabled true failed"), t3.toString()), ND("error", this, "setEnabled", e2, t3.toString()), t3;
          }
          dD.info("[".concat(this.getTrackId(), "] setEnabled success")), ND("info", this, "setEnabled", e2, "success");
        }
        close() {
          super.close(), IO() && VV.unbindInterruptDetectorTrack(this);
        }
        onTrackEnded() {
          if ((fO() || vO()) && this._enabled && !this._isClosed && VV.duringInterruption) {
            const e2 = async () => {
              VV.off(NV.IOS_INTERRUPTION_END, e2), this._enabled && !this._isClosed && (dD.debug("[".concat(this.getTrackId(), "] try capture microphone media device for interrupted iOS device.")), TD("debug", this, "try capture microphone media device for interrupted iOS device"), await this.setEnabled(false), await this.setEnabled(true));
            };
            VV.on(NV.IOS_INTERRUPTION_END, e2);
          } else
            dD.debug("[".concat(this.getTrackId(), "] track ended")), OD("debug", ["MediaStreamTrack", this.getTrackId()], "ended"), this.emit(gk.TRACK_ENDED);
        }
        async renewMediaStreamTrack(e2) {
          const t2 = e2 || this._constraints, r2 = dj.searchDeviceIdByName(this._deviceName);
          r2 && !t2.deviceId && (t2.deviceId = r2), this._constraints = t2, this._originMediaStreamTrack.stop();
          const i2 = await oj({ audio: this._constraints }, this.getTrackId());
          await this._updateOriginMediaStreamTrack(i2.getAudioTracks()[0], true);
        }
        bindProcessorContextEvents() {
          this.processorContext.on(kk.REQUEST_UPDATE_CONSTRAINTS, async (e2, t2, r2) => {
            try {
              const r3 = Object.assign({}, this._originalConstraints, ...e2);
              await this.renewMediaStreamTrack(r3), t2();
            } catch (e3) {
              r2(e3);
            }
          }), this.processorContext.on(kk.REQUEST_CONSTRAINTS, async (e2) => {
            e2(this._originMediaStreamTrack.getSettings());
          });
        }
      }).prototype, "setDevice", [Oj], Object.getOwnPropertyDescriptor(Pj.prototype, "setDevice"), Pj.prototype), zF(Pj.prototype, "setEnabled", [Nj, Dj], Object.getOwnPropertyDescriptor(Pj.prototype, "setEnabled"), Pj.prototype), Lj = Pj)) || Lj), Wj = (kj = PD("BufferSourceAudioTrack", "getTrackId"), Bj = pj(), Mj = pj(), Uj = pj(), Qj = pj(), xj = pj(), kj((zF((Vj = class extends Hj {
        constructor(e2, t2, r2, i2) {
          super(t2.createOutputTrack(), r2, i2), kO(this, "source", void 0), kO(this, "_bufferSource", void 0), LD("info", this, "constructor", { trackId: i2 }), this.source = e2, this._bufferSource = t2, this._bufferSource.on(BP.AUDIO_SOURCE_STATE_CHANGE, (e3) => {
            this.emit(gk.SOURCE_STATE_CHANGE, e3);
          });
          try {
            this._mediaStreamTrack = this._source.createOutputTrack();
          } catch (e3) {
          }
        }
        get currentState() {
          return this._bufferSource.currentState;
        }
        get duration() {
          return this._bufferSource.duration;
        }
        getCurrentTime() {
          return this._bufferSource.currentTime;
        }
        startProcessAudioBuffer(e2) {
          const t2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.BUFFER_AUDIO_TRACK_START, options: [this.getTrackId(), e2, this.duration] });
          e2 && this._bufferSource.updateOptions(e2), this._bufferSource.startProcessAudioBuffer(), t2.onSuccess();
        }
        pauseProcessAudioBuffer() {
          const e2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.BUFFER_AUDIO_TRACK_PAUSE, options: [this.getTrackId()] });
          this._bufferSource.pauseProcessAudioBuffer(), e2.onSuccess();
        }
        seekAudioBuffer(e2) {
          const t2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.BUFFER_AUDIO_TRACK_SEEK, options: [this.getTrackId()] });
          this._bufferSource.seekAudioBuffer(e2), t2.onSuccess();
        }
        resumeProcessAudioBuffer() {
          const e2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.BUFFER_AUDIO_TRACK_RESUME, options: [this.getTrackId()] });
          this._bufferSource.resumeProcessAudioBuffer(), e2.onSuccess();
        }
        stopProcessAudioBuffer() {
          const e2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.BUFFER_AUDIO_TRACK_STOP, options: [this.getTrackId()] });
          this._bufferSource.stopProcessAudioBuffer(), e2.onSuccess();
        }
      }).prototype, "startProcessAudioBuffer", [Bj], Object.getOwnPropertyDescriptor(Vj.prototype, "startProcessAudioBuffer"), Vj.prototype), zF(Vj.prototype, "pauseProcessAudioBuffer", [Mj], Object.getOwnPropertyDescriptor(Vj.prototype, "pauseProcessAudioBuffer"), Vj.prototype), zF(Vj.prototype, "seekAudioBuffer", [Uj], Object.getOwnPropertyDescriptor(Vj.prototype, "seekAudioBuffer"), Vj.prototype), zF(Vj.prototype, "resumeProcessAudioBuffer", [Qj], Object.getOwnPropertyDescriptor(Vj.prototype, "resumeProcessAudioBuffer"), Vj.prototype), zF(Vj.prototype, "stopProcessAudioBuffer", [xj], Object.getOwnPropertyDescriptor(Vj.prototype, "stopProcessAudioBuffer"), Vj.prototype), Fj = Vj)) || Fj), Jj = PD("MixingAudioTrack", "getTrackId")(jj = class extends Hj {
        get isActive() {
          for (const e2 of this.trackList)
            if (e2._enabled && !e2._isClosed && !e2.muted)
              return true;
          return false;
        }
        constructor() {
          const e2 = GV().createMediaStreamDestination();
          super(e2.stream.getAudioTracks()[0], void 0, SG(8, "track-mix-")), kO(this, "trackList", void 0), kO(this, "destNode", void 0);
          try {
            this._mediaStreamTrack = this._source.createOutputTrack();
          } catch (e3) {
          }
          this.destNode = e2, this.trackList = [];
        }
        hasAudioTrack(e2) {
          return this.trackList.indexOf(e2) !== -1;
        }
        addAudioTrack(e2) {
          if (this.trackList.indexOf(e2) !== -1)
            return dD.debug("track ".concat(e2.getTrackId(), " is already added")), void TD("debug", this, "track already added");
          dD.debug("add ".concat(e2.getTrackId(), " to mixing track")), ND("debug", this, "addAudioTrack", e2.getTrackId()), e2._source.outputNode.connect(this.destNode), this.trackList.push(e2), this.updateEncoderConfig();
        }
        removeAudioTrack(e2) {
          if (this.trackList.indexOf(e2) !== -1) {
            dD.debug("remove ".concat(e2.getTrackId(), " from mixing track")), ND("debug", this, "removeAudioTrack", e2.getTrackId());
            try {
              e2._source.outputNode.disconnect(this.destNode);
            } catch (e3) {
            }
            LG(this.trackList, e2), this.updateEncoderConfig();
          }
        }
        updateEncoderConfig() {
          const e2 = {};
          this.trackList.forEach((t2) => {
            t2._encoderConfig && ((t2._encoderConfig.bitrate || 0) > (e2.bitrate || 0) && (e2.bitrate = t2._encoderConfig.bitrate), (t2._encoderConfig.sampleRate || 0) > (e2.sampleRate || 0) && (e2.sampleRate = t2._encoderConfig.sampleRate), (t2._encoderConfig.sampleSize || 0) > (e2.sampleSize || 0) && (e2.sampleSize = t2._encoderConfig.sampleSize), t2._encoderConfig.stereo && (e2.stereo = true));
          }), this._encoderConfig = e2;
        }
      }) || jj;
      class qj extends ZN {
        constructor(e2) {
          super(), kO(this, "name", "AudioProcessorDestination"), kO(this, "ID", "0"), kO(this, "inputTrack", void 0), kO(this, "inputNode", void 0), kO(this, "audioProcessorContext", void 0), kO(this, "_source", void 0), this.audioProcessorContext = e2;
        }
        get kind() {
          return "audio";
        }
        get enabled() {
          return true;
        }
        pipe() {
          throw new tD(eD.NOT_SUPPORTED, "AudioProcessorDestination cannot pipe to any other Processor");
        }
        unpipe() {
          throw new tD(eD.NOT_SUPPORTED, "VideoProcessor cannot unpipe to any other Processor");
        }
        enable() {
        }
        disable() {
        }
        reset() {
          this.inputTrack = void 0, this.inputNode = void 0, this.emit(Pk.ON_TRACK, void 0), this.emit(Pk.ON_NODE, void 0);
        }
        updateInput(e2) {
          if (e2.context !== this.audioProcessorContext)
            throw new Error("ProcessorContext passed to VideoTrack.processorDestination doesn't match it's belonging VideoTrack's context.\n        Probably you are making pipeline like this: audioTrack1.pipe(processor).pipe(audioTrack2.processorDestination).");
          e2.track && this.inputTrack !== e2.track && (this.inputTrack = e2.track, this.emit(Pk.ON_TRACK, this.inputTrack)), e2.node && this.inputNode !== e2.node && (this.inputNode = e2.node, this.emit(Pk.ON_NODE, this.inputNode));
        }
      }
      class zj extends ZN {
        constructor(e2, t2) {
          super(), kO(this, "constraintsMap", /* @__PURE__ */ new Map()), kO(this, "statsRegistry", []), kO(this, "audioContext", void 0), kO(this, "trackId", void 0), this.audioContext = e2, this.trackId = t2;
        }
        async getConstraints() {
          return bG(this, kk.REQUEST_CONSTRAINTS);
        }
        getAudioContext() {
          return this.audioContext;
        }
        async requestApplyConstraints(e2, t2) {
          var r2;
          return dD.info("processor ".concat(t2.name, " requestApplyConstraints for ").concat(this.trackId)), e2 && this.constraintsMap.set(t2, e2), OG(this, kk.REQUEST_UPDATE_CONSTRAINTS, Array.from(nV(r2 = this.constraintsMap).call(r2)));
        }
        async requestRevertConstraints(e2) {
          var t2;
          if (this.constraintsMap.has(e2))
            return this.constraintsMap.delete(e2), OG(this, kk.REQUEST_UPDATE_CONSTRAINTS, Array.from(nV(t2 = this.constraintsMap).call(t2)));
        }
        registerStats(e2, t2, r2) {
          this.statsRegistry.find((r3) => r3.processorID === e2.ID && r3.processorName === e2.name && r3.type === t2) || this.statsRegistry.push({ processorName: e2.name, processorID: e2.ID, type: t2, cb: r2 });
        }
        unregisterStats(e2, t2) {
        }
        gatherStats() {
          return this.statsRegistry.map((e2) => {
            let { processorID: t2, processorName: r2, type: i2, cb: n2 } = e2;
            return { processorID: t2, processorName: r2, type: i2, stats: n2() };
          });
        }
      }
      class Xj extends ZN {
        constructor() {
          super(...arguments), kO(this, "resultStorage", /* @__PURE__ */ new Map());
        }
        setLocalAudioStats(e2, t2, r2) {
          this.record("AUDIO_INPUT_LEVEL_TOO_LOW", e2, this.checkAudioInputLevel(r2, t2)), this.record("SEND_AUDIO_BITRATE_TOO_LOW", e2, this.checkSendAudioBitrate(r2, t2));
        }
        setLocalVideoStats(e2, t2, r2) {
          this.record("SEND_VIDEO_BITRATE_TOO_LOW", e2, this.checkSendVideoBitrate(r2, t2)), this.record("FRAMERATE_INPUT_TOO_LOW", e2, this.checkFramerateInput(r2, t2)), this.record("FRAMERATE_SENT_TOO_LOW", e2, this.checkFramerateSent(r2));
        }
        setRemoteAudioStats(e2, t2) {
          const r2 = e2.getUserId();
          this.record("AUDIO_OUTPUT_LEVEL_TOO_LOW", r2, this.checkAudioOutputLevel(t2));
        }
        setRemoteVideoStats(e2, t2) {
          const r2 = e2.getUserId();
          this.record("RECV_VIDEO_DECODE_FAILED", r2, this.checkVideoDecode(t2));
        }
        record(e2, t2, r2) {
          this.resultStorage.has(e2) || this.resultStorage.set(e2, { result: [], isPrevNormal: true });
          const i2 = this.resultStorage.get(e2);
          if (i2 && (i2.result.push(r2), i2.result.length >= 5)) {
            const r3 = i2.result.includes(true);
            i2.isPrevNormal && !r3 && this.emit("exception", Zj[e2], e2, t2), !i2.isPrevNormal && r3 && this.emit("exception", Zj[e2] + 2e3, e2 + "_RECOVER", t2), i2.isPrevNormal = r3, i2.result = [];
          }
        }
        checkAudioOutputLevel(e2) {
          return !(e2.receiveBitrate > 0 && e2.receiveLevel === 0);
        }
        checkAudioInputLevel(e2, t2) {
          return t2 instanceof Jj && !t2.isActive || (!!t2.muted || e2.sendVolumeLevel !== 0);
        }
        checkFramerateInput(e2, t2) {
          let r2 = null;
          t2._encoderConfig && t2._encoderConfig.frameRate && (r2 = uG(t2._encoderConfig.frameRate));
          const i2 = e2.captureFrameRate;
          return !r2 || !i2 || !(r2 > 10 && i2 < 5 || r2 < 10 && r2 >= 5 && i2 <= 1);
        }
        checkFramerateSent(e2) {
          return !(e2.captureFrameRate && e2.sendFrameRate && e2.captureFrameRate > 5 && e2.sendFrameRate <= 1);
        }
        checkSendVideoBitrate(e2, t2) {
          return !!t2.muted || e2.sendBitrate !== 0;
        }
        checkSendAudioBitrate(e2, t2) {
          return t2 instanceof Jj && !t2.isActive || (!!t2.muted || e2.sendBitrate !== 0);
        }
        checkVideoDecode(e2) {
          return e2.receiveBitrate === 0 || e2.decodeFrameRate !== 0;
        }
      }
      const Zj = { FRAMERATE_INPUT_TOO_LOW: 1001, FRAMERATE_SENT_TOO_LOW: 1002, SEND_VIDEO_BITRATE_TOO_LOW: 1003, RECV_VIDEO_DECODE_FAILED: 1005, AUDIO_INPUT_LEVEL_TOO_LOW: 2001, AUDIO_OUTPUT_LEVEL_TOO_LOW: 2002, SEND_AUDIO_BITRATE_TOO_LOW: 2003 };
      const $j = new class {
        markSubscribeStart(e2, t2) {
          performance.mark("agora-web-sdk/".concat(e2, "/subscribe-").concat(t2));
        }
        markPublishStart(e2, t2) {
          performance.mark("agora-web-sdk/".concat(e2, "/publish-").concat(t2));
        }
        measureFromSubscribeStart(e2, t2) {
          const r2 = performance.getEntriesByName("agora-web-sdk/".concat(e2, "/subscribe-").concat(t2));
          if (r2.length > 0) {
            const e3 = r2[r2.length - 1];
            return Math.round(performance.now() - e3.startTime);
          }
          return 0;
        }
        measureFromPublishStart(e2, t2) {
          const r2 = performance.getEntriesByName("agora-web-sdk/".concat(e2, "/publish-").concat(t2));
          if (r2.length > 0) {
            const e3 = r2[r2.length - 1];
            return Math.round(performance.now() - e3.startTime);
          }
          return 0;
        }
      }();
      function eG(e2, t2) {
        var r2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          t2 && (i2 = i2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), r2.push.apply(r2, i2);
        }
        return r2;
      }
      function tG(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r2 = arguments[t2] != null ? arguments[t2] : {};
          t2 % 2 ? eG(Object(r2), true).forEach(function(t3) {
            kO(e2, t3, r2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : eG(Object(r2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
          });
        }
        return e2;
      }
      class rG {
        constructor(e2) {
          kO(this, "store", void 0), kO(this, "onStatsException", void 0), kO(this, "onUploadPublishDuration", void 0), kO(this, "localStats", /* @__PURE__ */ new Map()), kO(this, "remoteStats", /* @__PURE__ */ new Map()), kO(this, "updateStatsInterval", void 0), kO(this, "trafficStats", void 0), kO(this, "trafficStatsPeerList", []), kO(this, "uplinkStats", void 0), kO(this, "exceptionMonitor", void 0), kO(this, "p2pChannel", void 0), kO(this, "updateStats", () => {
            this.p2pChannel && (this.updateRemoteStats(this.p2pChannel), this.updateLocalStats(this.p2pChannel));
          }), this.store = e2, this.updateStatsInterval = window.setInterval(this.updateStats, 1e3), this.exceptionMonitor = new Xj(), this.exceptionMonitor.on("exception", (e3, t2, r2) => {
            this.onStatsException && this.onStatsException(e3, t2, r2);
          });
        }
        reset() {
          this.localStats = /* @__PURE__ */ new Map(), this.remoteStats = /* @__PURE__ */ new Map(), this.trafficStats = void 0, this.trafficStatsPeerList = [], this.uplinkStats = void 0;
        }
        getLocalAudioTrackStats() {
          return this.localStats.get(Tk.LocalAudioTrack) || tG({}, VP);
        }
        getLocalVideoTrackStats() {
          return this.localStats.get(Tk.LocalVideoTrack) || tG({}, jP);
        }
        getRemoteAudioTrackStats(e2) {
          const t2 = (e3, t3) => {
            if (!this.trafficStats)
              return t3;
            const r3 = this.trafficStats.peer_delay.find((t4) => t4.peer_uid === e3);
            return r3 && (t3.publishDuration = r3.B_ppad + (Date.now() - this.trafficStats.timestamp)), t3;
          }, r2 = {};
          if (e2) {
            var i2;
            const n2 = (i2 = this.remoteStats.get(e2)) === null || i2 === void 0 ? void 0 : i2.audioStats;
            n2 && (r2[e2] = t2(e2, n2));
          } else
            Array.from(this.remoteStats.entries()).forEach((e3) => {
              let [i3, { audioStats: n2 }] = e3;
              n2 && (r2[i3] = t2(i3, n2));
            });
          return r2;
        }
        getRemoteNetworkQualityStats(e2) {
          const t2 = {};
          if (e2) {
            var r2;
            const i2 = (r2 = this.remoteStats.get(e2)) === null || r2 === void 0 ? void 0 : r2.networkStats;
            i2 && (t2[e2] = i2);
          } else
            Array.from(this.remoteStats.entries()).forEach((e3) => {
              let [r3, { networkStats: i2 }] = e3;
              i2 && (t2[r3] = i2);
            });
          return t2;
        }
        getRemoteVideoTrackStats(e2) {
          const t2 = (e3, t3) => {
            if (!this.trafficStats)
              return t3;
            const r3 = this.trafficStats.peer_delay.find((t4) => t4.peer_uid === e3);
            return r3 && (t3.publishDuration = r3.B_ppvd + (Date.now() - this.trafficStats.timestamp)), t3;
          }, r2 = {};
          if (e2) {
            var i2;
            const n2 = (i2 = this.remoteStats.get(e2)) === null || i2 === void 0 ? void 0 : i2.videoStats;
            n2 && (r2[e2] = t2(e2, n2));
          } else
            Array.from(this.remoteStats.entries()).forEach((e3) => {
              let [i3, { videoStats: n2 }] = e3;
              n2 && (r2[i3] = t2(i3, n2));
            });
          return r2;
        }
        getRTCStats() {
          let e2 = 0, t2 = 0, r2 = 0, i2 = 0;
          const n2 = this.localStats.get(Tk.LocalAudioTrack);
          n2 && (e2 += n2.sendBytes, t2 += n2.sendBitrate);
          const o2 = this.localStats.get(Tk.LocalVideoTrack);
          o2 && (e2 += o2.sendBytes, t2 += o2.sendBitrate);
          const s2 = this.localStats.get(Tk.LocalVideoLowTrack);
          s2 && (e2 += s2.sendBytes, t2 += s2.sendBitrate), this.remoteStats.forEach((e3) => {
            let { audioStats: t3, videoStats: n3 } = e3;
            t3 && (r2 += t3.receiveBytes, i2 += t3.receiveBitrate), n3 && (r2 += n3.receiveBytes, i2 += n3.receiveBitrate);
          });
          let a2 = 1;
          return this.trafficStats && (a2 += this.trafficStats.peer_delay.length), { Duration: 0, UserCount: a2, SendBitrate: t2, SendBytes: e2, RecvBytes: r2, RecvBitrate: i2, OutgoingAvailableBandwidth: this.uplinkStats ? this.uplinkStats.B_uab / 1e3 : 0, RTT: this.trafficStats ? 2 * this.trafficStats.B_acd : 0 };
        }
        addLocalStats(e2) {
          this.localStats.set(e2, void 0);
        }
        removeLocalStats(e2) {
          e2 ? this.localStats.delete(e2) : this.localStats.clear();
        }
        addRemoteStats(e2) {
          this.remoteStats.set(e2, {});
        }
        removeRemoteStats(e2) {
          e2 ? this.remoteStats.delete(e2) : this.remoteStats.clear();
        }
        addP2PChannel(e2) {
          this.p2pChannel = e2;
        }
        updateTrafficStats(e2) {
          e2.peer_delay = e2.peer_delay.filter((e3) => e3.B_ppad !== void 0 || e3.B_ppvd !== void 0);
          e2.peer_delay.filter((e3) => this.trafficStatsPeerList.indexOf(e3.peer_uid) === -1).forEach((e3) => {
            var t2;
            const r2 = (t2 = this.p2pChannel) === null || t2 === void 0 ? void 0 : t2.getRemoteMedia(e3.peer_uid), i2 = r2 != null && r2.videoSSRC ? $j.measureFromSubscribeStart(this.store.clientId, r2.videoSSRC) : 0, n2 = r2 != null && r2.audioSSRC ? $j.measureFromSubscribeStart(this.store.clientId, r2.audioSSRC) : 0;
            e3.B_ppad !== void 0 && e3.B_ppvd !== void 0 && (this.onUploadPublishDuration && this.onUploadPublishDuration(e3.peer_uid, e3.B_ppad, e3.B_ppvd, i2 > n2 ? i2 : n2), this.trafficStatsPeerList.push(e3.peer_uid));
          }), this.trafficStats = e2;
        }
        updateUplinkStats(e2) {
          this.uplinkStats && this.uplinkStats.B_fir !== e2.B_fir && dD.debug("[".concat(this.store.clientId, "]: Period fir changes to ").concat(e2.B_fir)), this.uplinkStats = e2;
        }
        static isRemoteVideoFreeze(e2, t2, r2) {
          if (!e2)
            return false;
          const i2 = !!r2 && t2.framesDecodeFreezeTime > r2.framesDecodeFreezeTime, n2 = !r2 || t2.framesDecodeCount > r2.framesDecodeCount;
          return i2 || !n2;
        }
        static isRemoteAudioFreeze(e2) {
          return !!e2 && e2._isFreeze();
        }
        isLocalVideoFreeze(e2) {
          return !(!e2.inputFrame || !e2.sentFrame) && (e2.inputFrame.frameRate > 5 && e2.sentFrame.frameRate < 3);
        }
        updateLocalStats(e2) {
          Array.from(this.localStats.entries()).forEach((t2) => {
            let [r2, i2] = t2;
            switch (r2) {
              case Tk.LocalVideoTrack:
              case Tk.LocalVideoLowTrack: {
                const t3 = i2, n2 = tG({}, jP), o2 = e2.getStats(), s2 = e2.getLocalMedia(r2);
                if (o2) {
                  const r3 = o2.videoSend.find((e3) => e3.ssrc === (s2 == null ? void 0 : s2.ssrcs[0].ssrcId));
                  if (r3) {
                    const i3 = e2.getLocalVideoSize(), o3 = e2.getEncoderConfig(Tk.LocalVideoTrack);
                    r3.codec !== "H264" && r3.codec !== "VP8" && r3.codec !== "VP9" && r3.codec !== "AV1X" && r3.codec !== "AV1" || (n2.codecType = r3.codec), n2.sendBytes = r3.bytes, n2.sendBitrate = t3 ? 8 * Math.max(0, n2.sendBytes - t3.sendBytes) : 0, r3.inputFrame ? (n2.captureFrameRate = r3.inputFrame.frameRate, n2.captureResolutionHeight = r3.inputFrame.height, n2.captureResolutionWidth = r3.inputFrame.width) : i3 && (n2.captureResolutionWidth = i3.width, n2.captureResolutionHeight = i3.height), r3.sentFrame ? (n2.sendFrameRate = r3.sentFrame.frameRate, n2.sendResolutionHeight = r3.sentFrame.height, n2.sendResolutionWidth = r3.sentFrame.width) : i3 && (n2.sendResolutionWidth = i3.width, n2.sendResolutionHeight = i3.height), r3.avgEncodeMs && (n2.encodeDelay = r3.avgEncodeMs), o3 && o3.bitrateMax && (n2.targetSendBitrate = 1e3 * o3.bitrateMax), n2.sendPackets = r3.packets, n2.sendPacketsLost = r3.packetsLost, n2.totalDuration = t3 ? t3.totalDuration + 1 : 1, n2.totalFreezeTime = t3 ? t3.totalFreezeTime : 0, this.isLocalVideoFreeze(r3) && (n2.totalFreezeTime += 1);
                  }
                  this.trafficStats && (n2.sendPacketsLost = this.trafficStats.B_pvlr4 / 100);
                }
                this.localStats.set(r2, n2), n2 && s2 && this.exceptionMonitor.setLocalVideoStats(this.store.uid, s2.track, n2);
                break;
              }
              case Tk.LocalAudioTrack: {
                const t3 = i2, n2 = tG({}, VP), o2 = e2.getStats(), s2 = e2.getLocalMedia(r2);
                if (o2) {
                  const r3 = o2.audioSend.find((e3) => e3.ssrc === (s2 == null ? void 0 : s2.ssrcs[0].ssrcId));
                  if (r3) {
                    if (r3.codec !== "opus" && r3.codec !== "aac" && r3.codec !== "PCMU" && r3.codec !== "PCMA" && r3.codec !== "G722" || (n2.codecType = r3.codec), r3.inputLevel)
                      n2.sendVolumeLevel = Math.round(32767 * r3.inputLevel);
                    else {
                      const t4 = e2.getLocalAudioVolume();
                      t4 && (n2.sendVolumeLevel = Math.round(32767 * t4));
                    }
                    n2.sendBytes = r3.bytes, n2.sendPackets = r3.packets, n2.sendPacketsLost = r3.packetsLost, n2.sendBitrate = t3 ? 8 * Math.max(0, n2.sendBytes - t3.sendBytes) : 0;
                  }
                }
                this.trafficStats && (n2.sendPacketsLost = this.trafficStats.B_pvlr4 / 100), this.localStats.set(Tk.LocalAudioTrack, n2), n2 && s2 && this.exceptionMonitor.setLocalAudioStats(this.store.uid, s2.track, n2);
                break;
              }
            }
          });
        }
        updateRemoteStats(e2) {
          Array.from(this.remoteStats.entries()).forEach((t2) => {
            let [r2, { videoStats: i2, audioStats: n2, videoPcStats: o2 }] = t2;
            const s2 = n2, a2 = i2, c2 = o2, d2 = tG({}, GP), u2 = tG({}, HP), A2 = tG({}, KP), { audioTrack: h2, videoTrack: l2, audioSSRC: p2, videoSSRC: g2 } = e2.getRemoteMedia(r2), f2 = e2.getStats(), E2 = f2 == null ? void 0 : f2.audioRecv.find((e3) => e3.ssrc === p2), I2 = f2 == null ? void 0 : f2.videoRecv.find((e3) => e3.ssrc === g2), m2 = this.trafficStats && this.trafficStats.peer_delay.find((e3) => e3.peer_uid === r2);
            if (E2 && (E2.codec !== "opus" && E2.codec !== "aac" && E2.codec !== "PCMU" && E2.codec !== "PCMA" && E2.codec !== "G722" || (d2.codecType = E2.codec), E2.outputLevel ? d2.receiveLevel = Math.round(32767 * E2.outputLevel) : h2 && (d2.receiveLevel = Math.round(32767 * h2.getVolumeLevel())), d2.receiveBytes = E2.bytes, d2.receivePackets = E2.packets, d2.receivePacketsLost = E2.packetsLost, d2.packetLossRate = d2.receivePacketsLost / (d2.receivePackets + d2.receivePacketsLost), d2.receiveBitrate = s2 ? 8 * Math.max(0, d2.receiveBytes - s2.receiveBytes) : 0, d2.totalDuration = s2 ? s2.totalDuration + 1 : 1, d2.totalFreezeTime = s2 ? s2.totalFreezeTime : 0, d2.freezeRate = d2.totalFreezeTime / d2.totalDuration, d2.receiveDelay = E2.jitterBufferMs, d2.totalDuration > 10 && rG.isRemoteAudioFreeze(h2) && (d2.totalFreezeTime += 1)), I2) {
              I2.codec !== "H264" && I2.codec !== "VP8" && I2.codec !== "VP9" && I2.codec !== "AV1X" && I2.codec !== "AV1" || (u2.codecType = I2.codec), u2.receiveBytes = I2.bytes, u2.receiveBitrate = a2 ? 8 * Math.max(0, u2.receiveBytes - a2.receiveBytes) : 0, u2.decodeFrameRate = I2.decodeFrameRate < 0 ? 0 : I2.decodeFrameRate, u2.renderFrameRate = I2.decodeFrameRate < 0 ? 0 : I2.decodeFrameRate, I2.outputFrame && (u2.renderFrameRate = I2.outputFrame.frameRate), I2.receivedFrame ? (u2.receiveFrameRate = I2.receivedFrame.frameRate, u2.receiveResolutionHeight = I2.receivedFrame.height, u2.receiveResolutionWidth = I2.receivedFrame.width) : l2 && (u2.receiveResolutionHeight = l2._videoHeight || 0, u2.receiveResolutionWidth = l2._videoWidth || 0), I2.framesRateFirefox !== void 0 && (u2.receiveFrameRate = Math.round(I2.framesRateFirefox)), u2.receivePackets = I2.packets, u2.receivePacketsLost = I2.packetsLost, u2.packetLossRate = u2.receivePacketsLost / (u2.receivePackets + u2.receivePacketsLost), u2.totalDuration = a2 ? a2.totalDuration + 1 : 1, u2.totalFreezeTime = a2 ? a2.totalFreezeTime : 0, u2.receiveDelay = I2.jitterBufferMs || 0;
              const t3 = !!g2 && e2.getRemoteVideoIsReady(g2);
              l2 && t3 && rG.isRemoteVideoFreeze(l2, I2, c2) && (u2.totalFreezeTime += 1), u2.freezeRate = u2.totalFreezeTime / u2.totalDuration;
            }
            m2 && (d2.end2EndDelay = m2.B_ad, u2.end2EndDelay = m2.B_vd, d2.transportDelay = m2.B_ed, u2.transportDelay = m2.B_ed, d2.currentPacketLossRate = m2.B_ealr4 / 100, u2.currentPacketLossRate = m2.B_evlr4 / 100, A2.uplinkNetworkQuality = m2.B_punq ? m2.B_punq : 0, A2.downlinkNetworkQuality = m2.B_pdnq ? m2.B_pdnq : 0), this.remoteStats.set(r2, { audioStats: d2, videoStats: u2, videoPcStats: I2, networkStats: A2 }), h2 && this.exceptionMonitor.setRemoteAudioStats(h2, d2), l2 && this.exceptionMonitor.setRemoteVideoStats(l2, u2);
          });
        }
      }
      function iG(e2) {
        return new TextEncoder().encode(e2);
      }
      const nG = async (e2) => function(e3, t2) {
        let r2 = "";
        return new Uint8Array(e3).forEach((e4) => {
          r2 += e4.toString(t2).padStart(2, "0");
        }), r2;
      }(await crypto.subtle.digest("SHA-256", iG(e2)), 16);
      function oG(e2, t2) {
        var r2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          t2 && (i2 = i2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), r2.push.apply(r2, i2);
        }
        return r2;
      }
      function sG(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r2 = arguments[t2] != null ? arguments[t2] : {};
          t2 % 2 ? oG(Object(r2), true).forEach(function(t3) {
            kO(e2, t3, r2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : oG(Object(r2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
          });
        }
        return e2;
      }
      function aG(e2) {
        if (!e2.address || !e2.tcp)
          throw new tD(eD.UNEXPECTED_RESPONSE, "Invalid address format ".concat(e2));
        return e2.address.match(/^[\.\:\d]+$/) ? "".concat(e2.address.replace(/[^\d]/g, "-"), ".edge.agora.io") : (dD.info("Cannot recognized as IP address ".concat(e2.address, ". Used As Host instead")), "".concat(e2.address, ":").concat(e2.tcp));
      }
      function cG(e2) {
        return e2.match(/^[\.\:\d]+$/) ? "".concat(e2.replace(/[^\d]/g, "-"), ".").concat(JD("TURN_DOMAIN")) : (dD.info("Cannot recognized as IP address ".concat(e2, ". Used As Host instead")), e2);
      }
      function dG(e2, t2) {
        const r2 = JD("GATEWAY_DOMAINS");
        let i2 = r2[1] && t2.indexOf(r2[1]) !== -1 ? 1 : 0;
        e2.addresses = e2.addresses || [];
        return { gatewayAddrs: e2.addresses.map((e3) => e3.domain_prefix ? { address: "".concat(e3.domain_prefix, ".").concat(r2[i2++ % r2.length], ":").concat(e3.port) } : e3.ip.match(/^[\.\:\d]+$/) ? { ip: e3.ip, port: e3.port, address: "".concat(e3.ip.replace(/[^\d]/g, "-"), ".").concat(r2[i2++ % r2.length], ":").concat(e3.port) } : (dD.info("Cannot recognized as IP address ".concat(e3.ip, ". Used As Host instead")), { ip: e3.ip, port: e3.port, address: "".concat(e3.ip, ":").concat(e3.port) })), uid: e2.uid, cid: e2.cid, vid: e2.detail && e2.detail[8], uni_lbs_ip: e2.detail && e2.detail[1], res: e2, csIp: e2.detail && e2.detail[502] };
      }
      function uG(e2) {
        return typeof e2 == "number" ? e2 : e2.exact || e2.ideal || e2.max || e2.min || 0;
      }
      function AG(e2) {
        const t2 = e2._encoderConfig;
        if (!t2)
          return {};
        const r2 = { resolution: t2.width && t2.height ? "".concat(uG(t2.width), "x").concat(uG(t2.height)) : void 0, maxVideoBW: t2.bitrateMax, minVideoBW: t2.bitrateMin };
        return typeof t2.frameRate == "number" ? (r2.maxFrameRate = t2.frameRate, r2.minFrameRate = t2.frameRate) : t2.frameRate && (r2.maxFrameRate = t2.frameRate.max || t2.frameRate.ideal || t2.frameRate.exact || t2.frameRate.min, r2.minFrameRate = t2.frameRate.min || t2.frameRate.ideal || t2.frameRate.exact || t2.frameRate.max), r2;
      }
      function hG(e2, t2, r2) {
        var i2;
        const n2 = t2.videoSend.find((t3) => t3.ssrc === e2);
        if (!n2)
          return null;
        const o2 = r2 == null || (i2 = r2.videoSend.find((t3) => t3.ssrc === e2)) === null || i2 === void 0 ? void 0 : i2.inputFrame, s2 = { id: SG(10, ""), timestamp: new Date(t2.timestamp).toISOString(), mediaType: "video", type: "ssrc", ssrc: n2.ssrc.toString() };
        return n2.inputFrame && (o2 && n2.inputFrame.height === o2.height || (s2.A_fhi = n2.inputFrame.height ? n2.inputFrame.height.toString() : "0"), o2 && n2.inputFrame.width === o2.width || (s2.A_fwi = n2.inputFrame.width ? n2.inputFrame.width.toString() : "0"), o2 && n2.inputFrame.frameRate === o2.frameRate || (s2.A_fri = n2.inputFrame.frameRate ? n2.inputFrame.frameRate.toString() : "0")), s2;
      }
      function lG(e2) {
        return e2 >= 0 && e2 < 0.17 ? 1 : e2 >= 0.17 && e2 < 0.36 ? 2 : e2 >= 0.36 && e2 < 0.59 ? 3 : e2 >= 0.59 && e2 <= 1 ? 4 : e2 > 1 ? 5 : 0;
      }
      function pG(e2, t2) {
        let r2, i2, n2 = void 0;
        switch (t2) {
          case Qx.CHOOSE_SERVER:
            r2 = 4096, i2 = "choose server";
            break;
          case Qx.CLOUD_PROXY:
            r2 = 1048576, i2 = "proxy";
            break;
          case Qx.CLOUD_PROXY_5:
            r2 = 4194304, i2 = "proxy5";
            break;
          case Qx.CLOUD_PROXY_FALLBACK:
            r2 = 4194310, i2 = "proxy fallback";
            break;
          default:
            throw new tD(eD.UNEXPECTED_ERROR, "multi unlibs response transformer get unknown service id", { csIp: e2.detail && e2.detail[502], retry: false });
        }
        if (e2.response_body.forEach((t3) => {
          t3.buffer && t3.buffer.flag === r2 && (n2 = { code: t3.buffer.code, addresses: (t3.buffer.edges_services || []).map((e3) => sG(sG({}, e3), {}, { ticket: t3.buffer.cert })), server_ts: e2.enter_ts, uid: t3.buffer.uid, cid: t3.buffer.cid, cname: t3.buffer.cname, detail: sG(sG({}, t3.buffer.detail), e2.detail), flag: t3.buffer.flag, opid: e2.opid });
        }), !n2)
          throw new tD(eD.MULTI_UNILBS_RESPONSE_ERROR, "cannot parse response ".concat(i2, " from multi unilbs response"), { csIp: e2.detail && e2.detail[502] });
        return n2;
      }
      async function gG(e2, t2) {
        return await nR.all(e2.addresses.map(async (e3) => ({ address: cG(e3.ip), tcpport: e3.port, udpport: e3.port, username: t2 && JD("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? t2.toString() : QD.username, password: t2 && JD("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? await nG(t2.toString()) : QD.password })));
      }
      function fG(e2, t2) {
        const r2 = t2._videoHeight || t2.getMediaStreamTrack(true).getSettings().height;
        return r2 ? r2 / uG(e2.height) : 4;
      }
      function EG(e2) {
        let { candidateType: t2, relayProtocol: r2, type: i2, address: n2, port: o2, protocol: s2 } = e2;
        return i2 === "local-candidate" ? { candidateType: t2, relayProtocol: r2, protocol: s2 } : { candidateType: t2, relayProtocol: r2, address: n2, port: o2, protocol: s2 };
      }
      function IG(e2, t2) {
        var r2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          t2 && (i2 = i2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), r2.push.apply(r2, i2);
        }
        return r2;
      }
      function mG(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r2 = arguments[t2] != null ? arguments[t2] : {};
          t2 % 2 ? IG(Object(r2), true).forEach(function(t3) {
            kO(e2, t3, r2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : IG(Object(r2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
          });
        }
        return e2;
      }
      function _G(e2) {
        return window.TextEncoder ? new TextEncoder().encode(e2).length : e2.length;
      }
      function CG(e2) {
        return new nR((t2) => {
          window.setTimeout(t2, e2);
        });
      }
      function vG(e2) {
        const t2 = new tD(eD.TIMEOUT, "timeout");
        return new nR((r2, i2) => {
          window.setTimeout(() => i2(t2), e2);
        });
      }
      function SG() {
        let e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 7, t2 = arguments.length > 1 ? arguments[1] : void 0;
        const r2 = Math.random().toString(16).substr(2, e2).toLowerCase();
        return r2.length === e2 ? "".concat(t2).concat(r2) : "".concat(t2).concat(r2) + SG(e2 - r2.length, "");
      }
      function RG() {
        return SG(32, "").toUpperCase();
      }
      const yG = () => {
      };
      function TG(e2) {
        return new nR((t2, r2) => {
          let i2 = false;
          const n2 = document.createElement("video");
          n2.setAttribute("autoplay", ""), n2.setAttribute("muted", ""), n2.muted = true, n2.autoplay = true, n2.setAttribute("playsinline", ""), n2.setAttribute("style", "position: fixed; top: 0; left: 0; width: 1px; height: 1px"), document.body.appendChild(n2);
          const o2 = fO() ? "canplay" : "playing";
          n2.addEventListener(o2, () => {
            const e3 = n2.videoWidth, r3 = n2.videoHeight;
            !e3 && gO() || (i2 = true, n2.srcObject = null, n2.remove(), t2([e3, r3]));
          }), n2.srcObject = new MediaStream([e2]), n2.play().catch(yG), setTimeout(() => {
            i2 || (n2.srcObject = null, n2.remove(), t2([n2.videoWidth, n2.videoHeight]));
          }, 4e3);
        });
      }
      function wG(e2) {
        return nR.all(e2.map((e3) => e3.then((e4) => {
          throw e4;
        }, (e4) => e4))).then((e3) => {
          throw e3;
        }, (e3) => e3);
      }
      function bG(e2, t2) {
        for (var r2 = arguments.length, i2 = new Array(r2 > 2 ? r2 - 2 : 0), n2 = 2; n2 < r2; n2++)
          i2[n2 - 2] = arguments[n2];
        return e2.getListeners(t2).length === 0 ? nR.reject(new tD(eD.UNEXPECTED_ERROR, "can not emit promise")) : new nR((r3, n3) => {
          e2.emit(t2, ...i2, r3, n3);
        });
      }
      function OG(e2, t2) {
        if (e2.getListeners(t2).length === 0)
          return nR.resolve();
        for (var r2 = arguments.length, i2 = new Array(r2 > 2 ? r2 - 2 : 0), n2 = 2; n2 < r2; n2++)
          i2[n2 - 2] = arguments[n2];
        return bG(e2, t2, ...i2);
      }
      function NG(e2, t2) {
        if (e2.getListeners(t2).length === 0)
          return null;
        for (var r2 = arguments.length, i2 = new Array(r2 > 2 ? r2 - 2 : 0), n2 = 2; n2 < r2; n2++)
          i2[n2 - 2] = arguments[n2];
        return DG(e2, t2, ...i2);
      }
      function DG(e2, t2) {
        let r2 = null, i2 = null;
        for (var n2 = arguments.length, o2 = new Array(n2 > 2 ? n2 - 2 : 0), s2 = 2; s2 < n2; s2++)
          o2[s2 - 2] = arguments[s2];
        if (e2.emit(t2, ...o2, (e3) => {
          r2 = e3;
        }, (e3) => {
          i2 = e3;
        }), i2 !== null)
          throw i2;
        if (r2 === null)
          throw new tD(eD.UNEXPECTED_ERROR, "handler is not sync");
        return r2;
      }
      function LG(e2, t2) {
        const r2 = e2.indexOf(t2);
        r2 !== -1 && e2.splice(r2, 1);
      }
      function PG(e2) {
        const t2 = [];
        return e2.forEach((e3) => {
          t2.indexOf(e3) === -1 && t2.push(e3);
        }), t2;
      }
      function kG(e2) {
        nR.resolve().then(e2);
      }
      function BG(e2) {
        return JSON.parse(JSON.stringify(e2));
      }
      const MG = {};
      function UG(e2, t2) {
        MG[t2] || (MG[t2] = true, e2());
      }
      function QG(e2) {
        const t2 = window.atob(e2), r2 = new Uint8Array(new ArrayBuffer(t2.length));
        for (let e3 = 0; e3 < t2.length; e3 += 1)
          r2[e3] = t2.charCodeAt(e3);
        return r2;
      }
      function xG(e2) {
        let t2 = "";
        for (let r2 = 0; r2 < e2.length; r2 += 1)
          t2 += String.fromCharCode(e2[r2]);
        return window.btoa(t2);
      }
      const FG = new class {
        constructor() {
          kO(this, "fnMap", /* @__PURE__ */ new Map());
        }
        throttleByKey(e2, t2, r2, i2) {
          for (var n2 = arguments.length, o2 = new Array(n2 > 4 ? n2 - 4 : 0), s2 = 4; s2 < n2; s2++)
            o2[s2 - 4] = arguments[s2];
          if (this.fnMap.has(t2)) {
            const n3 = this.fnMap.get(t2);
            if (n3.threshold !== r2) {
              n3.fn(...n3.args), clearTimeout(n3.timer);
              const s3 = window.setTimeout(() => {
                const e3 = this.fnMap.get(t2);
                e3 && e3.fn(...e3.args), this.fnMap.delete(t2);
              }, r2);
              this.fnMap.set(t2, { fn: e2, threshold: r2, timer: s3, args: o2, skipFn: i2 });
            } else
              n3.skipFn && n3.skipFn(...n3.args), this.fnMap.set(t2, mG(mG({}, n3), {}, { fn: e2, args: o2, skipFn: i2 }));
          } else {
            const n3 = window.setTimeout(() => {
              const e3 = this.fnMap.get(t2);
              e3 && e3.fn(...e3.args), this.fnMap.delete(t2);
            }, r2);
            this.fnMap.set(t2, { fn: e2, threshold: r2, timer: n3, args: o2, skipFn: i2 });
          }
        }
      }(), VG = FG.throttleByKey.bind(FG), jG = async (e2) => {
        let { fragementLength: t2, referenceList: r2, asyncMapHandler: i2, allFailedhandler: n2, promisesCollector: o2 } = e2, s2 = 0;
        const a2 = t2;
        let c2, d2 = 0;
        const u2 = async () => {
          const e3 = (() => {
            const e4 = s2 * a2, t3 = e4 + a2;
            return r2.slice(e4, t3).map(i2);
          })();
          o2 && o2.push(...e3);
          try {
            c2 = await wG(e3);
          } catch (e4) {
            if (d2 += a2, s2++, !(d2 >= r2.length))
              return void await u2();
            n2(e4);
          }
          e3.forEach((e4) => e4.cancel());
        };
        return await u2(), c2;
      };
      function GG(e2) {
        return typeof e2 == "object" && e2 !== null && !(e2 instanceof RegExp);
      }
      var KG = bc, HG = Nu("iterator"), YG = !KG(function() {
        var e2 = new URL("b?a=1&b=2&c=3", "http://a"), t2 = e2.searchParams, r2 = "";
        return e2.pathname = "c%20d", t2.forEach(function(e3, i2) {
          t2.delete("b"), r2 += i2 + e3;
        }), !e2.toJSON || !t2.sort || e2.href !== "http://a/c%20d?a=1&c=3" || t2.get("c") !== "3" || String(new URLSearchParams("?a=1")) !== "a=1" || !t2[HG] || new URL("https://a@b").username !== "a" || new URLSearchParams(new URLSearchParams("a=b")).get("a") !== "b" || new URL("http://\u0442\u0435\u0441\u0442").host !== "xn--e1aybc" || new URL("http://a#\u0431").hash !== "#%D0%B1" || r2 !== "a1c3" || new URL("http://x", void 0).host !== "x";
      }), WG = Yc, JG = Bc, qG = qc, zG = bc, XG = Yf, ZG = Lf, $G = zc, eK = Au, tK = hd, rK = Object.assign, iK = Object.defineProperty, nK = JG([].concat), oK = !rK || zG(function() {
        if (WG && rK({ b: 1 }, rK(iK({}, "a", { enumerable: true, get: function() {
          iK(this, "b", { value: 3, enumerable: false });
        } }), { b: 2 })).b !== 1)
          return true;
        var e2 = {}, t2 = {}, r2 = Symbol(), i2 = "abcdefghijklmnopqrst";
        return e2[r2] = 7, i2.split("").forEach(function(e3) {
          t2[e3] = e3;
        }), rK({}, e2)[r2] != 7 || XG(rK({}, t2)).join("") != i2;
      }) ? function(e2, t2) {
        for (var r2 = eK(e2), i2 = arguments.length, n2 = 1, o2 = ZG.f, s2 = $G.f; i2 > n2; )
          for (var a2, c2 = tK(arguments[n2++]), d2 = o2 ? nK(XG(c2), o2(c2)) : XG(c2), u2 = d2.length, A2 = 0; u2 > A2; )
            a2 = d2[A2++], WG && !qG(s2, c2, a2) || (r2[a2] = c2[a2]);
        return r2;
      } : rK, sK = vA, aK = qE, cK = gA, dK = qc, uK = Au, AK = function(e2, t2, r2, i2) {
        try {
          return i2 ? t2(sK(r2)[0], r2[1]) : t2(r2);
        } catch (t3) {
          aK(e2, "throw", t3);
        }
      }, hK = SE, lK = K_, pK = th, gK = aL, fK = HE, EK = QE, IK = Qc.Array, mK = Bc, _K = 2147483647, CK = /[^\0-\u007E]/, vK = /[.\u3002\uFF0E\uFF61]/g, SK = "Overflow: input needs wider integers to process", RK = Qc.RangeError, yK = mK(vK.exec), TK = Math.floor, wK = String.fromCharCode, bK = mK("".charCodeAt), OK = mK([].join), NK = mK([].push), DK = mK("".replace), LK = mK("".split), PK = mK("".toLowerCase), kK = function(e2) {
        return e2 + 22 + 75 * (e2 < 26);
      }, BK = function(e2, t2, r2) {
        var i2 = 0;
        for (e2 = r2 ? TK(e2 / 700) : e2 >> 1, e2 += TK(e2 / t2); e2 > 455; )
          e2 = TK(e2 / 35), i2 += 36;
        return TK(i2 + 36 * e2 / (e2 + 38));
      }, MK = function(e2) {
        var t2, r2, i2 = [], n2 = (e2 = function(e3) {
          for (var t3 = [], r3 = 0, i3 = e3.length; r3 < i3; ) {
            var n3 = bK(e3, r3++);
            if (n3 >= 55296 && n3 <= 56319 && r3 < i3) {
              var o3 = bK(e3, r3++);
              (64512 & o3) == 56320 ? NK(t3, ((1023 & n3) << 10) + (1023 & o3) + 65536) : (NK(t3, n3), r3--);
            } else
              NK(t3, n3);
          }
          return t3;
        }(e2)).length, o2 = 128, s2 = 0, a2 = 72;
        for (t2 = 0; t2 < e2.length; t2++)
          (r2 = e2[t2]) < 128 && NK(i2, wK(r2));
        var c2 = i2.length, d2 = c2;
        for (c2 && NK(i2, "-"); d2 < n2; ) {
          var u2 = _K;
          for (t2 = 0; t2 < e2.length; t2++)
            (r2 = e2[t2]) >= o2 && r2 < u2 && (u2 = r2);
          var A2 = d2 + 1;
          if (u2 - o2 > TK((_K - s2) / A2))
            throw RK(SK);
          for (s2 += (u2 - o2) * A2, o2 = u2, t2 = 0; t2 < e2.length; t2++) {
            if ((r2 = e2[t2]) < o2 && ++s2 > _K)
              throw RK(SK);
            if (r2 == o2) {
              for (var h2 = s2, l2 = 36; ; ) {
                var p2 = l2 <= a2 ? 1 : l2 >= a2 + 26 ? 26 : l2 - a2;
                if (h2 < p2)
                  break;
                var g2 = h2 - p2, f2 = 36 - p2;
                NK(i2, wK(kK(p2 + g2 % f2))), h2 = TK(g2 / f2), l2 += 36;
              }
              NK(i2, wK(kK(h2))), a2 = BK(s2, A2, d2 == c2), s2 = 0, d2++;
            }
          }
          s2++, o2++;
        }
        return OK(i2, "");
      }, UK = Qc.TypeError, QK = JA, xK = Qc, FK = yd, VK = qc, jK = Bc, GK = YG, KK = mm, HK = g_, YK = Um, WK = Km, JK = Am, qK = v_, zK = Kc, XK = pu, ZK = gA, $K = PE, eH = vA, tH = md, rH = hI, iH = hE, nH = rd, oH = HE, sH = QE, aH = function(e2, t2) {
        if (e2 < t2)
          throw UK("Not enough arguments");
        return e2;
      }, cH = mL, dH = Nu("iterator"), uH = "URLSearchParams", AH = "URLSearchParamsIterator", hH = JK.set, lH = JK.getterFor(uH), pH = JK.getterFor(AH), gH = FK("fetch"), fH = FK("Request"), EH = FK("Headers"), IH = fH && fH.prototype, mH = EH && EH.prototype, _H = xK.RegExp, CH = xK.TypeError, vH = xK.decodeURIComponent, SH = xK.encodeURIComponent, RH = jK("".charAt), yH = jK([].join), TH = jK([].push), wH = jK("".replace), bH = jK([].shift), OH = jK([].splice), NH = jK("".split), DH = jK("".slice), LH = /\+/g, PH = Array(4), kH = function(e2) {
        return PH[e2 - 1] || (PH[e2 - 1] = _H("((?:%[\\da-f]{2}){" + e2 + "})", "gi"));
      }, BH = function(e2) {
        try {
          return vH(e2);
        } catch (t2) {
          return e2;
        }
      }, MH = function(e2) {
        var t2 = wH(e2, LH, " "), r2 = 4;
        try {
          return vH(t2);
        } catch (e3) {
          for (; r2; )
            t2 = wH(t2, kH(r2--), BH);
          return t2;
        }
      }, UH = /[!'()~]|%20/g, QH = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+" }, xH = function(e2) {
        return QH[e2];
      }, FH = function(e2) {
        return wH(SH(e2), UH, xH);
      }, VH = WK(function(e2, t2) {
        hH(this, { type: AH, iterator: oH(lH(e2).entries), kind: t2 });
      }, "Iterator", function() {
        var e2 = pH(this), t2 = e2.kind, r2 = e2.iterator.next(), i2 = r2.value;
        return r2.done || (r2.value = t2 === "keys" ? i2.key : t2 === "values" ? i2.value : [i2.key, i2.value]), r2;
      }, true), jH = function(e2) {
        this.entries = [], this.url = null, e2 !== void 0 && (tH(e2) ? this.parseObject(e2) : this.parseQuery(typeof e2 == "string" ? RH(e2, 0) === "?" ? DH(e2, 1) : e2 : rH(e2)));
      };
      jH.prototype = { type: uH, bindURL: function(e2) {
        this.url = e2, this.update();
      }, parseObject: function(e2) {
        var t2, r2, i2, n2, o2, s2, a2, c2 = sH(e2);
        if (c2)
          for (r2 = (t2 = oH(e2, c2)).next; !(i2 = VK(r2, t2)).done; ) {
            if (o2 = (n2 = oH(eH(i2.value))).next, (s2 = VK(o2, n2)).done || (a2 = VK(o2, n2)).done || !VK(o2, n2).done)
              throw CH("Expected sequence with length 2");
            TH(this.entries, { key: rH(s2.value), value: rH(a2.value) });
          }
        else
          for (var d2 in e2)
            XK(e2, d2) && TH(this.entries, { key: d2, value: rH(e2[d2]) });
      }, parseQuery: function(e2) {
        if (e2)
          for (var t2, r2, i2 = NH(e2, "&"), n2 = 0; n2 < i2.length; )
            (t2 = i2[n2++]).length && (r2 = NH(t2, "="), TH(this.entries, { key: MH(bH(r2)), value: MH(yH(r2, "=")) }));
      }, serialize: function() {
        for (var e2, t2 = this.entries, r2 = [], i2 = 0; i2 < t2.length; )
          e2 = t2[i2++], TH(r2, FH(e2.key) + "=" + FH(e2.value));
        return yH(r2, "&");
      }, update: function() {
        this.entries.length = 0, this.parseQuery(this.url.query);
      }, updateURL: function() {
        this.url && this.url.update();
      } };
      var GH = function() {
        qK(this, KH);
        var e2 = arguments.length > 0 ? arguments[0] : void 0;
        hH(this, new jH(e2));
      }, KH = GH.prototype;
      if (HK(KH, { append: function(e2, t2) {
        aH(arguments.length, 2);
        var r2 = lH(this);
        TH(r2.entries, { key: rH(e2), value: rH(t2) }), r2.updateURL();
      }, delete: function(e2) {
        aH(arguments.length, 1);
        for (var t2 = lH(this), r2 = t2.entries, i2 = rH(e2), n2 = 0; n2 < r2.length; )
          r2[n2].key === i2 ? OH(r2, n2, 1) : n2++;
        t2.updateURL();
      }, get: function(e2) {
        aH(arguments.length, 1);
        for (var t2 = lH(this).entries, r2 = rH(e2), i2 = 0; i2 < t2.length; i2++)
          if (t2[i2].key === r2)
            return t2[i2].value;
        return null;
      }, getAll: function(e2) {
        aH(arguments.length, 1);
        for (var t2 = lH(this).entries, r2 = rH(e2), i2 = [], n2 = 0; n2 < t2.length; n2++)
          t2[n2].key === r2 && TH(i2, t2[n2].value);
        return i2;
      }, has: function(e2) {
        aH(arguments.length, 1);
        for (var t2 = lH(this).entries, r2 = rH(e2), i2 = 0; i2 < t2.length; )
          if (t2[i2++].key === r2)
            return true;
        return false;
      }, set: function(e2, t2) {
        aH(arguments.length, 1);
        for (var r2, i2 = lH(this), n2 = i2.entries, o2 = false, s2 = rH(e2), a2 = rH(t2), c2 = 0; c2 < n2.length; c2++)
          (r2 = n2[c2]).key === s2 && (o2 ? OH(n2, c2--, 1) : (o2 = true, r2.value = a2));
        o2 || TH(n2, { key: s2, value: a2 }), i2.updateURL();
      }, sort: function() {
        var e2 = lH(this);
        cH(e2.entries, function(e3, t2) {
          return e3.key > t2.key ? 1 : -1;
        }), e2.updateURL();
      }, forEach: function(e2) {
        for (var t2, r2 = lH(this).entries, i2 = ZK(e2, arguments.length > 1 ? arguments[1] : void 0), n2 = 0; n2 < r2.length; )
          i2((t2 = r2[n2++]).value, t2.key, this);
      }, keys: function() {
        return new VH(this, "keys");
      }, values: function() {
        return new VH(this, "values");
      }, entries: function() {
        return new VH(this, "entries");
      } }, { enumerable: true }), KK(KH, dH, KH.entries, { name: "entries" }), KK(KH, "toString", function() {
        return lH(this).serialize();
      }, { enumerable: true }), YK(GH, uH), QK({ global: true, forced: !GK }, { URLSearchParams: GH }), !GK && zK(EH)) {
        var HH = jK(mH.has), YH = jK(mH.set), WH = function(e2) {
          if (tH(e2)) {
            var t2, r2 = e2.body;
            if ($K(r2) === uH)
              return t2 = e2.headers ? new EH(e2.headers) : new EH(), HH(t2, "content-type") || YH(t2, "content-type", "application/x-www-form-urlencoded;charset=UTF-8"), iH(e2, { body: nH(0, rH(r2)), headers: nH(0, t2) });
          }
          return e2;
        };
        if (zK(gH) && QK({ global: true, enumerable: true, forced: true }, { fetch: function(e2) {
          return gH(e2, arguments.length > 1 ? WH(arguments[1]) : {});
        } }), zK(fH)) {
          var JH = function(e2) {
            return qK(this, IH), new fH(e2, arguments.length > 1 ? WH(arguments[1]) : {});
          };
          IH.constructor = JH, JH.prototype = IH, QK({ global: true, forced: true }, { Request: JH });
        }
      }
      var qH, zH = { URLSearchParams: GH, getState: lH }, XH = JA, ZH = Yc, $H = YG, eY = Qc, tY = gA, rY = Bc, iY = Gf.f, nY = mm, oY = v_, sY = pu, aY = oK, cY = function(e2) {
        var t2 = uK(e2), r2 = lK(this), i2 = arguments.length, n2 = i2 > 1 ? arguments[1] : void 0, o2 = n2 !== void 0;
        o2 && (n2 = cK(n2, i2 > 2 ? arguments[2] : void 0));
        var s2, a2, c2, d2, u2, A2, h2 = EK(t2), l2 = 0;
        if (!h2 || this == IK && hK(h2))
          for (s2 = pK(t2), a2 = r2 ? new this(s2) : IK(s2); s2 > l2; l2++)
            A2 = o2 ? n2(t2[l2], l2) : t2[l2], gK(a2, l2, A2);
        else
          for (u2 = (d2 = fK(t2, h2)).next, a2 = r2 ? new this() : []; !(c2 = dK(u2, d2)).done; l2++)
            A2 = o2 ? AK(d2, n2, [c2.value, l2], true) : c2.value, gK(a2, l2, A2);
        return a2.length = l2, a2;
      }, dY = lL, uY = xS.codeAt, AY = function(e2) {
        var t2, r2, i2 = [], n2 = LK(DK(PK(e2), vK, "."), ".");
        for (t2 = 0; t2 < n2.length; t2++)
          r2 = n2[t2], NK(i2, yK(CK, r2) ? "xn--" + MK(r2) : r2);
        return OK(i2, ".");
      }, hY = hI, lY = Um, pY = zH, gY = Am, fY = gY.set, EY = gY.getterFor("URL"), IY = pY.URLSearchParams, mY = pY.getState, _Y = eY.URL, CY = eY.TypeError, vY = eY.parseInt, SY = Math.floor, RY = Math.pow, yY = rY("".charAt), TY = rY(/./.exec), wY = rY([].join), bY = rY(1 .toString), OY = rY([].pop), NY = rY([].push), DY = rY("".replace), LY = rY([].shift), PY = rY("".split), kY = rY("".slice), BY = rY("".toLowerCase), MY = rY([].unshift), UY = "Invalid scheme", QY = "Invalid host", xY = "Invalid port", FY = /[a-z]/i, VY = /[\d+-.a-z]/i, jY = /\d/, GY = /^0x/i, KY = /^[0-7]+$/, HY = /^\d+$/, YY = /^[\da-f]+$/i, WY = /[\0\t\n\r #%/:<>?@[\\\]^|]/, JY = /[\0\t\n\r #/:<>?@[\\\]^|]/, qY = /^[\u0000-\u0020]+|[\u0000-\u0020]+$/g, zY = /[\t\n\r]/g, XY = function(e2) {
        var t2, r2, i2, n2;
        if (typeof e2 == "number") {
          for (t2 = [], r2 = 0; r2 < 4; r2++)
            MY(t2, e2 % 256), e2 = SY(e2 / 256);
          return wY(t2, ".");
        }
        if (typeof e2 == "object") {
          for (t2 = "", i2 = function(e3) {
            for (var t3 = null, r3 = 1, i3 = null, n3 = 0, o2 = 0; o2 < 8; o2++)
              e3[o2] !== 0 ? (n3 > r3 && (t3 = i3, r3 = n3), i3 = null, n3 = 0) : (i3 === null && (i3 = o2), ++n3);
            return n3 > r3 && (t3 = i3, r3 = n3), t3;
          }(e2), r2 = 0; r2 < 8; r2++)
            n2 && e2[r2] === 0 || (n2 && (n2 = false), i2 === r2 ? (t2 += r2 ? ":" : "::", n2 = true) : (t2 += bY(e2[r2], 16), r2 < 7 && (t2 += ":")));
          return "[" + t2 + "]";
        }
        return e2;
      }, ZY = {}, $Y = aY({}, ZY, { " ": 1, '"': 1, "<": 1, ">": 1, "`": 1 }), eW = aY({}, $Y, { "#": 1, "?": 1, "{": 1, "}": 1 }), tW = aY({}, eW, { "/": 1, ":": 1, ";": 1, "=": 1, "@": 1, "[": 1, "\\": 1, "]": 1, "^": 1, "|": 1 }), rW = function(e2, t2) {
        var r2 = uY(e2, 0);
        return r2 > 32 && r2 < 127 && !sY(t2, e2) ? e2 : encodeURIComponent(e2);
      }, iW = { ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443 }, nW = function(e2, t2) {
        var r2;
        return e2.length == 2 && TY(FY, yY(e2, 0)) && ((r2 = yY(e2, 1)) == ":" || !t2 && r2 == "|");
      }, oW = function(e2) {
        var t2;
        return e2.length > 1 && nW(kY(e2, 0, 2)) && (e2.length == 2 || (t2 = yY(e2, 2)) === "/" || t2 === "\\" || t2 === "?" || t2 === "#");
      }, sW = function(e2) {
        return e2 === "." || BY(e2) === "%2e";
      }, aW = {}, cW = {}, dW = {}, uW = {}, AW = {}, hW = {}, lW = {}, pW = {}, gW = {}, fW = {}, EW = {}, IW = {}, mW = {}, _W = {}, CW = {}, vW = {}, SW = {}, RW = {}, yW = {}, TW = {}, wW = {}, bW = function(e2, t2, r2) {
        var i2, n2, o2, s2 = hY(e2);
        if (t2) {
          if (n2 = this.parse(s2))
            throw CY(n2);
          this.searchParams = null;
        } else {
          if (r2 !== void 0 && (i2 = new bW(r2, true)), n2 = this.parse(s2, null, i2))
            throw CY(n2);
          (o2 = mY(new IY())).bindURL(this), this.searchParams = o2;
        }
      };
      bW.prototype = { type: "URL", parse: function(e2, t2, r2) {
        var i2, n2, o2, s2, a2, c2 = this, d2 = t2 || aW, u2 = 0, A2 = "", h2 = false, l2 = false, p2 = false;
        for (e2 = hY(e2), t2 || (c2.scheme = "", c2.username = "", c2.password = "", c2.host = null, c2.port = null, c2.path = [], c2.query = null, c2.fragment = null, c2.cannotBeABaseURL = false, e2 = DY(e2, qY, "")), e2 = DY(e2, zY, ""), i2 = cY(e2); u2 <= i2.length; ) {
          switch (n2 = i2[u2], d2) {
            case aW:
              if (!n2 || !TY(FY, n2)) {
                if (t2)
                  return UY;
                d2 = dW;
                continue;
              }
              A2 += BY(n2), d2 = cW;
              break;
            case cW:
              if (n2 && (TY(VY, n2) || n2 == "+" || n2 == "-" || n2 == "."))
                A2 += BY(n2);
              else {
                if (n2 != ":") {
                  if (t2)
                    return UY;
                  A2 = "", d2 = dW, u2 = 0;
                  continue;
                }
                if (t2 && (c2.isSpecial() != sY(iW, A2) || A2 == "file" && (c2.includesCredentials() || c2.port !== null) || c2.scheme == "file" && !c2.host))
                  return;
                if (c2.scheme = A2, t2)
                  return void (c2.isSpecial() && iW[c2.scheme] == c2.port && (c2.port = null));
                A2 = "", c2.scheme == "file" ? d2 = _W : c2.isSpecial() && r2 && r2.scheme == c2.scheme ? d2 = uW : c2.isSpecial() ? d2 = pW : i2[u2 + 1] == "/" ? (d2 = AW, u2++) : (c2.cannotBeABaseURL = true, NY(c2.path, ""), d2 = yW);
              }
              break;
            case dW:
              if (!r2 || r2.cannotBeABaseURL && n2 != "#")
                return UY;
              if (r2.cannotBeABaseURL && n2 == "#") {
                c2.scheme = r2.scheme, c2.path = dY(r2.path), c2.query = r2.query, c2.fragment = "", c2.cannotBeABaseURL = true, d2 = wW;
                break;
              }
              d2 = r2.scheme == "file" ? _W : hW;
              continue;
            case uW:
              if (n2 != "/" || i2[u2 + 1] != "/") {
                d2 = hW;
                continue;
              }
              d2 = gW, u2++;
              break;
            case AW:
              if (n2 == "/") {
                d2 = fW;
                break;
              }
              d2 = RW;
              continue;
            case hW:
              if (c2.scheme = r2.scheme, n2 == qH)
                c2.username = r2.username, c2.password = r2.password, c2.host = r2.host, c2.port = r2.port, c2.path = dY(r2.path), c2.query = r2.query;
              else if (n2 == "/" || n2 == "\\" && c2.isSpecial())
                d2 = lW;
              else if (n2 == "?")
                c2.username = r2.username, c2.password = r2.password, c2.host = r2.host, c2.port = r2.port, c2.path = dY(r2.path), c2.query = "", d2 = TW;
              else {
                if (n2 != "#") {
                  c2.username = r2.username, c2.password = r2.password, c2.host = r2.host, c2.port = r2.port, c2.path = dY(r2.path), c2.path.length--, d2 = RW;
                  continue;
                }
                c2.username = r2.username, c2.password = r2.password, c2.host = r2.host, c2.port = r2.port, c2.path = dY(r2.path), c2.query = r2.query, c2.fragment = "", d2 = wW;
              }
              break;
            case lW:
              if (!c2.isSpecial() || n2 != "/" && n2 != "\\") {
                if (n2 != "/") {
                  c2.username = r2.username, c2.password = r2.password, c2.host = r2.host, c2.port = r2.port, d2 = RW;
                  continue;
                }
                d2 = fW;
              } else
                d2 = gW;
              break;
            case pW:
              if (d2 = gW, n2 != "/" || yY(A2, u2 + 1) != "/")
                continue;
              u2++;
              break;
            case gW:
              if (n2 != "/" && n2 != "\\") {
                d2 = fW;
                continue;
              }
              break;
            case fW:
              if (n2 == "@") {
                h2 && (A2 = "%40" + A2), h2 = true, o2 = cY(A2);
                for (var g2 = 0; g2 < o2.length; g2++) {
                  var f2 = o2[g2];
                  if (f2 != ":" || p2) {
                    var E2 = rW(f2, tW);
                    p2 ? c2.password += E2 : c2.username += E2;
                  } else
                    p2 = true;
                }
                A2 = "";
              } else if (n2 == qH || n2 == "/" || n2 == "?" || n2 == "#" || n2 == "\\" && c2.isSpecial()) {
                if (h2 && A2 == "")
                  return "Invalid authority";
                u2 -= cY(A2).length + 1, A2 = "", d2 = EW;
              } else
                A2 += n2;
              break;
            case EW:
            case IW:
              if (t2 && c2.scheme == "file") {
                d2 = vW;
                continue;
              }
              if (n2 != ":" || l2) {
                if (n2 == qH || n2 == "/" || n2 == "?" || n2 == "#" || n2 == "\\" && c2.isSpecial()) {
                  if (c2.isSpecial() && A2 == "")
                    return QY;
                  if (t2 && A2 == "" && (c2.includesCredentials() || c2.port !== null))
                    return;
                  if (s2 = c2.parseHost(A2))
                    return s2;
                  if (A2 = "", d2 = SW, t2)
                    return;
                  continue;
                }
                n2 == "[" ? l2 = true : n2 == "]" && (l2 = false), A2 += n2;
              } else {
                if (A2 == "")
                  return QY;
                if (s2 = c2.parseHost(A2))
                  return s2;
                if (A2 = "", d2 = mW, t2 == IW)
                  return;
              }
              break;
            case mW:
              if (!TY(jY, n2)) {
                if (n2 == qH || n2 == "/" || n2 == "?" || n2 == "#" || n2 == "\\" && c2.isSpecial() || t2) {
                  if (A2 != "") {
                    var I2 = vY(A2, 10);
                    if (I2 > 65535)
                      return xY;
                    c2.port = c2.isSpecial() && I2 === iW[c2.scheme] ? null : I2, A2 = "";
                  }
                  if (t2)
                    return;
                  d2 = SW;
                  continue;
                }
                return xY;
              }
              A2 += n2;
              break;
            case _W:
              if (c2.scheme = "file", n2 == "/" || n2 == "\\")
                d2 = CW;
              else {
                if (!r2 || r2.scheme != "file") {
                  d2 = RW;
                  continue;
                }
                if (n2 == qH)
                  c2.host = r2.host, c2.path = dY(r2.path), c2.query = r2.query;
                else if (n2 == "?")
                  c2.host = r2.host, c2.path = dY(r2.path), c2.query = "", d2 = TW;
                else {
                  if (n2 != "#") {
                    oW(wY(dY(i2, u2), "")) || (c2.host = r2.host, c2.path = dY(r2.path), c2.shortenPath()), d2 = RW;
                    continue;
                  }
                  c2.host = r2.host, c2.path = dY(r2.path), c2.query = r2.query, c2.fragment = "", d2 = wW;
                }
              }
              break;
            case CW:
              if (n2 == "/" || n2 == "\\") {
                d2 = vW;
                break;
              }
              r2 && r2.scheme == "file" && !oW(wY(dY(i2, u2), "")) && (nW(r2.path[0], true) ? NY(c2.path, r2.path[0]) : c2.host = r2.host), d2 = RW;
              continue;
            case vW:
              if (n2 == qH || n2 == "/" || n2 == "\\" || n2 == "?" || n2 == "#") {
                if (!t2 && nW(A2))
                  d2 = RW;
                else if (A2 == "") {
                  if (c2.host = "", t2)
                    return;
                  d2 = SW;
                } else {
                  if (s2 = c2.parseHost(A2))
                    return s2;
                  if (c2.host == "localhost" && (c2.host = ""), t2)
                    return;
                  A2 = "", d2 = SW;
                }
                continue;
              }
              A2 += n2;
              break;
            case SW:
              if (c2.isSpecial()) {
                if (d2 = RW, n2 != "/" && n2 != "\\")
                  continue;
              } else if (t2 || n2 != "?")
                if (t2 || n2 != "#") {
                  if (n2 != qH && (d2 = RW, n2 != "/"))
                    continue;
                } else
                  c2.fragment = "", d2 = wW;
              else
                c2.query = "", d2 = TW;
              break;
            case RW:
              if (n2 == qH || n2 == "/" || n2 == "\\" && c2.isSpecial() || !t2 && (n2 == "?" || n2 == "#")) {
                if ((a2 = BY(a2 = A2)) === ".." || a2 === "%2e." || a2 === ".%2e" || a2 === "%2e%2e" ? (c2.shortenPath(), n2 == "/" || n2 == "\\" && c2.isSpecial() || NY(c2.path, "")) : sW(A2) ? n2 == "/" || n2 == "\\" && c2.isSpecial() || NY(c2.path, "") : (c2.scheme == "file" && !c2.path.length && nW(A2) && (c2.host && (c2.host = ""), A2 = yY(A2, 0) + ":"), NY(c2.path, A2)), A2 = "", c2.scheme == "file" && (n2 == qH || n2 == "?" || n2 == "#"))
                  for (; c2.path.length > 1 && c2.path[0] === ""; )
                    LY(c2.path);
                n2 == "?" ? (c2.query = "", d2 = TW) : n2 == "#" && (c2.fragment = "", d2 = wW);
              } else
                A2 += rW(n2, eW);
              break;
            case yW:
              n2 == "?" ? (c2.query = "", d2 = TW) : n2 == "#" ? (c2.fragment = "", d2 = wW) : n2 != qH && (c2.path[0] += rW(n2, ZY));
              break;
            case TW:
              t2 || n2 != "#" ? n2 != qH && (n2 == "'" && c2.isSpecial() ? c2.query += "%27" : c2.query += n2 == "#" ? "%23" : rW(n2, ZY)) : (c2.fragment = "", d2 = wW);
              break;
            case wW:
              n2 != qH && (c2.fragment += rW(n2, $Y));
          }
          u2++;
        }
      }, parseHost: function(e2) {
        var t2, r2, i2;
        if (yY(e2, 0) == "[") {
          if (yY(e2, e2.length - 1) != "]")
            return QY;
          if (!(t2 = function(e3) {
            var t3, r3, i3, n2, o2, s2, a2, c2 = [0, 0, 0, 0, 0, 0, 0, 0], d2 = 0, u2 = null, A2 = 0, h2 = function() {
              return yY(e3, A2);
            };
            if (h2() == ":") {
              if (yY(e3, 1) != ":")
                return;
              A2 += 2, u2 = ++d2;
            }
            for (; h2(); ) {
              if (d2 == 8)
                return;
              if (h2() != ":") {
                for (t3 = r3 = 0; r3 < 4 && TY(YY, h2()); )
                  t3 = 16 * t3 + vY(h2(), 16), A2++, r3++;
                if (h2() == ".") {
                  if (r3 == 0)
                    return;
                  if (A2 -= r3, d2 > 6)
                    return;
                  for (i3 = 0; h2(); ) {
                    if (n2 = null, i3 > 0) {
                      if (!(h2() == "." && i3 < 4))
                        return;
                      A2++;
                    }
                    if (!TY(jY, h2()))
                      return;
                    for (; TY(jY, h2()); ) {
                      if (o2 = vY(h2(), 10), n2 === null)
                        n2 = o2;
                      else {
                        if (n2 == 0)
                          return;
                        n2 = 10 * n2 + o2;
                      }
                      if (n2 > 255)
                        return;
                      A2++;
                    }
                    c2[d2] = 256 * c2[d2] + n2, ++i3 != 2 && i3 != 4 || d2++;
                  }
                  if (i3 != 4)
                    return;
                  break;
                }
                if (h2() == ":") {
                  if (A2++, !h2())
                    return;
                } else if (h2())
                  return;
                c2[d2++] = t3;
              } else {
                if (u2 !== null)
                  return;
                A2++, u2 = ++d2;
              }
            }
            if (u2 !== null)
              for (s2 = d2 - u2, d2 = 7; d2 != 0 && s2 > 0; )
                a2 = c2[d2], c2[d2--] = c2[u2 + s2 - 1], c2[u2 + --s2] = a2;
            else if (d2 != 8)
              return;
            return c2;
          }(kY(e2, 1, -1))))
            return QY;
          this.host = t2;
        } else if (this.isSpecial()) {
          if (e2 = AY(e2), TY(WY, e2))
            return QY;
          if ((t2 = function(e3) {
            var t3, r3, i3, n2, o2, s2, a2, c2 = PY(e3, ".");
            if (c2.length && c2[c2.length - 1] == "" && c2.length--, (t3 = c2.length) > 4)
              return e3;
            for (r3 = [], i3 = 0; i3 < t3; i3++) {
              if ((n2 = c2[i3]) == "")
                return e3;
              if (o2 = 10, n2.length > 1 && yY(n2, 0) == "0" && (o2 = TY(GY, n2) ? 16 : 8, n2 = kY(n2, o2 == 8 ? 1 : 2)), n2 === "")
                s2 = 0;
              else {
                if (!TY(o2 == 10 ? HY : o2 == 8 ? KY : YY, n2))
                  return e3;
                s2 = vY(n2, o2);
              }
              NY(r3, s2);
            }
            for (i3 = 0; i3 < t3; i3++)
              if (s2 = r3[i3], i3 == t3 - 1) {
                if (s2 >= RY(256, 5 - t3))
                  return null;
              } else if (s2 > 255)
                return null;
            for (a2 = OY(r3), i3 = 0; i3 < r3.length; i3++)
              a2 += r3[i3] * RY(256, 3 - i3);
            return a2;
          }(e2)) === null)
            return QY;
          this.host = t2;
        } else {
          if (TY(JY, e2))
            return QY;
          for (t2 = "", r2 = cY(e2), i2 = 0; i2 < r2.length; i2++)
            t2 += rW(r2[i2], ZY);
          this.host = t2;
        }
      }, cannotHaveUsernamePasswordPort: function() {
        return !this.host || this.cannotBeABaseURL || this.scheme == "file";
      }, includesCredentials: function() {
        return this.username != "" || this.password != "";
      }, isSpecial: function() {
        return sY(iW, this.scheme);
      }, shortenPath: function() {
        var e2 = this.path, t2 = e2.length;
        !t2 || this.scheme == "file" && t2 == 1 && nW(e2[0], true) || e2.length--;
      }, serialize: function() {
        var e2 = this, t2 = e2.scheme, r2 = e2.username, i2 = e2.password, n2 = e2.host, o2 = e2.port, s2 = e2.path, a2 = e2.query, c2 = e2.fragment, d2 = t2 + ":";
        return n2 !== null ? (d2 += "//", e2.includesCredentials() && (d2 += r2 + (i2 ? ":" + i2 : "") + "@"), d2 += XY(n2), o2 !== null && (d2 += ":" + o2)) : t2 == "file" && (d2 += "//"), d2 += e2.cannotBeABaseURL ? s2[0] : s2.length ? "/" + wY(s2, "/") : "", a2 !== null && (d2 += "?" + a2), c2 !== null && (d2 += "#" + c2), d2;
      }, setHref: function(e2) {
        var t2 = this.parse(e2);
        if (t2)
          throw CY(t2);
        this.searchParams.update();
      }, getOrigin: function() {
        var e2 = this.scheme, t2 = this.port;
        if (e2 == "blob")
          try {
            return new OW(e2.path[0]).origin;
          } catch (e3) {
            return "null";
          }
        return e2 != "file" && this.isSpecial() ? e2 + "://" + XY(this.host) + (t2 !== null ? ":" + t2 : "") : "null";
      }, getProtocol: function() {
        return this.scheme + ":";
      }, setProtocol: function(e2) {
        this.parse(hY(e2) + ":", aW);
      }, getUsername: function() {
        return this.username;
      }, setUsername: function(e2) {
        var t2 = cY(hY(e2));
        if (!this.cannotHaveUsernamePasswordPort()) {
          this.username = "";
          for (var r2 = 0; r2 < t2.length; r2++)
            this.username += rW(t2[r2], tW);
        }
      }, getPassword: function() {
        return this.password;
      }, setPassword: function(e2) {
        var t2 = cY(hY(e2));
        if (!this.cannotHaveUsernamePasswordPort()) {
          this.password = "";
          for (var r2 = 0; r2 < t2.length; r2++)
            this.password += rW(t2[r2], tW);
        }
      }, getHost: function() {
        var e2 = this.host, t2 = this.port;
        return e2 === null ? "" : t2 === null ? XY(e2) : XY(e2) + ":" + t2;
      }, setHost: function(e2) {
        this.cannotBeABaseURL || this.parse(e2, EW);
      }, getHostname: function() {
        var e2 = this.host;
        return e2 === null ? "" : XY(e2);
      }, setHostname: function(e2) {
        this.cannotBeABaseURL || this.parse(e2, IW);
      }, getPort: function() {
        var e2 = this.port;
        return e2 === null ? "" : hY(e2);
      }, setPort: function(e2) {
        this.cannotHaveUsernamePasswordPort() || ((e2 = hY(e2)) == "" ? this.port = null : this.parse(e2, mW));
      }, getPathname: function() {
        var e2 = this.path;
        return this.cannotBeABaseURL ? e2[0] : e2.length ? "/" + wY(e2, "/") : "";
      }, setPathname: function(e2) {
        this.cannotBeABaseURL || (this.path = [], this.parse(e2, SW));
      }, getSearch: function() {
        var e2 = this.query;
        return e2 ? "?" + e2 : "";
      }, setSearch: function(e2) {
        (e2 = hY(e2)) == "" ? this.query = null : (yY(e2, 0) == "?" && (e2 = kY(e2, 1)), this.query = "", this.parse(e2, TW)), this.searchParams.update();
      }, getSearchParams: function() {
        return this.searchParams.facade;
      }, getHash: function() {
        var e2 = this.fragment;
        return e2 ? "#" + e2 : "";
      }, setHash: function(e2) {
        (e2 = hY(e2)) != "" ? (yY(e2, 0) == "#" && (e2 = kY(e2, 1)), this.fragment = "", this.parse(e2, wW)) : this.fragment = null;
      }, update: function() {
        this.query = this.searchParams.serialize() || null;
      } };
      var OW = function(e2) {
        var t2 = oY(this, NW), r2 = arguments.length > 1 ? arguments[1] : void 0, i2 = fY(t2, new bW(e2, false, r2));
        ZH || (t2.href = i2.serialize(), t2.origin = i2.getOrigin(), t2.protocol = i2.getProtocol(), t2.username = i2.getUsername(), t2.password = i2.getPassword(), t2.host = i2.getHost(), t2.hostname = i2.getHostname(), t2.port = i2.getPort(), t2.pathname = i2.getPathname(), t2.search = i2.getSearch(), t2.searchParams = i2.getSearchParams(), t2.hash = i2.getHash());
      }, NW = OW.prototype, DW = function(e2, t2) {
        return { get: function() {
          return EY(this)[e2]();
        }, set: t2 && function(e3) {
          return EY(this)[t2](e3);
        }, configurable: true, enumerable: true };
      };
      if (ZH && iY(NW, { href: DW("serialize", "setHref"), origin: DW("getOrigin"), protocol: DW("getProtocol", "setProtocol"), username: DW("getUsername", "setUsername"), password: DW("getPassword", "setPassword"), host: DW("getHost", "setHost"), hostname: DW("getHostname", "setHostname"), port: DW("getPort", "setPort"), pathname: DW("getPathname", "setPathname"), search: DW("getSearch", "setSearch"), searchParams: DW("getSearchParams"), hash: DW("getHash", "setHash") }), nY(NW, "toJSON", function() {
        return EY(this).serialize();
      }, { enumerable: true }), nY(NW, "toString", function() {
        return EY(this).serialize();
      }, { enumerable: true }), _Y) {
        var LW = _Y.createObjectURL, PW = _Y.revokeObjectURL;
        LW && nY(OW, "createObjectURL", tY(LW, _Y)), PW && nY(OW, "revokeObjectURL", tY(PW, _Y));
      }
      lY(OW, "URL"), XH({ global: true, forced: !$H, sham: !ZH }, { URL: OW });
      var kW = _d.URL;
      const BW = { [_P.ACCESS_POINT]: { [SP.NO_FLAG_SET]: { desc: "flag is zero", retry: false }, [SP.FLAG_SET_BUT_EMPTY]: { desc: "flag is empty", retry: false }, [SP.INVALID_FALG_SET]: { desc: "invalid flag", retry: false }, [SP.FLAG_SET_BUT_NO_RE]: { desc: "flag set unilbs but no request", retry: false }, [SP.INVALID_SERVICE_ID]: { desc: "invalid service id", retry: false }, [SP.NO_SERVICE_AVAILABLE]: { desc: "no service available", retry: true }, [SP.NO_SERVICE_AVAILABLE_P2P]: { desc: "no unilbs p2p service available", retry: true }, [SP.NO_SERVICE_AVAILABLE_VOET]: { desc: "no unilbs voice service available", retry: true }, [SP.NO_SERVICE_AVAILABLE_WEBRTC]: { desc: "no unilbs webrtc service available", retry: true }, [SP.NO_SERVICE_AVAILABLE_CDS]: { desc: "no cds service available", retry: true }, [SP.NO_SERVICE_AVAILABLE_CDN]: { desc: "no cdn dispatcher service available", retry: true }, [SP.NO_SERVICE_AVAILABLE_TDS]: { desc: "no tds service available", retry: true }, [SP.NO_SERVICE_AVAILABLE_REPORT]: { desc: "no unilbs report service available", retry: true }, [SP.NO_SERVICE_AVAILABLE_APP_CENTER]: { desc: "no app center service available", retry: true }, [SP.NO_SERVICE_AVAILABLE_ENV0]: { desc: "no unilbs sig env0 service available", retry: true }, [SP.NO_SERVICE_AVAILABLE_VOET]: { desc: "no unilbs voet service available", retry: true }, [SP.NO_SERVICE_AVAILABLE_STRING_UID]: { desc: "no string uid service available", retry: true }, [SP.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS]: { desc: "no webrtc unilbs service available", retry: true } }, [_P.UNILBS]: { [vP.INVALID_VENDOR_KEY]: { desc: "invalid vendor key, can not find appid", retry: false }, [vP.INVALID_CHANNEL_NAME]: { desc: "invalid channel name", retry: false }, [vP.INTERNAL_ERROR]: { desc: "unilbs internal error", retry: false }, [vP.NO_AUTHORIZED]: { desc: "invalid token, authorized failed", retry: false }, [vP.DYNAMIC_KEY_TIMEOUT]: { desc: "dynamic key or token timeout", retry: false }, [vP.NO_ACTIVE_STATUS]: { desc: "no active status", retry: false }, [vP.DYNAMIC_KEY_EXPIRED]: { desc: "dynamic key expired", retry: false }, [vP.STATIC_USE_DYNAMIC_KEY]: { desc: "static use dynamic key", retry: false }, [vP.DYNAMIC_USE_STATIC_KEY]: { desc: "dynamic use static key", retry: false }, [vP.USER_OVERLOAD]: { desc: "amount of users over load", retry: false }, [vP.FORBIDDEN_REGION]: { desc: "the request is forbidden in this area", retry: false }, [vP.CANNOT_MEET_AREA_DEMAND]: { desc: "unable to allocate services in this area", retry: false } }, [_P.STRING_UID_ALLOCATOR]: { [CP.IIIEGAL_APPID]: { desc: "invalid appid", retry: false }, [CP.IIIEGAL_UID]: { desc: "invalid string uid", retry: false }, [CP.INTERNAL_ERROR]: { desc: "string uid allocator internal error", retry: true } } };
      function MW(e2) {
        const t2 = BW[Math.floor(e2 / 1e4)];
        if (!t2)
          return { desc: "unkonw error", retry: false };
        const r2 = t2[e2 % 1e4];
        if (!r2) {
          if (Math.floor(e2 / 1e4) === _P.ACCESS_POINT) {
            const t3 = e2 % 1e4;
            if (t3.toString()[0] === "1")
              return { desc: e2.toString(), retry: false };
            if (t3.toString()[0] === "2")
              return { desc: e2.toString(), retry: true };
          }
          return { desc: "unkonw error", retry: false };
        }
        return r2;
      }
      const UW = { [RP.K_TIMESTAMP_EXPIRED]: { desc: "K_TIMESTAMP_EXPIRED", action: "failed" }, [RP.K_CHANNEL_PERMISSION_INVALID]: { desc: "K_CHANNEL_PERMISSION_INVALID", action: "failed" }, [RP.K_CERTIFICATE_INVALID]: { desc: "K_CERTIFICATE_INVALID", action: "failed" }, [RP.K_CHANNEL_NAME_EMPTY]: { desc: "K_CHANNEL_NAME_EMPTY", action: "failed" }, [RP.K_CHANNEL_NOT_FOUND]: { desc: "K_CHANNEL_NOT_FOUND", action: "failed" }, [RP.K_TICKET_INVALID]: { desc: "K_TICKET_INVALID", action: "failed" }, [RP.K_CHANNEL_CONFLICTED]: { desc: "K_CHANNEL_CONFLICTED", action: "failed" }, [RP.K_SERVICE_NOT_READY]: { desc: "K_SERVICE_NOT_READY", action: "tryNext" }, [RP.K_SERVICE_TOO_HEAVY]: { desc: "K_SERVICE_TOO_HEAVY", action: "tryNext" }, [RP.K_UID_BANNED]: { desc: "K_UID_BANNED", action: "failed" }, [RP.K_IP_BANNED]: { desc: "K_IP_BANNED", action: "failed" }, [RP.ERR_INVALID_VENDOR_KEY]: { desc: "ERR_INVALID_VENDOR_KEY", action: "failed" }, [RP.ERR_INVALID_CHANNEL_NAME]: { desc: "ERR_INVALID_CHANNEL_NAME", action: "failed" }, [RP.WARN_NO_AVAILABLE_CHANNEL]: { desc: "WARN_NO_AVAILABLE_CHANNEL", action: "failed" }, [RP.WARN_LOOKUP_CHANNEL_TIMEOUT]: { desc: "WARN_LOOKUP_CHANNEL_TIMEOUT", action: "tryNext" }, [RP.WARN_LOOKUP_CHANNEL_REJECTED]: { desc: "WARN_LOOKUP_CHANNEL_REJECTED", action: "failed" }, [RP.WARN_OPEN_CHANNEL_TIMEOUT]: { desc: "WARN_OPEN_CHANNEL_TIMEOUT", action: "tryNext" }, [RP.WARN_OPEN_CHANNEL_REJECTED]: { desc: "WARN_OPEN_CHANNEL_REJECTED", action: "failed" }, [RP.WARN_REQUEST_DEFERRED]: { desc: "WARN_REQUEST_DEFERRED", action: "failed" }, [RP.ERR_DYNAMIC_KEY_TIMEOUT]: { desc: "ERR_DYNAMIC_KEY_TIMEOUT", action: "failed" }, [RP.ERR_NO_AUTHORIZED]: { desc: "ERR_NO_AUTHORIZED", action: "failed" }, [RP.ERR_VOM_SERVICE_UNAVAILABLE]: { desc: "ERR_VOM_SERVICE_UNAVAILABLE", action: "tryNext" }, [RP.ERR_NO_CHANNEL_AVAILABLE_CODE]: { desc: "ERR_NO_CHANNEL_AVAILABLE_CODE", action: "failed" }, [RP.ERR_MASTER_VOCS_UNAVAILABLE]: { desc: "ERR_MASTER_VOCS_UNAVAILABLE", action: "tryNext" }, [RP.ERR_INTERNAL_ERROR]: { desc: "ERR_INTERNAL_ERROR", action: "tryNext" }, [RP.ERR_NO_ACTIVE_STATUS]: { desc: "ERR_NO_ACTIVE_STATUS", action: "failed" }, [RP.ERR_INVALID_UID]: { desc: "ERR_INVALID_UID", action: "failed" }, [RP.ERR_DYNAMIC_KEY_EXPIRED]: { desc: "ERR_DYNAMIC_KEY_EXPIRED", action: "failed" }, [RP.ERR_STATIC_USE_DYANMIC_KE]: { desc: "ERR_STATIC_USE_DYANMIC_KE", action: "failed" }, [RP.ERR_DYNAMIC_USE_STATIC_KE]: { desc: "ERR_DYNAMIC_USE_STATIC_KE", action: "failed" }, [RP.ERR_NO_VOCS_AVAILABLE]: { desc: "ERR_NO_VOCS_AVAILABLE", action: "tryNext" }, [RP.ERR_NO_VOS_AVAILABLE]: { desc: "ERR_NO_VOS_AVAILABLE", action: "tryNext" }, [RP.ERR_JOIN_CHANNEL_TIMEOUT]: { desc: "ERR_JOIN_CHANNEL_TIMEOUT", action: "tryNext" }, [RP.ERR_JOIN_BY_MULTI_IP]: { desc: "ERR_JOIN_BY_MULTI_IP", action: "recover" }, [RP.ERR_NOT_JOINED]: { desc: "ERR_NOT_JOINED", action: "failed" }, [RP.ERR_REPEAT_JOIN_REQUEST]: { desc: "ERR_REPEAT_JOIN_REQUEST", action: "quit" }, [RP.ERR_REPEAT_JOIN_CHANNEL]: { desc: "ERR_REPEAT_JOIN_CHANNEL", action: "quit" }, [RP.ERR_INVALID_VENDOR_KEY]: { desc: "ERR_INVALID_VENDOR_KEY", action: "failed" }, [RP.ERR_INVALID_CHANNEL_NAME]: { desc: "ERR_INVALID_CHANNEL_NAME", action: "failed" }, [RP.ERR_INVALID_STRINGUID]: { desc: "ERR_INVALID_STRINGUID", action: "failed" }, [RP.ERR_TOO_MANY_USERS]: { desc: "ERR_TOO_MANY_USERS", action: "tryNext" }, [RP.ERR_SET_CLIENT_ROLE_TIMEOUT]: { desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed" }, [RP.ERR_SET_CLIENT_ROLE_NO_PERMISSION]: { desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed" }, [RP.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE]: { desc: "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE", action: "success" }, [RP.ERR_PUBLISH_REQUEST_INVALID]: { desc: "ERR_PUBLISH_REQUEST_INVALID", action: "failed" }, [RP.ERR_SUBSCRIBE_REQUEST_INVALID]: { desc: "ERR_SUBSCRIBE_REQUEST_INVALID", action: "failed" }, [RP.ERR_NOT_SUPPORTED_MESSAGE]: { desc: "ERR_NOT_SUPPORTED_MESSAGE", action: "failed" }, [RP.ERR_ILLEAGAL_PLUGIN]: { desc: "ERR_ILLEAGAL_PLUGIN", action: "failed" }, [RP.ILLEGAL_CLIENT_ROLE_LEVEL]: { desc: "ILLEGAL_CLIENT_ROLE_LEVEL", action: "failed" }, [RP.ERR_REJOIN_TOKEN_INVALID]: { desc: "ERR_REJOIN_TOKEN_INVALID", action: "failed" }, [RP.ERR_REJOIN_USER_NOT_JOINED]: { desc: "ERR_REJOIN_NOT_JOINED", action: "failed" }, [RP.ERR_INVALID_OPTIONAL_INFO]: { desc: "ERR_INVALID_OPTIONAL_INFO", action: "quit" }, [RP.ERR_TEST_RECOVER]: { desc: "ERR_TEST_RECOVER", action: "recover" }, [RP.ERR_TEST_TRYNEXT]: { desc: "ERR_TEST_TRYNEXT", action: "recover" }, [RP.ERR_TEST_RETRY]: { desc: "ERR_TEST_RETRY", action: "recover" }, [RP.ILLEGAL_AES_PASSWORD]: { desc: "ERR_TEST_RETRY", action: "failed" }, [RP.ERR_TOO_MANY_BROADCASTERS]: { desc: "ERR_TOO_MANY_BROADCASTERS", action: "failed" }, [RP.ERR_TOO_MANY_SUBSCRIBERS]: { desc: "ERR_TOO_MANY_SUBSCRIBERS", action: "failed" } };
      function QW(e2) {
        const t2 = UW[e2];
        return t2 || { desc: "UNKNOW_ERROR_".concat(e2), action: "failed" };
      }
      var xW = { exports: {} };
      !function(e2, t2) {
        e2.exports = function() {
          var e3 = { d: function(t4, r3) {
            for (var i3 in r3)
              e3.o(r3, i3) && !e3.o(t4, i3) && Object.defineProperty(t4, i3, { enumerable: true, get: r3[i3] });
          }, o: function(e4, t4) {
            return Object.prototype.hasOwnProperty.call(e4, t4);
          }, r: function(e4) {
            typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e4, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e4, "__esModule", { value: true });
          } }, t3 = {};
          e3.r(t3), e3.d(t3, { DataViewIndexOutOfBoundsError: function() {
            return F2;
          }, DecodeError: function() {
            return I2;
          }, Decoder: function() {
            return G2;
          }, EXT_TIMESTAMP: function() {
            return m2;
          }, Encoder: function() {
            return O2;
          }, ExtData: function() {
            return f2;
          }, ExtensionCodec: function() {
            return T2;
          }, decode: function() {
            return H2;
          }, decodeArrayStream: function() {
            return $2;
          }, decodeAsync: function() {
            return Z2;
          }, decodeMulti: function() {
            return Y2;
          }, decodeMultiStream: function() {
            return ee2;
          }, decodeStream: function() {
            return te2;
          }, decodeTimestampExtension: function() {
            return R2;
          }, decodeTimestampToTimeSpec: function() {
            return S2;
          }, encode: function() {
            return D2;
          }, encodeDateToTimeSpec: function() {
            return C2;
          }, encodeTimeSpecToTimestamp: function() {
            return _2;
          }, encodeTimestampExtension: function() {
            return v2;
          } });
          var r2 = 4294967295;
          function i2(e4, t4, r3) {
            var i3 = Math.floor(r3 / 4294967296), n3 = r3;
            e4.setUint32(t4, i3), e4.setUint32(t4 + 4, n3);
          }
          function n2(e4, t4) {
            return 4294967296 * e4.getInt32(t4) + e4.getUint32(t4 + 4);
          }
          var o2 = function(e4, t4) {
            var r3 = typeof Symbol == "function" && e4[Symbol.iterator];
            if (!r3)
              return e4;
            var i3, n3, o3 = r3.call(e4), s3 = [];
            try {
              for (; (t4 === void 0 || t4-- > 0) && !(i3 = o3.next()).done; )
                s3.push(i3.value);
            } catch (e5) {
              n3 = { error: e5 };
            } finally {
              try {
                i3 && !i3.done && (r3 = o3.return) && r3.call(o3);
              } finally {
                if (n3)
                  throw n3.error;
              }
            }
            return s3;
          }, s2 = function(e4, t4) {
            for (var r3 = 0, i3 = t4.length, n3 = e4.length; r3 < i3; r3++, n3++)
              e4[n3] = t4[r3];
            return e4;
          }, a2 = typeof TextEncoder != "undefined" && typeof TextDecoder != "undefined";
          function c2(e4) {
            for (var t4 = e4.length, r3 = 0, i3 = 0; i3 < t4; ) {
              var n3 = e4.charCodeAt(i3++);
              if ((4294967168 & n3) != 0)
                if ((4294965248 & n3) == 0)
                  r3 += 2;
                else {
                  if (n3 >= 55296 && n3 <= 56319 && i3 < t4) {
                    var o3 = e4.charCodeAt(i3);
                    (64512 & o3) == 56320 && (++i3, n3 = ((1023 & n3) << 10) + (1023 & o3) + 65536);
                  }
                  r3 += (4294901760 & n3) == 0 ? 3 : 4;
                }
              else
                r3++;
            }
            return r3;
          }
          var d2 = a2 ? new TextEncoder() : void 0, u2 = a2 ? typeof process != "undefined" ? 200 : 0 : r2, A2 = (d2 == null ? void 0 : d2.encodeInto) ? function(e4, t4, r3) {
            d2.encodeInto(e4, t4.subarray(r3));
          } : function(e4, t4, r3) {
            t4.set(d2.encode(e4), r3);
          };
          function h2(e4, t4, r3) {
            for (var i3 = t4, n3 = i3 + r3, a3 = [], c3 = ""; i3 < n3; ) {
              var d3 = e4[i3++];
              if ((128 & d3) == 0)
                a3.push(d3);
              else if ((224 & d3) == 192) {
                var u3 = 63 & e4[i3++];
                a3.push((31 & d3) << 6 | u3);
              } else if ((240 & d3) == 224) {
                u3 = 63 & e4[i3++];
                var A3 = 63 & e4[i3++];
                a3.push((31 & d3) << 12 | u3 << 6 | A3);
              } else if ((248 & d3) == 240) {
                var h3 = (7 & d3) << 18 | (u3 = 63 & e4[i3++]) << 12 | (A3 = 63 & e4[i3++]) << 6 | 63 & e4[i3++];
                h3 > 65535 && (h3 -= 65536, a3.push(h3 >>> 10 & 1023 | 55296), h3 = 56320 | 1023 & h3), a3.push(h3);
              } else
                a3.push(d3);
              a3.length >= 4096 && (c3 += String.fromCharCode.apply(String, s2([], o2(a3))), a3.length = 0);
            }
            return a3.length > 0 && (c3 += String.fromCharCode.apply(String, s2([], o2(a3)))), c3;
          }
          var l2, p2 = a2 ? new TextDecoder() : null, g2 = a2 ? typeof process != "undefined" ? 200 : 0 : r2, f2 = function(e4, t4) {
            this.type = e4, this.data = t4;
          }, E2 = (l2 = function(e4, t4) {
            return (l2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e5, t5) {
              e5.__proto__ = t5;
            } || function(e5, t5) {
              for (var r3 in t5)
                Object.prototype.hasOwnProperty.call(t5, r3) && (e5[r3] = t5[r3]);
            })(e4, t4);
          }, function(e4, t4) {
            if (typeof t4 != "function" && t4 !== null)
              throw new TypeError("Class extends value " + String(t4) + " is not a constructor or null");
            function r3() {
              this.constructor = e4;
            }
            l2(e4, t4), e4.prototype = t4 === null ? Object.create(t4) : (r3.prototype = t4.prototype, new r3());
          }), I2 = function(e4) {
            function t4(r3) {
              var i3 = e4.call(this, r3) || this, n3 = Object.create(t4.prototype);
              return Object.setPrototypeOf(i3, n3), Object.defineProperty(i3, "name", { configurable: true, enumerable: false, value: t4.name }), i3;
            }
            return E2(t4, e4), t4;
          }(Error), m2 = -1;
          function _2(e4) {
            var t4, r3 = e4.sec, n3 = e4.nsec;
            if (r3 >= 0 && n3 >= 0 && r3 <= 17179869183) {
              if (n3 === 0 && r3 <= 4294967295) {
                var o3 = new Uint8Array(4);
                return (t4 = new DataView(o3.buffer)).setUint32(0, r3), o3;
              }
              var s3 = r3 / 4294967296, a3 = 4294967295 & r3;
              return o3 = new Uint8Array(8), (t4 = new DataView(o3.buffer)).setUint32(0, n3 << 2 | 3 & s3), t4.setUint32(4, a3), o3;
            }
            return o3 = new Uint8Array(12), (t4 = new DataView(o3.buffer)).setUint32(0, n3), i2(t4, 4, r3), o3;
          }
          function C2(e4) {
            var t4 = e4.getTime(), r3 = Math.floor(t4 / 1e3), i3 = 1e6 * (t4 - 1e3 * r3), n3 = Math.floor(i3 / 1e9);
            return { sec: r3 + n3, nsec: i3 - 1e9 * n3 };
          }
          function v2(e4) {
            return e4 instanceof Date ? _2(C2(e4)) : null;
          }
          function S2(e4) {
            var t4 = new DataView(e4.buffer, e4.byteOffset, e4.byteLength);
            switch (e4.byteLength) {
              case 4:
                return { sec: t4.getUint32(0), nsec: 0 };
              case 8:
                var r3 = t4.getUint32(0);
                return { sec: 4294967296 * (3 & r3) + t4.getUint32(4), nsec: r3 >>> 2 };
              case 12:
                return { sec: n2(t4, 4), nsec: t4.getUint32(0) };
              default:
                throw new I2("Unrecognized data size for timestamp (expected 4, 8, or 12): " + e4.length);
            }
          }
          function R2(e4) {
            var t4 = S2(e4);
            return new Date(1e3 * t4.sec + t4.nsec / 1e6);
          }
          var y2 = { type: m2, encode: v2, decode: R2 }, T2 = function() {
            function e4() {
              this.builtInEncoders = [], this.builtInDecoders = [], this.encoders = [], this.decoders = [], this.register(y2);
            }
            return e4.prototype.register = function(e5) {
              var t4 = e5.type, r3 = e5.encode, i3 = e5.decode;
              if (t4 >= 0)
                this.encoders[t4] = r3, this.decoders[t4] = i3;
              else {
                var n3 = 1 + t4;
                this.builtInEncoders[n3] = r3, this.builtInDecoders[n3] = i3;
              }
            }, e4.prototype.tryToEncode = function(e5, t4) {
              for (var r3 = 0; r3 < this.builtInEncoders.length; r3++)
                if ((i3 = this.builtInEncoders[r3]) != null && (n3 = i3(e5, t4)) != null)
                  return new f2(-1 - r3, n3);
              for (r3 = 0; r3 < this.encoders.length; r3++) {
                var i3, n3;
                if ((i3 = this.encoders[r3]) != null && (n3 = i3(e5, t4)) != null)
                  return new f2(r3, n3);
              }
              return e5 instanceof f2 ? e5 : null;
            }, e4.prototype.decode = function(e5, t4, r3) {
              var i3 = t4 < 0 ? this.builtInDecoders[-1 - t4] : this.decoders[t4];
              return i3 ? i3(e5, t4, r3) : new f2(t4, e5);
            }, e4.defaultCodec = new e4(), e4;
          }();
          function w2(e4) {
            return e4 instanceof Uint8Array ? e4 : ArrayBuffer.isView(e4) ? new Uint8Array(e4.buffer, e4.byteOffset, e4.byteLength) : e4 instanceof ArrayBuffer ? new Uint8Array(e4) : Uint8Array.from(e4);
          }
          var b2 = function(e4) {
            var t4 = typeof Symbol == "function" && Symbol.iterator, r3 = t4 && e4[t4], i3 = 0;
            if (r3)
              return r3.call(e4);
            if (e4 && typeof e4.length == "number")
              return { next: function() {
                return e4 && i3 >= e4.length && (e4 = void 0), { value: e4 && e4[i3++], done: !e4 };
              } };
            throw new TypeError(t4 ? "Object is not iterable." : "Symbol.iterator is not defined.");
          }, O2 = function() {
            function e4(e5, t4, r3, i3, n3, o3, s3, a3) {
              e5 === void 0 && (e5 = T2.defaultCodec), t4 === void 0 && (t4 = void 0), r3 === void 0 && (r3 = 100), i3 === void 0 && (i3 = 2048), n3 === void 0 && (n3 = false), o3 === void 0 && (o3 = false), s3 === void 0 && (s3 = false), a3 === void 0 && (a3 = false), this.extensionCodec = e5, this.context = t4, this.maxDepth = r3, this.initialBufferSize = i3, this.sortKeys = n3, this.forceFloat32 = o3, this.ignoreUndefined = s3, this.forceIntegerToFloat = a3, this.pos = 0, this.view = new DataView(new ArrayBuffer(this.initialBufferSize)), this.bytes = new Uint8Array(this.view.buffer);
            }
            return e4.prototype.getUint8Array = function() {
              return this.bytes.subarray(0, this.pos);
            }, e4.prototype.reinitializeState = function() {
              this.pos = 0;
            }, e4.prototype.encode = function(e5) {
              return this.reinitializeState(), this.doEncode(e5, 1), this.getUint8Array();
            }, e4.prototype.doEncode = function(e5, t4) {
              if (t4 > this.maxDepth)
                throw new Error("Too deep objects in depth " + t4);
              e5 == null ? this.encodeNil() : typeof e5 == "boolean" ? this.encodeBoolean(e5) : typeof e5 == "number" ? this.encodeNumber(e5) : typeof e5 == "string" ? this.encodeString(e5) : this.encodeObject(e5, t4);
            }, e4.prototype.ensureBufferSizeToWrite = function(e5) {
              var t4 = this.pos + e5;
              this.view.byteLength < t4 && this.resizeBuffer(2 * t4);
            }, e4.prototype.resizeBuffer = function(e5) {
              var t4 = new ArrayBuffer(e5), r3 = new Uint8Array(t4), i3 = new DataView(t4);
              r3.set(this.bytes), this.view = i3, this.bytes = r3;
            }, e4.prototype.encodeNil = function() {
              this.writeU8(192);
            }, e4.prototype.encodeBoolean = function(e5) {
              e5 === false ? this.writeU8(194) : this.writeU8(195);
            }, e4.prototype.encodeNumber = function(e5) {
              Number.isSafeInteger(e5) && !this.forceIntegerToFloat ? e5 >= 0 ? e5 < 128 ? this.writeU8(e5) : e5 < 256 ? (this.writeU8(204), this.writeU8(e5)) : e5 < 65536 ? (this.writeU8(205), this.writeU16(e5)) : e5 < 4294967296 ? (this.writeU8(206), this.writeU32(e5)) : (this.writeU8(207), this.writeU64(e5)) : e5 >= -32 ? this.writeU8(224 | e5 + 32) : e5 >= -128 ? (this.writeU8(208), this.writeI8(e5)) : e5 >= -32768 ? (this.writeU8(209), this.writeI16(e5)) : e5 >= -2147483648 ? (this.writeU8(210), this.writeI32(e5)) : (this.writeU8(211), this.writeI64(e5)) : this.forceFloat32 ? (this.writeU8(202), this.writeF32(e5)) : (this.writeU8(203), this.writeF64(e5));
            }, e4.prototype.writeStringHeader = function(e5) {
              if (e5 < 32)
                this.writeU8(160 + e5);
              else if (e5 < 256)
                this.writeU8(217), this.writeU8(e5);
              else if (e5 < 65536)
                this.writeU8(218), this.writeU16(e5);
              else {
                if (!(e5 < 4294967296))
                  throw new Error("Too long string: " + e5 + " bytes in UTF-8");
                this.writeU8(219), this.writeU32(e5);
              }
            }, e4.prototype.encodeString = function(e5) {
              if (e5.length > u2) {
                var t4 = c2(e5);
                this.ensureBufferSizeToWrite(5 + t4), this.writeStringHeader(t4), A2(e5, this.bytes, this.pos), this.pos += t4;
              } else
                t4 = c2(e5), this.ensureBufferSizeToWrite(5 + t4), this.writeStringHeader(t4), function(e6, t5, r3) {
                  for (var i3 = e6.length, n3 = r3, o3 = 0; o3 < i3; ) {
                    var s3 = e6.charCodeAt(o3++);
                    if ((4294967168 & s3) != 0) {
                      if ((4294965248 & s3) == 0)
                        t5[n3++] = s3 >> 6 & 31 | 192;
                      else {
                        if (s3 >= 55296 && s3 <= 56319 && o3 < i3) {
                          var a3 = e6.charCodeAt(o3);
                          (64512 & a3) == 56320 && (++o3, s3 = ((1023 & s3) << 10) + (1023 & a3) + 65536);
                        }
                        (4294901760 & s3) == 0 ? (t5[n3++] = s3 >> 12 & 15 | 224, t5[n3++] = s3 >> 6 & 63 | 128) : (t5[n3++] = s3 >> 18 & 7 | 240, t5[n3++] = s3 >> 12 & 63 | 128, t5[n3++] = s3 >> 6 & 63 | 128);
                      }
                      t5[n3++] = 63 & s3 | 128;
                    } else
                      t5[n3++] = s3;
                  }
                }(e5, this.bytes, this.pos), this.pos += t4;
            }, e4.prototype.encodeObject = function(e5, t4) {
              var r3 = this.extensionCodec.tryToEncode(e5, this.context);
              if (r3 != null)
                this.encodeExtension(r3);
              else if (Array.isArray(e5))
                this.encodeArray(e5, t4);
              else if (ArrayBuffer.isView(e5))
                this.encodeBinary(e5);
              else {
                if (typeof e5 != "object")
                  throw new Error("Unrecognized object: " + Object.prototype.toString.apply(e5));
                this.encodeMap(e5, t4);
              }
            }, e4.prototype.encodeBinary = function(e5) {
              var t4 = e5.byteLength;
              if (t4 < 256)
                this.writeU8(196), this.writeU8(t4);
              else if (t4 < 65536)
                this.writeU8(197), this.writeU16(t4);
              else {
                if (!(t4 < 4294967296))
                  throw new Error("Too large binary: " + t4);
                this.writeU8(198), this.writeU32(t4);
              }
              var r3 = w2(e5);
              this.writeU8a(r3);
            }, e4.prototype.encodeArray = function(e5, t4) {
              var r3, i3, n3 = e5.length;
              if (n3 < 16)
                this.writeU8(144 + n3);
              else if (n3 < 65536)
                this.writeU8(220), this.writeU16(n3);
              else {
                if (!(n3 < 4294967296))
                  throw new Error("Too large array: " + n3);
                this.writeU8(221), this.writeU32(n3);
              }
              try {
                for (var o3 = b2(e5), s3 = o3.next(); !s3.done; s3 = o3.next()) {
                  var a3 = s3.value;
                  this.doEncode(a3, t4 + 1);
                }
              } catch (e6) {
                r3 = { error: e6 };
              } finally {
                try {
                  s3 && !s3.done && (i3 = o3.return) && i3.call(o3);
                } finally {
                  if (r3)
                    throw r3.error;
                }
              }
            }, e4.prototype.countWithoutUndefined = function(e5, t4) {
              var r3, i3, n3 = 0;
              try {
                for (var o3 = b2(t4), s3 = o3.next(); !s3.done; s3 = o3.next())
                  e5[s3.value] !== void 0 && n3++;
              } catch (e6) {
                r3 = { error: e6 };
              } finally {
                try {
                  s3 && !s3.done && (i3 = o3.return) && i3.call(o3);
                } finally {
                  if (r3)
                    throw r3.error;
                }
              }
              return n3;
            }, e4.prototype.encodeMap = function(e5, t4) {
              var r3, i3, n3 = Object.keys(e5);
              this.sortKeys && n3.sort();
              var o3 = this.ignoreUndefined ? this.countWithoutUndefined(e5, n3) : n3.length;
              if (o3 < 16)
                this.writeU8(128 + o3);
              else if (o3 < 65536)
                this.writeU8(222), this.writeU16(o3);
              else {
                if (!(o3 < 4294967296))
                  throw new Error("Too large map object: " + o3);
                this.writeU8(223), this.writeU32(o3);
              }
              try {
                for (var s3 = b2(n3), a3 = s3.next(); !a3.done; a3 = s3.next()) {
                  var c3 = a3.value, d3 = e5[c3];
                  this.ignoreUndefined && d3 === void 0 || (this.encodeString(c3), this.doEncode(d3, t4 + 1));
                }
              } catch (e6) {
                r3 = { error: e6 };
              } finally {
                try {
                  a3 && !a3.done && (i3 = s3.return) && i3.call(s3);
                } finally {
                  if (r3)
                    throw r3.error;
                }
              }
            }, e4.prototype.encodeExtension = function(e5) {
              var t4 = e5.data.length;
              if (t4 === 1)
                this.writeU8(212);
              else if (t4 === 2)
                this.writeU8(213);
              else if (t4 === 4)
                this.writeU8(214);
              else if (t4 === 8)
                this.writeU8(215);
              else if (t4 === 16)
                this.writeU8(216);
              else if (t4 < 256)
                this.writeU8(199), this.writeU8(t4);
              else if (t4 < 65536)
                this.writeU8(200), this.writeU16(t4);
              else {
                if (!(t4 < 4294967296))
                  throw new Error("Too large extension object: " + t4);
                this.writeU8(201), this.writeU32(t4);
              }
              this.writeI8(e5.type), this.writeU8a(e5.data);
            }, e4.prototype.writeU8 = function(e5) {
              this.ensureBufferSizeToWrite(1), this.view.setUint8(this.pos, e5), this.pos++;
            }, e4.prototype.writeU8a = function(e5) {
              var t4 = e5.length;
              this.ensureBufferSizeToWrite(t4), this.bytes.set(e5, this.pos), this.pos += t4;
            }, e4.prototype.writeI8 = function(e5) {
              this.ensureBufferSizeToWrite(1), this.view.setInt8(this.pos, e5), this.pos++;
            }, e4.prototype.writeU16 = function(e5) {
              this.ensureBufferSizeToWrite(2), this.view.setUint16(this.pos, e5), this.pos += 2;
            }, e4.prototype.writeI16 = function(e5) {
              this.ensureBufferSizeToWrite(2), this.view.setInt16(this.pos, e5), this.pos += 2;
            }, e4.prototype.writeU32 = function(e5) {
              this.ensureBufferSizeToWrite(4), this.view.setUint32(this.pos, e5), this.pos += 4;
            }, e4.prototype.writeI32 = function(e5) {
              this.ensureBufferSizeToWrite(4), this.view.setInt32(this.pos, e5), this.pos += 4;
            }, e4.prototype.writeF32 = function(e5) {
              this.ensureBufferSizeToWrite(4), this.view.setFloat32(this.pos, e5), this.pos += 4;
            }, e4.prototype.writeF64 = function(e5) {
              this.ensureBufferSizeToWrite(8), this.view.setFloat64(this.pos, e5), this.pos += 8;
            }, e4.prototype.writeU64 = function(e5) {
              this.ensureBufferSizeToWrite(8), function(e6, t4, r3) {
                var i3 = r3 / 4294967296, n3 = r3;
                e6.setUint32(t4, i3), e6.setUint32(t4 + 4, n3);
              }(this.view, this.pos, e5), this.pos += 8;
            }, e4.prototype.writeI64 = function(e5) {
              this.ensureBufferSizeToWrite(8), i2(this.view, this.pos, e5), this.pos += 8;
            }, e4;
          }(), N2 = {};
          function D2(e4, t4) {
            return t4 === void 0 && (t4 = N2), new O2(t4.extensionCodec, t4.context, t4.maxDepth, t4.initialBufferSize, t4.sortKeys, t4.forceFloat32, t4.ignoreUndefined, t4.forceIntegerToFloat).encode(e4);
          }
          function L2(e4) {
            return (e4 < 0 ? "-" : "") + "0x" + Math.abs(e4).toString(16).padStart(2, "0");
          }
          var P2 = function() {
            function e4(e5, t4) {
              e5 === void 0 && (e5 = 16), t4 === void 0 && (t4 = 16), this.maxKeyLength = e5, this.maxLengthPerKey = t4, this.hit = 0, this.miss = 0, this.caches = [];
              for (var r3 = 0; r3 < this.maxKeyLength; r3++)
                this.caches.push([]);
            }
            return e4.prototype.canBeCached = function(e5) {
              return e5 > 0 && e5 <= this.maxKeyLength;
            }, e4.prototype.find = function(e5, t4, r3) {
              var i3, n3, o3 = this.caches[r3 - 1];
              try {
                e:
                  for (var s3 = function(e6) {
                    var t5 = typeof Symbol == "function" && Symbol.iterator, r4 = t5 && e6[t5], i4 = 0;
                    if (r4)
                      return r4.call(e6);
                    if (e6 && typeof e6.length == "number")
                      return { next: function() {
                        return e6 && i4 >= e6.length && (e6 = void 0), { value: e6 && e6[i4++], done: !e6 };
                      } };
                    throw new TypeError(t5 ? "Object is not iterable." : "Symbol.iterator is not defined.");
                  }(o3), a3 = s3.next(); !a3.done; a3 = s3.next()) {
                    for (var c3 = a3.value, d3 = c3.bytes, u3 = 0; u3 < r3; u3++)
                      if (d3[u3] !== e5[t4 + u3])
                        continue e;
                    return c3.str;
                  }
              } catch (e6) {
                i3 = { error: e6 };
              } finally {
                try {
                  a3 && !a3.done && (n3 = s3.return) && n3.call(s3);
                } finally {
                  if (i3)
                    throw i3.error;
                }
              }
              return null;
            }, e4.prototype.store = function(e5, t4) {
              var r3 = this.caches[e5.length - 1], i3 = { bytes: e5, str: t4 };
              r3.length >= this.maxLengthPerKey ? r3[Math.random() * r3.length | 0] = i3 : r3.push(i3);
            }, e4.prototype.decode = function(e5, t4, r3) {
              var i3 = this.find(e5, t4, r3);
              if (i3 != null)
                return this.hit++, i3;
              this.miss++;
              var n3 = h2(e5, t4, r3), o3 = Uint8Array.prototype.slice.call(e5, t4, t4 + r3);
              return this.store(o3, n3), n3;
            }, e4;
          }(), k2 = function(e4, t4) {
            var r3, i3, n3, o3, s3 = { label: 0, sent: function() {
              if (1 & n3[0])
                throw n3[1];
              return n3[1];
            }, trys: [], ops: [] };
            return o3 = { next: a3(0), throw: a3(1), return: a3(2) }, typeof Symbol == "function" && (o3[Symbol.iterator] = function() {
              return this;
            }), o3;
            function a3(o4) {
              return function(a4) {
                return function(o5) {
                  if (r3)
                    throw new TypeError("Generator is already executing.");
                  for (; s3; )
                    try {
                      if (r3 = 1, i3 && (n3 = 2 & o5[0] ? i3.return : o5[0] ? i3.throw || ((n3 = i3.return) && n3.call(i3), 0) : i3.next) && !(n3 = n3.call(i3, o5[1])).done)
                        return n3;
                      switch (i3 = 0, n3 && (o5 = [2 & o5[0], n3.value]), o5[0]) {
                        case 0:
                        case 1:
                          n3 = o5;
                          break;
                        case 4:
                          return s3.label++, { value: o5[1], done: false };
                        case 5:
                          s3.label++, i3 = o5[1], o5 = [0];
                          continue;
                        case 7:
                          o5 = s3.ops.pop(), s3.trys.pop();
                          continue;
                        default:
                          if (!((n3 = (n3 = s3.trys).length > 0 && n3[n3.length - 1]) || o5[0] !== 6 && o5[0] !== 2)) {
                            s3 = 0;
                            continue;
                          }
                          if (o5[0] === 3 && (!n3 || o5[1] > n3[0] && o5[1] < n3[3])) {
                            s3.label = o5[1];
                            break;
                          }
                          if (o5[0] === 6 && s3.label < n3[1]) {
                            s3.label = n3[1], n3 = o5;
                            break;
                          }
                          if (n3 && s3.label < n3[2]) {
                            s3.label = n3[2], s3.ops.push(o5);
                            break;
                          }
                          n3[2] && s3.ops.pop(), s3.trys.pop();
                          continue;
                      }
                      o5 = t4.call(e4, s3);
                    } catch (e5) {
                      o5 = [6, e5], i3 = 0;
                    } finally {
                      r3 = n3 = 0;
                    }
                  if (5 & o5[0])
                    throw o5[1];
                  return { value: o5[0] ? o5[1] : void 0, done: true };
                }([o4, a4]);
              };
            }
          }, B2 = function(e4) {
            if (!Symbol.asyncIterator)
              throw new TypeError("Symbol.asyncIterator is not defined.");
            var t4, r3 = e4[Symbol.asyncIterator];
            return r3 ? r3.call(e4) : (e4 = typeof __values == "function" ? __values(e4) : e4[Symbol.iterator](), t4 = {}, i3("next"), i3("throw"), i3("return"), t4[Symbol.asyncIterator] = function() {
              return this;
            }, t4);
            function i3(r4) {
              t4[r4] = e4[r4] && function(t5) {
                return new Promise(function(i4, n3) {
                  !function(e5, t6, r5, i5) {
                    Promise.resolve(i5).then(function(t7) {
                      e5({ value: t7, done: r5 });
                    }, t6);
                  }(i4, n3, (t5 = e4[r4](t5)).done, t5.value);
                });
              };
            }
          }, M2 = function(e4) {
            return this instanceof M2 ? (this.v = e4, this) : new M2(e4);
          }, U2 = function(e4, t4, r3) {
            if (!Symbol.asyncIterator)
              throw new TypeError("Symbol.asyncIterator is not defined.");
            var i3, n3 = r3.apply(e4, t4 || []), o3 = [];
            return i3 = {}, s3("next"), s3("throw"), s3("return"), i3[Symbol.asyncIterator] = function() {
              return this;
            }, i3;
            function s3(e5) {
              n3[e5] && (i3[e5] = function(t5) {
                return new Promise(function(r4, i4) {
                  o3.push([e5, t5, r4, i4]) > 1 || a3(e5, t5);
                });
              });
            }
            function a3(e5, t5) {
              try {
                (r4 = n3[e5](t5)).value instanceof M2 ? Promise.resolve(r4.value.v).then(c3, d3) : u3(o3[0][2], r4);
              } catch (e6) {
                u3(o3[0][3], e6);
              }
              var r4;
            }
            function c3(e5) {
              a3("next", e5);
            }
            function d3(e5) {
              a3("throw", e5);
            }
            function u3(e5, t5) {
              e5(t5), o3.shift(), o3.length && a3(o3[0][0], o3[0][1]);
            }
          }, Q2 = new DataView(new ArrayBuffer(0)), x2 = new Uint8Array(Q2.buffer), F2 = function() {
            try {
              Q2.getInt8(0);
            } catch (e4) {
              return e4.constructor;
            }
            throw new Error("never reached");
          }(), V2 = new F2("Insufficient data"), j2 = new P2(), G2 = function() {
            function e4(e5, t4, i3, n3, o3, s3, a3, c3) {
              e5 === void 0 && (e5 = T2.defaultCodec), t4 === void 0 && (t4 = void 0), i3 === void 0 && (i3 = r2), n3 === void 0 && (n3 = r2), o3 === void 0 && (o3 = r2), s3 === void 0 && (s3 = r2), a3 === void 0 && (a3 = r2), c3 === void 0 && (c3 = j2), this.extensionCodec = e5, this.context = t4, this.maxStrLength = i3, this.maxBinLength = n3, this.maxArrayLength = o3, this.maxMapLength = s3, this.maxExtLength = a3, this.keyDecoder = c3, this.totalPos = 0, this.pos = 0, this.view = Q2, this.bytes = x2, this.headByte = -1, this.stack = [];
            }
            return e4.prototype.reinitializeState = function() {
              this.totalPos = 0, this.headByte = -1, this.stack.length = 0;
            }, e4.prototype.setBuffer = function(e5) {
              this.bytes = w2(e5), this.view = function(e6) {
                if (e6 instanceof ArrayBuffer)
                  return new DataView(e6);
                var t4 = w2(e6);
                return new DataView(t4.buffer, t4.byteOffset, t4.byteLength);
              }(this.bytes), this.pos = 0;
            }, e4.prototype.appendBuffer = function(e5) {
              if (this.headByte !== -1 || this.hasRemaining(1)) {
                var t4 = this.bytes.subarray(this.pos), r3 = w2(e5), i3 = new Uint8Array(t4.length + r3.length);
                i3.set(t4), i3.set(r3, t4.length), this.setBuffer(i3);
              } else
                this.setBuffer(e5);
            }, e4.prototype.hasRemaining = function(e5) {
              return this.view.byteLength - this.pos >= e5;
            }, e4.prototype.createExtraByteError = function(e5) {
              var t4 = this.view, r3 = this.pos;
              return new RangeError("Extra " + (t4.byteLength - r3) + " of " + t4.byteLength + " byte(s) found at buffer[" + e5 + "]");
            }, e4.prototype.decode = function(e5) {
              this.reinitializeState(), this.setBuffer(e5);
              var t4 = this.doDecodeSync();
              if (this.hasRemaining(1))
                throw this.createExtraByteError(this.pos);
              return t4;
            }, e4.prototype.decodeMulti = function(e5) {
              return k2(this, function(t4) {
                switch (t4.label) {
                  case 0:
                    this.reinitializeState(), this.setBuffer(e5), t4.label = 1;
                  case 1:
                    return this.hasRemaining(1) ? [4, this.doDecodeSync()] : [3, 3];
                  case 2:
                    return t4.sent(), [3, 1];
                  case 3:
                    return [2];
                }
              });
            }, e4.prototype.decodeAsync = function(e5) {
              var t4, r3, i3, n3, o3, s3, a3, c3;
              return o3 = this, s3 = void 0, c3 = function() {
                var o4, s4, a4, c4, d3, u3, A3, h3;
                return k2(this, function(l3) {
                  switch (l3.label) {
                    case 0:
                      o4 = false, l3.label = 1;
                    case 1:
                      l3.trys.push([1, 6, 7, 12]), t4 = B2(e5), l3.label = 2;
                    case 2:
                      return [4, t4.next()];
                    case 3:
                      if ((r3 = l3.sent()).done)
                        return [3, 5];
                      if (a4 = r3.value, o4)
                        throw this.createExtraByteError(this.totalPos);
                      this.appendBuffer(a4);
                      try {
                        s4 = this.doDecodeSync(), o4 = true;
                      } catch (e6) {
                        if (!(e6 instanceof F2))
                          throw e6;
                      }
                      this.totalPos += this.pos, l3.label = 4;
                    case 4:
                      return [3, 2];
                    case 5:
                      return [3, 12];
                    case 6:
                      return c4 = l3.sent(), i3 = { error: c4 }, [3, 12];
                    case 7:
                      return l3.trys.push([7, , 10, 11]), r3 && !r3.done && (n3 = t4.return) ? [4, n3.call(t4)] : [3, 9];
                    case 8:
                      l3.sent(), l3.label = 9;
                    case 9:
                      return [3, 11];
                    case 10:
                      if (i3)
                        throw i3.error;
                      return [7];
                    case 11:
                      return [7];
                    case 12:
                      if (o4) {
                        if (this.hasRemaining(1))
                          throw this.createExtraByteError(this.totalPos);
                        return [2, s4];
                      }
                      throw u3 = (d3 = this).headByte, A3 = d3.pos, h3 = d3.totalPos, new RangeError("Insufficient data in parsing " + L2(u3) + " at " + h3 + " (" + A3 + " in the current buffer)");
                  }
                });
              }, new ((a3 = void 0) || (a3 = Promise))(function(e6, t5) {
                function r4(e7) {
                  try {
                    n4(c3.next(e7));
                  } catch (e8) {
                    t5(e8);
                  }
                }
                function i4(e7) {
                  try {
                    n4(c3.throw(e7));
                  } catch (e8) {
                    t5(e8);
                  }
                }
                function n4(t6) {
                  var n5;
                  t6.done ? e6(t6.value) : (n5 = t6.value, n5 instanceof a3 ? n5 : new a3(function(e7) {
                    e7(n5);
                  })).then(r4, i4);
                }
                n4((c3 = c3.apply(o3, s3 || [])).next());
              });
            }, e4.prototype.decodeArrayStream = function(e5) {
              return this.decodeMultiAsync(e5, true);
            }, e4.prototype.decodeStream = function(e5) {
              return this.decodeMultiAsync(e5, false);
            }, e4.prototype.decodeMultiAsync = function(e5, t4) {
              return U2(this, arguments, function() {
                var r3, i3, n3, o3, s3, a3, c3, d3, u3;
                return k2(this, function(A3) {
                  switch (A3.label) {
                    case 0:
                      r3 = t4, i3 = -1, A3.label = 1;
                    case 1:
                      A3.trys.push([1, 13, 14, 19]), n3 = B2(e5), A3.label = 2;
                    case 2:
                      return [4, M2(n3.next())];
                    case 3:
                      if ((o3 = A3.sent()).done)
                        return [3, 12];
                      if (s3 = o3.value, t4 && i3 === 0)
                        throw this.createExtraByteError(this.totalPos);
                      this.appendBuffer(s3), r3 && (i3 = this.readArraySize(), r3 = false, this.complete()), A3.label = 4;
                    case 4:
                      A3.trys.push([4, 9, , 10]), A3.label = 5;
                    case 5:
                      return [4, M2(this.doDecodeSync())];
                    case 6:
                      return [4, A3.sent()];
                    case 7:
                      return A3.sent(), --i3 == 0 ? [3, 8] : [3, 5];
                    case 8:
                      return [3, 10];
                    case 9:
                      if (!((a3 = A3.sent()) instanceof F2))
                        throw a3;
                      return [3, 10];
                    case 10:
                      this.totalPos += this.pos, A3.label = 11;
                    case 11:
                      return [3, 2];
                    case 12:
                      return [3, 19];
                    case 13:
                      return c3 = A3.sent(), d3 = { error: c3 }, [3, 19];
                    case 14:
                      return A3.trys.push([14, , 17, 18]), o3 && !o3.done && (u3 = n3.return) ? [4, M2(u3.call(n3))] : [3, 16];
                    case 15:
                      A3.sent(), A3.label = 16;
                    case 16:
                      return [3, 18];
                    case 17:
                      if (d3)
                        throw d3.error;
                      return [7];
                    case 18:
                      return [7];
                    case 19:
                      return [2];
                  }
                });
              });
            }, e4.prototype.doDecodeSync = function() {
              e:
                for (; ; ) {
                  var e5 = this.readHeadByte(), t4 = void 0;
                  if (e5 >= 224)
                    t4 = e5 - 256;
                  else if (e5 < 192)
                    if (e5 < 128)
                      t4 = e5;
                    else if (e5 < 144) {
                      if ((i3 = e5 - 128) != 0) {
                        this.pushMapState(i3), this.complete();
                        continue e;
                      }
                      t4 = {};
                    } else if (e5 < 160) {
                      if ((i3 = e5 - 144) != 0) {
                        this.pushArrayState(i3), this.complete();
                        continue e;
                      }
                      t4 = [];
                    } else {
                      var r3 = e5 - 160;
                      t4 = this.decodeUtf8String(r3, 0);
                    }
                  else if (e5 === 192)
                    t4 = null;
                  else if (e5 === 194)
                    t4 = false;
                  else if (e5 === 195)
                    t4 = true;
                  else if (e5 === 202)
                    t4 = this.readF32();
                  else if (e5 === 203)
                    t4 = this.readF64();
                  else if (e5 === 204)
                    t4 = this.readU8();
                  else if (e5 === 205)
                    t4 = this.readU16();
                  else if (e5 === 206)
                    t4 = this.readU32();
                  else if (e5 === 207)
                    t4 = this.readU64();
                  else if (e5 === 208)
                    t4 = this.readI8();
                  else if (e5 === 209)
                    t4 = this.readI16();
                  else if (e5 === 210)
                    t4 = this.readI32();
                  else if (e5 === 211)
                    t4 = this.readI64();
                  else if (e5 === 217)
                    r3 = this.lookU8(), t4 = this.decodeUtf8String(r3, 1);
                  else if (e5 === 218)
                    r3 = this.lookU16(), t4 = this.decodeUtf8String(r3, 2);
                  else if (e5 === 219)
                    r3 = this.lookU32(), t4 = this.decodeUtf8String(r3, 4);
                  else if (e5 === 220) {
                    if ((i3 = this.readU16()) !== 0) {
                      this.pushArrayState(i3), this.complete();
                      continue e;
                    }
                    t4 = [];
                  } else if (e5 === 221) {
                    if ((i3 = this.readU32()) !== 0) {
                      this.pushArrayState(i3), this.complete();
                      continue e;
                    }
                    t4 = [];
                  } else if (e5 === 222) {
                    if ((i3 = this.readU16()) !== 0) {
                      this.pushMapState(i3), this.complete();
                      continue e;
                    }
                    t4 = {};
                  } else if (e5 === 223) {
                    if ((i3 = this.readU32()) !== 0) {
                      this.pushMapState(i3), this.complete();
                      continue e;
                    }
                    t4 = {};
                  } else if (e5 === 196) {
                    var i3 = this.lookU8();
                    t4 = this.decodeBinary(i3, 1);
                  } else if (e5 === 197)
                    i3 = this.lookU16(), t4 = this.decodeBinary(i3, 2);
                  else if (e5 === 198)
                    i3 = this.lookU32(), t4 = this.decodeBinary(i3, 4);
                  else if (e5 === 212)
                    t4 = this.decodeExtension(1, 0);
                  else if (e5 === 213)
                    t4 = this.decodeExtension(2, 0);
                  else if (e5 === 214)
                    t4 = this.decodeExtension(4, 0);
                  else if (e5 === 215)
                    t4 = this.decodeExtension(8, 0);
                  else if (e5 === 216)
                    t4 = this.decodeExtension(16, 0);
                  else if (e5 === 199)
                    i3 = this.lookU8(), t4 = this.decodeExtension(i3, 1);
                  else if (e5 === 200)
                    i3 = this.lookU16(), t4 = this.decodeExtension(i3, 2);
                  else {
                    if (e5 !== 201)
                      throw new I2("Unrecognized type byte: " + L2(e5));
                    i3 = this.lookU32(), t4 = this.decodeExtension(i3, 4);
                  }
                  this.complete();
                  for (var n3 = this.stack; n3.length > 0; ) {
                    var o3 = n3[n3.length - 1];
                    if (o3.type === 0) {
                      if (o3.array[o3.position] = t4, o3.position++, o3.position !== o3.size)
                        continue e;
                      n3.pop(), t4 = o3.array;
                    } else {
                      if (o3.type === 1) {
                        if ((s3 = typeof t4) != "string" && s3 !== "number")
                          throw new I2("The type of key must be string or number but " + typeof t4);
                        if (t4 === "__proto__")
                          throw new I2("The key __proto__ is not allowed");
                        o3.key = t4, o3.type = 2;
                        continue e;
                      }
                      if (o3.map[o3.key] = t4, o3.readCount++, o3.readCount !== o3.size) {
                        o3.key = null, o3.type = 1;
                        continue e;
                      }
                      n3.pop(), t4 = o3.map;
                    }
                  }
                  return t4;
                }
              var s3;
            }, e4.prototype.readHeadByte = function() {
              return this.headByte === -1 && (this.headByte = this.readU8()), this.headByte;
            }, e4.prototype.complete = function() {
              this.headByte = -1;
            }, e4.prototype.readArraySize = function() {
              var e5 = this.readHeadByte();
              switch (e5) {
                case 220:
                  return this.readU16();
                case 221:
                  return this.readU32();
                default:
                  if (e5 < 160)
                    return e5 - 144;
                  throw new I2("Unrecognized array type byte: " + L2(e5));
              }
            }, e4.prototype.pushMapState = function(e5) {
              if (e5 > this.maxMapLength)
                throw new I2("Max length exceeded: map length (" + e5 + ") > maxMapLengthLength (" + this.maxMapLength + ")");
              this.stack.push({ type: 1, size: e5, key: null, readCount: 0, map: {} });
            }, e4.prototype.pushArrayState = function(e5) {
              if (e5 > this.maxArrayLength)
                throw new I2("Max length exceeded: array length (" + e5 + ") > maxArrayLength (" + this.maxArrayLength + ")");
              this.stack.push({ type: 0, size: e5, array: new Array(e5), position: 0 });
            }, e4.prototype.decodeUtf8String = function(e5, t4) {
              var r3;
              if (e5 > this.maxStrLength)
                throw new I2("Max length exceeded: UTF-8 byte length (" + e5 + ") > maxStrLength (" + this.maxStrLength + ")");
              if (this.bytes.byteLength < this.pos + t4 + e5)
                throw V2;
              var i3, n3 = this.pos + t4;
              return i3 = this.stateIsMapKey() && ((r3 = this.keyDecoder) === null || r3 === void 0 ? void 0 : r3.canBeCached(e5)) ? this.keyDecoder.decode(this.bytes, n3, e5) : e5 > g2 ? function(e6, t5, r4) {
                var i4 = e6.subarray(t5, t5 + r4);
                return p2.decode(i4);
              }(this.bytes, n3, e5) : h2(this.bytes, n3, e5), this.pos += t4 + e5, i3;
            }, e4.prototype.stateIsMapKey = function() {
              return this.stack.length > 0 && this.stack[this.stack.length - 1].type === 1;
            }, e4.prototype.decodeBinary = function(e5, t4) {
              if (e5 > this.maxBinLength)
                throw new I2("Max length exceeded: bin length (" + e5 + ") > maxBinLength (" + this.maxBinLength + ")");
              if (!this.hasRemaining(e5 + t4))
                throw V2;
              var r3 = this.pos + t4, i3 = this.bytes.subarray(r3, r3 + e5);
              return this.pos += t4 + e5, i3;
            }, e4.prototype.decodeExtension = function(e5, t4) {
              if (e5 > this.maxExtLength)
                throw new I2("Max length exceeded: ext length (" + e5 + ") > maxExtLength (" + this.maxExtLength + ")");
              var r3 = this.view.getInt8(this.pos + t4), i3 = this.decodeBinary(e5, t4 + 1);
              return this.extensionCodec.decode(i3, r3, this.context);
            }, e4.prototype.lookU8 = function() {
              return this.view.getUint8(this.pos);
            }, e4.prototype.lookU16 = function() {
              return this.view.getUint16(this.pos);
            }, e4.prototype.lookU32 = function() {
              return this.view.getUint32(this.pos);
            }, e4.prototype.readU8 = function() {
              var e5 = this.view.getUint8(this.pos);
              return this.pos++, e5;
            }, e4.prototype.readI8 = function() {
              var e5 = this.view.getInt8(this.pos);
              return this.pos++, e5;
            }, e4.prototype.readU16 = function() {
              var e5 = this.view.getUint16(this.pos);
              return this.pos += 2, e5;
            }, e4.prototype.readI16 = function() {
              var e5 = this.view.getInt16(this.pos);
              return this.pos += 2, e5;
            }, e4.prototype.readU32 = function() {
              var e5 = this.view.getUint32(this.pos);
              return this.pos += 4, e5;
            }, e4.prototype.readI32 = function() {
              var e5 = this.view.getInt32(this.pos);
              return this.pos += 4, e5;
            }, e4.prototype.readU64 = function() {
              var e5, t4, r3 = (e5 = this.view, t4 = this.pos, 4294967296 * e5.getUint32(t4) + e5.getUint32(t4 + 4));
              return this.pos += 8, r3;
            }, e4.prototype.readI64 = function() {
              var e5 = n2(this.view, this.pos);
              return this.pos += 8, e5;
            }, e4.prototype.readF32 = function() {
              var e5 = this.view.getFloat32(this.pos);
              return this.pos += 4, e5;
            }, e4.prototype.readF64 = function() {
              var e5 = this.view.getFloat64(this.pos);
              return this.pos += 8, e5;
            }, e4;
          }(), K2 = {};
          function H2(e4, t4) {
            return t4 === void 0 && (t4 = K2), new G2(t4.extensionCodec, t4.context, t4.maxStrLength, t4.maxBinLength, t4.maxArrayLength, t4.maxMapLength, t4.maxExtLength).decode(e4);
          }
          function Y2(e4, t4) {
            return t4 === void 0 && (t4 = K2), new G2(t4.extensionCodec, t4.context, t4.maxStrLength, t4.maxBinLength, t4.maxArrayLength, t4.maxMapLength, t4.maxExtLength).decodeMulti(e4);
          }
          var W2 = function(e4, t4) {
            var r3, i3, n3, o3, s3 = { label: 0, sent: function() {
              if (1 & n3[0])
                throw n3[1];
              return n3[1];
            }, trys: [], ops: [] };
            return o3 = { next: a3(0), throw: a3(1), return: a3(2) }, typeof Symbol == "function" && (o3[Symbol.iterator] = function() {
              return this;
            }), o3;
            function a3(o4) {
              return function(a4) {
                return function(o5) {
                  if (r3)
                    throw new TypeError("Generator is already executing.");
                  for (; s3; )
                    try {
                      if (r3 = 1, i3 && (n3 = 2 & o5[0] ? i3.return : o5[0] ? i3.throw || ((n3 = i3.return) && n3.call(i3), 0) : i3.next) && !(n3 = n3.call(i3, o5[1])).done)
                        return n3;
                      switch (i3 = 0, n3 && (o5 = [2 & o5[0], n3.value]), o5[0]) {
                        case 0:
                        case 1:
                          n3 = o5;
                          break;
                        case 4:
                          return s3.label++, { value: o5[1], done: false };
                        case 5:
                          s3.label++, i3 = o5[1], o5 = [0];
                          continue;
                        case 7:
                          o5 = s3.ops.pop(), s3.trys.pop();
                          continue;
                        default:
                          if (!((n3 = (n3 = s3.trys).length > 0 && n3[n3.length - 1]) || o5[0] !== 6 && o5[0] !== 2)) {
                            s3 = 0;
                            continue;
                          }
                          if (o5[0] === 3 && (!n3 || o5[1] > n3[0] && o5[1] < n3[3])) {
                            s3.label = o5[1];
                            break;
                          }
                          if (o5[0] === 6 && s3.label < n3[1]) {
                            s3.label = n3[1], n3 = o5;
                            break;
                          }
                          if (n3 && s3.label < n3[2]) {
                            s3.label = n3[2], s3.ops.push(o5);
                            break;
                          }
                          n3[2] && s3.ops.pop(), s3.trys.pop();
                          continue;
                      }
                      o5 = t4.call(e4, s3);
                    } catch (e5) {
                      o5 = [6, e5], i3 = 0;
                    } finally {
                      r3 = n3 = 0;
                    }
                  if (5 & o5[0])
                    throw o5[1];
                  return { value: o5[0] ? o5[1] : void 0, done: true };
                }([o4, a4]);
              };
            }
          }, J2 = function(e4) {
            return this instanceof J2 ? (this.v = e4, this) : new J2(e4);
          }, q2 = function(e4, t4, r3) {
            if (!Symbol.asyncIterator)
              throw new TypeError("Symbol.asyncIterator is not defined.");
            var i3, n3 = r3.apply(e4, t4 || []), o3 = [];
            return i3 = {}, s3("next"), s3("throw"), s3("return"), i3[Symbol.asyncIterator] = function() {
              return this;
            }, i3;
            function s3(e5) {
              n3[e5] && (i3[e5] = function(t5) {
                return new Promise(function(r4, i4) {
                  o3.push([e5, t5, r4, i4]) > 1 || a3(e5, t5);
                });
              });
            }
            function a3(e5, t5) {
              try {
                (r4 = n3[e5](t5)).value instanceof J2 ? Promise.resolve(r4.value.v).then(c3, d3) : u3(o3[0][2], r4);
              } catch (e6) {
                u3(o3[0][3], e6);
              }
              var r4;
            }
            function c3(e5) {
              a3("next", e5);
            }
            function d3(e5) {
              a3("throw", e5);
            }
            function u3(e5, t5) {
              e5(t5), o3.shift(), o3.length && a3(o3[0][0], o3[0][1]);
            }
          };
          function z2(e4) {
            if (e4 == null)
              throw new Error("Assertion Failure: value must not be null nor undefined");
          }
          function X2(e4) {
            return e4[Symbol.asyncIterator] != null ? e4 : function(e5) {
              return q2(this, arguments, function() {
                var t4, r3, i3, n3;
                return W2(this, function(o3) {
                  switch (o3.label) {
                    case 0:
                      t4 = e5.getReader(), o3.label = 1;
                    case 1:
                      o3.trys.push([1, , 9, 10]), o3.label = 2;
                    case 2:
                      return [4, J2(t4.read())];
                    case 3:
                      return r3 = o3.sent(), i3 = r3.done, n3 = r3.value, i3 ? [4, J2(void 0)] : [3, 5];
                    case 4:
                      return [2, o3.sent()];
                    case 5:
                      return z2(n3), [4, J2(n3)];
                    case 6:
                      return [4, o3.sent()];
                    case 7:
                      return o3.sent(), [3, 2];
                    case 8:
                      return [3, 10];
                    case 9:
                      return t4.releaseLock(), [7];
                    case 10:
                      return [2];
                  }
                });
              });
            }(e4);
          }
          function Z2(e4, t4) {
            return t4 === void 0 && (t4 = K2), r3 = this, i3 = void 0, o3 = function() {
              var r4;
              return function(e5, t5) {
                var r5, i4, n4, o4, s3 = { label: 0, sent: function() {
                  if (1 & n4[0])
                    throw n4[1];
                  return n4[1];
                }, trys: [], ops: [] };
                return o4 = { next: a3(0), throw: a3(1), return: a3(2) }, typeof Symbol == "function" && (o4[Symbol.iterator] = function() {
                  return this;
                }), o4;
                function a3(o5) {
                  return function(a4) {
                    return function(o6) {
                      if (r5)
                        throw new TypeError("Generator is already executing.");
                      for (; s3; )
                        try {
                          if (r5 = 1, i4 && (n4 = 2 & o6[0] ? i4.return : o6[0] ? i4.throw || ((n4 = i4.return) && n4.call(i4), 0) : i4.next) && !(n4 = n4.call(i4, o6[1])).done)
                            return n4;
                          switch (i4 = 0, n4 && (o6 = [2 & o6[0], n4.value]), o6[0]) {
                            case 0:
                            case 1:
                              n4 = o6;
                              break;
                            case 4:
                              return s3.label++, { value: o6[1], done: false };
                            case 5:
                              s3.label++, i4 = o6[1], o6 = [0];
                              continue;
                            case 7:
                              o6 = s3.ops.pop(), s3.trys.pop();
                              continue;
                            default:
                              if (!((n4 = (n4 = s3.trys).length > 0 && n4[n4.length - 1]) || o6[0] !== 6 && o6[0] !== 2)) {
                                s3 = 0;
                                continue;
                              }
                              if (o6[0] === 3 && (!n4 || o6[1] > n4[0] && o6[1] < n4[3])) {
                                s3.label = o6[1];
                                break;
                              }
                              if (o6[0] === 6 && s3.label < n4[1]) {
                                s3.label = n4[1], n4 = o6;
                                break;
                              }
                              if (n4 && s3.label < n4[2]) {
                                s3.label = n4[2], s3.ops.push(o6);
                                break;
                              }
                              n4[2] && s3.ops.pop(), s3.trys.pop();
                              continue;
                          }
                          o6 = t5.call(e5, s3);
                        } catch (e6) {
                          o6 = [6, e6], i4 = 0;
                        } finally {
                          r5 = n4 = 0;
                        }
                      if (5 & o6[0])
                        throw o6[1];
                      return { value: o6[0] ? o6[1] : void 0, done: true };
                    }([o5, a4]);
                  };
                }
              }(this, function(i4) {
                return r4 = X2(e4), [2, new G2(t4.extensionCodec, t4.context, t4.maxStrLength, t4.maxBinLength, t4.maxArrayLength, t4.maxMapLength, t4.maxExtLength).decodeAsync(r4)];
              });
            }, new ((n3 = void 0) || (n3 = Promise))(function(e5, t5) {
              function s3(e6) {
                try {
                  c3(o3.next(e6));
                } catch (e7) {
                  t5(e7);
                }
              }
              function a3(e6) {
                try {
                  c3(o3.throw(e6));
                } catch (e7) {
                  t5(e7);
                }
              }
              function c3(t6) {
                var r4;
                t6.done ? e5(t6.value) : (r4 = t6.value, r4 instanceof n3 ? r4 : new n3(function(e6) {
                  e6(r4);
                })).then(s3, a3);
              }
              c3((o3 = o3.apply(r3, i3 || [])).next());
            });
            var r3, i3, n3, o3;
          }
          function $2(e4, t4) {
            t4 === void 0 && (t4 = K2);
            var r3 = X2(e4);
            return new G2(t4.extensionCodec, t4.context, t4.maxStrLength, t4.maxBinLength, t4.maxArrayLength, t4.maxMapLength, t4.maxExtLength).decodeArrayStream(r3);
          }
          function ee2(e4, t4) {
            t4 === void 0 && (t4 = K2);
            var r3 = X2(e4);
            return new G2(t4.extensionCodec, t4.context, t4.maxStrLength, t4.maxBinLength, t4.maxArrayLength, t4.maxMapLength, t4.maxExtLength).decodeStream(r3);
          }
          function te2(e4, t4) {
            return t4 === void 0 && (t4 = K2), ee2(e4, t4);
          }
          return t3;
        }();
      }(xW), (0, RM.exports)("Int8", function(e2) {
        return function(t2, r2, i2) {
          return e2(this, t2, r2, i2);
        };
      }), (0, RM.exports)("Int16", function(e2) {
        return function(t2, r2, i2) {
          return e2(this, t2, r2, i2);
        };
      }), (0, RM.exports)("Int32", function(e2) {
        return function(t2, r2, i2) {
          return e2(this, t2, r2, i2);
        };
      }), (0, RM.exports)("Uint16", function(e2) {
        return function(t2, r2, i2) {
          return e2(this, t2, r2, i2);
        };
      }), (0, RM.exports)("Uint32", function(e2) {
        return function(t2, r2, i2) {
          return e2(this, t2, r2, i2);
        };
      }), (0, RM.exports)("Float32", function(e2) {
        return function(t2, r2, i2) {
          return e2(this, t2, r2, i2);
        };
      }), (0, RM.exports)("Float64", function(e2) {
        return function(t2, r2, i2) {
          return e2(this, t2, r2, i2);
        };
      });
      const FW = () => function(e2) {
        const t2 = window.atob(e2).split("").map((e3) => e3.charCodeAt(0));
        return new Uint8Array(t2, 0, t2.length / Uint8Array.BYTES_PER_ELEMENT);
      }("AGFzbQEAAAABMAlgA39/fwF/YAF/AGACf38AYAF/AX9gAn9/AX9gA39/fwBgBH9/f38AYAABf2AAAAI6AgNlbnYWZW1zY3JpcHRlbl9yZXNpemVfaGVhcAADA2VudhVlbXNjcmlwdGVuX21lbWNweV9iaWcAAAMjIggAAAAAAQEDAQEEBAQEAQEGAQYCBQUAAgAHAwEDAAIHAQMEBQFwAQYGBQYBAYACgAIGCQF/AUHQ48ACCweUAQoGbWVtb3J5AgARX193YXNtX2NhbGxfY3RvcnMAAhlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQAGbWFsbG9jABwEZnJlZQAdEF9fZXJybm9fbG9jYXRpb24AGwx6bGliQ29tcHJlc3MAGglzdGFja1NhdmUAIQxzdGFja1Jlc3RvcmUAIgpzdGFja0FsbG9jACMJCwEAQQELBRgZDA0PCq6FAiIDAAELpQcBBH8gAEH//wNxIQMgAEEQdiEEQQEhACACQQFGBEAgAyABLQAAaiIAQfH/A2sgACAAQfD/A0sbIgAgBGoiA0EQdCIEQYCAPGogBCADQfD/A0sbIAByDwsgAQR/IAJBEE8EQAJAAkACQCACQa8rSwRAA0AgAkGwK2shAkHbAiEFIAEhAANAIAMgAC0AAGoiAyAEaiADIAAtAAFqIgNqIAMgAC0AAmoiA2ogAyAALQADaiIDaiADIAAtAARqIgNqIAMgAC0ABWoiA2ogAyAALQAGaiIDaiADIAAtAAdqIgNqIAMgAC0ACGoiA2ogAyAALQAJaiIDaiADIAAtAApqIgNqIAMgAC0AC2oiA2ogAyAALQAMaiIDaiADIAAtAA1qIgNqIAMgAC0ADmoiA2ogAyAALQAPaiIDaiEEIABBEGohACAFQQFrIgUNAAsgBEHx/wNwIQQgA0Hx/wNwIQMgAUGwK2ohASACQa8rSw0ACyACRQ0DIAJBEEkNAQsDQCADIAEtAABqIgAgBGogACABLQABaiIAaiAAIAEtAAJqIgBqIAAgAS0AA2oiAGogACABLQAEaiIAaiAAIAEtAAVqIgBqIAAgAS0ABmoiAGogACABLQAHaiIAaiAAIAEtAAhqIgBqIAAgAS0ACWoiAGogACABLQAKaiIAaiAAIAEtAAtqIgBqIAAgAS0ADGoiAGogACABLQANaiIAaiAAIAEtAA5qIgBqIAAgAS0AD2oiA2ohBCABQRBqIQEgAkEQayICQQ9LDQALIAJFDQELIAJBAWshBiACQQNxIgUEQCABIQADQCACQQFrIQIgAyAALQAAaiIDIARqIQQgAEEBaiIBIQAgBUEBayIFDQALCyAGQQNJDQADQCADIAEtAABqIgAgAS0AAWoiBSABLQACaiIGIAEtAANqIgMgBiAFIAAgBGpqamohBCABQQRqIQEgAkEEayICDQALCyAEQfH/A3AhBCADQfH/A3AhAwsgBEEQdCADcg8LAkAgAkUNACACQQFrIQYgAkEDcSIFBEAgASEAA0AgAkEBayECIAMgAC0AAGoiAyAEaiEEIABBAWoiASEAIAVBAWsiBQ0ACwsgBkEDSQ0AA0AgAyABLQAAaiIAIAEtAAFqIgUgAS0AAmoiBiABLQADaiIDIAYgBSAAIARqampqIQQgAUEEaiEBIAJBBGsiAg0ACwsgBEHx/wNwQRB0IANB8f8DayADIANB8P8DSxtyBSAACwsKACAAIAEgAhADC4UJAQJ/IAFFBEBBAA8LIABBf3MhAAJAIAJFDQAgAUEDcUUNACABLQAAIABB/wFxc0ECdEGACGooAgAgAEEIdnMhACACQQFrIgRBACABQQFqIgNBA3EbRQRAIAMhASAEIQIMAQsgAS0AASAAQf8BcXNBAnRBgAhqKAIAIABBCHZzIQAgAUECaiEDAkAgAkECayIERQ0AIANBA3FFDQAgAS0AAiAAQf8BcXNBAnRBgAhqKAIAIABBCHZzIQAgAUEDaiEDAkAgAkEDayIERQ0AIANBA3FFDQAgAS0AAyAAQf8BcXNBAnRBgAhqKAIAIABBCHZzIQAgAkEEayECIAFBBGohAQwCCyADIQEgBCECDAELIAMhASAEIQILIAJBH0sEQANAIAEoAhwgASgCGCABKAIUIAEoAhAgASgCDCABKAIIIAEoAgQgASgCACAAcyIAQQZ2QfwHcUGAGGooAgAgAEH/AXFBAnRBgCBqKAIAcyAAQQ52QfwHcUGAEGooAgBzIABBFnZB/AdxQYAIaigCAHNzIgBBBnZB/AdxQYAYaigCACAAQf8BcUECdEGAIGooAgBzIABBDnZB/AdxQYAQaigCAHMgAEEWdkH8B3FBgAhqKAIAc3MiAEEGdkH8B3FBgBhqKAIAIABB/wFxQQJ0QYAgaigCAHMgAEEOdkH8B3FBgBBqKAIAcyAAQRZ2QfwHcUGACGooAgBzcyIAQQZ2QfwHcUGAGGooAgAgAEH/AXFBAnRBgCBqKAIAcyAAQQ52QfwHcUGAEGooAgBzIABBFnZB/AdxQYAIaigCAHNzIgBBBnZB/AdxQYAYaigCACAAQf8BcUECdEGAIGooAgBzIABBDnZB/AdxQYAQaigCAHMgAEEWdkH8B3FBgAhqKAIAc3MiAEEGdkH8B3FBgBhqKAIAIABB/wFxQQJ0QYAgaigCAHMgAEEOdkH8B3FBgBBqKAIAcyAAQRZ2QfwHcUGACGooAgBzcyIAQQZ2QfwHcUGAGGooAgAgAEH/AXFBAnRBgCBqKAIAcyAAQQ52QfwHcUGAEGooAgBzIABBFnZB/AdxQYAIaigCAHNzIgBBBnZB/AdxQYAYaigCACAAQf8BcUECdEGAIGooAgBzIABBDnZB/AdxQYAQaigCAHMgAEEWdkH8B3FBgAhqKAIAcyEAIAFBIGohASACQSBrIgJBH0sNAAsLIAJBA0sEQANAIAEoAgAgAHMiAEEGdkH8B3FBgBhqKAIAIABB/wFxQQJ0QYAgaigCAHMgAEEOdkH8B3FBgBBqKAIAcyAAQRZ2QfwHcUGACGooAgBzIQAgAUEEaiEBIAJBBGsiAkEDSw0ACwsCQCACRQ0AIAJBAXEEfyABLQAAIABB/wFxc0ECdEGACGooAgAgAEEIdnMhACABQQFqIQEgAkEBawUgAgshAyACQQFGDQADQCABLQABIAEtAAAgAEH/AXFzQQJ0QYAIaigCACAAQQh2cyIAQf8BcXNBAnRBgAhqKAIAIABBCHZzIQAgAUECaiEBIANBAmsiAw0ACwsgAEF/cwsKACAAIAEgAhAFC9wEAQN/AkBByN8ALQAAQTFHDQAgAEUNACAAQQA2AhggACgCICIBRQRAIABBADYCKCAAQQE2AiBBASEBCyAAKAIkRQRAIABBAjYCJAsgACgCKEEBQcQtIAERAAAiAUUNACAAIAE2AhwgAUEPNgIwIAFBADYCHCABQQA2AhggAUEqNgIEIAEgADYCACABQQs2AlAgAUGAgAI2AiwgAUH//wE2AjQgAUGAEDYCTCABQQQ2AlggAUH/DzYCVCABIAAoAihBgIACQQIgACgCIBEAADYCOCABIAAoAiggASgCLEECIAAoAiARAAA2AkAgACgCKCABKAJMQQIgACgCIBEAACECIAFBADYCwC0gASACNgJEIAFBgAg2ApwtIAEgACgCKEGACEEEIAAoAiARAAAiAjYCCCABIAEoApwtIgNBAnQ2AgwCQAJAIAEoAjhFDQAgASgCQEUNACACRQ0AIAEoAkQNAQsgAUGaBTYCBCAAQbjfACgCADYCGCAAEAgPCyABQQA2AogBIAFBCTYChAEgAUEIOgAkIAEgAiADQQNsajYCmC0gASACIANBfnFqNgKkLSAAEAkNACAAKAIcIgAgACgCLEEBdDYCPCAAKAJEIgEgACgCTEEBdEECayIDakEAOwEAIAEgAxAgIABBADYCtC0gAEKAgICAIDcCdCAAQgA3AmggAEKAgICAIDcCXCAAQQA2AkggACAAKAKEAUEMbCIBQYTIAGovAQA2ApABIAAgAUGAyABqLwEANgKMASAAIAFBgsgAai8BADYCgAEgACABQYbIAGovAQA2AnwLC6kCAQN/AkAgAEUNACAAKAIgRQ0AIAAoAiQiA0UNACAAKAIcIgFFDQAgASgCACAARw0AAkACQCABKAIEIgJBOWsOOQECAgICAgICAgICAgECAgIBAgICAgICAgICAgICAgICAgIBAgICAgICAgICAgIBAgICAgICAgICAQALIAJBmgVGDQAgAkEqRw0BCwJ/An8CfyABKAIIIgIEQCAAKAIoIAIgAxECACAAKAIcIQELIAEoAkQiAgsEQCAAKAIoIAIgACgCJBECACAAKAIcIQELIAEoAkAiAgsEQCAAKAIoIAIgACgCJBECACAAKAIcIQELIAEoAjgiAgsEQCAAKAIoIAIgACgCJBECACAAKAIcIQELIAAoAiggASAAKAIkEQIAIABBADYCHAsLlgIBA39BfiECAkAgAEUNACAAKAIgRQ0AIAAoAiRFDQAgACgCHCIBRQ0AIAEoAgAgAEcNAAJAAkAgASgCBCIDQTlrDjkBAgICAgICAgICAgIBAgICAQICAgICAgICAgICAgICAgICAQICAgICAgICAgICAQICAgICAgICAgEACyADQZoFRg0AIANBKkcNAQsgAEECNgIsIABBADYCCCAAQgA3AhQgAUEANgIUIAEgASgCCDYCECABKAIYIgJBf0wEQCABQQAgAmsiAjYCGAsgAUE5QSpB8QAgAhsgAkECRhs2AgQgAAJ/IAJBAkYEQEEAQQBBABAGDAELQQBBAEEAEAQLNgIwQQAhAiABQQA2AiggARAQCyACC9wIAQt/IAAoAiwiB0GGAmshCyAAKAJ0IQUgByEBA0AgACgCPCAFayAAKAJsIghrIQYgASALaiAITQRAIAAoAjgiASABIAdqIAcgBmsQHxogACAAKAJwIAdrNgJwIAAgACgCbCAHayIINgJsIAAgACgCXCAHazYCXCAAKAJMIgRBAWshCiAAKAJEIARBAXRqIQMgACgCLCEBIARBA3EiAgRAA0AgA0ECayIDQQAgAy8BACIFIAFrIgkgBSAJSRs7AQAgBEEBayEEIAJBAWsiAg0ACwsgCkEDTwRAA0AgA0ECayICQQAgAi8BACICIAFrIgUgAiAFSRs7AQAgA0EEayICQQAgAi8BACICIAFrIgUgAiAFSRs7AQAgA0EGayICQQAgAi8BACICIAFrIgUgAiAFSRs7AQAgA0EIayIDQQAgAy8BACICIAFrIgUgAiAFSRs7AQAgBEEEayIEDQALCyABQQFrIQogACgCQCABQQF0aiEDIAEhBCABQQNxIgIEQANAIANBAmsiA0EAIAMvAQAiBSABayIJIAUgCUkbOwEAIARBAWshBCACQQFrIgINAAsLIApBA08EQANAIANBAmsiAkEAIAIvAQAiAiABayIFIAIgBUkbOwEAIANBBGsiAkEAIAIvAQAiAiABayIFIAIgBUkbOwEAIANBBmsiAkEAIAIvAQAiAiABayIFIAIgBUkbOwEAIANBCGsiA0EAIAMvAQAiAiABayIFIAIgBUkbOwEAIARBBGsiBA0ACwsgBiAHaiEGCwJAIAAoAgAiASgCBCIERQ0AIAAoAnQhAiAGIAQgBCAGSxsiAwRAIAAoAjghBSABIAQgA2s2AgQgBSAIaiACaiABKAIAIAMQHyEEAkACQAJAIAEoAhwoAhhBAWsOAgABAgsgASABKAIwIAQgAxAENgIwDAELIAEgASgCMCAEIAMQBjYCMAsgASABKAIAIANqNgIAIAEgASgCCCADajYCCCAAKAJ0IQILIAAgAiADaiIFNgJ0AkAgACgCtC0iAyAFakEDSQ0AIAAgACgCOCIJIAAoAmwgA2siAWoiBC0AACICNgJIIAAgACgCVCIIIAQtAAEgAiAAKAJYIgZ0c3EiBDYCSANAIANFDQEgACABIAlqLQACIAQgBnRzIAhxIgQ2AkggACgCQCAAKAI0IAFxQQF0aiAAKAJEIARBAXRqIgIvAQA7AQAgAiABOwEAIAAgA0EBayIDNgK0LSABQQFqIQEgAyAFakECSw0ACwsgBUGFAksNACAAKAIAKAIERQ0AIAAoAiwhAQwBCwsCQCAAKAI8IgQgACgCwC0iAU0NACAAKAJ0IAAoAmxqIgMgAUsEQCAAKAI4IANqIAQgA2siAUGCAiABQYICSRsiARAgIAAgASADajYCwC0PCyADQYICaiIDIAFNDQAgACgCOCABaiAEIAFrIgQgAyABayIBIAEgBEsbIgEQICAAIAAoAsAtIAFqNgLALQsLsSwBCn8CQCAARQ0AIAAoAiBFDQAgACgCJEUNACAAKAIcIgFFDQAgASgCACAARw0AAkACQCABKAIEIgNBOWsOOQECAgICAgICAgICAgECAgIBAgICAgICAgICAgICAgICAgIBAgICAgICAgICAgIBAgICAgICAgICAQALIANBmgVGDQAgA0EqRw0BCwJAAkAgACgCDEUNACAAKAIEIgIEQCAAKAIARQ0BCyADQZoFRw0BCyAAQbDfACgCADYCGA8LIAAoAhBFBEAgAEG83wAoAgA2AhgPCyABKAIoIQUgAUEDNgIoAkAgASgCFARAIAEQEwJAIAAoAhAiAyABKAIUIgQgAyAESRsiAkUNACAAKAIMIAEoAhAgAhAfGiAAIAAoAgwgAmo2AgwgASABKAIQIAJqNgIQIAAgACgCFCACajYCFCAAIAAoAhAgAmsiAzYCECABIAEoAhQgAmsiBDYCFCAEDQAgASABKAIINgIQQQAhBAsgAwRAIAEoAgQhAwwCCyABQX82AigPCyACDQAgBUEBdEF3QQAgBUEEShtqQQZIDQAgAEG83wAoAgA2AhgPCwJAAkACQAJAAn8CQAJAAkACQAJAAkAgA0EqRwRAIANBmgVHDQEgACgCBEUNAiAAQbzfACgCADYCGA8LIAEoAjBBDHRBgPABayEDQQAhAgJAIAEoAogBQQFKDQAgASgChAEiBUECSA0AQcAAIQIgBUEGSA0AQYABQcABIAVBBkYbIQILIAEgBEEBajYCFCABKAIIIARqIAIgA3IiAkEgciACIAEoAmwbIgJBCHY6AAAgASABKAIUIgNBAWo2AhQgAyABKAIIaiACQR9wIAJyQR9zOgAAIAEoAmwEQCAAKAIwIQIgASABKAIUIgNBAWo2AhQgAyABKAIIaiACQRh2OgAAIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAkEQdjoAACAAKAIwIQIgASABKAIUIgNBAWo2AhQgAyABKAIIaiACQQh2OgAAIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAjoAAAsgAEEAQQBBABAENgIwIAFB8QA2AgQgACgCHCICEBMCQCAAKAIQIgMgAigCFCIEIAMgBEkbIgNFDQAgACgCDCACKAIQIAMQHxogACAAKAIMIANqNgIMIAIgAigCECADajYCECAAIAAoAhQgA2o2AhQgACAAKAIQIANrNgIQIAIgAigCFCADayIDNgIUIAMNACACIAIoAgg2AhALIAEoAhQNBCABKAIEIQMLAkACQAJAAkACQAJAAkAgA0E5RgR/IABBAEEAQQAQBjYCMCABIAEoAhQiAkEBajYCFCACIAEoAghqQR86AAAgASABKAIUIgJBAWo2AhQgAiABKAIIakGLAToAACABIAEoAhQiAkEBajYCFCACIAEoAghqQQg6AAAgASgCHCICDQIgASABKAIUIgJBAWo2AhQgAiABKAIIakEAOgAAIAEgASgCFCICQQFqNgIUIAIgASgCCGpBADoAACABIAEoAhQiAkEBajYCFCACIAEoAghqQQA6AAAgASABKAIUIgJBAWo2AhQgAiABKAIIakEAOgAAIAEgASgCFCICQQFqNgIUIAIgASgCCGpBADoAAEECIQIgASgChAEiA0EJRwRAQQQgASgCiAFBAUpBAnQgA0ECSBshAgsgASABKAIUIgNBAWo2AhQgAyABKAIIaiACOgAAIAEgASgCFCICQQFqNgIUIAIgASgCCGpBAzoAACABQfEANgIEIAAoAhwiAhATAkAgACgCECIDIAIoAhQiBCADIARJGyIDRQ0AIAAoAgwgAigCECADEB8aIAAgACgCDCADajYCDCACIAIoAhAgA2o2AhAgACAAKAIUIANqNgIUIAAgACgCECADazYCECACIAIoAhQgA2siAzYCFCADDQAgAiACKAIINgIQCyABKAIUDQEgASgCBAUgAwtBxQBrDiMCBgYGAwYGBgYGBgYGBgYGBgYGBgYGBAYGBgYGBgYGBgYGBQYLIAFBfzYCKA8LIAIoAiQhAyACKAIcIQQgAigCECEFIAIoAiwhBiACKAIAIQggASABKAIUIgdBAWo2AhRBAiECIAcgASgCCGogBkEAR0EBdCAIQQBHciAFQQBHQQJ0ciAEQQBHQQN0ciADQQBHQQR0cjoAACABKAIcKAIEIQMgASABKAIUIgRBAWo2AhQgBCABKAIIaiADOgAAIAEoAhwoAgQhAyABIAEoAhQiBEEBajYCFCAEIAEoAghqIANBCHY6AAAgASgCHC8BBiEDIAEgASgCFCIEQQFqNgIUIAQgASgCCGogAzoAACABKAIcLQAHIQMgASABKAIUIgRBAWo2AhQgBCABKAIIaiADOgAAIAEoAoQBIgNBCUcEQEEEIAEoAogBQQFKQQJ0IANBAkgbIQILIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAjoAACABKAIcKAIMIQIgASABKAIUIgNBAWo2AhQgAyABKAIIaiACOgAAIAEoAhwiAigCEAR/IAIoAhQhAiABIAEoAhQiA0EBajYCFCADIAEoAghqIAI6AAAgASgCHCgCFCECIAEgASgCFCIDQQFqNgIUIAMgASgCCGogAkEIdjoAACABKAIcBSACCygCLARAIAAgACgCMCABKAIIIAEoAhQQBjYCMAsgAUHFADYCBCABQQA2AiALIAEoAhwiBCgCECIDBEAgASgCFCICIAQvARQgASgCICIGayIFaiABKAIMIgRLBEADQCABKAIIIAJqIAMgBmogBCACayIEEB8aIAEgASgCDCIDNgIUAkAgAiADTw0AIAEoAhwoAixFDQAgACAAKAIwIAEoAgggAmogAyACaxAGNgIwCyABIAEoAiAgBGo2AiAgACgCHCICEBMCQCAAKAIQIgMgAigCFCIGIAMgBkkbIgNFDQAgACgCDCACKAIQIAMQHxogACAAKAIMIANqNgIMIAIgAigCECADajYCECAAIAAoAhQgA2o2AhQgACAAKAIQIANrNgIQIAIgAigCFCADayIDNgIUIAMNACACIAIoAgg2AhALIAEoAhQEQCABQX82AigPCyABKAIgIQYgASgCHCgCECEDQQAhAiAFIARrIgUgASgCDCIESw0ACwsgASgCCCACaiADIAZqIAUQHxogASABKAIUIAVqIgM2AhQCQCACIANPDQAgASgCHCgCLEUNACAAIAAoAjAgASgCCCACaiADIAJrEAY2AjALIAFBADYCIAsgAUHJADYCBAsgASgCHCgCHARAIAEoAhQiAiEFA0ACQCACIAEoAgxHDQACQCACIAVNDQAgASgCHCgCLEUNACAAIAAoAjAgASgCCCAFaiACIAVrEAY2AjALIAAoAhwiAhATAkAgACgCECIDIAIoAhQiBCADIARJGyIDRQ0AIAAoAgwgAigCECADEB8aIAAgACgCDCADajYCDCACIAIoAhAgA2o2AhAgACAAKAIUIANqNgIUIAAgACgCECADazYCECACIAIoAhQgA2siAzYCFCADDQAgAiACKAIINgIQC0EAIQJBACEFIAEoAhRFDQAgAUF/NgIoDwsgASgCHCgCHCEDIAEgASgCICIEQQFqNgIgIAMgBGotAAAhAyABIAJBAWo2AhQgASgCCCACaiADOgAAIAMEQCABKAIUIQIMAQsLAkAgASgCHCgCLEUNACABKAIUIgIgBU0NACAAIAAoAjAgASgCCCAFaiACIAVrEAY2AjALIAFBADYCIAsgAUHbADYCBAsCQCABKAIcKAIkRQ0AIAEoAhQiAiEFA0ACQCACIAEoAgxHDQACQCACIAVNDQAgASgCHCgCLEUNACAAIAAoAjAgASgCCCAFaiACIAVrEAY2AjALIAAoAhwiAhATAkAgACgCECIDIAIoAhQiBCADIARJGyIDRQ0AIAAoAgwgAigCECADEB8aIAAgACgCDCADajYCDCACIAIoAhAgA2o2AhAgACAAKAIUIANqNgIUIAAgACgCECADazYCECACIAIoAhQgA2siAzYCFCADDQAgAiACKAIINgIQC0EAIQJBACEFIAEoAhRFDQAgAUF/NgIoDwsgASgCHCgCJCEDIAEgASgCICIEQQFqNgIgIAMgBGotAAAhAyABIAJBAWo2AhQgASgCCCACaiADOgAAIAMEQCABKAIUIQIMAQsLIAEoAhwoAixFDQAgASgCFCICIAVNDQAgACAAKAIwIAEoAgggBWogAiAFaxAGNgIwCyABQecANgIECyABKAIcKAIsBEAgASgCDCABKAIUIgJBAmpJBEAgACgCHCICEBMCQCAAKAIQIgMgAigCFCIEIAMgBEkbIgNFDQAgACgCDCACKAIQIAMQHxogACAAKAIMIANqNgIMIAIgAigCECADajYCECAAIAAoAhQgA2o2AhQgACAAKAIQIANrNgIQIAIgAigCFCADayIDNgIUIAMNACACIAIoAgg2AhALIAEoAhQNBUEAIQILIAAoAjAhAyABIAJBAWo2AhQgASgCCCACaiADOgAAIAAoAjAhAiABIAEoAhQiA0EBajYCFCADIAEoAghqIAJBCHY6AAAgAEEAQQBBABAGNgIwCyABQfEANgIEIAAoAhwiAhATAkAgACgCECIDIAIoAhQiBCADIARJGyIDRQ0AIAAoAgwgAigCECADEB8aIAAgACgCDCADajYCDCACIAIoAhAgA2o2AhAgACAAKAIUIANqNgIUIAAgACgCECADazYCECACIAIoAhQgA2siAzYCFCADDQAgAiACKAIINgIQCyABKAIURQ0AIAFBfzYCKA8LIAAoAgQNAQsgASgCdA0AIAEoAgRBmgVGDQgLIAEoAoQBIgJFBEAgAUEDEAwMBAsCQAJAIAEoAogBQQJrDgIAAQQLA0ACQAJAIAEoAnQNACABEAogASgCdA0AIAFBADYCtC0MAQsgAUEANgJgIAEoAjggASgCbGotAAAhAiABKAKkLSABKAKgLSIDQQF0akEAOwEAIAEgA0EBajYCoC0gAyABKAKYLWogAjoAACABIAJBAnRqQZQBaiICIAIvAQBBAWo7AQAgASABKAJ0QQFrNgJ0IAEgASgCbEEBaiICNgJsIAEoAqAtIAEoApwtQQFrRw0BIAEgASgCXCIEQQBOBH8gASgCOCAEagVBAAsgAiAEa0EAEBQgASABKAJsNgJcIAEoAgAiAigCHCIDEBMCQCACKAIQIgQgAygCFCIFIAQgBUkbIgRFDQAgAigCDCADKAIQIAQQHxogAiACKAIMIARqNgIMIAMgAygCECAEajYCECACIAIoAhQgBGo2AhQgAiACKAIQIARrNgIQIAMgAygCFCAEayICNgIUIAINACADIAMoAgg2AhALIAEoAgAoAhANAQwHCwsgASgCoC1FDQcgASABKAJcIgNBAE4EfyABKAI4IANqBUEACyABKAJsIANrQQAQFCABIAEoAmw2AlwgASgCACICKAIcIgMQEwJAIAIoAhAiBCADKAIUIgUgBCAFSRsiBEUNACACKAIMIAMoAhAgBBAfGiACIAIoAgwgBGo2AgwgAyADKAIQIARqNgIQIAIgAigCFCAEajYCFCACIAIoAhAgBGs2AhAgAyADKAIUIARrIgI2AhQgAg0AIAMgAygCCDYCEAsgASgCACgCEEUNBQwHCwNAAkACQAJAIAEoAnQiAkGDAk8EQCABQQA2AmAMAQsgARAKIAEoAnQiAgRAIAFBADYCYCACQQJLDQEgASgCbCEDDAILIAFBADYCtC0gASgCoC1FDQogASABKAJcIgNBAE4EfyABKAI4IANqBUEACyABKAJsIANrQQAQFCABIAEoAmw2AlwgASgCACICKAIcIgMQEwJAIAIoAhAiBCADKAIUIgUgBCAFSRsiBEUNACACKAIMIAMoAhAgBBAfGiACIAIoAgwgBGo2AgwgAyADKAIQIARqNgIQIAIgAigCFCAEajYCFCACIAIoAhAgBGs2AhAgAyADKAIUIARrIgI2AhQgAg0AIAMgAygCCDYCEAsgASgCACgCEEUNCAwKCyABKAJsIgNFBEBBACEDDAELIAEoAjggA2oiBkEBayIFLQAAIgQgBi0AAEcNACAEIAUtAAJHDQAgBCAFLQADRw0AIAZBggJqIQlBfyEIAkACQAJAAkACQAJAA0AgBiAIaiIFLQAEIARGBEAgBCAFLQAFRw0CIAQgBS0ABkcNAyAEIAUtAAdHDQQgBCAGIAhBCGoiCmoiBy0AAEcNByAEIAUtAAlHDQUgBCAFLQAKRw0GIAVBC2ohByAIQfYBSg0HIAohCCAEIActAABGDQEMBwsLIAVBBGohBwwFCyAFQQVqIQcMBAsgBUEGaiEHDAMLIAVBB2ohBwwCCyAFQQlqIQcMAQsgBUEKaiEHCyABIAIgByAJa0GCAmoiBCACIARJGyICNgJgIAJBA0kNACABKAKkLSABKAKgLSIDQQF0akEBOwEAIAEgA0EBajYCoC0gAyABKAKYLWogAkEDayICOgAAIAJB/wFxQYDNAGotAABBAnQgAWpBmAlqIgIgAi8BAEEBajsBACABQYDJAC0AAEECdGpBiBNqIgIgAi8BAEEBajsBACABKAJgIQIgAUEANgJgIAEgASgCdCACazYCdCABIAIgASgCbGoiAjYCbCABKAKgLSABKAKcLUEBa0cNAgwBCyABKAI4IANqLQAAIQIgASgCpC0gASgCoC0iA0EBdGpBADsBACABIANBAWo2AqAtIAMgASgCmC1qIAI6AAAgASACQQJ0akGUAWoiAiACLwEAQQFqOwEAIAEgASgCdEEBazYCdCABIAEoAmxBAWoiAjYCbCABKAKgLSABKAKcLUEBa0cNAQsgASABKAJcIgRBAE4EfyABKAI4IARqBUEACyACIARrQQAQFCABIAEoAmw2AlwgASgCACICKAIcIgMQEwJAIAIoAhAiBCADKAIUIgUgBCAFSRsiBEUNACACKAIMIAMoAhAgBBAfGiACIAIoAgwgBGo2AgwgAyADKAIQIARqNgIQIAIgAigCFCAEajYCFCACIAIoAhAgBGs2AhAgAyADKAIUIARrIgI2AhQgAg0AIAMgAygCCDYCEAsgASgCACgCEA0ACwwECyABQX82AigPCyABQX82AigPCyABQQMgAkEMbEGIyABqKAIAEQQACyICQX5xQQJGBEAgAUGaBTYCBAsgAkF9cQ0BCyAAKAIQDQMgAUF/NgIoDwsgAkEBRw0BCyABQQBBAEEAEBIgASgCRCICIAEoAkxBAXRBAmsiA2pBADsBACACIAMQICABKAJ0RQRAIAFBADYCtC0gAUEANgJcIAFBADYCbAsgACgCHCICEBMCQCAAKAIQIgQgAigCFCIDIAMgBEsbIgNFDQAgACgCDCACKAIQIAMQHxogACAAKAIMIANqNgIMIAIgAigCECADajYCECAAIAAoAhQgA2o2AhQgACAAKAIQIANrIgQ2AhAgAiACKAIUIANrIgM2AhQgAw0AIAIgAigCCDYCEAsgBA0AIAFBfzYCKAsLC7YNAQt/IAAoAgAiBCgCBCEJQQEhCAJAIAQoAhAiAyAAKAK8LUEqakEDdSICSQ0AIAAoAiwiBSAAKAIMQQVrIgYgBSAGSRshCiABQQRHIQsDQCAKIAMgAmsiAyAAKAJsIAAoAlxrIgYgBCgCBGoiAkH//wMgAkH//wNJGyIFIAMgBUkbIgNLBEAgAiADRw0CIAFFDQIgCyADRXENAgsgAEEAQQAgAUEERiACIANGcSIHEBIgACgCFCAAKAIIakEEayADOgAAIAAoAhQgACgCCGpBA2sgA0EIdjoAACAAKAIUIAAoAghqQQJrIANBf3MiAjoAACAAKAIUIAAoAghqQQFrIAJBCHY6AAAgACgCACICKAIcIgQQEwJAIAIoAhAiBSAEKAIUIgwgBSAMSRsiBUUNACACKAIMIAQoAhAgBRAfGiACIAIoAgwgBWo2AgwgBCAEKAIQIAVqNgIQIAIgAigCFCAFajYCFCACIAIoAhAgBWs2AhAgBCAEKAIUIAVrIgI2AhQgAg0AIAQgBCgCCDYCEAsCfyAGBEAgACgCACgCDCAAKAI4IAAoAlxqIAMgBiADIAZJGyICEB8aIAAoAgAiBCAEKAIMIAJqNgIMIAQgBCgCECACazYCECAEIAQoAhQgAmo2AhQgACAAKAJcIAJqNgJcIAMgAmshAwsgAwsEQCAAKAIAIgIoAgwhBSADIAIoAgQiBiADIAZJGyIEBEAgAiAGIARrNgIEIAUgAigCACAEEB8hBQJAAkACQCACKAIcKAIYQQFrDgIAAQILIAIgAigCMCAFIAQQBDYCMAwBCyACIAIoAjAgBSAEEAY2AjALIAIgAigCACAEajYCACACIAIoAgggBGo2AgggACgCACICKAIMIQULIAIgAyAFajYCDCACIAIoAhAgA2s2AhAgAiACKAIUIANqNgIUCyAAKAIAIQQgBwRAQQAhCAwCCyAEKAIQIgMgACgCvC1BKmpBA3UiAk8NAAsLAkAgCSAEKAIEayIDRQRAIAAoAmwhAgwBCwJAIAAoAiwiAiADTQRAIABBAjYCsC0gACgCOCAEKAIAIAJrIAIQHxogACAAKAIsIgQ2AmwgBCECDAELAkAgACgCPCAAKAJsIgRrIANLDQAgACAEIAJrIgQ2AmwgACgCOCIFIAIgBWogBBAfGiAAKAKwLSICQQFLDQAgACACQQFqNgKwLQsgACgCOCAAKAJsaiAAKAIAKAIAIANrIAMQHxogACAAKAJsIANqIgI2AmwgACgCLCEECyAAIAI2AlwgACAEIAAoArQtIgVrIgQgAyADIARLGyAFajYCtC0LIAIgACgCwC1LBEAgACACNgLALQtBAyEDAkAgCEUNACAAKAIAIgQoAgQhAwJAAkAgAUF7cUUNACADDQBBASEDIAIgACgCXEYNAiAAKAI8IAJBf3NqIQVBACEDDAELIAMgACgCPCACQX9zaiIFTQ0AIAAoAlwiByAAKAIsIgZIDQAgACACIAZrIgM2AmwgACAHIAZrNgJcIAAoAjgiAiACIAZqIAMQHxogACgCsC0iA0EBTQRAIAAgA0EBajYCsC0LIAAoAiwgBWohBSAAKAIAIgQoAgQhAwsCQCADIAUgAyAFSRsiAkUEQCAAKAJsIQMMAQsgACgCbCEFIAAoAjghBiAEIAMgAms2AgQgBSAGaiAEKAIAIAIQHyEDAkACQAJAIAQoAhwoAhhBAWsOAgABAgsgBCAEKAIwIAMgAhAENgIwDAELIAQgBCgCMCADIAIQBjYCMAsgBCAEKAIAIAJqNgIAIAQgBCgCCCACajYCCCAAIAAoAmwgAmoiAzYCbAsgAyAAKALALUsEQCAAIAM2AsAtCyADIAAoAlwiBmsiBCAAKAIsIgMgACgCDCAAKAK8LUEqakEDdWsiAkH//wMgAkH//wNJGyICIAIgA0sbSQRAQQAhAyABRQ0BIAFBBEYgBEEAR3JFDQEgAiAESQ0BIAAoAgAoAgQNAQtBACEFIAAgACgCOCAGaiACIAQgAiAESRsiAwJ/IAFBBEYEQCAAKAIAKAIERSACIARPcSEFCyAFCxASIAAgACgCXCADajYCXCAAKAIAIgAoAhwiAxATAkAgACgCECICIAMoAhQiBCACIARJGyICRQ0AIAAoAgwgAygCECACEB8aIAAgACgCDCACajYCDCADIAMoAhAgAmo2AhAgACAAKAIUIAJqNgIUIAAgACgCECACazYCECADIAMoAhQgAmsiADYCFCAADQAgAyADKAIINgIQC0ECQQAgBRshAwsgAwu5CwENfwJAA0ACQAJAIAAoAnRBhQJNBEAgABAKIAAoAnQhAgJAIAENACACQYYCTw0AQQAPCyACRQ0EIAJBA0kNAQsgACAAKAJUIAAoAmwiAiAAKAI4ai0AAiAAKAJIIAAoAlh0c3EiAzYCSCAAKAJAIAIgACgCNHFBAXRqIAAoAkQgA0EBdGoiBC8BACIDOwEAIAQgAjsBACADRQ0AIAAoAixBhgJrIAIgA2tJDQAgACAAIAMQDiICNgJgDAELIAAoAmAhAgsCQCACQQNPBEAgACgCpC0gACgCoC0iA0EBdGogACgCbCAAKAJwayIEOwEAIAAgA0EBajYCoC0gAyAAKAKYLWogAkEDayICOgAAIAJB/wFxQYDNAGotAABBAnQgAGpBmAlqIgIgAi8BAEEBajsBACAAIARBAWtB//8DcSICIAJBB3ZBgAJqIAJBgAJJG0GAyQBqLQAAQQJ0akGIE2oiAiACLwEAQQFqOwEAIAAgACgCdCAAKAJgIgJrIgM2AnQgACgCnC1BAWshBiAAKAKgLSEHAkAgA0EDSQ0AIAIgACgCgAFLDQAgACACQQFrIgM2AmAgACgCSCEEIAAoAmwhAiAAKAI0IQggACgCQCEJIAAoAkQhCiAAKAJUIQsgACgCOCEMIAAoAlghDQNAIAAgAiIFQQFqIgI2AmwgACAFIAxqLQADIAQgDXRzIAtxIgQ2AkggCSACIAhxQQF0aiAKIARBAXRqIg4vAQA7AQAgDiACOwEAIAAgA0EBayIDNgJgIAMNAAsgACAFQQJqIgI2AmwgBiAHRw0DDAILIABBADYCYCAAIAAoAmwgAmoiAjYCbCAAIAAoAjggAmoiAy0AACIENgJIIAAgACgCVCADLQABIAQgACgCWHRzcTYCSCAGIAdHDQIMAQsgACgCOCAAKAJsai0AACECIAAoAqQtIAAoAqAtIgNBAXRqQQA7AQAgACADQQFqNgKgLSADIAAoApgtaiACOgAAIAAgAkECdGpBlAFqIgIgAi8BAEEBajsBACAAIAAoAnRBAWs2AnQgACAAKAJsQQFqIgI2AmwgACgCoC0gACgCnC1BAWtHDQELQQAhAyAAIAAoAlwiBEEATgR/IAAoAjggBGoFIAMLIAIgBGtBABAUIAAgACgCbDYCXCAAKAIAIgIoAhwiAxATAkAgAigCECIEIAMoAhQiBSAEIAVJGyIERQ0AIAIoAgwgAygCECAEEB8aIAIgAigCDCAEajYCDCADIAMoAhAgBGo2AhAgAiACKAIUIARqNgIUIAIgAigCECAEazYCECADIAMoAhQgBGsiAjYCFCACDQAgAyADKAIINgIQCyAAKAIAKAIQDQALQQAPCyAAIAAoAmwiAkECIAJBAkkbNgK0LSABQQRGBEBBACEDIAAgACgCXCIEQQBOBH8gACgCOCAEagUgAwsgAiAEa0EBEBQgACAAKAJsNgJcIAAoAgAiAigCHCIDEBMCQCACKAIQIgQgAygCFCIFIAQgBUkbIgRFDQAgAigCDCADKAIQIAQQHxogAiACKAIMIARqNgIMIAMgAygCECAEajYCECACIAIoAhQgBGo2AhQgAiACKAIQIARrNgIQIAMgAygCFCAEayICNgIUIAINACADIAMoAgg2AhALQQNBAiAAKAIAKAIQGw8LAkAgACgCoC1FDQBBACEDIAAgACgCXCIEQQBOBH8gACgCOCAEagUgAwsgAiAEa0EAEBQgACAAKAJsNgJcIAAoAgAiAigCHCIDEBMCQCACKAIQIgQgAygCFCIFIAQgBUkbIgRFDQAgAigCDCADKAIQIAQQHxogAiACKAIMIARqNgIMIAMgAygCECAEajYCECACIAIoAhQgBGo2AhQgAiACKAIQIARrNgIQIAMgAygCFCAEayICNgIUIAINACADIAMoAgg2AhALIAAoAgAoAhANAEEADwtBAQukBAEQfyAAKAJ8IgMgA0ECdiAAKAJ4IgQgACgCjAFJGyEJQQAgACgCbCIDIAAoAixrQYYCaiICIAIgA0sbIQwgACgCdCIHIAAoApABIgIgAiAHSxshDSAAKAI4Ig4gA2oiBUGCAmohDyAEIAVqIgMtAAAhCiADQQFrLQAAIQsgACgCNCEQIAAoAkAhEQNAAkACQCABIA5qIgMgBGoiAi0AACAKRw0AIAJBAWstAAAgC0cNACADLQAAIAUtAABHDQBBAiEGIAMtAAEgBS0AAUcNAAJAAkACQAJAAkACQAJAA0AgBSAGaiICLQABIAMtAANHDQYgAi0AAiADLQAERw0FIAItAAMgAy0ABUcNBCACLQAEIAMtAAZHDQMgAi0ABSADLQAHRw0CIAItAAYgAy0ACEcNASACLQAHIAMtAAlGBEAgBkH5AUshCCAFIAZBCGoiBmohAiAIDQggAy0ACiEIIANBCGohAyACLQAAIAhGDQEMCAsLIAJBB2ohAgwGCyACQQZqIQIMBQsgAkEFaiECDAQLIAJBBGohAgwDCyACQQNqIQIMAgsgAkECaiECDAELIAJBAWohAgsgAiAPayICQYICaiIDIARMDQAgACABNgJwIAMgDU4EQCADIQQMAgsgAyAFai0AACEKIAIgBWotAIECIQsgAyEECyAJQQFrIglFDQAgDCARIAEgEHFBAXRqLwEAIgFJDQELCyAHIAQgBCAHSxsL3Q4BB38DQAJAAkACQCAAKAJ0QYUCSw0AIAAQCiAAKAJ0IQICQCABDQAgAkGGAk8NAEEADwsgAkUNAiACQQJLDQAgACAAKAJgIgI2AnggACAAKAJwNgJkQQIhAyAAQQI2AmAMAQtBAiEDIAAgACgCVCAAKAJsIgIgACgCOGotAAIgACgCSCAAKAJYdHNxIgQ2AkggACgCQCACIAAoAjRxQQF0aiAAKAJEIARBAXRqIgUvAQAiBDsBACAFIAI7AQAgACAAKAJgIgI2AnggACAAKAJwNgJkIABBAjYCYCAERQ0AAkAgAiAAKAKAAU8NACAAKAIsQYYCayAAKAJsIARrSQ0AIAAgACAEEA4iAzYCYCADQQVLDQAgACgCiAFBAUcEQCADQQNHDQFBAyEDIAAoAmwgACgCcGtBgSBJDQELQQIhAyAAQQI2AmALIAAoAnghAgsCQCACQQNJDQAgAiADSQ0AIAAoAnQhBCAAKAKkLSAAKAKgLSIDQQF0aiAAKAJsIgUgACgCZEF/c2oiBjsBACAAIANBAWo2AqAtIAMgACgCmC1qIAJBA2siAjoAACACQf8BcUGAzQBqLQAAQQJ0IABqQZgJaiICIAIvAQBBAWo7AQAgACAGQQFrQf//A3EiAiACQQd2QYACaiACQYACSRtBgMkAai0AAEECdGpBiBNqIgIgAi8BAEEBajsBACAAIAAoAngiAkECayIDNgJ4IAAgACgCdCACa0EBajYCdCAEIAVqQQNrIQUgACgCnC1BAWshByAAKAJsIQIgACgCoC0hCANAIAAgAiIEQQFqIgI2AmwgAiAFTQRAIAAgACgCVCAEIAAoAjhqLQADIAAoAkggACgCWHRzcSIGNgJIIAAoAkAgACgCNCACcUEBdGogACgCRCAGQQF0aiIGLwEAOwEAIAYgAjsBAAsgACADQQFrIgM2AnggAw0ACyAAQQI2AmAgAEEANgJoIAAgBEECaiICNgJsIAcgCEcNAkEAIQMgACAAKAJcIgRBAE4EfyAAKAI4IARqBSADCyACIARrQQAQFCAAIAAoAmw2AlwgACgCACICKAIcIgMQEwJAIAIoAhAiBCADKAIUIgUgBCAFSRsiBEUNACACKAIMIAMoAhAgBBAfGiACIAIoAgwgBGo2AgwgAyADKAIQIARqNgIQIAIgAigCFCAEajYCFCACIAIoAhAgBGs2AhAgAyADKAIUIARrIgI2AhQgAg0AIAMgAygCCDYCEAsgACgCACgCEA0CQQAPCyAAKAJoBEAgACgCbCAAKAI4akEBay0AACECIAAoAqQtIAAoAqAtIgNBAXRqQQA7AQAgACADQQFqNgKgLSADIAAoApgtaiACOgAAIAAgAkECdGpBlAFqIgIgAi8BAEEBajsBAAJAIAAoAqAtIAAoApwtQQFrRw0AQQAhAyAAIAAoAlwiAkEATgR/IAAoAjggAmoFIAMLIAAoAmwgAmtBABAUIAAgACgCbDYCXCAAKAIAIgIoAhwiAxATIAIoAhAiBCADKAIUIgUgBCAFSRsiBEUNACACKAIMIAMoAhAgBBAfGiACIAIoAgwgBGo2AgwgAyADKAIQIARqNgIQIAIgAigCFCAEajYCFCACIAIoAhAgBGs2AhAgAyADKAIUIARrIgI2AhQgAg0AIAMgAygCCDYCEAsgACAAKAJsQQFqNgJsIAAgACgCdEEBazYCdCAAKAIAKAIQDQJBAA8FIABBATYCaCAAIAAoAmxBAWo2AmwgACAAKAJ0QQFrNgJ0DAILAAsLIAAoAmgEQCAAKAJsIAAoAjhqQQFrLQAAIQIgACgCpC0gACgCoC0iA0EBdGpBADsBACAAIANBAWo2AqAtIAMgACgCmC1qIAI6AAAgACACQQJ0akGUAWoiAiACLwEAQQFqOwEAIABBADYCaAsgACAAKAJsIgJBAiACQQJJGzYCtC0gAUEERgRAQQAhAyAAIAAoAlwiBEEATgR/IAAoAjggBGoFIAMLIAIgBGtBARAUIAAgACgCbDYCXCAAKAIAIgIoAhwiAxATAkAgAigCECIEIAMoAhQiBSAEIAVJGyIERQ0AIAIoAgwgAygCECAEEB8aIAIgAigCDCAEajYCDCADIAMoAhAgBGo2AhAgAiACKAIUIARqNgIUIAIgAigCECAEazYCECADIAMoAhQgBGsiAjYCFCACDQAgAyADKAIINgIQC0EDQQIgACgCACgCEBsPCwJAIAAoAqAtRQ0AQQAhAyAAIAAoAlwiBEEATgR/IAAoAjggBGoFIAMLIAIgBGtBABAUIAAgACgCbDYCXCAAKAIAIgIoAhwiAxATAkAgAigCECIEIAMoAhQiBSAEIAVJGyIERQ0AIAIoAgwgAygCECAEEB8aIAIgAigCDCAEajYCDCADIAMoAhAgBGo2AhAgAiACKAIUIARqNgIUIAIgAigCECAEazYCECADIAMoAhQgBGsiAjYCFCACDQAgAyADKAIINgIQCyAAKAIAKAIQDQBBAA8LQQELYQAgAEEANgK8LSAAQQA7AbgtIABBuBZqQajPADYCACAAIABB/BRqNgKwFiAAQawWakGUzwA2AgAgACAAQYgTajYCpBYgAEGgFmpBgM8ANgIAIAAgAEGUAWo2ApgWIAAQEQvwBAEDfyAAQZQBaiECA0AgAiABQQJ0IgNqQQA7AQAgAiADQQRyakEAOwEAIAFBAmoiAUGeAkcNAAsgAEEAOwH8FCAAQQA7AYgTIABBxBVqQQA7AQAgAEHAFWpBADsBACAAQbwVakEAOwEAIABBuBVqQQA7AQAgAEG0FWpBADsBACAAQbAVakEAOwEAIABBrBVqQQA7AQAgAEGoFWpBADsBACAAQaQVakEAOwEAIABBoBVqQQA7AQAgAEGcFWpBADsBACAAQZgVakEAOwEAIABBlBVqQQA7AQAgAEGQFWpBADsBACAAQYwVakEAOwEAIABBiBVqQQA7AQAgAEGEFWpBADsBACAAQYAVakEAOwEAIABB/BNqQQA7AQAgAEH4E2pBADsBACAAQfQTakEAOwEAIABB8BNqQQA7AQAgAEHsE2pBADsBACAAQegTakEAOwEAIABB5BNqQQA7AQAgAEHgE2pBADsBACAAQdwTakEAOwEAIABB2BNqQQA7AQAgAEHUE2pBADsBACAAQdATakEAOwEAIABBzBNqQQA7AQAgAEHIE2pBADsBACAAQcQTakEAOwEAIABBwBNqQQA7AQAgAEG8E2pBADsBACAAQbgTakEAOwEAIABBtBNqQQA7AQAgAEGwE2pBADsBACAAQawTakEAOwEAIABBqBNqQQA7AQAgAEGkE2pBADsBACAAQaATakEAOwEAIABBnBNqQQA7AQAgAEGYE2pBADsBACAAQZQTakEAOwEAIABBkBNqQQA7AQAgAEGME2pBADsBACAAQgA3AqwtIABBlAlqQQE7AQAgAEEANgKoLSAAQQA2AqAtC7IDAQJ/IAAgAC8BuC0gA0H//wNxIgUgACgCvC0iBHRyIgM7AbgtAkACQAJ/IARBDk4EQCAAIAAoAhQiBEEBajYCFCAEIAAoAghqIAM6AAAgACAAKAIUIgNBAWo2AhQgAyAAKAIIaiAAQbktai0AADoAACAAIAVBECAAKAK8LSIEa3YiAzsBuC0gBEENawwBCyAEQQNqCyIEQQlOBEAgACAAKAIUIgRBAWo2AhQgBCAAKAIIaiADOgAAIAAgACgCFCIDQQFqNgIUIAMgACgCCGohBCAAQbktai0AACEDDAELIARBAUgNASAAIAAoAhQiBEEBajYCFCAEIAAoAghqIQQLIAQgAzoAAAsgAEEANgK8LSAAQQA7AbgtIAAgACgCFCIDQQFqNgIUIAMgACgCCGogAjoAACAAIAAoAhQiA0EBajYCFCADIAAoAghqIAJBCHY6AAAgACAAKAIUIgNBAWo2AhQgAyAAKAIIaiACQX9zIgM6AAAgACAAKAIUIgRBAWo2AhQgBCAAKAIIaiADQQh2OgAAIAAoAgggACgCFGogASACEB8aIAAgACgCFCACajYCFAusAQEBfwJAIAACfyAAKAK8LSIBQRBGBEAgACAAKAIUIgFBAWo2AhQgASAAKAIIaiAALQC4LToAACAAIAAoAhQiAUEBajYCFCABIAAoAghqIABBuS1qLQAAOgAAIABBADsBuC1BAAwBCyABQQhIDQEgACAAKAIUIgFBAWo2AhQgASAAKAIIaiAALQC4LToAACAAIABBuS1qLQAAOwG4LSAAKAK8LUEIaws2ArwtCwuhEwENfwJ/AkACQAJAIAAoAoQBQQFOBEAgACgCACIGKAIsQQJHDQNB/4D/n38hBANAAkAgBEEBcUUNACAAIAVBAnRqLwGUAUUNAEEAIQQMBAsCQCAEQQJxRQ0AIAAgBUECdEEEcmovAZQBRQ0AQQAhBAwECyAEQQJ2IQQgBUECaiIFQSBHDQALDAELIAJBBWoiBQwDCwJAIAAvAbgBDQAgAC8BvAENACAALwHIAQ0AQSAhBQNAIAAgBUECdCIEai8BlAENASAAIARBBHJqLwGUAQ0BIAAgBEEIcmovAZQBDQEgACAEQQxyai8BlAENAUEAIQQgBUEEaiIFQYACRw0ACwwBC0EBIQQLIAYgBDYCLAsgACAAQZgWahAVIAAgAEGkFmoQFSAALwGWASEEIAAgAEGcFmooAgAiCkECdGpB//8DOwGaASAKQQBOBEBBB0GKASAEGyEJQQRBAyAEGyELIABBwBVqIQ4gAEHEFWohDyAAQbwVaiEQQX8hDANAIAQhBSAAIAgiDUEBaiIIQQJ0ai8BlgEhBAJAAkAgB0EBaiIGIAlODQAgBCAFRw0AIAYhBwwBCwJ/IAYgC0gEQCAAIAVBAnRqQfwUaiIHLwEAIAZqDAELIAUEQCAFIAxHBEAgACAFQQJ0akH8FGoiBiAGLwEAQQFqOwEACyAQIgcvAQBBAWoMAQsgB0EJTARAIA4iBy8BAEEBagwBCyAPIgcvAQBBAWoLIQYgByAGOwEAQQAhBwJ/IARFBEBBAyELQYoBDAELQQNBBCAEIAVGIgYbIQtBBkEHIAYbCyEJIAUhDAsgCiANRw0ACwsgAEGKE2ovAQAhBCAAIABBqBZqKAIAIgpBAnRqQY4TakH//wM7AQBBACEHIApBAE4EQEEHQYoBIAQbIQlBBEEDIAQbIQsgAEHAFWohDiAAQcQVaiEPIABBvBVqIRBBfyEMQQAhCANAIAQhBSAAIAgiDUEBaiIIQQJ0akGKE2ovAQAhBAJAAkAgB0EBaiIGIAlODQAgBCAFRw0AIAYhBwwBCwJ/IAYgC0gEQCAAIAVBAnRqQfwUaiIHLwEAIAZqDAELIAUEQCAFIAxHBEAgACAFQQJ0akH8FGoiBiAGLwEAQQFqOwEACyAQIgcvAQBBAWoMAQsgB0EJTARAIA4iBy8BAEEBagwBCyAPIgcvAQBBAWoLIQYgByAGOwEAQQAhBwJ/IARFBEBBAyELQYoBDAELQQNBBCAEIAVGIgYbIQtBBkEHIAYbCyEJIAUhDAsgCiANRw0ACwsgACAAQbAWahAVIAAgACgCqC0Cf0ESIABBuhVqLwEADQAaQREgAEGCFWovAQANABpBECAAQbYVai8BAA0AGkEPIABBhhVqLwEADQAaQQ4gAEGyFWovAQANABpBDSAAQYoVai8BAA0AGkEMIABBrhVqLwEADQAaQQsgAEGOFWovAQANABpBCiAAQaoVai8BAA0AGkEJIABBkhVqLwEADQAaQQggAEGmFWovAQANABpBByAAQZYVai8BAA0AGkEGIABBohVqLwEADQAaQQUgAEGaFWovAQANABpBBCAAQZ4Vai8BAA0AGkEDQQIgAEH+FGovAQAbCyIIQQNsaiIEQRFqNgKoLSAEQRtqQQN2IgQgACgCrC1BCmpBA3YiBSAEIAVJGwshBAJAAkAgAUUNACACQQRqIARLDQAgACABIAIgAxASDAELIAAoArwtIQYCQCAEIAVHBEAgACgCiAFBBEcNAQsgACAALwG4LSADQQJqQf//A3EiBCAGdHIiBTsBuC0gAAJ/IAZBDk4EQCAAIAAoAhQiBkEBajYCFCAGIAAoAghqIAU6AAAgACAAKAIUIgVBAWo2AhQgBSAAKAIIaiAAQbktai0AADoAACAAIARBECAAKAK8LSIFa3Y7AbgtIAVBDWsMAQsgBkEDags2ArwtIABBwM8AQcDYABAWDAELIAAvAbgtIANBBGpB//8DcSIHIAZ0ciEFAkAgBkEOTgRAIAAgBTsBuC0gACAAKAIUIgRBAWo2AhQgBCAAKAIIaiAFOgAAIAAgACgCFCIEQQFqNgIUIAQgACgCCGogAEG5LWotAAA6AAAgACgCvC0iBUENayEEIAdBECAFa3YhBQwBCyAGQQNqIQQLIAAgBDYCvC0gAEGcFmooAgAiCkGA/gNqQf//A3EiByAEdCEGIABBqBZqKAIAIQkCfyAEQQxOBEAgACAFIAZyIgQ7AbgtIAAgACgCFCIFQQFqNgIUIAUgACgCCGogBDoAACAAIAAoAhQiBEEBajYCFCAEIAAoAghqIABBuS1qLQAAOgAAIAAoArwtIgVBC2shBCAHQRAgBWt2DAELIARBBWohBCAFIAZyCyEFIAAgBDYCvC0gCUH//wNxIgcgBHQhBgJ/IARBDE4EQCAAIAUgBnIiBDsBuC0gACAAKAIUIgVBAWo2AhQgBSAAKAIIaiAEOgAAIAAgACgCFCIEQQFqNgIUIAQgACgCCGogAEG5LWotAAA6AAAgACgCvC0iBUELayEEIAdBECAFa3YMAQsgBEEFaiEEIAUgBnILIQUgACAENgK8LSAIQf3/A2pB//8DcSIHIAR0IQYCfyAEQQ1OBEAgACAFIAZyIgQ7AbgtIAAgACgCFCIFQQFqNgIUIAUgACgCCGogBDoAACAAIAAoAhQiBEEBajYCFCAEIAAoAghqIABBuS1qLQAAOgAAIAAoArwtIgVBDGshBCAHQRAgBWt2DAELIARBBGohBCAFIAZyCyEGIAAgBDYCvC1BACEFIABBuS1qIQ0DQCAAIAYgACAFQZDcAGotAABBAnRqQf4Uai8BACIHIAR0ciIGOwG4LSAAAn8gBEEOTgRAIAAgACgCFCIEQQFqNgIUIAQgACgCCGogBjoAACAAIAAoAhQiBEEBajYCFCAEIAAoAghqIA0tAAA6AAAgACAHQRAgACgCvC0iBGt2IgY7AbgtIARBDWsMAQsgBEEDagsiBDYCvC0gBSAIRyEHIAVBAWohBSAHDQALIAAgAEGUAWoiBCAKEBcgACAAQYgTaiIFIAkQFyAAIAQgBRAWCyAAEBEgAwRAAkACfyAAKAK8LSIEQQlOBEAgACAAKAIUIgRBAWo2AhQgBCAAKAIIaiAALQC4LToAACAAIAAoAhQiBEEBajYCFCAEIAAoAghqIQQgAEG5LWotAAAMAQsgBEEBSA0BIAAgACgCFCIEQQFqNgIUIAQgACgCCGohBCAALQC4LQshBSAEIAU6AAALIABBADYCvC0gAEEAOwG4LQsLsRUBFX8jAEEgayEKIAEoAgAhCSABKAIIIgIoAgAhBSACKAIMIQ0gAEKAgICA0McANwLQKEF/IRACQCANQQBKBEBBACECA0ACQCAJIAJBAnRqIgMvAQAEQCAAIAAoAtAoQQFqIgM2AtAoIAAgA0ECdGpB3BZqIAI2AgAgACACakHYKGpBADoAACACIRAMAQsgA0EAOwECCyACQQFqIgIgDUcNAAsgACgC0CgiBEEBSg0BCwNAIAAgBEEBaiICNgLQKCAAIAJBAnRqQdwWaiAQQQFqIgNBACAQQQJIIgQbIgI2AgAgCSACQQJ0IgdqQQE7AQAgACACakHYKGpBADoAACAAIAAoAqgtQQFrNgKoLSAFBEAgACAAKAKsLSAFIAdqLwECazYCrC0LIAMgECAEGyEQIAAoAtAoIgRBAkgNAAsLIAEgEDYCBCAEQQF2IQgDQCAAIAhBAnRqQdwWaigCACELAkAgCCICQQF0IgMgBEoNACAAIAtqQdgoaiEPIAkgC0ECdGohBiAIIQUDQAJAIAMgBE4EQCADIQIMAQsgCSAAQdwWaiICIANBAXIiBEECdGooAgAiDkECdGovAQAiByAJIAIgA0ECdGooAgAiDEECdGovAQAiAk8EQCACIAdHBEAgAyECDAILIAMhAiAAQdgoaiIDIA5qLQAAIAMgDGotAABLDQELIAQhAgsgBi8BACIEIAkgACACQQJ0akHcFmooAgAiA0ECdGovAQAiB0kEQCAFIQIMAgsCQCAEIAdHDQAgDy0AACAAIANqQdgoai0AAEsNACAFIQIMAgsgACAFQQJ0akHcFmogAzYCACACIQUgAkEBdCIDIAAoAtAoIgRMDQALCyAAIAJBAnRqQdwWaiALNgIAIAhBAk4EQCAIQQFrIQggACgC0CghBAwBCwsgACgC0CghAwNAIA0hCCAAIANBAWsiBDYC0CggACgC4BYhCyAAIAAgA0ECdGpB3BZqKAIAIg02AuAWQQEhAgJAIANBA0gNACAAIA1qQdgoaiEPQQIhAyAJIA1BAnRqIQZBASEFA0ACQCADIAROBEAgAyECDAELIAkgAEHcFmoiAiADQQFyIgRBAnRqKAIAIg5BAnRqLwEAIgcgCSACIANBAnRqKAIAIgxBAnRqLwEAIgJPBEAgAiAHRwRAIAMhAgwCCyADIQIgAEHYKGoiAyAOai0AACADIAxqLQAASw0BCyAEIQILIAYvAQAiBCAJIAAgAkECdGpB3BZqKAIAIgNBAnRqLwEAIgdJBEAgBSECDAILAkAgBCAHRw0AIA8tAAAgACADakHYKGotAABLDQAgBSECDAILIAAgBUECdGpB3BZqIAM2AgAgAiEFIAJBAXQiAyAAKALQKCIETA0ACwtBAiEDIABB3BZqIgYgAkECdGogDTYCACAAIAAoAtQoQQFrIgQ2AtQoIAAoAuAWIQIgBiAEQQJ0aiALNgIAIAAgACgC1ChBAWsiBDYC1CggBiAEQQJ0aiACNgIAIAkgCEECdGoiDiAJIAJBAnRqIgQvAQAgCSALQQJ0aiIFLwEAajsBACAAQdgoaiIMIAhqIg8gAiAMai0AACICIAsgDGotAAAiByACIAdLG0EBajoAACAEIAg7AQIgBSAIOwECIAAgCDYC4BZBASEFQQEhAgJAIAAoAtAoIgRBAkgNAANAAn8gAyADIARODQAaIAkgBiADQQFyIgRBAnRqKAIAIgtBAnRqLwEAIgIgCSAGIANBAnRqKAIAIg1BAnRqLwEAIgdPBEAgAyACIAdHDQEaIAMgCyAMai0AACAMIA1qLQAASw0BGgsgBAshAiAOLwEAIgQgCSAAIAJBAnRqQdwWaigCACIDQQJ0ai8BACIHSQRAIAUhAgwCCwJAIAQgB0cNACAPLQAAIAAgA2pB2ChqLQAASw0AIAUhAgwCCyAAIAVBAnRqQdwWaiADNgIAIAIhBSACQQF0IgMgACgC0CgiBEwNAAsLIAhBAWohDSAAIAJBAnRqQdwWaiAINgIAIAAoAtAoIgNBAUoNAAsgACAAKALUKEEBayICNgLUKCAAQdwWaiIDIAJBAnRqIAAoAuAWNgIAIAEoAgQhByABKAIIIgIoAhAhBiACKAIIIREgAigCBCETIAIoAgAhEiABKAIAIQwgAEHUFmoiAUIANwEAIABBzBZqIhRCADcBACAAQcQWaiIVQgA3AQAgAEG8FmoiFkIANwEAQQAhCCAMIAMgACgC1ChBAnRqKAIAQQJ0akEAOwECAkAgACgC1CgiAkG7BEoNACACQQFqIQJBACEOA0AgDCAAIAJBAnRqQdwWaigCACIEQQJ0Ig1qIgUgDCAFLwECQQJ0ai8BAiIDQQFqIAYgAyAGSBsiDzsBAiADIAZOIQMCQCAEIAdKDQAgACAPQQF0akG8FmoiCyALLwEAQQFqOwEAQQAhCyAEIBFOBEAgEyAEIBFrQQJ0aigCACELCyAAIAAoAqgtIAUvAQAiBCALIA9qbGo2AqgtIBJFDQAgACAAKAKsLSALIA0gEmovAQJqIARsajYCrC0LIAMgDmohDiACQQFqIgJBvQRHDQALIA5FDQAgACAGQQF0akG8FmohDwNAIAYhAgNAIAAgAiIDQQFrIgJBAXRqQbwWaiIELwEAIgVFDQALIAQgBUEBazsBACAAIANBAXRqQbwWaiICIAIvAQBBAmo7AQAgDyAPLwEAQQFrIgI7AQAgDkECSiEDIA5BAmshDiADDQALIAZFDQBBvQQhBQNAIAJB//8DcSEDIAUhAgNAIAMEQCAAIAJBAWsiAkECdGpB3BZqKAIAIgQgB0oNASAMIARBAnRqIgQvAQIiBSAGRwRAIAAgACgCqC0gBC8BACAGIAVrbGo2AqgtIAQgBjsBAgsgA0EBayEDIAIhBQwBCwsgBkEBayIGRQ0BIAAgBkEBdGpBvBZqLwEAIQIMAAsACyAKIBYvAQBBAXQiAjsBAiAKIAIgAEG+FmovAQBqQQF0IgI7AQQgCiACIABBwBZqLwEAakEBdCICOwEGIAogAiAAQcIWai8BAGpBAXQiAjsBCCAKIAIgFS8BAGpBAXQiAjsBCiAKIAIgAEHGFmovAQBqQQF0IgI7AQwgCiACIABByBZqLwEAakEBdCICOwEOIAogAiAAQcoWai8BAGpBAXQiAjsBECAKIAIgFC8BAGpBAXQiAjsBEiAKIAIgAEHOFmovAQBqQQF0IgI7ARQgCiACIABB0BZqLwEAakEBdCICOwEWIAogAiAAQdIWai8BAGpBAXQiAjsBGCAKIAEvAQAgAmpBAXQiAjsBGiAKIABB1hZqLwEAIAJqQQF0IgI7ARwgCiACIABB2BZqLwEAakEBdDsBHiAQQQBOBEADQCAJIAhBAnRqIgcvAQIiBARAIAogBEEBdGoiACAALwEAIgBBAWo7AQAgBEEDcSEDQQAhAiAEQQFrQQNPBEAgBEH8/wNxIQUDQCAAQQN2QQFxIABBAnZBAXEgAEECcSACIABBAXFyQQJ0cnJBAXRyIgRBAXQhAiAAQQR2IQAgBUEEayIFDQALCyADBEADQCACIABBAXFyIgRBAXQhAiAAQQF2IQAgA0EBayIDDQALCyAHIAQ7AQALIAggEEchACAIQQFqIQggAA0ACwsL2QgBCn8CQCAAKAKgLUUEQCAAKAK8LSEDDAELIABBuS1qIQgDQCAEQQFqIQogACgCmC0gBGotAAAhBQJAIAACfyAAKAKkLSAEQQF0ai8BACIHRQRAIAEgBUECdGoiAy8BAiEEIAAgAC8BuC0gAy8BACIFIAAoArwtIgN0ciIHOwG4LUEQIARrIANIBEAgACAAKAIUIgNBAWo2AhQgAyAAKAIIaiAHOgAAIAAgACgCFCIDQQFqNgIUIAMgACgCCGogCC0AADoAACAAIAVBECAAKAK8LSIDa3Y7AbgtIAMgBGpBEGsMAgsgAyAEagwBCyAFQYDNAGotAAAiC0ECdCIJQYAIciABaiIDLwEGIQQgACAALwG4LSADLwEEIgwgACgCvC0iBnRyIgM7AbgtIAACf0EQIARrIAZIBEAgACAAKAIUIgZBAWo2AhQgBiAAKAIIaiADOgAAIAAgACgCFCIDQQFqNgIUIAMgACgCCGogCC0AADoAACAAIAxBECAAKAK8LSIGa3YiAzsBuC0gBCAGakEQawwBCyAEIAZqCyIENgK8LSALQQhrQRNNBEAgACADIAUgCUGw3ABqKAIAa0H//wNxIgYgBHRyIgM7AbgtIAACf0EQIAlBwNkAaigCACIFayAESARAIAAgACgCFCIEQQFqNgIUIAQgACgCCGogAzoAACAAIAAoAhQiBEEBajYCFCAEIAAoAghqIAgtAAA6AAAgACAGQRAgACgCvC0iBGt2IgM7AbgtIAQgBWpBEGsMAQsgBCAFagsiBDYCvC0LIAIgB0EBayIFIAVBB3ZBgAJqIAVBgAJJG0GAyQBqLQAAIgtBAnQiCWoiBi8BAiEHIAAgAyAGLwEAIgwgBHRyIgY7AbgtIAACf0EQIAdrIARIBEAgACAAKAIUIgRBAWo2AhQgBCAAKAIIaiAGOgAAIAAgACgCFCIEQQFqNgIUIAQgACgCCGogCC0AADoAACAAIAxBECAAKAK8LSIEa3YiBjsBuC0gBCAHakEQawwBCyAEIAdqCyIDNgK8LSALQQRJDQEgACAGIAUgCUGw3QBqKAIAa0H//wNxIgUgA3RyIgc7AbgtQRAgCUHA2gBqKAIAIgRrIANIBEAgACAAKAIUIgNBAWo2AhQgAyAAKAIIaiAHOgAAIAAgACgCFCIDQQFqNgIUIAMgACgCCGogCC0AADoAACAAIAVBECAAKAK8LSIDa3Y7AbgtIAMgBGpBEGsMAQsgAyAEagsiAzYCvC0LIAoiBCAAKAKgLUkNAAsLIAFBgghqLwEAIQQgACAALwG4LSABLwGACCIKIAN0ciIFOwG4LUEQIARrIANIBEAgACAAKAIUIgNBAWo2AhQgAyAAKAIIaiAFOgAAIAAgACgCFCIDQQFqNgIUIAMgACgCCGogAEG5LWotAAA6AAAgACAKQRAgACgCvC0iA2t2OwG4LSAAIAMgBGpBEGs2ArwtDwsgACADIARqNgK8LQuXCwEMfyACQQBOBEBBBEEDIAEvAQIiChshBkEHQYoBIAobIQMgAEG5LWohCEF/IQcDQCAKIQkgASALIgxBAWoiC0ECdGovAQIhCgJAAkAgBUEBaiIEIANODQAgCSAKRw0AIAQhBQwBCwJAIAQgBkgEQCAAIAlBAnRqIgVB/BRqIQ0gBUH+FGohDiAAKAK8LSEFA0AgDi8BACEDIAAgAC8BuC0gDS8BACIGIAV0ciIHOwG4LSAAAn9BECADayAFSARAIAAgACgCFCIFQQFqNgIUIAUgACgCCGogBzoAACAAIAAoAhQiBUEBajYCFCAFIAAoAghqIAgtAAA6AAAgACAGQRAgACgCvC0iBWt2OwG4LSADIAVqQRBrDAELIAMgBWoLIgU2ArwtIARBAWsiBA0ACwwBCyAAAn8gCQRAAkAgByAJRgRAIAAoArwtIQMgBCEFDAELIAAgCUECdGoiBEH+FGovAQAhAyAAIAAvAbgtIARB/BRqLwEAIgYgACgCvC0iBHRyIgc7AbgtIAACf0EQIANrIARIBEAgACAAKAIUIgRBAWo2AhQgBCAAKAIIaiAHOgAAIAAgACgCFCIEQQFqNgIUIAQgACgCCGogCC0AADoAACAAIAZBECAAKAK8LSIEa3Y7AbgtIAMgBGpBEGsMAQsgAyAEagsiAzYCvC0LIAAvAbgtIAAvAbwVIgcgA3RyIQQCQEEQIAAvAb4VIgZrIANIBEAgACAEOwG4LSAAIAAoAhQiA0EBajYCFCADIAAoAghqIAQ6AAAgACAAKAIUIgNBAWo2AhQgAyAAKAIIaiAILQAAOgAAIAYgACgCvC0iBGpBEGshAyAHQRAgBGt2IQQMAQsgAyAGaiEDCyAAIAM2ArwtIAAgBCAFQf3/A2pB//8DcSIFIAN0ciIEOwG4LSADQQ9OBEAgACAAKAIUIgNBAWo2AhQgAyAAKAIIaiAEOgAAIAAgACgCFCIDQQFqNgIUIAMgACgCCGogCC0AADoAACAAIAVBECAAKAK8LSIDa3Y7AbgtIANBDmsMAgsgA0ECagwBCyAFQQlMBEAgAC8BuC0gAC8BwBUiByAAKAK8LSIDdHIhBAJAQRAgAC8BwhUiBmsgA0gEQCAAIAQ7AbgtIAAgACgCFCIDQQFqNgIUIAMgACgCCGogBDoAACAAIAAoAhQiA0EBajYCFCADIAAoAghqIAgtAAA6AAAgBiAAKAK8LSIEakEQayEDIAdBECAEa3YhBAwBCyADIAZqIQMLIAAgAzYCvC0gACAEIAVB/v8DakH//wNxIgUgA3RyIgQ7AbgtIANBDk4EQCAAIAAoAhQiA0EBajYCFCADIAAoAghqIAQ6AAAgACAAKAIUIgNBAWo2AhQgAyAAKAIIaiAILQAAOgAAIAAgBUEQIAAoArwtIgNrdjsBuC0gA0ENawwCCyADQQNqDAELIAAvAbgtIAAvAcQVIgcgACgCvC0iA3RyIQQCQEEQIAAvAcYVIgZrIANIBEAgACAEOwG4LSAAIAAoAhQiA0EBajYCFCADIAAoAghqIAQ6AAAgACAAKAIUIgNBAWo2AhQgAyAAKAIIaiAILQAAOgAAIAYgACgCvC0iBGpBEGshAyAHQRAgBGt2IQQMAQsgAyAGaiEDCyAAIAM2ArwtIAAgBCAFQfb/A2pB//8DcSIFIAN0ciIEOwG4LSADQQpOBEAgACAAKAIUIgNBAWo2AhQgAyAAKAIIaiAEOgAAIAAgACgCFCIDQQFqNgIUIAMgACgCCGogCC0AADoAACAAIAVBECAAKAK8LSIDa3Y7AbgtIANBCWsMAQsgA0EHags2ArwtC0EAIQUCfyAKRQRAQYoBIQNBAwwBC0EGQQcgCSAKRiIEGyEDQQNBBCAEGwshBiAJIQcLIAIgDEcNAAsLCwkAIAEgAmwQHAsGACABEB0LXwEBfyMAQUBqIgMkACADQQA2AjAgA0IANwMoIAMgADYCCCADIAI2AhQgAyABNgIMIAMgAUEDbDYCGCADQQhqEAcgA0EIahALIANBCGoQCCADKAIcIQEgA0FAayQAIAELBgBB1N8AC6QuAQx/IwBBEGsiDCQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB9AFNBEBB2N8AKAIAIgZBECAAQQtqQXhxIABBC0kbIgRBA3YiAXYiAEEDcQRAIABBf3NBAXEgAWoiAkEDdCIDQYjgAGooAgAiAUEIaiEAAkAgASgCCCIEIANBgOAAaiIDRgRAQdjfACAGQX4gAndxNgIADAELIAQgAzYCDCADIAQ2AggLIAEgAkEDdCICQQNyNgIEIAEgAmoiASABKAIEQQFyNgIEDA0LIARB4N8AKAIAIghNDQEgAARAAkAgACABdEECIAF0IgBBACAAa3JxIgBBACAAa3FBAWsiACAAQQx2QRBxIgB2IgFBBXZBCHEiAiAAciABIAJ2IgBBAnZBBHEiAXIgACABdiIAQQF2QQJxIgFyIAAgAXYiAEEBdkEBcSIBciAAIAF2aiICQQN0IgNBiOAAaigCACIBKAIIIgAgA0GA4ABqIgNGBEBB2N8AIAZBfiACd3EiBjYCAAwBCyAAIAM2AgwgAyAANgIICyABQQhqIQAgASAEQQNyNgIEIAEgBGoiAyACQQN0IgUgBGsiAkEBcjYCBCABIAVqIAI2AgAgCARAIAhBA3YiBUEDdEGA4ABqIQRB7N8AKAIAIQECfyAGQQEgBXQiBXFFBEBB2N8AIAUgBnI2AgAgBAwBCyAEKAIICyEFIAQgATYCCCAFIAE2AgwgASAENgIMIAEgBTYCCAtB7N8AIAM2AgBB4N8AIAI2AgAMDQtB3N8AKAIAIglFDQEgCUEAIAlrcUEBayIAIABBDHZBEHEiAHYiAUEFdkEIcSICIAByIAEgAnYiAEECdkEEcSIBciAAIAF2IgBBAXZBAnEiAXIgACABdiIAQQF2QQFxIgFyIAAgAXZqQQJ0QYjiAGooAgAiAygCBEF4cSAEayEBIAMhAgNAAkAgAigCECIARQRAIAIoAhQiAEUNAQsgACgCBEF4cSAEayICIAEgASACSyICGyEBIAAgAyACGyEDIAAhAgwBCwsgAyAEaiILIANNDQIgAygCGCEKIAMgAygCDCIFRwRAIAMoAggiAEHo3wAoAgBJGiAAIAU2AgwgBSAANgIIDAwLIANBFGoiAigCACIARQRAIAMoAhAiAEUNBCADQRBqIQILA0AgAiEHIAAiBUEUaiICKAIAIgANACAFQRBqIQIgBSgCECIADQALIAdBADYCAAwLC0F/IQQgAEG/f0sNACAAQQtqIgBBeHEhBEHc3wAoAgAiCEUNAEEfIQcgBEH///8HTQRAIABBCHYiACAAQYD+P2pBEHZBCHEiAHQiASABQYDgH2pBEHZBBHEiAXQiAiACQYCAD2pBEHZBAnEiAnRBD3YgACABciACcmsiAEEBdCAEIABBFWp2QQFxckEcaiEHC0EAIARrIQECQAJAAkAgB0ECdEGI4gBqKAIAIgJFBEBBACEADAELQQAhACAEQQBBGSAHQQF2ayAHQR9GG3QhAwNAAkAgAigCBEF4cSAEayIGIAFPDQAgAiEFIAYiAQ0AQQAhASACIQAMAwsgACACKAIUIgYgBiACIANBHXZBBHFqKAIQIgJGGyAAIAYbIQAgA0EBdCEDIAINAAsLIAAgBXJFBEBBAiAHdCIAQQAgAGtyIAhxIgBFDQMgAEEAIABrcUEBayIAIABBDHZBEHEiAHYiAkEFdkEIcSIDIAByIAIgA3YiAEECdkEEcSICciAAIAJ2IgBBAXZBAnEiAnIgACACdiIAQQF2QQFxIgJyIAAgAnZqQQJ0QYjiAGooAgAhAAsgAEUNAQsDQCAAKAIEQXhxIARrIgYgAUkhAyAGIAEgAxshASAAIAUgAxshBSAAKAIQIgIEfyACBSAAKAIUCyIADQALCyAFRQ0AIAFB4N8AKAIAIARrTw0AIAQgBWoiByAFTQ0BIAUoAhghCSAFIAUoAgwiA0cEQCAFKAIIIgBB6N8AKAIASRogACADNgIMIAMgADYCCAwKCyAFQRRqIgIoAgAiAEUEQCAFKAIQIgBFDQQgBUEQaiECCwNAIAIhBiAAIgNBFGoiAigCACIADQAgA0EQaiECIAMoAhAiAA0ACyAGQQA2AgAMCQsgBEHg3wAoAgAiAE0EQEHs3wAoAgAhAQJAIAAgBGsiAkEQTwRAQeDfACACNgIAQezfACABIARqIgM2AgAgAyACQQFyNgIEIAAgAWogAjYCACABIARBA3I2AgQMAQtB7N8AQQA2AgBB4N8AQQA2AgAgASAAQQNyNgIEIAAgAWoiACAAKAIEQQFyNgIECyABQQhqIQAMCwsgBEHk3wAoAgAiA0kEQEHk3wAgAyAEayIBNgIAQfDfAEHw3wAoAgAiACAEaiICNgIAIAIgAUEBcjYCBCAAIARBA3I2AgQgAEEIaiEADAsLQQAhACAEQS9qIggCf0Gw4wAoAgAEQEG44wAoAgAMAQtBvOMAQn83AgBBtOMAQoCggICAgAQ3AgBBsOMAIAxBDGpBcHFB2KrVqgVzNgIAQcTjAEEANgIAQZTjAEEANgIAQYAgCyIBaiIGQQAgAWsiB3EiBSAETQ0KQZDjACgCACIBBEBBiOMAKAIAIgIgBWoiCSACTQ0LIAEgCUkNCwtBlOMALQAAQQRxDQUCQAJAQfDfACgCACIBBEBBmOMAIQADQCABIAAoAgAiAk8EQCACIAAoAgRqIAFLDQMLIAAoAggiAA0ACwtBABAeIgNBf0YNBiAFIQZBtOMAKAIAIgBBAWsiASADcQRAIAUgA2sgASADakEAIABrcWohBgsgBCAGTw0GIAZB/v///wdLDQZBkOMAKAIAIgAEQEGI4wAoAgAiASAGaiICIAFNDQcgACACSQ0HCyAGEB4iACADRw0BDAgLIAYgA2sgB3EiBkH+////B0sNBSAGEB4iAyAAKAIAIAAoAgRqRg0EIAMhAAsCQCAEQTBqIAZNDQAgAEF/Rg0AQbjjACgCACIBIAggBmtqQQAgAWtxIgFB/v///wdLBEAgACEDDAgLIAEQHkF/RwRAIAEgBmohBiAAIQMMCAtBACAGaxAeGgwFCyAAIQMgAEF/Rw0GDAQLAAtBACEFDAcLQQAhAwwFCyADQX9HDQILQZTjAEGU4wAoAgBBBHI2AgALIAVB/v///wdLDQEgBRAeIgNBABAeIgBPDQEgA0F/Rg0BIABBf0YNASAAIANrIgYgBEEoak0NAQtBiOMAQYjjACgCACAGaiIANgIAQYzjACgCACAASQRAQYzjACAANgIACwJAAkACQEHw3wAoAgAiAQRAQZjjACEAA0AgAyAAKAIAIgIgACgCBCIFakYNAiAAKAIIIgANAAsMAgtB6N8AKAIAIgBBACAAIANNG0UEQEHo3wAgAzYCAAtBACEAQZzjACAGNgIAQZjjACADNgIAQfjfAEF/NgIAQfzfAEGw4wAoAgA2AgBBpOMAQQA2AgADQCAAQQN0IgFBiOAAaiABQYDgAGoiAjYCACABQYzgAGogAjYCACAAQQFqIgBBIEcNAAtB5N8AIAZBKGsiAEF4IANrQQdxQQAgA0EIakEHcRsiAWsiAjYCAEHw3wAgASADaiIBNgIAIAEgAkEBcjYCBCAAIANqQSg2AgRB9N8AQcDjACgCADYCAAwCCyABIANPDQAgASACSQ0AIAAoAgxBCHENACAAIAUgBmo2AgRB8N8AIAFBeCABa0EHcUEAIAFBCGpBB3EbIgBqIgI2AgBB5N8AQeTfACgCACAGaiIDIABrIgA2AgAgAiAAQQFyNgIEIAEgA2pBKDYCBEH03wBBwOMAKAIANgIADAELQejfACgCACADSwRAQejfACADNgIACyADIAZqIQJBmOMAIQACQAJAAkACQAJAAkADQCACIAAoAgBHBEAgACgCCCIADQEMAgsLIAAtAAxBCHFFDQELQZjjACEAA0AgASAAKAIAIgJPBEAgAiAAKAIEaiICIAFLDQMLIAAoAgghAAwACwALIAAgAzYCACAAIAAoAgQgBmo2AgQgA0F4IANrQQdxQQAgA0EIakEHcRtqIgcgBEEDcjYCBCACQXggAmtBB3FBACACQQhqQQdxG2oiBiAHayAEayECIAQgB2ohBCABIAZGBEBB8N8AIAQ2AgBB5N8AQeTfACgCACACaiIANgIAIAQgAEEBcjYCBAwDCyAGQezfACgCAEYEQEHs3wAgBDYCAEHg3wBB4N8AKAIAIAJqIgA2AgAgBCAAQQFyNgIEIAAgBGogADYCAAwDCyAGKAIEIgBBA3FBAUYEQCAAQXhxIQgCQCAAQf8BTQRAIAYoAggiASAAQQN2IgVBA3RBgOAAakYaIAEgBigCDCIARgRAQdjfAEHY3wAoAgBBfiAFd3E2AgAMAgsgASAANgIMIAAgATYCCAwBCyAGKAIYIQkCQCAGIAYoAgwiA0cEQCAGKAIIIgAgAzYCDCADIAA2AggMAQsCQCAGQRRqIgAoAgAiAQ0AIAZBEGoiACgCACIBDQBBACEDDAELA0AgACEFIAEiA0EUaiIAKAIAIgENACADQRBqIQAgAygCECIBDQALIAVBADYCAAsgCUUNAAJAIAYgBigCHCIBQQJ0QYjiAGoiACgCAEYEQCAAIAM2AgAgAw0BQdzfAEHc3wAoAgBBfiABd3E2AgAMAgsgCUEQQRQgCSgCECAGRhtqIAM2AgAgA0UNAQsgAyAJNgIYIAYoAhAiAARAIAMgADYCECAAIAM2AhgLIAYoAhQiAEUNACADIAA2AhQgACADNgIYCyAGIAhqIQYgAiAIaiECCyAGIAYoAgRBfnE2AgQgBCACQQFyNgIEIAIgBGogAjYCACACQf8BTQRAIAJBA3YiAUEDdEGA4ABqIQACf0HY3wAoAgAiAkEBIAF0IgFxRQRAQdjfACABIAJyNgIAIAAMAQsgACgCCAshASAAIAQ2AgggASAENgIMIAQgADYCDCAEIAE2AggMAwtBHyEAIAJB////B00EQCACQQh2IgAgAEGA/j9qQRB2QQhxIgB0IgEgAUGA4B9qQRB2QQRxIgF0IgMgA0GAgA9qQRB2QQJxIgN0QQ92IAAgAXIgA3JrIgBBAXQgAiAAQRVqdkEBcXJBHGohAAsgBCAANgIcIARCADcCECAAQQJ0QYjiAGohAQJAQdzfACgCACIDQQEgAHQiBXFFBEBB3N8AIAMgBXI2AgAgASAENgIAIAQgATYCGAwBCyACQQBBGSAAQQF2ayAAQR9GG3QhACABKAIAIQMDQCADIgEoAgRBeHEgAkYNAyAAQR12IQMgAEEBdCEAIAEgA0EEcWpBEGoiBSgCACIDDQALIAUgBDYCACAEIAE2AhgLIAQgBDYCDCAEIAQ2AggMAgtB5N8AIAZBKGsiAEF4IANrQQdxQQAgA0EIakEHcRsiBWsiBzYCAEHw3wAgAyAFaiIFNgIAIAUgB0EBcjYCBCAAIANqQSg2AgRB9N8AQcDjACgCADYCACABIAJBJyACa0EHcUEAIAJBJ2tBB3EbakEvayIAIAAgAUEQakkbIgVBGzYCBCAFQaDjACkCADcCECAFQZjjACkCADcCCEGg4wAgBUEIajYCAEGc4wAgBjYCAEGY4wAgAzYCAEGk4wBBADYCACAFQRhqIQADQCAAQQc2AgQgAEEIaiEDIABBBGohACACIANLDQALIAEgBUYNAyAFIAUoAgRBfnE2AgQgASAFIAFrIgZBAXI2AgQgBSAGNgIAIAZB/wFNBEAgBkEDdiICQQN0QYDgAGohAAJ/QdjfACgCACIDQQEgAnQiAnFFBEBB2N8AIAIgA3I2AgAgAAwBCyAAKAIICyECIAAgATYCCCACIAE2AgwgASAANgIMIAEgAjYCCAwEC0EfIQAgAUIANwIQIAZB////B00EQCAGQQh2IgAgAEGA/j9qQRB2QQhxIgB0IgIgAkGA4B9qQRB2QQRxIgJ0IgMgA0GAgA9qQRB2QQJxIgN0QQ92IAAgAnIgA3JrIgBBAXQgBiAAQRVqdkEBcXJBHGohAAsgASAANgIcIABBAnRBiOIAaiECAkBB3N8AKAIAIgNBASAAdCIFcUUEQEHc3wAgAyAFcjYCACACIAE2AgAgASACNgIYDAELIAZBAEEZIABBAXZrIABBH0YbdCEAIAIoAgAhAwNAIAMiAigCBEF4cSAGRg0EIABBHXYhAyAAQQF0IQAgAiADQQRxakEQaiIFKAIAIgMNAAsgBSABNgIAIAEgAjYCGAsgASABNgIMIAEgATYCCAwDCyABKAIIIgAgBDYCDCABIAQ2AgggBEEANgIYIAQgATYCDCAEIAA2AggLIAdBCGohAAwFCyACKAIIIgAgATYCDCACIAE2AgggAUEANgIYIAEgAjYCDCABIAA2AggLQeTfACgCACIAIARNDQBB5N8AIAAgBGsiATYCAEHw3wBB8N8AKAIAIgAgBGoiAjYCACACIAFBAXI2AgQgACAEQQNyNgIEIABBCGohAAwDC0HU3wBBMDYCAEEAIQAMAgsCQCAJRQ0AAkAgBSgCHCICQQJ0QYjiAGoiACgCACAFRgRAIAAgAzYCACADDQFB3N8AIAhBfiACd3EiCDYCAAwCCyAJQRBBFCAJKAIQIAVGG2ogAzYCACADRQ0BCyADIAk2AhggBSgCECIABEAgAyAANgIQIAAgAzYCGAsgBSgCFCIARQ0AIAMgADYCFCAAIAM2AhgLAkAgAUEPTQRAIAUgASAEaiIAQQNyNgIEIAAgBWoiACAAKAIEQQFyNgIEDAELIAUgBEEDcjYCBCAHIAFBAXI2AgQgASAHaiABNgIAIAFB/wFNBEAgAUEDdiIBQQN0QYDgAGohAAJ/QdjfACgCACICQQEgAXQiAXFFBEBB2N8AIAEgAnI2AgAgAAwBCyAAKAIICyEBIAAgBzYCCCABIAc2AgwgByAANgIMIAcgATYCCAwBC0EfIQAgAUH///8HTQRAIAFBCHYiACAAQYD+P2pBEHZBCHEiAHQiAiACQYDgH2pBEHZBBHEiAnQiBCAEQYCAD2pBEHZBAnEiBHRBD3YgACACciAEcmsiAEEBdCABIABBFWp2QQFxckEcaiEACyAHIAA2AhwgB0IANwIQIABBAnRBiOIAaiECAkACQCAIQQEgAHQiBHFFBEBB3N8AIAQgCHI2AgAgAiAHNgIAIAcgAjYCGAwBCyABQQBBGSAAQQF2ayAAQR9GG3QhACACKAIAIQQDQCAEIgIoAgRBeHEgAUYNAiAAQR12IQQgAEEBdCEAIAIgBEEEcWpBEGoiAygCACIEDQALIAMgBzYCACAHIAI2AhgLIAcgBzYCDCAHIAc2AggMAQsgAigCCCIAIAc2AgwgAiAHNgIIIAdBADYCGCAHIAI2AgwgByAANgIICyAFQQhqIQAMAQsCQCAKRQ0AAkAgAygCHCICQQJ0QYjiAGoiACgCACADRgRAIAAgBTYCACAFDQFB3N8AIAlBfiACd3E2AgAMAgsgCkEQQRQgCigCECADRhtqIAU2AgAgBUUNAQsgBSAKNgIYIAMoAhAiAARAIAUgADYCECAAIAU2AhgLIAMoAhQiAEUNACAFIAA2AhQgACAFNgIYCwJAIAFBD00EQCADIAEgBGoiAEEDcjYCBCAAIANqIgAgACgCBEEBcjYCBAwBCyADIARBA3I2AgQgCyABQQFyNgIEIAEgC2ogATYCACAIBEAgCEEDdiIEQQN0QYDgAGohAkHs3wAoAgAhAAJ/QQEgBHQiBCAGcUUEQEHY3wAgBCAGcjYCACACDAELIAIoAggLIQQgAiAANgIIIAQgADYCDCAAIAI2AgwgACAENgIIC0Hs3wAgCzYCAEHg3wAgATYCAAsgA0EIaiEACyAMQRBqJAAgAAvMDAEHfwJAIABFDQAgAEEIayICIABBBGsoAgAiAUF4cSIAaiEFAkAgAUEBcQ0AIAFBA3FFDQEgAiACKAIAIgFrIgJB6N8AKAIASQ0BIAAgAWohACACQezfACgCAEcEQCABQf8BTQRAIAIoAggiBCABQQN2IgdBA3RBgOAAakYaIAQgAigCDCIBRgRAQdjfAEHY3wAoAgBBfiAHd3E2AgAMAwsgBCABNgIMIAEgBDYCCAwCCyACKAIYIQYCQCACIAIoAgwiA0cEQCACKAIIIgEgAzYCDCADIAE2AggMAQsCQCACQRRqIgEoAgAiBA0AIAJBEGoiASgCACIEDQBBACEDDAELA0AgASEHIAQiA0EUaiIBKAIAIgQNACADQRBqIQEgAygCECIEDQALIAdBADYCAAsgBkUNAQJAIAIgAigCHCIEQQJ0QYjiAGoiASgCAEYEQCABIAM2AgAgAw0BQdzfAEHc3wAoAgBBfiAEd3E2AgAMAwsgBkEQQRQgBigCECACRhtqIAM2AgAgA0UNAgsgAyAGNgIYIAIoAhAiAQRAIAMgATYCECABIAM2AhgLIAIoAhQiAUUNASADIAE2AhQgASADNgIYDAELIAUoAgQiAUEDcUEDRw0AQeDfACAANgIAIAUgAUF+cTYCBCACIABBAXI2AgQgACACaiAANgIADwsgAiAFTw0AIAUoAgQiAUEBcUUNAAJAIAFBAnFFBEAgBUHw3wAoAgBGBEBB8N8AIAI2AgBB5N8AQeTfACgCACAAaiIANgIAIAIgAEEBcjYCBCACQezfACgCAEcNA0Hg3wBBADYCAEHs3wBBADYCAA8LIAVB7N8AKAIARgRAQezfACACNgIAQeDfAEHg3wAoAgAgAGoiADYCACACIABBAXI2AgQgACACaiAANgIADwsgAUF4cSAAaiEAAkAgAUH/AU0EQCAFKAIIIgQgAUEDdiIHQQN0QYDgAGpGGiAEIAUoAgwiAUYEQEHY3wBB2N8AKAIAQX4gB3dxNgIADAILIAQgATYCDCABIAQ2AggMAQsgBSgCGCEGAkAgBSAFKAIMIgNHBEAgBSgCCCIBQejfACgCAEkaIAEgAzYCDCADIAE2AggMAQsCQCAFQRRqIgEoAgAiBA0AIAVBEGoiASgCACIEDQBBACEDDAELA0AgASEHIAQiA0EUaiIBKAIAIgQNACADQRBqIQEgAygCECIEDQALIAdBADYCAAsgBkUNAAJAIAUgBSgCHCIEQQJ0QYjiAGoiASgCAEYEQCABIAM2AgAgAw0BQdzfAEHc3wAoAgBBfiAEd3E2AgAMAgsgBkEQQRQgBigCECAFRhtqIAM2AgAgA0UNAQsgAyAGNgIYIAUoAhAiAQRAIAMgATYCECABIAM2AhgLIAUoAhQiAUUNACADIAE2AhQgASADNgIYCyACIABBAXI2AgQgACACaiAANgIAIAJB7N8AKAIARw0BQeDfACAANgIADwsgBSABQX5xNgIEIAIgAEEBcjYCBCAAIAJqIAA2AgALIABB/wFNBEAgAEEDdiIBQQN0QYDgAGohAAJ/QdjfACgCACIEQQEgAXQiAXFFBEBB2N8AIAEgBHI2AgAgAAwBCyAAKAIICyEBIAAgAjYCCCABIAI2AgwgAiAANgIMIAIgATYCCA8LQR8hASACQgA3AhAgAEH///8HTQRAIABBCHYiASABQYD+P2pBEHZBCHEiAXQiBCAEQYDgH2pBEHZBBHEiBHQiAyADQYCAD2pBEHZBAnEiA3RBD3YgASAEciADcmsiAUEBdCAAIAFBFWp2QQFxckEcaiEBCyACIAE2AhwgAUECdEGI4gBqIQQCQAJAAkBB3N8AKAIAIgNBASABdCIFcUUEQEHc3wAgAyAFcjYCACAEIAI2AgAgAiAENgIYDAELIABBAEEZIAFBAXZrIAFBH0YbdCEBIAQoAgAhAwNAIAMiBCgCBEF4cSAARg0CIAFBHXYhAyABQQF0IQEgBCADQQRxakEQaiIFKAIAIgMNAAsgBSACNgIAIAIgBDYCGAsgAiACNgIMIAIgAjYCCAwBCyAEKAIIIgAgAjYCDCAEIAI2AgggAkEANgIYIAIgBDYCDCACIAA2AggLQfjfAEH43wAoAgBBAWsiAkF/IAIbNgIACwtVAQJ/QdDfACgCACIBIABBA2pBfHEiAmohAAJAIAJBAU5BACAAIAFNGw0APwBBEHQgAEkEQCAAEABFDQELQdDfACAANgIAIAEPC0HU3wBBMDYCAEF/C4IEAQN/IAJBgARPBEAgACABIAIQARogAA8LIAAgAmohAwJAIAAgAXNBA3FFBEACQCACQQFIBEAgACECDAELIABBA3FFBEAgACECDAELIAAhAgNAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIANPDQEgAkEDcQ0ACwsCQCADQXxxIgRBwABJDQAgAiAEQUBqIgVLDQADQCACIAEoAgA2AgAgAiABKAIENgIEIAIgASgCCDYCCCACIAEoAgw2AgwgAiABKAIQNgIQIAIgASgCFDYCFCACIAEoAhg2AhggAiABKAIcNgIcIAIgASgCIDYCICACIAEoAiQ2AiQgAiABKAIoNgIoIAIgASgCLDYCLCACIAEoAjA2AjAgAiABKAI0NgI0IAIgASgCODYCOCACIAEoAjw2AjwgAUFAayEBIAJBQGsiAiAFTQ0ACwsgAiAETw0BA0AgAiABKAIANgIAIAFBBGohASACQQRqIgIgBEkNAAsMAQsgA0EESQRAIAAhAgwBCyAAIANBBGsiBEsEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAIgAS0AAToAASACIAEtAAI6AAIgAiABLQADOgADIAFBBGohASACQQRqIgIgBE0NAAsLIAIgA0kEQANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIANHDQALCyAAC9YCAQJ/AkAgAUUNACAAIAFqIgJBAWtBADoAACAAQQA6AAAgAUEDSQ0AIAJBAmtBADoAACAAQQA6AAEgAkEDa0EAOgAAIABBADoAAiABQQdJDQAgAkEEa0EAOgAAIABBADoAAyABQQlJDQAgAEEAIABrQQNxIgNqIgJBADYCACACIAEgA2tBfHEiA2oiAUEEa0EANgIAIANBCUkNACACQQA2AgggAkEANgIEIAFBCGtBADYCACABQQxrQQA2AgAgA0EZSQ0AIAJBADYCGCACQQA2AhQgAkEANgIQIAJBADYCDCABQRBrQQA2AgAgAUEUa0EANgIAIAFBGGtBADYCACABQRxrQQA2AgAgAyACQQRxQRhyIgNrIgFBIEkNACACIANqIQIDQCACQgA3AxggAkIANwMQIAJCADcDCCACQgA3AwAgAkEgaiECIAFBIGsiAUEfSw0ACwsLBAAjAAsGACAAJAALEAAjACAAa0FwcSIAJAAgAAsLvVYIAEGECAvxQJYwB3csYQ7uulEJmRnEbQeP9GpwNaVj6aOVZJ4yiNsOpLjceR7p1eCI2dKXK0y2Cb18sX4HLbjnkR2/kGQQtx3yILBqSHG5895BvoR91Noa6+TdbVG11PTHhdODVphsE8Coa2R6+WL97Mllik9cARTZbAZjYz0P+vUNCI3IIG47XhBpTORBYNVycWei0eQDPEfUBEv9hQ3Sa7UKpfqotTVsmLJC1sm720D5vKzjbNgydVzfRc8N1txZPdGrrDDZJjoA3lGAUdfIFmHQv7X0tCEjxLNWmZW6zw+lvbieuAIoCIgFX7LZDMYk6Quxh3xvLxFMaFirHWHBPS1mtpBB3HYGcdsBvCDSmCoQ1e+JhbFxH7W2BqXkv58z1LjooskHeDT5AA+OqAmWGJgO4bsNan8tPW0Il2xkkQFcY+b0UWtrYmFsHNgwZYVOAGLy7ZUGbHulARvB9AiCV8QP9cbZsGVQ6bcS6ri+i3yIufzfHd1iSS3aFfN804xlTNT7WGGyTc5RtTp0ALyj4jC71EGl30rXldg9bcTRpPv01tNq6WlD/NluNEaIZ63QuGDacy0EROUdAzNfTAqqyXwN3TxxBVCqQQInEBALvoYgDMkltWhXs4VvIAnUZrmf5GHODvneXpjJ2SkimNCwtKjXxxc9s1mBDbQuO1y9t61susAgg7jttrO/mgzitgOa0rF0OUfV6q930p0VJtsEgxbccxILY+OEO2SUPmptDahaanoLzw7knf8JkyeuAAqxngd9RJMP8NKjCIdo8gEe/sIGaV1XYvfLZ2WAcTZsGecGa252G9T+4CvTiVp62hDMSt1nb9+5+fnvvo5DvrcX1Y6wYOij1tZ+k9GhxMLYOFLy30/xZ7vRZ1e8pt0GtT9LNrJI2isN2EwbCq/2SgM2YHoEQcPvYN9V32eo745uMXm+aUaMs2HLGoNmvKDSbyU24mhSlXcMzANHC7u5FgIiLyYFVb47usUoC72yklq0KwRqs1yn/9fCMc/QtYue2Swdrt5bsMJkmybyY+yco2p1CpNtAqkGCZw/Ng7rhWcHchNXAAWCSr+VFHq44q4rsXs4G7YMm47Skg2+1eW379x8Id/bC9TS04ZC4tTx+LPdaG6D2h/NFr6BWya59uF3sG93R7cY5loIiHBqD//KOwZmXAsBEf+eZY9prmL40/9rYUXPbBZ44gqg7tIN11SDBE7CswM5YSZnp/cWYNBNR2lJ23duPkpq0a7cWtbZZgvfQPA72DdTrrypxZ673n/Pskfp/7UwHPK9vYrCusowk7NTpqO0JAU20LqTBtfNKVfeVL9n2SMuemazuEphxAIbaF2UK28qN74LtKGODMMb3wVaje8CLQAAAABBMRsZgmI2MsNTLSsExWxkRfR3fYanWlbHlkFPCIrZyEm7wtGK6O/6y9n04wxPtaxNfq61ji2Dns8cmIdREsJKECPZU9Nw9HiSQe9hVdeuLhTmtTfXtZgcloSDBVmYG4IYqQCb2/otsJrLNqldXXfmHGxs/98/QdSeDlrNoiSEleMVn4wgRrKnYXepvqbh6PHn0PPoJIPew2Wyxdqqrl1d659GRCjMa29p/XB2rmsxOe9aKiAsCQcLbTgcEvM2Rt+yB13GcVRw7TBla/T38yq7tsIxonWRHIk0oAeQ+7yfF7qNhA553qklOO+yPP9583O+SOhqfRvFQTwq3lgFT3nwRH5i6YctT8LGHFTbAYoVlEC7Do2D6COmwtk4vw3FoDhM9Lshj6eWCs6WjRMJAMxcSDHXRYti+m7KU+F3VF27uhVsoKPWP42Ilw6WkVCY194RqczH0vrh7JPL+vVc12JyHeZ5a961VECfhE9ZWBIOFhkjFQ/acDgkm0EjPadr/WXmWuZ8JQnLV2Q40E6jrpEB4p+KGCHMpzNg/bwqr+Ekre7QP7QtgxKfbLIJhqskSMnqFVPQKUZ++2h3ZeL2eT8vt0gkNnQbCR01KhIE8rxTS7ONSFJw3mV5Me9+YP7z5ue/wv3+fJHQ1T2gy8z6NoqDuweRmnhUvLE5ZaeoS5iDOwqpmCLJ+rUJiMuuEE9d718ObPRGzT/ZbYwOwnRDElrzAiNB6sFwbMGAQXfYR9c2lwbmLY7FtQClhIQbvBqKQXFbu1pomOh3Q9nZbFoeTy0VX342DJwtGyfdHAA+EgCYuVMxg6CQYq6L0VO1khbF9N1X9O/ElKfC79WW2fbpvAeuqI0ct2veMZwq7yqF7XlryqxIcNNvG134LipG4eE23magB8V/Y1ToVCJl803l87ICpMKpG2eRhDAmoJ8puK7F5Pmf3v06zPPWe/3oz7xrqYD9WrKZPgmfsn84hKuwJBws8RUHNTJGKh5zdzEHtOFwSPXQa1E2g0Z6d7JdY07X+ssP5uHSzLXM+Y2E1+BKEpavCyONtshwoJ2JQbuERl0jAwdsOBrEPxUxhQ4OKEKYT2cDqVR+wPp5VYHLYkwfxTiBXvQjmJ2nDrPclhWqGwBU5VoxT/yZYmLX2FN5zhdP4UlWfvpQlS3Xe9QczGITio0tUruWNJHoux/Q2aAG7PN+Xq3CZUdukUhsL6BTdeg2EjqpBwkjalQkCCtlPxHkeaeWpUi8j2YbkaQnKoq94LzL8qGN0Oti3v3AI+/m2b3hvBT80KcNP4OKJn6ykT+5JNBw+BXLaTtG5kJ6d/1btWtl3PRafsU3CVPudjhI97GuCbjwnxKhM8w/inL9JJMAAAAAN2rCAW7UhANZvkYC3KgJB+vCywayfI0EhRZPBbhREw6PO9EP1oWXDeHvVQxk+RoJU5PYCAotngo9R1wLcKMmHEfJ5B0ed6IfKR1gHqwLLxubYe0awt+rGPW1aRnI8jUS/5j3E6YmsRGRTHMQFFo8FSMw/hR6jrgWTeR6F+BGTTjXLI85jpLJO7n4Czo87kQ/C4SGPlI6wDxlUAI9WBdeNm99nDc2w9o1AakYNIS/VzGz1ZUw6mvTMt0BETOQ5Wskp4+pJf4x7yfJWy0mTE1iI3snoCIimeYgFfMkISi0eCof3rorRmD8KXEKPij0HHEtw3azLJrI9S6tojcvwI2acPfnWHGuWR5zmTPcchwlk3crT1F2cvEXdEWb1XV43Il+T7ZLfxYIDX0hYs98pHSAeZMeQnjKoAR6/crGe7AuvGyHRH5t3vo4b+mQ+m5shrVrW+x3agJSMWg1OPNpCH+vYj8VbWNmqythUcHpYNTXpmXjvWRkugMiZo1p4Gcgy9dIF6EVSU4fU0t5dZFK/GPeT8sJHE6St1pMpd2YTZiaxEav8AZH9k5ARcEkgkREMs1Bc1gPQCrmSUIdjItDUGjxVGcCM1U+vHVXCda3VozA+FO7qjpS4hR8UNV+vlHoOeJa31MgW4btZlmxh6RYNJHrXQP7KVxaRW9ebS+tX4AbNeG3cffg7s+x4tmlc+Ncszzma9n+5zJnuOUFDXrkOEom7w8g5O5WnqLsYfRg7eTiL+jTiO3pijar671caerwuBP9x9LR/J5sl/6pBlX/LBAa+ht62PtCxJ75da5c+EjpAPN/g8LyJj2E8BFXRvGUQQn0oyvL9fqVjffN/0/2YF142Vc3utgOifzaOeM+27z1cd6Ln7Pf0iH13eVLN9zYDGvX72ap1rbY79SBsi3VBKRi0DPOoNFqcObTXRok0hD+XsUnlJzEfiraxklAGMfMVlfC+zyVw6KC08GV6BHAqK9Ny5/Fj8rGe8nI8RELyXQHRMxDbYbNGtPAzy25As5Alq+Rd/xtkC5CK5IZKOmTnD6mlqtUZJfy6iKVxYDglPjHvJ/PrX6elhM4nKF5+p0kb7WYEwV3mUq7MZt90fOaMDWJjQdfS4xe4Q2OaYvPj+ydgIrb90KLgkkEibUjxoiIZJqDvw5YguawHoDR2tyBVMyThGOmUYU6GBeHDXLVhqDQ4qmXuiCozgRmqvlupKt8eOuuSxIprxKsb60lxq2sGIHxpy/rM6Z2VXWkQT+3pcQp+KDzQzqhqv18o52XvqLQc8S15xkGtL6nQLaJzYK3DNvNsjuxD7NiD0mxVWWLsGgi17tfSBW6BvZTuDGckbm0it68g+AcvdpeWr/tNJi+AAAAAGVnvLiLyAmq7q+1EleXYo8y8N433F9rJbk4153vKLTFik8IfWTgvW8BhwHXuL/WSt3YavIzd9/gVhBjWJ9XGVD6MKXoFJ8Q+nH4rELIwHvfrafHZ0MIcnUmb87NcH+tlRUYES37t6Q/ntAYhyfozxpCj3OirCDGsMlHegg+rzKgW8iOGLVnOwrQAIeyaThQLwxf7Jfi8FmFh5flPdGHhmW04DrdWk+Pzz8oM3eGEOTq43dYUg3Y7UBov1H4ofgr8MSfl0gqMCJaT1ee4vZvSX+TCPXHfadA1RjA/G1O0J81K7cjjcUYlp+gfyonGUf9unwgQQKSj/QQ9+hIqD1YFJtYP6gjtpAdMdP3oYlqz3YUD6jKrOEHf76EYMMG0nCgXrcXHOZZuKn0PN8VTIXnwtHggH5pDi/Le2tId8OiDw3Lx2ixcynHBGFMoLjZ9ZhvRJD/0/x+UGbuGzfaVk0nuQ4oQAW2xu+wpKOIDBwasNuBf9dnOZF40iv0H26TA/cmO2aQmoOIPy+R7ViTKVRgRLQxB/gM36hNHrrP8abs35L+ibguRmcXm1QCcCfsu0jwcd4vTMkwgPnbVedFY5ygP2v5x4PTF2g2wXIPinnLN13krlDhXED/VE4lmOj2c4iLrhbvNxb4QIIEnSc+vCQf6SFBeFWZr9fgi8qwXDM7tlntXtHlVbB+UEfVGez/bCE7YglGh9rn6TLIgo6OcNSe7Six+VGQX1bkgjoxWDqDCY+n5m4zHwjBhg1tpjq1pOFAvcGG/AUvKUkXSk71r/N2IjKWEZ6KeL4rmB3ZlyBLyfR4Lq5IwMAB/dKlZkFqHF6W93k5Kk+Xlp9d8vEj5QUZa01gftf1jtFi5+u23l9SjgnCN+m1etlGAGi8IbzQ6jHfiI9WYzBh+dYiBJ5qmr2mvQfYwQG/Nm60rVMJCBWaTnId/ynOpRGGe7d04ccPzdkQkqi+rCpGERk4I3algHVmxtgQAXpg/q7PcpvJc8oi8aRXR5YY76k5rf3MXhFFBu5NdmOJ8c6NJkTc6EH4ZFF5L/k0HpNB2rEmU7/WmuvpxvmzjKFFC2IO8BkHaUyhvlGbPNs2J4Q1mZKWUP4uLpm5VCb83uieEnFdjHcW4TTOLjapq0mKEUXmPwMggYO7dpHg4xP2XFv9WelJmD5V8SEGgmxEYT7Uqs6Lxs+pN344QX/WXSbDbrOJdnzW7srEb9YdWQqxoeHkHhTzgXmoS9dpyxOyDnerXKHCuTnGfgGA/qmc5ZkVJAs2oDZuURyOpxZmhsJx2j4s3m8sSbnTlPCBBAmV5rixe0kNox4usRtIPtJDLVlu+8P22+mmkWdRH6mwzHrODHSUYblm8QYF3gAAAAB3BzCW7g5hLJkJUboHbcQZcGr0j+ljpTWeZJWjDtuIMnncuKTg1ekel9LZiAm2TCt+sXy957gtB5C/HZEdtxBkarAg8vO5cUiEvkHeGtrUfW3d5Ov01LVRg9OFxxNsmFZka6jA/WL5eoplyewUAVxPYwZs2foPPWONCA31O24gyExpEF7VYEHkomdxcjwD5NFLBNRH0g2F/aUKtWs1taj6QrKYbNu7ydasvPlAMths40XfXHXc1g3Pq9E9WSbZMKxR3gA6yNdRgL/QYRYhtPS1VrPEI8+6lZm4vaUPKAK4nl8FiAjGDNmysQvpJC9vfIdYaEwRwWEdq7ZmLT123EGQAdtxBpjSILzv1RAqcbGFiQa2tR+fv+Sl6LjUM3gHyaIPAPk0lgmojuEOmBh/ag27CG09LZFkbJfmY1wBa2tR9BxsYWKFZTDY8mIATmwGle0bAaV7ggj0wfUPxFdlsNnGErfpUIu+uOr8uYh8Yt0d3xXaLUmM03zz+9RMZU2yYVg6tVHOo7wAdNS7MOJK36VBPdiV16TRxG3T1vT7Q2npajRu2fytZ4hG2mC40EQELXMzAx3lqgpMX90NfMlQBXE8JwJBqr4LEBDJDCCGV2i1JSBvhbO5ZtQJzmHkn17e+Q4p2cmYsNCYIsfXqLRZsz0XLrQNgbe9XDvAumyt7biDIJq/s7YDtuIMdLHSmurVRzmd0nevBNsmFXPcFoPjYwsSlGQ7hA1taj56alqo5A7PC5MJ/50KAK4nfQeesfAPk0SHCKPSHgHyaGkGwv73YlddgGVnyxlsNnFuawbn/tQbdonTK+AQ2npaZ91KzPm532+Ovu/5F7e+Q2CwjtXW1qPoodGTfjjYwsRP3/JS0btn8aa8V2c/tQbdSLI2S9gNK9qvChtMNgNK9kEEemDfYO/DqGffVTFuju9Gab55y2GzjLxmgxolb9KgUmjiNswMd5W7C0cDIgIWuVUFJi/Fuju+sr0LKCu0WpJcs2oEwtf/p7XQzzEs2Z6LW96uHZtkwrDsY/ImdWqjnAJtkwqcCQap6w42P3IHZ4UFAFcTlb9KguK4ehR7sSuuDLYbOJLSjpvl1b4NfNzvtwvb3yGG09LU8dTiQmjds/gf2oNugb4Wzfa5JltvsHfhGLdHd4gIWub/D2pwZgY7yhEBC1yPZZ7/+GKuaWFr/9MWbM9FoArieNcN0u5OBINUOQOzwqdnJmHQYBb3SWlHTT5ud9uu0WpK2dZa3EDfC2Y32DvwqbyuU967nsVHss9/MLX/6b298hzKusKKU7OTMCS0o6a60DYFzdcGk1TeVykj2We/s2Z6LsRhSrhdaBsCKm8rlLQLvjfDDI6hWgXfGy0C740AAAAAGRsxQTI2YoIrLVPDZGzFBH139EVWWqeGT0GWx8jZigjRwrtJ+u/oiuP02custU8Mta5+TZ6DLY6HmBzPSsISUVPZIxB49HDTYe9Bki6u11U3teYUHJi11wWDhJaCG5hZmwCpGLAt+tupNsua5nddXf9sbBzUQT/fzVoOnpWEJKKMnxXjp7JGIL6pd2Hx6OGm6PPQ58PegyTaxbJlXV2uqkRGn+tva8wodnD9aTkxa64gKlrvCwcJLBIcOG3fRjbzxl0Hsu1wVHH0a2Uwuyrz96IxwraJHJF1kAegNBefvPsOhI26JaneeTyy7zhz83n/auhIvkHFG31Y3io88HlPBelifkTCTy2H21QcxpQVigGNDrtApiPog7842cI4oMUNIbv0TAqWp48TjZbOXMwACUXXMUhu+mKLd+FTyrq7XVSjoGwViI0/1pGWDpfe15hQx8ypEezh+tL1+suTcmLXXGt55h1AVLXeWU+EnxYOElgPFSMZJDhw2j0jQZtl/WunfOZa5lfLCSVO0DhkAZGuoxiKn+Izp8whKrz9YK0k4a+0P9DunxKDLYYJsmzJSCSr0FMV6vt+RiniZXdoLz959jYkSLcdCRt0BBIqNUtTvPJSSI2zeWXecGB+7zHn5vP+/v3Cv9XQkXzMy6A9g4o2+pqRB7uxvFR4qKdlOTuDmEsimKkKCbX6yRCuy4hf711PRvRsDm3ZP810wg6M81oSQ+pBIwLBbHDB2HdBgJc210eOLeYGpQC1xbwbhIRxQYoaaFq7W0N36JhabNnZFS1PHgw2fl8nGy2cPgAc3bmYABKggzFTi65ikJK1U9Hd9MUWxO/0V+/Cp5T22ZbVrge86bccjaicMd5rhSrvKspree3TcEis+F0bb+FGKi5m3jbhf8UHoFToVGNN82UiArLz5RupwqQwhJFnKZ+gJuTFrrj93p/51vPMOs/o/XuAqWu8mbJa/bKfCT6rhDh/LBwksDUHFfEeKkYyBzF3c0hw4bRRa9D1ekaDNmNdsnfL+tdO0uHmD/nMtczg14SNr5YSSraNIwudoHDIhLtBiQMjXUYaOGwHMRU/xCgODoVnT5hCflSpA1V5+sBMYsuBgTjFH5gj9F6zDqedqhWW3OVUABv8TzFa12Jimc55U9hJ4U8XUPp+VnvXLZVizBzULY2KEzSWu1Ifu+iRBqDZ0F5+8+xHZcKtbEiRbnVToC86EjboIwkHqQgkVGoRP2Urlqd55I+8SKWkkRtmvYoqJ/LLvODr0I2hwP3eYtnm7yMUvOG9DafQ/CaKgz8/kbJ+cNAkuWnLFfhC5kY7W/13etxla7XFflr07lMJN/dIOHa4Ca6xoRKf8Io/zDOTJP1yAAAAAAHCajcDhNRuAka+WQcJqNwGy8LrBI18sgVPFoUOE1G4D9E7jw2XhdYMVe/hCRr5ZAjYk1MKni0KC1xHPRwmo3Ad5MlHH6J3Hh5gHSkbLwusGu1hmxir38IZabX1EjXyyBP3mP8RsSamEHNMkRU8WhQU/jAjFriOehd65E04TUbgOY8s1zvJko46C/i5P0TuPD6GhAs8wDpSPQJQZTZeF1g3nH1vNdrDNjQYqQExV7+EMJXVszLTa+ozEQHdJGvlkCWpj6cn7zH+Ji1bySNiTUwioCd7IOaZIiEk8xUqeLQoK7reHyn8YEYoPgpxLXEc9CyzdsMu9ciaLzeirXCajcBxWOf3cx5ZrnLcM5l3kyUcdlFPK3QX8XJ11ZtFfonceH9Ltk99DQgWfM9iIXmAdKR4Qh6TegSgynvGyv1svC6wbX5Eh284+t5u+pDpa7WGbGp37FtoMVICafM4NWKvfwhjbRU/YSurZmDpwVFlptfUZGS942YiA7pn4GmNSNfLIEkVoRdLUx9OSpF1eU/eY/xOHAnLTFq3kk2Y3aVGxJqYRwbwr0VATvZEgiTBQc0yREAPWHNCSeYqQ4uMHVTxaFBVMwJnV3W8Pla31glT+MCMUjqqu1B8FOJRvn7VWuI56FsgU99ZZu2GWKSHsV3rkTRcKfsDXm9FWl+tL23hNRuA4Pdxt+Kxz+7jc6XZ5jyzXOf+2WvluGcy5HoNBe8mSjju5CAP7KKeVu1g9GHoL+Lk6e2I0+urNorqaVy9/RO48PzR0sf+l2ye/1UGqfoaECz72Hob+Z7EQvhcrnXzAOlI8sKDf/CEPSbxRlcR9AlBlPXLK6P3jZX69k//zdl4XWDYujdX2vyJDts+4znecfW837Ofi931IdLcN0vl12sM2NapZu/U79i21S2ygdBipATRoM4z0+ZwatIkGl3FXv4QxJyUJ8baKn7HGEBJwldWzMOVPPvB04KiwBHolctNr6jKj8WfyMl7xskLEfHMRAd0zYZtQ8/A0xrOArktka+WQJBt/HeSK0Iuk+koGZamPpyXZFSrlSLq8pTggMWfvMf4nn6tz5w4E5ad+nmhmLVvJJl3BRObMbtKmvPRfY2JNTCMS18Hjg3hXo/Pi2mKgJ3si0L324kESYKIxiO1g5pkiIJYDr+AHrDmgdza0YSTzFSFUaZjhxcYOobVcg2p4tCgqCC6l6pmBM6rpG75rut4fK8pEkutb6wSrK3GJafxgRimM+svpHVVdqW3P0Gg+CnEoTpD86N8/aqivpedtcRz0LQGGee2QKe+t4LNibLN2wyzD7E7sUkPYrCLZVW71yJouhVIX7hT9ga5kZwxvN6KtL0c4IO/Wl7avpg07QAAAAC4vGdlqgnIixK1r+6PYpdXN97wMiVrX9yd1zi5xbQo730IT4pvveBk1wGHAUrWv7jyatjd4N93M1hjEFZQGVef6KUw+voQnxRCrPhx33vAyGfHp611cghDzc5vJpWtf3AtERgVP6S3+4cY0J4az+gnonOPQrDGIKwIekfJoDKvPhiOyFsKO2e1socA0C9QOGmX7F8MhVnw4j3ll4dlhofR3TrgtM+PT1p3Myg/6uQQhlJYd+NA7dgN+FG/aPAr+KFIl5/EWiIwKuKeV09/SW/2x/UIk9VAp31t/MAYNZ/QTo0jtyuflhjFJyp/oLr9RxkCQSB8EPSPkqhI6PebFFg9I6g/WDEdkLaJoffTFHbPaqzKqA++fwfhBsNghF6gcNLmHBe39Km4WUwV3zzRwueFaX6A4HvLLw7Dd0hryw0PonOxaMdhBMcp2bigTERvmPX80/+Q7mZQflbaNxsOuSdNtgVAKKSw78YcDIijgduwGjln138r0niRk24f9Dsm9wODmpBmkS8/iCmTWO20RGBUDPgHMR5NqN+m8c+6/pLf7EYuuIlUmxdn7CdwAnHwSLvJTC/e2/mAMGNF51VrP6Cc04PH+cE2aBd5ig9y5F03y1zhUK5OVP9A9uiYJa6LiHMWN+8WBIJA+Lw+J50h6R8kmVV4QYvg168zXLDK7Vm2O1Xl0V5HUH6w/+wZ1WI7IWzah0YJyDLp53COjoIo7Z7UkFH5sYLkVl86WDE6p48Jgx8zbuYNhsEItTqmbb1A4aQF/IbBF0kpL6/1TkoyInbzip4Rlpgrvnggl9kdePTJS8BIri7S/QHAakFmpfeWXhxPKjl5XZ+Wl+Uj8fJNaxkF9dd+YOdi0Y5f3rbrwgmOUnq16TdoAEbZ0LwhvIjfMeowY1aPItb5YZpqngQHvaa9vwHB2K20bjYVCAlTHXJOmqXOKf+3e4YRD8fhdJIQ2c0qrL6oOBkRRoCldiPYxmZ1YHoBEHLPrv7Kc8mbV6TxIu8Ylkf9rTmpRRFezHZN7gbO8Ylj3EQmjWT4Qej5L3lRQZMeNFMmsdrrmta/s/nG6QtFoYwZ8A5ioUxpBzybUb6EJzbblpKZNS4u/lAmVLmZnuje/IxdcRI04RZ3qTYuzhGKSasDP+ZFu4OBIOPgkXZbXPYTSelZ/fFVPphsggYh1D5hRMaLzqp+N6nP1n9BOG7DJl18domzxMru1lkd1m/hobEK8xQe5EuoeYETy2nXq3cOsrnCoVwBfsY5nKn+gCQVmeU2oDYLjhxRboZmFqc+2nHCLG/eLJTTuUkJBIHwsbjmlaMNSXsbsS4eQ9I+SPtuWS3p2/bDUWeRpsywqR90DM56ZrlhlN4FBvEAAAAAAAAAAAMAAAAEAAQACAAEAAQAAAAEAAUAEAAIAAQAAAAEAAYAIAAgAAQAAAAEAAQAEAAQAAUAAAAIABAAIAAgAAUAAAAIABAAgACAAAUAAAAIACAAgAAAAQUAAAAgAIAAAgEABAUAAAAgAAIBAgEAEAUAQYHJAAu2EAECAwQEBQUGBgYGBwcHBwgICAgICAgICQkJCQkJCQkKCgoKCgoKCgoKCgoKCgoKCwsLCwsLCwsLCwsLCwsLCwwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDwAAEBESEhMTFBQUFBUVFRUWFhYWFhYWFhcXFxcXFxcXGBgYGBgYGBgYGBgYGBgYGBkZGRkZGRkZGRkZGRkZGRkaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHB0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0AAQIDBAUGBwgICQkKCgsLDAwMDA0NDQ0ODg4ODw8PDxAQEBAQEBAQERERERERERESEhISEhISEhMTExMTExMTFBQUFBQUFBQUFBQUFBQUFBUVFRUVFRUVFRUVFRUVFRUWFhYWFhYWFhYWFhYWFhYWFxcXFxcXFxcXFxcXFxcXFxgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxscwCcAAMAsAAABAQAAHgEAAA8AAABALAAAQC0AAAAAAAAeAAAADwAAAAAAAADALQAAAAAAABMAAAAHAAAAAAAAAAwACACMAAgATAAIAMwACAAsAAgArAAIAGwACADsAAgAHAAIAJwACABcAAgA3AAIADwACAC8AAgAfAAIAPwACAACAAgAggAIAEIACADCAAgAIgAIAKIACABiAAgA4gAIABIACACSAAgAUgAIANIACAAyAAgAsgAIAHIACADyAAgACgAIAIoACABKAAgAygAIACoACACqAAgAagAIAOoACAAaAAgAmgAIAFoACADaAAgAOgAIALoACAB6AAgA+gAIAAYACACGAAgARgAIAMYACAAmAAgApgAIAGYACADmAAgAFgAIAJYACABWAAgA1gAIADYACAC2AAgAdgAIAPYACAAOAAgAjgAIAE4ACADOAAgALgAIAK4ACABuAAgA7gAIAB4ACACeAAgAXgAIAN4ACAA+AAgAvgAIAH4ACAD+AAgAAQAIAIEACABBAAgAwQAIACEACAChAAgAYQAIAOEACAARAAgAkQAIAFEACADRAAgAMQAIALEACABxAAgA8QAIAAkACACJAAgASQAIAMkACAApAAgAqQAIAGkACADpAAgAGQAIAJkACABZAAgA2QAIADkACAC5AAgAeQAIAPkACAAFAAgAhQAIAEUACADFAAgAJQAIAKUACABlAAgA5QAIABUACACVAAgAVQAIANUACAA1AAgAtQAIAHUACAD1AAgADQAIAI0ACABNAAgAzQAIAC0ACACtAAgAbQAIAO0ACAAdAAgAnQAIAF0ACADdAAgAPQAIAL0ACAB9AAgA/QAIABMACQATAQkAkwAJAJMBCQBTAAkAUwEJANMACQDTAQkAMwAJADMBCQCzAAkAswEJAHMACQBzAQkA8wAJAPMBCQALAAkACwEJAIsACQCLAQkASwAJAEsBCQDLAAkAywEJACsACQArAQkAqwAJAKsBCQBrAAkAawEJAOsACQDrAQkAGwAJABsBCQCbAAkAmwEJAFsACQBbAQkA2wAJANsBCQA7AAkAOwEJALsACQC7AQkAewAJAHsBCQD7AAkA+wEJAAcACQAHAQkAhwAJAIcBCQBHAAkARwEJAMcACQDHAQkAJwAJACcBCQCnAAkApwEJAGcACQBnAQkA5wAJAOcBCQAXAAkAFwEJAJcACQCXAQkAVwAJAFcBCQDXAAkA1wEJADcACQA3AQkAtwAJALcBCQB3AAkAdwEJAPcACQD3AQkADwAJAA8BCQCPAAkAjwEJAE8ACQBPAQkAzwAJAM8BCQAvAAkALwEJAK8ACQCvAQkAbwAJAG8BCQDvAAkA7wEJAB8ACQAfAQkAnwAJAJ8BCQBfAAkAXwEJAN8ACQDfAQkAPwAJAD8BCQC/AAkAvwEJAH8ACQB/AQkA/wAJAP8BCQAAAAcAQAAHACAABwBgAAcAEAAHAFAABwAwAAcAcAAHAAgABwBIAAcAKAAHAGgABwAYAAcAWAAHADgABwB4AAcABAAHAEQABwAkAAcAZAAHABQABwBUAAcANAAHAHQABwADAAgAgwAIAEMACADDAAgAIwAIAKMACABjAAgA4wAIAAAABQAQAAUACAAFABgABQAEAAUAFAAFAAwABQAcAAUAAgAFABIABQAKAAUAGgAFAAYABQAWAAUADgAFAB4ABQABAAUAEQAFAAkABQAZAAUABQAFABUABQANAAUAHQAFAAMABQATAAUACwAFABsABQAHAAUAFwAFAEHg2QALTQEAAAABAAAAAQAAAAEAAAACAAAAAgAAAAIAAAACAAAAAwAAAAMAAAADAAAAAwAAAAQAAAAEAAAABAAAAAQAAAAFAAAABQAAAAUAAAAFAEHQ2gALZQEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAUAAAAGAAAABgAAAAcAAAAHAAAACAAAAAgAAAAJAAAACQAAAAoAAAAKAAAACwAAAAsAAAAMAAAADAAAAA0AAAANAEGA3AALIwIAAAADAAAABwAAAAAAAAAQERIACAcJBgoFCwQMAw0CDgEPAEG03AALaQEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAcAAAAIAAAACgAAAAwAAAAOAAAAEAAAABQAAAAYAAAAHAAAACAAAAAoAAAAMAAAADgAAABAAAAAUAAAAGAAAABwAAAAgAAAAKAAAADAAAAA4ABBtN0AC5oCAQAAAAIAAAADAAAABAAAAAYAAAAIAAAADAAAABAAAAAYAAAAIAAAADAAAABAAAAAYAAAAIAAAADAAAAAAAEAAIABAAAAAgAAAAMAAAAEAAAABgAAAAgAAAAMAAAAEAAAABgAAAAgAAAAMAAAAEAAAABgAABuZWVkIGRpY3Rpb25hcnkAc3RyZWFtIGVuZAAAZmlsZSBlcnJvcgBzdHJlYW0gZXJyb3IAZGF0YSBlcnJvcgBpbnN1ZmZpY2llbnQgbWVtb3J5AGJ1ZmZlciBlcnJvcgBpbmNvbXBhdGlibGUgdmVyc2lvbgAAAAAoLwAAOC8AAEMvAABELwAATy8AAFwvAABnLwAAey8AAIgvAABDLwAAMS4yLjExAEHQ3wALA9AxUA==");
      let VW, jW;
      async function GW() {
        if (VW)
          return VW;
        const e2 = {};
        let t2, r2 = {};
        for (t2 in e2)
          Object.prototype.hasOwnProperty.call(e2, t2) && (r2[t2] = e2[t2]);
        let i2 = false, n2 = false;
        i2 = typeof window == "object", n2 = typeof importScripts == "function", typeof process == "object" && typeof process.versions == "object" && process.versions.node;
        let o2 = "";
        (i2 || n2) && (n2 ? o2 = self.location.href : typeof document != "undefined" && document.currentScript && (o2 = document.currentScript.src), o2 = o2.indexOf("blob:") !== 0 ? o2.substr(0, o2.lastIndexOf("/") + 1) : ""), e2.print || console.log.bind(console);
        const s2 = e2.printErr || console.warn.bind(console);
        for (t2 in r2)
          Object.prototype.hasOwnProperty.call(r2, t2) && (e2[t2] = r2[t2]);
        let a2;
        r2 = null, e2.arguments, e2.thisProgram, e2.quit, e2.wasmBinary, e2.noExitRuntime, typeof WebAssembly != "object" && C2("no native wasm support detected");
        let c2 = false;
        function d2(t3) {
          const r3 = e2["_" + t3];
          var i3;
          return i3 = "Cannot call unknown function " + t3 + ", make sure it is exported", r3 || C2("Assertion failed: " + i3), r3;
        }
        function u2(e3, t3, r3, i3, n3) {
          const o3 = { string: function(e4) {
            let t4 = 0;
            if (e4 != null && e4 !== 0) {
              const r4 = 1 + (e4.length << 2);
              t4 = D2(r4), function(e5, t5, r5) {
                (function(e6, t6, r6, i4) {
                  if (!(i4 > 0))
                    return 0;
                  const n4 = r6, o4 = r6 + i4 - 1;
                  for (let i5 = 0; i5 < e6.length; ++i5) {
                    let n5 = e6.charCodeAt(i5);
                    if (n5 >= 55296 && n5 <= 57343) {
                      n5 = 65536 + ((1023 & n5) << 10) | 1023 & e6.charCodeAt(++i5);
                    }
                    if (n5 <= 127) {
                      if (r6 >= o4)
                        break;
                      t6[r6++] = n5;
                    } else if (n5 <= 2047) {
                      if (r6 + 1 >= o4)
                        break;
                      t6[r6++] = 192 | n5 >> 6, t6[r6++] = 128 | 63 & n5;
                    } else if (n5 <= 65535) {
                      if (r6 + 2 >= o4)
                        break;
                      t6[r6++] = 224 | n5 >> 12, t6[r6++] = 128 | n5 >> 6 & 63, t6[r6++] = 128 | 63 & n5;
                    } else {
                      if (r6 + 3 >= o4)
                        break;
                      t6[r6++] = 240 | n5 >> 18, t6[r6++] = 128 | n5 >> 12 & 63, t6[r6++] = 128 | n5 >> 6 & 63, t6[r6++] = 128 | 63 & n5;
                    }
                  }
                  t6[r6] = 0;
                })(e5, l2, t5, r5);
              }(e4, t4, r4);
            }
            return t4;
          }, array: function(e4) {
            const t4 = D2(e4.length);
            var r4, i4;
            return r4 = e4, i4 = t4, h2.set(r4, i4), t4;
          } };
          const s3 = d2(e3), a3 = [];
          let c3 = 0;
          if (i3)
            for (let e4 = 0; e4 < i3.length; e4++) {
              const t4 = o3[r3[e4]];
              t4 ? (c3 === 0 && (c3 = O2()), a3[e4] = t4(i3[e4])) : a3[e4] = i3[e4];
            }
          let u3 = s3.apply(null, a3);
          return u3 = function(e4) {
            return t3 === "string" ? (r4 = e4) ? function(e5, t4, r5) {
              const i5 = t4 + r5;
              let n4 = t4, o4 = "";
              for (; e5[n4] && !(n4 >= i5); )
                ++n4;
              if (n4 - t4 > 16 && e5.subarray && A2)
                return A2.decode(e5.subarray(t4, n4));
              for (; t4 < n4; ) {
                let r6 = e5[t4++];
                if (!(128 & r6)) {
                  o4 += String.fromCharCode(r6);
                  continue;
                }
                const i6 = 63 & e5[t4++];
                if ((224 & r6) == 192) {
                  o4 += String.fromCharCode((31 & r6) << 6 | i6);
                  continue;
                }
                const n5 = 63 & e5[t4++];
                if (r6 = (240 & r6) == 224 ? (15 & r6) << 12 | i6 << 6 | n5 : (7 & r6) << 18 | i6 << 12 | n5 << 6 | 63 & e5[t4++], r6 < 65536)
                  o4 += String.fromCharCode(r6);
                else {
                  const e6 = r6 - 65536;
                  o4 += String.fromCharCode(55296 | e6 >> 10, 56320 | 1023 & e6);
                }
              }
              return o4;
            }(l2, r4, i4) : "" : t3 === "boolean" ? Boolean(e4) : e4;
            var r4, i4;
          }(u3), c3 !== 0 && N2(c3), u3;
        }
        const A2 = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
        let h2, l2, p2;
        typeof TextDecoder != "undefined" && new TextDecoder("utf-16le"), e2.INITIAL_MEMORY;
        const g2 = [], f2 = [], E2 = [], I2 = [];
        f2.push({ func: function() {
          T2();
        } });
        let m2 = 0, _2 = null;
        function C2(t3) {
          e2.onAbort && e2.onAbort(t3), s2(t3 += ""), c2 = true, t3 = "abort(" + t3 + "). Build with -s ASSERTIONS=1 for more info.";
          throw new WebAssembly.RuntimeError(t3);
        }
        e2.preloadedImages = {}, e2.preloadedAudios = {};
        let v2 = "deflate.wasm";
        var S2;
        function R2(t3) {
          for (; t3.length > 0; ) {
            const r3 = t3.shift();
            if (typeof r3 == "function") {
              r3(e2);
              continue;
            }
            const i3 = r3.func;
            typeof i3 == "number" ? r3.arg === void 0 ? p2.get(i3)() : p2.get(i3)(r3.arg) : i3(r3.arg === void 0 ? null : r3.arg);
          }
        }
        S2 = "data:application/octet-stream;base64,", v2.startsWith(S2) || (v2 = function(t3) {
          return e2.locateFile ? e2.locateFile(t3, o2) : o2 + t3;
        }(v2));
        const y2 = { emscripten_memcpy_big: function(e3, t3, r3) {
          l2.copyWithin(e3, t3, t3 + r3);
        }, emscripten_resize_heap: function(e3) {
          C2("OOM");
        } };
        await async function() {
          const t3 = { env: y2, wasi_snapshot_preview1: y2 };
          function r3(t4, r4) {
            const i4 = t4.exports;
            var n4;
            e2.asm = i4, a2 = e2.asm.memory, n4 = a2.buffer, e2.HEAP8 = h2 = new Int8Array(n4), e2.HEAP16 = new Int16Array(n4), e2.HEAP32 = new Int32Array(n4), e2.HEAPU8 = l2 = new Uint8Array(n4), e2.HEAPU16 = new Uint16Array(n4), e2.HEAPU32 = new Uint32Array(n4), e2.HEAPF32 = new Float32Array(n4), e2.HEAPF64 = new Float64Array(n4), p2 = e2.asm.__indirect_function_table, function(t5) {
              if (m2--, e2.monitorRunDependencies && e2.monitorRunDependencies(m2), m2 == 0 && _2) {
                const e3 = _2;
                _2 = null, e3();
              }
            }();
          }
          function i3(e3) {
            r3(e3.instance);
          }
          function n3(e3) {
            return new nR((e4, t4) => {
              e4(FW().buffer);
            }).then(function(e4) {
              return WebAssembly.instantiate(e4, t3);
            }).then(e3, function(e4) {
              s2("failed to asynchronously prepare wasm: " + e4), C2(e4);
            });
          }
          if (m2++, e2.monitorRunDependencies && e2.monitorRunDependencies(m2), e2.instantiateWasm)
            try {
              return e2.instantiateWasm(t3, r3);
            } catch (e3) {
              return s2("Module.instantiateWasm callback failed with error: " + e3), false;
            }
          return await n3(i3), {};
        }();
        let T2 = e2.___wasm_call_ctors = function() {
          return (T2 = e2.___wasm_call_ctors = e2.asm.__wasm_call_ctors).apply(null, arguments);
        }, w2 = e2._malloc = function() {
          return (w2 = e2._malloc = e2.asm.malloc).apply(null, arguments);
        };
        e2._free = function() {
          return (e2._free = e2.asm.free).apply(null, arguments);
        }, e2.___errno_location = function() {
          return (e2.___errno_location = e2.asm.__errno_location).apply(null, arguments);
        }, e2._zlibCompress = function() {
          return (e2._zlibCompress = e2.asm.zlibCompress).apply(null, arguments);
        };
        let b2, O2 = e2.stackSave = function() {
          return (O2 = e2.stackSave = e2.asm.stackSave).apply(null, arguments);
        }, N2 = e2.stackRestore = function() {
          return (N2 = e2.stackRestore = e2.asm.stackRestore).apply(null, arguments);
        }, D2 = e2.stackAlloc = function() {
          return (D2 = e2.stackAlloc = e2.asm.stackAlloc).apply(null, arguments);
        };
        function L2(t3) {
          function r3() {
            b2 || (b2 = true, e2.calledRun = true, c2 || (R2(f2), R2(E2), e2.onRuntimeInitialized && e2.onRuntimeInitialized(), function() {
              if (e2.postRun)
                for (typeof e2.postRun == "function" && (e2.postRun = [e2.postRun]); e2.postRun.length; )
                  t4 = e2.postRun.shift(), I2.unshift(t4);
              var t4;
              R2(I2);
            }()));
          }
          m2 > 0 || (!function() {
            if (e2.preRun)
              for (typeof e2.preRun == "function" && (e2.preRun = [e2.preRun]); e2.preRun.length; )
                t4 = e2.preRun.shift(), g2.unshift(t4);
            var t4;
            R2(g2);
          }(), m2 > 0 || (e2.setStatus ? (e2.setStatus("Running..."), setTimeout(function() {
            setTimeout(function() {
              e2.setStatus("");
            }, 1), r3();
          }, 1)) : r3()));
        }
        if (e2.ccall = u2, e2.cwrap = function(e3, t3, r3, i3) {
          const n3 = (r3 = r3 || []).every(function(e4) {
            return e4 === "number";
          });
          return t3 !== "string" && n3 && !i3 ? d2(e3) : function() {
            return u2(e3, t3, r3, arguments);
          };
        }, e2.allocate = function(e3, t3) {
          let r3;
          return r3 = t3 == 1 ? D2(e3.length) : w2(e3.length), e3.subarray || e3.slice ? l2.set(e3, r3) : l2.set(new Uint8Array(e3), r3), r3;
        }, _2 = function e3() {
          b2 || L2(), b2 || (_2 = e3);
        }, e2.run = L2, e2.preInit)
          for (typeof e2.preInit == "function" && (e2.preInit = [e2.preInit]); e2.preInit.length > 0; )
            e2.preInit.pop()();
        return L2(), VW = e2, e2;
      }
      const KW = Uint8Array.BYTES_PER_ELEMENT;
      const HW = { bytesReceived: "br", frameDropped: "fd", frameReceived: "fr", googJitterReceived: "jr", isAudioMute: "am", isFreeze: "fz", mediaType: "mt", packetsLost: "pl", packetsReceived: "pr", peerId: "pid", id: "id", ssrc: "ssrc", timestamp: "ts", type: "tp", frameRateInput: "fi", frameRateSent: "fs", googRtt: "rt", isVideoMute: "vm" }, YW = { stats: "sts", state: "st", stream_id: "stid", session_id: "seid", stream_type: "stt", app_id: "aid", channel_key: "ck", channel_name: "cn", sdk_version: "sv", browser: "b", process_id: "pcid", mode: "m", codec: "c", role: "r", has_changed_gateway: "hcg", ap_response: "ar", extends: "es", details: "d", features: "ft", p2p_id: "ppid", sdp: "sdp", audio: "a", video: "v", attributes: "at", hq: "h", lq: "l", stereo: "str", speech: "spe", extend: "e", pingpongElapse: "ppe" }, WW = { _message: "m", _type: "t", _id: "id" }, JW = { join_v2: "j2", publish: "pub", publish_related_stats: "prs", ping: "pi", traffic_stats: "ts", ping_back: "pib", publish_stats: "pubs" };
      let qW;
      class zW {
        constructor() {
          kO(this, "zlibCompress", void 0);
        }
        async init() {
          if (!qW) {
            const e2 = await (async () => (jW || (jW = await GW()), { zlibCompress: (e3) => {
              const t2 = new Uint8Array(e3), r2 = KW * t2.byteLength, i2 = jW._malloc(r2), n2 = jW._malloc(3 * r2);
              for (let e4 = 0; e4 < r2; e4++)
                jW.HEAP8[i2 / KW + e4] = t2[e4];
              const o2 = jW._zlibCompress(i2, r2, n2), s2 = new Uint8Array(jW.HEAP8.slice(n2, n2 + o2));
              return jW._free(i2), jW._free(n2), s2;
            } }))();
            qW = e2.zlibCompress;
          }
          this.zlibCompress = qW;
        }
        msgPackCompress(e2) {
          return xW.exports.encode(e2);
        }
        compress(e2) {
          const t2 = Date.now(), r2 = this.compressKeyAndValue(JSON.parse(JSON.stringify(e2))), i2 = this.msgPackCompress(r2), n2 = this.zlibCompress(i2), o2 = new Uint8Array([49, 49, 49, 50, ...Array.from(n2)]);
          return { origin: Object.assign({}, e2), originLength: JSON.stringify(e2).length, shortKeyAndValue: r2, msgpackSer: i2, compressed: o2, compressedLength: o2.length, time: Date.now() - t2 };
        }
        compressKeyAndValue(e2) {
          return this._ObjectKeyCompress(this._typeCompress(e2));
        }
        _typeCompress(e2) {
          const t2 = e2._type;
          if (!t2)
            return e2;
          const r2 = JW[t2];
          return e2._type = r2 || t2, e2;
        }
        _ObjectKeyCompress(e2) {
          const t2 = e2._message;
          if (t2) {
            const r2 = t2.stats;
            r2 && (t2.stats = this._statsCompress(r2)), e2._message = this._messageCompress(t2);
          }
          return this._reportCompress(e2);
        }
        _statsCompress(e2) {
          return this._keyCompress(e2, HW);
        }
        _messageCompress(e2) {
          return this._keyCompress(e2, YW);
        }
        _reportCompress(e2) {
          return this._keyCompress(e2, WW);
        }
        _keyCompress(e2, t2) {
          const r2 = {}, i2 = Object.keys(e2);
          return vh(i2).call(i2, (i3, n2) => {
            const o2 = e2[n2];
            return t2[n2] ? r2[t2[n2]] = o2 : r2[n2] = o2, r2;
          }, r2), r2;
        }
      }
      class XW extends ZN {
        get queue() {
          return [...this.highPriorityQueue, ...this.lowPriorityQueue];
        }
        constructor(e2) {
          super(), kO(this, "lowPriorityQueue", []), kO(this, "highPriorityQueue", []), kO(this, "AgoraWebSocketManager", void 0), this.AgoraWebSocketManager = e2;
        }
        reset() {
          this.lowPriorityQueue = [], this.highPriorityQueue = [];
        }
        pushMessage(e2) {
          arguments.length > 1 && arguments[1] !== void 0 && arguments[1] ? this.highPriorityQueue.push(e2) : this.lowPriorityQueue.push(e2), this.sendMessage();
        }
        sendMessage() {
          const e2 = this.queue.length;
          let t2 = 0;
          t2 = e2 < 5 ? 15 * e2 : 60 + 3 * (e2 - 4), setTimeout(() => {
            this._sendMessage();
          }, t2);
        }
        _sendMessage() {
          if (!this.queue.length)
            return;
          const e2 = this.AgoraWebSocketManager.getConnection();
          if (!e2 || e2.readyState !== 1)
            return;
          const t2 = this.queue.shift();
          return this.lowPriorityQueue.includes(t2) ? this.lowPriorityQueue.shift() : this.highPriorityQueue.shift(), e2.send(t2.compressed), t2;
        }
      }
      var ZW;
      function $W(e2, t2) {
        var r2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          t2 && (i2 = i2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), r2.push.apply(r2, i2);
        }
        return r2;
      }
      let eJ = PD("AgoraWebSocketManager", "connectionID")(ZW = class extends ZN {
        get url() {
          return this.websocket ? this.websocket.url : null;
        }
        get reconnectMode() {
          return this._reconnectMode;
        }
        set reconnectMode(e2) {
          ["tryNext", "recover"].includes(e2) && this.resetReconnectCount(e2), this._reconnectMode = e2;
        }
        get state() {
          return this._state;
        }
        set state(e2) {
          e2 !== this._state && (this._state = e2, this._state === "reconnecting" ? this.emit(YP.RECONNECTING, this.reconnectReason) : this._state === "connected" ? this.emit(YP.CONNECTED) : this._state === "closed" ? this.emit(YP.CLOSED) : this._state === "failed" && this.emit(YP.FAILED));
        }
        resetReconnectCount(e2) {
          dD.debug("websocket reset reconnect count, reason: " + e2), ND("debug", this, "resetReconnectCount", e2, "websocket reset reconnect count, reason: " + e2), this.reconnectCount = 0;
        }
        constructor(e2, t2) {
          let r2 = arguments.length > 2 && arguments[2] !== void 0 && arguments[2], i2 = arguments.length > 3 && arguments[3] !== void 0 && arguments[3], n2 = arguments.length > 4 ? arguments[4] : void 0;
          super(), kO(this, "connectionID", 0), kO(this, "currentURLIndex", 0), kO(this, "urls", void 0), kO(this, "_reconnectMode", "tryNext"), kO(this, "reconnectReason", void 0), kO(this, "_initMutex", new kV("websocket")), kO(this, "name", void 0), kO(this, "_state", "closed"), kO(this, "reconnectInterrupter", void 0), kO(this, "websocket", void 0), kO(this, "retryConfig", void 0), kO(this, "reconnectCount", 0), kO(this, "onlineReconnectListener", void 0), kO(this, "compressor", new zW()), kO(this, "compressorInitStatus", "initializing"), kO(this, "compress", void 0), kO(this, "messageSender", void 0), kO(this, "useCompress", void 0), kO(this, "tryDoubleDomain", false), kO(this, "wsInflateLength", 0), kO(this, "wsDeflateLength", 0), kO(this, "closeEstablishingWs", () => {
          }), kO(this, "store", void 0), kO(this, "joinChannelServiceRecordIndex", void 0), this.store = n2, this.name = e2, this.retryConfig = function(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var r3 = arguments[t3] != null ? arguments[t3] : {};
              t3 % 2 ? $W(Object(r3), true).forEach(function(t4) {
                kO(e3, t4, r3[t4]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r3)) : $W(Object(r3)).forEach(function(t4) {
                Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r3, t4));
              });
            }
            return e3;
          }({}, t2), this.useCompress = r2, this.tryDoubleDomain = i2;
          const { timeout: o2, timeoutFactor: s2 } = t2, a2 = Math.max(300, Math.floor(3 * o2 / 5)), c2 = Math.max(1.2, Math.floor(8 * s2) / 10);
          Ok.ONLINE && (this.retryConfig.timeout = a2, this.retryConfig.timeoutFactor = c2), mV.on(Nk.NETWORK_STATE_CHANGE, (e3, t3) => {
            e3 !== t3 && (this.resetReconnectCount("network state change: ".concat(t3, " -> ").concat(e3)), e3 === Ok.ONLINE ? (this.retryConfig.timeout = a2, this.retryConfig.timeoutFactor = c2) : (this.retryConfig.timeout = o2, this.retryConfig.timeoutFactor = s2));
          });
          const d2 = Date.now();
          this.compressor.init().then(() => {
            this.compressorInitStatus = "initialized";
            const e3 = Date.now() - d2;
            dD.debug("websocket compressor initialized successfully in ".concat(e3, "ms")), ND("debug", this.compressor, "init", void 0, "websocket compressor initialized successfully in ".concat(e3, "ms")), bV.wsCompressorInit({ status: true, ec: null, eventElapse: e3 }), this.compress = this.compressor.compress.bind(this.compressor);
          }).catch((e3) => {
            this.compressorInitStatus = "failed";
            const t3 = e3 ? e3.message || e3.toString() : "Empty Error";
            dD.debug("websocket compressor failed to initialize because of ".concat(t3)), ND("debug", this.compressor, "init", void 0, "websocket compressor failed to initialize because of ".concat(t3)), bV.wsCompressorInit({ status: false, ec: t3, eventElapse: 1 });
          });
        }
        getConnection() {
          return this.websocket || void 0;
        }
        init(e2) {
          const t2 = (t3, r2) => {
            this.urls = e2;
            const i2 = this.urls[this.currentURLIndex];
            this.state = "connecting", this.messageSender = new XW(this), this.createWebSocketConnection(i2).then(t3).catch(r2), this.once(YP.CLOSED, () => r2(new tD(eD.WS_DISCONNECT))), this.once(YP.CONNECTED, () => t3());
          };
          return this._initMutex.lock().then((e3) => new nR((e4, r2) => {
            t2(e4, r2);
          }).then(() => {
            e3();
          }).catch(() => {
            e3();
          }));
        }
        close(e2, t2) {
          if (this.currentURLIndex = 0, this.resetReconnectCount("close"), this.reconnectInterrupter && this.reconnectInterrupter(), this.websocket) {
            this.websocket.onclose = null, this.websocket.onopen = null, this.websocket.onmessage = null;
            const e3 = this.websocket;
            t2 ? setTimeout(() => e3.close(), 500) : e3.close(), this.websocket = void 0;
          }
          this.state = e2 ? "failed" : "closed", this.closeEstablishingWs && this.closeEstablishingWs();
        }
        reconnect(e2, t2) {
          if (!this.websocket)
            return dD.warning("[".concat(this.name, "] can not reconnect, no websocket")), void ND("warning", this, "reconnect", "can not reconnect, no websocket");
          var r2;
          (e2 !== void 0 && (this.reconnectMode = e2), dD.debug("[".concat(this.name, "] reconnect is triggered initiative")), ND("debug", this, "reconnect"), typeof this.joinChannelServiceRecordIndex == "number") && ((r2 = this.store) === null || r2 === void 0 || r2.recordJoinChannelService({ status: "error", errors: [new Error(t2)] }, this.joinChannelServiceRecordIndex));
          const i2 = this.websocket.onclose;
          this.websocket.onclose = null, this.websocket.close(), i2 && i2.bind(this.websocket)({ code: 9999, reason: t2 });
        }
        sendMessageWithJSON(e2) {
          const t2 = JSON.stringify(e2);
          return { compressed: t2, compressedLength: t2.length, origin: e2 };
        }
        sendMessage(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
          if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN)
            throw new tD(eD.WS_ABORT, "websocket is not ready");
          try {
            let r2 = null;
            if (this.compressorInitStatus === "initialized" && this.useCompress && JD("WEBSOCKET_COMPRESS"))
              try {
                r2 = this.compress(e2), this.setWsInflateData(r2);
              } catch (t3) {
                r2 = this.sendMessageWithJSON(e2);
              }
            else
              r2 = this.sendMessageWithJSON(e2);
            t2 ? this.websocket.send(r2.compressed) : this.messageSender.pushMessage(r2);
          } catch (e3) {
            throw new tD(eD.WS_ERR, "send websocket message error" + e3.toString());
          }
        }
        setWsInflateData(e2) {
          this.wsDeflateLength = this.wsDeflateLength + e2.originLength, this.wsInflateLength = this.wsInflateLength + e2.compressedLength;
        }
        getWsInflateData() {
          const e2 = this.wsInflateLength, t2 = this.wsDeflateLength;
          return this.clearWsInflateData(), { wsInflateLength: e2, wsDeflateLength: t2 };
        }
        clearWsInflateData() {
          this.wsInflateLength = 0, this.wsDeflateLength = 0;
        }
        async createWebSocketConnection(e2, t2) {
          return this.connectionID += 1, this.connectionID, this.joinChannelServiceRecordIndex = void 0, new nR((r2, i2) => {
            var n2;
            const o2 = () => {
              dD.debug("[".concat(this.name, "] websocket opened:"), e2), OD("debug", ["WebSocket", this.connectionID], "open", e2), this.reconnectMode = "retry", this.state = "connected", this.resetReconnectCount("opened"), r2();
            }, s2 = async (e3) => {
              if (dD.debug("[".concat(this.name, "] websocket close ").concat(this.websocket && this.websocket.url, ", code: ").concat(e3.code, ", reason: ").concat(e3.reason, ", current mode: ").concat(this.reconnectMode)), OD("debug", ["WebSocket", this.connectionID], "close", { code: e3.code, reason: e3.reason, url: this.websocket && this.websocket.url, reconnectMode: this.reconnectMode }), this.reconnectCount < this.retryConfig.maxRetryCount) {
                this.state === "connected" && (this.reconnectReason = e3.reason, this.state = "reconnecting");
                const t3 = NG(this, YP.WILL_RECONNECT, this.reconnectMode) || this.reconnectMode, n3 = await this.reconnectWithAction(t3);
                if (this.state === "closed")
                  return dD.debug("[".concat(this.connectionID, "] ws is closed, no need to reconnect")), void TD("debug", this, "ws is closed, no need to reconnect");
                if (!n3)
                  return i2(new tD(eD.WS_DISCONNECT, "websocket reconnect failed: ".concat(e3.code))), void this.close(true);
                r2();
              } else
                i2(new tD(eD.WS_DISCONNECT, "websocket close: ".concat(e3.code))), this.close();
            }, a2 = (e3) => {
              this.emit(YP.ON_MESSAGE, e3);
            };
            this.websocket && (this.websocket.onclose = null, this.websocket.close()), JD("GATEWAY_WSS_ADDRESS") && this.name.startsWith("gateway") && (e2 = JD("GATEWAY_WSS_ADDRESS")), dD.debug("[".concat(this.name, "] start connect, url: ").concat(e2)), TD("debug", this, "start connect, url: ".concat(e2));
            const c2 = (n2 = this.store) === null || n2 === void 0 ? void 0 : n2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "gateway" });
            this.chooseBestWebsocketConnection(e2, !!t2, c2).then((e3) => {
              var t3;
              this.websocket = e3, o2 && o2(), e3.onclose = s2, e3.onmessage = a2, (t3 = this.store) === null || t3 === void 0 || t3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, c2), this.joinChannelServiceRecordIndex = c2;
            }).catch((e3) => {
              var t3;
              if ((t3 = this.store) === null || t3 === void 0 || t3.recordJoinChannelService({ endTs: Date.now(), status: e3 instanceof tD && e3.code === eD.WS_ABORT ? "aborted" : "error", errors: [e3] }, c2), this.state !== "closed") {
                if (e3 instanceof tD && e3.code === eD.WS_ERR) {
                  const t4 = new tD(eD.WS_ERR, "init websocket failed! Error: ".concat(e3.toString()));
                  return dD.error("[".concat(this.name, "]").concat(t4)), ND("error", this, "chooseBestWebsocketConnection", void 0, e3.toString()), void i2(t4);
                }
                s2 && s2(e3);
              } else
                i2(new tD(eD.WS_DISCONNECT, "websocket is closed: ".concat(e3.toString())));
            });
          });
        }
        async reconnectWithAction(e2) {
          let t2 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
          if (this.reconnectCount >= this.retryConfig.maxRetryCount)
            return false;
          if (!this.urls)
            return false;
          if (this.state === "closed")
            return false;
          this.onlineReconnectListener || mV.networkState !== Ok.OFFLINE || (this.onlineReconnectListener = mV.onlineWaiter && mV.onlineWaiter.then(() => {
            this.onlineReconnectListener = void 0;
          }));
          let r2 = true;
          if (this.reconnectInterrupter = () => {
            r2 = false;
          }, t2) {
            const t3 = iD(this.reconnectCount, this.retryConfig);
            dD.debug("[".concat(this.name, "] wait ").concat(t3, "ms to reconnect websocket, mode: ").concat(e2)), ND("debug", this, "reconnectWithAction", { timeout: t3, action: e2 }), await nR.race([CG(t3), this.onlineReconnectListener || new nR(() => {
            })]);
          }
          if (this.state === "closed" || !r2)
            return false;
          this.reconnectCount += 1;
          const i2 = async (e3, t3) => {
            this.emit(YP.RECONNECT_CREATE_CONNECTION, t3), await this.createWebSocketConnection(e3);
          };
          try {
            if (e2 === "retry") {
              const t3 = this.urls[this.currentURLIndex];
              this.emit(YP.RECONNECT_WAITTING_FINISH, e2), await i2(t3, e2);
            } else if (e2 === "tryNext") {
              if (this.currentURLIndex += 1, this.currentURLIndex >= this.urls.length)
                return await this.reconnectWithAction("recover", false);
              dD.debug("[".concat(this.name, "] websocket url length: ").concat(this.urls.length, " current index: ").concat(this.currentURLIndex)), TD("debug", this, "websocket url length: ".concat(this.urls.length, " current index: ").concat(this.currentURLIndex));
              const t3 = this.urls[this.currentURLIndex];
              this.emit(YP.RECONNECT_WAITTING_FINISH, e2), await i2(t3, e2);
            } else if (e2 === "recover") {
              dD.debug("[".concat(this.name, "] request new urls")), TD("debug", this, "request new urls"), this.resetReconnectCount("recover mode"), this.emit(YP.RECONNECT_WAITTING_FINISH, e2), this.urls = await bG(this, YP.REQUEST_NEW_URLS), this.currentURLIndex = 0;
              const t3 = this.urls[this.currentURLIndex];
              await i2(t3, e2);
            }
            return true;
          } catch (r3) {
            return dD.error("[".concat(this.name, "] reconnect failed"), r3.toString()), ND("error", this, "reconnectWithAction", void 0, r3.toString()), await this.reconnectWithAction(e2, t2);
          }
        }
        async chooseBestWebsocketConnection(e2, t2, r2) {
          return new nR((i2, n2) => {
            let o2 = false;
            const s2 = [];
            this.closeEstablishingWs = () => {
              dD.debug("[choose-best-ws] close establishing websockets"), s2.forEach((e3) => {
                e3.onclose = null, e3.onopen = null, e3.onmessage = null, e3.close();
              }), n2(new tD(eD.WS_ABORT, "choose best websocket aborted"));
            };
            const a2 = JD("GATEWAY_DOMAINS");
            let c2;
            const d2 = e2.indexOf("?h="), u2 = a2.find((t3) => d2 !== -1 ? e2.includes(t3, d2) : e2.includes(t3));
            dD.debug("[choose-best-ws] currentDomain: ", u2, ", domains: ", a2), ND("debug", this, "chooseBestWebsocketConnection", { currentDomain: u2, domains: a2 });
            let A2 = !this.tryDoubleDomain || t2 || !u2;
            if (!A2 && u2) {
              var h2;
              const t3 = Date.now();
              try {
                a2.forEach((t4) => {
                  const r3 = d2 === -1 ? e2.replace(u2, t4) : e2.substr(0, d2) + e2.substr(d2).replace(u2, t4), i3 = new WebSocket(r3);
                  i3.binaryType = "arraybuffer", s2.push(i3), dD.debug("[choose-best-ws] ws is connecting:", i3.url), TD("debug", this, "ws is connecting: ".concat(i3.url));
                });
              } catch (e3) {
                for (dD.debug("[choose-best-ws] ws create failed, fallback to single url"), TD("debug", this, "ws create failed, fallback to single url"), s2.forEach((e4) => e4.close()); s2.length; )
                  s2.pop();
                A2 = true;
              }
              (h2 = this.store) === null || h2 === void 0 || h2.recordJoinChannelService({ urls: s2.map((e3) => e3.url), service: "gateway" }, r2), s2.forEach((e3) => {
                e3.onopen = () => {
                  if (o2)
                    return;
                  const r3 = Date.now() - t3;
                  dD.debug("[choose-best-ws] ws open cost ".concat(r3, "ms")), s2.filter((t4) => t4 !== e3).forEach((e4) => {
                    dD.debug("[choose-best-ws]close backup websocket: ".concat(e4.url)), TD("debug", this, "close backup websocket: ".concat(e4.url)), e4.close();
                  }), o2 = true, i2(e3);
                }, e3.onclose = (e4) => {
                  if (c2 = e4, o2)
                    return;
                  s2.find((e5) => !(e5.readyState === WebSocket.CLOSED || e5.readyState === WebSocket.CLOSING)) || (dD.debug("[choose-best-ws] all websocket is closed"), TD("debug", this, "all websocket is closed"), o2 = true, n2(c2));
                }, e3.onmessage = (t4) => {
                  dD.debug("[choose-best-ws]".concat(e3.url, " onmessage: ").concat(t4.data)), TD("debug", this, "".concat(e3.url, " onmessage: ").concat(t4.data));
                };
              }), CG(5e3).then(() => {
                s2.forEach((e3) => {
                  e3.readyState !== WebSocket.OPEN && e3.close();
                });
              });
            }
            if (A2) {
              var l2;
              let t3;
              dD.debug("[choose-best-ws] use single url: ", e2), TD("debug", this, "use single url: ".concat(e2)), (l2 = this.store) === null || l2 === void 0 || l2.recordJoinChannelService({ urls: [e2], service: "gateway" }, r2);
              try {
                t3 = new WebSocket(e2), s2.push(t3), t3.binaryType = "arraybuffer";
              } catch (e3) {
                const t4 = new tD(eD.WS_ERR, "init websocket failed! Error: ".concat(e3.toString()));
                return dD.error("[".concat(this.name, "]").concat(t4)), ND("error", this, "chooseBestWebsocketConnection", void 0, e3.toString()), void n2(t4);
              }
              t3.onopen = () => {
                i2(t3);
              }, t3.onclose = (e3) => {
                n2(e3);
              }, t3.onmessage = (e3) => {
                dD.debug("[choose-best-ws]".concat(t3.url, " onmessage: ").concat(e3.data)), TD("debug", this, "".concat(t3.url, " onmessage: ").concat(e3.data));
              }, CG(5e3).then(() => {
                t3 && t3.readyState !== WebSocket.OPEN && t3.close();
              });
            }
          }).then((e3) => (this.closeEstablishingWs = void 0, e3)).catch((e3) => {
            throw this.closeEstablishingWs = void 0, e3;
          });
        }
      }) || ZW;
      class tJ {
        constructor(e2) {
          kO(this, "input", []), kO(this, "size", void 0), this.size = e2;
        }
        add(e2) {
          this.input.push(e2), this.input.length > this.size && this.input.splice(0, 1);
        }
        mean() {
          var e2;
          return this.input.length === 0 ? 0 : vh(e2 = this.input).call(e2, (e3, t2) => e3 + t2) / this.input.length;
        }
      }
      var rJ;
      let iJ = PD("AgoraRTCSignal", "websocket.connectionID")(rJ = class extends ZN {
        get connectionState() {
          return this._connectionState;
        }
        set connectionState(e2) {
          e2 !== this._connectionState && (this._connectionState = e2, e2 === OP.CONNECTED ? this.emit(NP.WS_CONNECTED) : e2 === OP.RECONNECTING ? this.emit(NP.WS_RECONNECTING, this._websocketReconnectReason) : e2 === OP.CLOSED && this.emit(NP.WS_CLOSED, this._disconnectedReason));
        }
        get currentURLIndex() {
          return this.websocket.currentURLIndex;
        }
        get url() {
          return this.websocket ? this.websocket.url : null;
        }
        get rtt() {
          return this.rttRolling.mean();
        }
        constructor(e2, t2) {
          super(), kO(this, "_disconnectedReason", void 0), kO(this, "_websocketReconnectReason", void 0), kO(this, "_connectionState", OP.CLOSED), kO(this, "reconnectToken", void 0), kO(this, "websocket", void 0), kO(this, "openConnectionTime", void 0), kO(this, "clientId", void 0), kO(this, "lastMsgTime", Date.now()), kO(this, "uploadCache", []), kO(this, "uploadCacheInterval", void 0), kO(this, "rttRolling", new tJ(5)), kO(this, "pingpongTimer", void 0), kO(this, "wsInflateDataTimer", void 0), kO(this, "pingpongTimeoutCount", 0), kO(this, "joinResponse", void 0), kO(this, "multiIpOption", void 0), kO(this, "initError", void 0), kO(this, "spec", void 0), kO(this, "store", void 0), kO(this, "onWebsocketMessage", (e3) => {
            if (e3.data instanceof ArrayBuffer)
              return void this.emit(NP.ON_BINARY_DATA, e3.data);
            const t3 = JSON.parse(e3.data);
            if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t3, "_id")) {
              const e4 = "res-@".concat(t3._id);
              this.emit(e4, t3._result, t3._message);
            } else if (Object.prototype.hasOwnProperty.call(t3, "_type") && (this.emit(t3._type, t3._message), t3._type === PP.ON_NOTIFICATION && this.handleNotification(t3._message), t3._type === PP.ON_USER_BANNED))
              switch (t3._message.error_code) {
                case 14:
                  this.close(TP.UID_BANNED);
                  break;
                case 15:
                  this.close(TP.IP_BANNED);
                  break;
                case 16:
                  this.close(TP.CHANNEL_BANNED);
              }
          }), this.clientId = e2.clientId, this.spec = e2, this.store = t2, this.websocket = new eJ("gateway-".concat(this.clientId), this.spec.retryConfig, true, true, t2), this.handleWebsocketEvents(), window.addEventListener("offline", () => {
            this.connectionState === OP.CONNECTED && this.reconnect("retry", bP.OFFLINE);
          });
        }
        async request(e2, t2, r2, i2) {
          const n2 = SG(6, ""), o2 = { _id: n2, _type: e2, _message: t2 }, s2 = this.websocket.connectionID, a2 = () => new nR((t3, r3) => {
            if (this.connectionState === OP.CONNECTED)
              return t3();
            const i3 = () => {
              this.off(NP.WS_CLOSED, n3), t3();
            }, n3 = () => {
              this.off(NP.WS_CONNECTED, i3), r3(new tD(eD.WS_ABORT));
            };
            this.once(NP.WS_CONNECTED, i3), this.once(NP.WS_CLOSED, n3), e2 !== DP.PUBLISH && e2 !== DP.SUBSCRIBE && e2 !== DP.UNSUBSCRIBE && e2 !== DP.UNPUBLISH && e2 !== DP.CONTROL || this.once(NP.DISCONNECT_P2P, () => {
              r3(new tD(eD.DISCONNECT_P2P));
            }), e2 === DP.PUBLISH && this.once(NP.ABORT_P2P_EXECUTION, () => {
              r3(new tD(eD.DISCONNECT_P2P));
            });
          });
          if (this.connectionState !== OP.CONNECTING && this.connectionState !== OP.RECONNECTING || e2 === DP.JOIN || e2 === DP.REJOIN || await a2(), this.websocket.sendMessage(o2, true), i2)
            return;
          const c2 = new nR((r3, i3) => {
            let o3 = false;
            const a3 = (i4, n3) => {
              o3 = true, r3({ isSuccess: i4 === "success", message: n3 || {} }), this.off(NP.WS_CLOSED, c3), this.off(NP.WS_RECONNECTING, c3), this.emit(NP.REQUEST_SUCCESS, e2, t2);
            };
            this.once("res-@".concat(n2), a3);
            const c3 = () => {
              i3(new tD(eD.WS_ABORT, "type: ".concat(e2))), this.off(NP.WS_CLOSED, c3), this.off(NP.WS_RECONNECTING, c3), this.off("res-@".concat(n2), a3);
            };
            this.once(NP.WS_CLOSED, c3), this.once(NP.WS_RECONNECTING, c3), CG(JD("SIGNAL_REQUEST_TIMEOUT")).then(() => {
              this.websocket.connectionID !== s2 || o3 || (dD.warning("ws request timeout, type: ".concat(e2)), TD("warning", this, "ws request timeout, type: ".concat(e2)), this.emit(NP.REQUEST_TIMEOUT, e2, t2));
            });
          });
          let d2 = null;
          try {
            d2 = await c2;
          } catch (i3) {
            if (this.connectionState === OP.CLOSED || e2 === DP.LEAVE)
              throw new tD(eD.WS_ABORT);
            return !this.spec.forceWaitGatewayResponse || r2 ? i3.throw() : e2 === DP.JOIN || e2 === DP.REJOIN ? null : (await a2(), await this.request(e2, t2));
          }
          if (d2.isSuccess)
            return d2.message;
          const u2 = Number(d2.message.error_code || d2.message.code), A2 = QW(u2), h2 = new tD(eD.UNEXPECTED_RESPONSE, "".concat(A2.desc, ": ").concat(d2.message.error_str), { code: u2, data: d2.message });
          return A2.action === "success" ? d2.message : (dD.warning("[".concat(this.websocket.connectionID, "] unexpected response from type ").concat(e2, ", error_code: ").concat(u2, ", message: ").concat(A2.desc, ", action: ").concat(A2.action)), TD("warning", this, "unexpected response from type ".concat(e2, ", error_code: ").concat(u2, ", message: ").concat(A2.desc, ", action: ").concat(A2.action)), u2 === RP.ERR_TOO_MANY_BROADCASTERS ? e2 === DP.JOIN || e2 === DP.REJOIN ? (this.initError = h2, this.close(), h2.throw()) : h2.throw() : A2.action === "failed" ? h2.throw() : A2.action === "quit" ? (this.initError = h2, this.close(), h2.throw()) : (u2 === RP.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d2.message.option, dD.warning("[".concat(this.clientId, "] detect multi ip, recover")), TD("warning", this, "detect multi ip, recover"), this.reconnect("recover", bP.MULTI_IP)) : this.reconnect(A2.action, bP.SERVER_ERROR), e2 === DP.JOIN || e2 === DP.REJOIN ? null : await this.request(e2, t2)));
        }
        waitMessage(e2, t2) {
          return new nR((r2) => {
            const i2 = (n2) => {
              (!t2 || t2(n2)) && (this.off(e2, i2), r2(n2));
            };
            this.on(e2, i2);
          });
        }
        upload(e2, t2) {
          const r2 = { _type: e2, _message: t2 };
          try {
            this.websocket.sendMessage(r2);
          } catch (e3) {
            const t3 = JD("MAX_UPLOAD_CACHE") || 50;
            this.uploadCache.push(r2), this.uploadCache.length > t3 && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {
              if (this.connectionState !== OP.CONNECTED)
                return;
              const e4 = this.uploadCache.splice(0, 1)[0];
              this.uploadCache.length === 0 && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e4._type, e4._message);
            }, JD("UPLOAD_CACHE_INTERVAL") || 2e3));
          }
        }
        send(e2, t2) {
          const r2 = { _type: e2, _message: t2 };
          this.websocket.sendMessage(r2);
        }
        init(e2, t2) {
          return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new nR((r2, i2) => {
            this.once(NP.WS_CONNECTED, () => r2(this.joinResponse)), this.once(NP.WS_CLOSED, () => i2(this.initError || new tD(eD.WS_ABORT))), this.connectionState = OP.CONNECTING, this.websocket.init(e2).catch(i2), this.wsInflateDataTimer && window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = window.setInterval(() => {
              this.handleWsInflateData();
            }, 2e4), setTimeout(() => {
              t2 && this.openConnectionTime === void 0 && (dD.debug("[".concat(this.clientId, "] init websocket timeout while join with fallback to proxy")), i2(new tD(eD.INIT_WEBSOCKET_TIMEOUT)));
            }, JD("JOIN_WITH_FALLBACK_PROXY_PENDING_DURATION"));
          });
        }
        close(e2) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.wsInflateDataTimer && (this.handleWsInflateData(), window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e2 || TP.LEAVE, this.connectionState = OP.CLOSED, dD.debug("[".concat(this.clientId, "] ") + "will close websocket in signal"), this.websocket.close(), e2 === TP.FALLBACK && (this.websocket.removeAllListeners(), this.websocket = new eJ("gateway-".concat(this.clientId), this.spec.retryConfig, true, true, this.store), this.handleWebsocketEvents());
        }
        async join() {
          if (!this.joinResponse) {
            this.emit(NP.ABORT_P2P_EXECUTION);
            const e2 = await bG(this, NP.REQUEST_JOIN_INFO), t2 = await this.request(DP.JOIN, e2);
            if (!t2)
              return this.emit(NP.REPORT_JOIN_GATEWAY, eD.TIMEOUT, this.url || ""), false;
            this.joinResponse = t2, this.emit(NP.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;
          }
          return this.connectionState = OP.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), true;
        }
        async rejoin() {
          if (!this.reconnectToken)
            throw new tD(eD.UNEXPECTED_ERROR, "can not rejoin, no rejoin token");
          const e2 = DG(this, NP.REQUEST_REJOIN_INFO);
          e2.token = this.reconnectToken;
          const t2 = await this.request(DP.REJOIN, e2);
          return !!t2 && (this.connectionState = OP.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), t2.peers && t2.peers.forEach((e3) => {
            this.emit(PP.ON_USER_ONLINE, { uid: e3.uid }), e3.audio_mute ? this.emit(PP.MUTE_AUDIO, { uid: e3.uid }) : this.emit(PP.UNMUTE_AUDIO, { uid: e3.uid }), e3.video_mute ? this.emit(PP.MUTE_VIDEO, { uid: e3.uid }) : this.emit(PP.UNMUTE_VIDEO, { uid: e3.uid }), e3.audio_enable_local ? this.emit(PP.ENABLE_LOCAL_AUDIO, { uid: e3.uid }) : this.emit(PP.DISABLE_LOCAL_AUDIO, { uid: e3.uid }), e3.video_enable_local ? this.emit(PP.ENABLE_LOCAL_VIDEO, { uid: e3.uid }) : this.emit(PP.DISABLE_LOCAL_VIDEO, { uid: e3.uid }), e3.audio || e3.video || this.emit(PP.ON_REMOVE_STREAM, { uid: e3.uid, uint_id: e3.uint_id }), e3.audio && this.emit(PP.ON_ADD_AUDIO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, audio: true, ssrcId: e3.audio_ssrc }), e3.video && this.emit(PP.ON_ADD_VIDEO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, video: true, ssrcId: e3.video_ssrc });
          }), true);
        }
        reconnect(e2, t2) {
          this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e2, t2);
        }
        handleNotification(e2) {
          dD.debug("[".concat(this.clientId, "] receive notification: "), e2), ND("debug", this, "handleNotification", e2);
          const t2 = QW(e2.code);
          if (t2.action !== "success")
            return t2.action === "failed" ? (dD.error("[".concat(this.clientId, "] ignore error: "), t2.desc), void TD("error", this, "ignore error: ".concat(t2.desc))) : t2.action === "quit" ? (t2.desc === "ERR_REPEAT_JOIN_CHANNEL" && this.close(TP.UID_BANNED), void this.close()) : void this.reconnect(t2.action, bP.SERVER_ERROR);
        }
        handlePingPong() {
          if (!this.websocket || this.websocket.state !== "connected")
            return;
          this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;
          const e2 = JD("PING_PONG_TIME_OUT"), t2 = Date.now();
          this.pingpongTimeoutCount >= e2 && (dD.warning("PINGPONG Timeout. Last Socket Message: ".concat(t2 - this.lastMsgTime, "ms")), TD("warning", this, "PINGPONG Timeout. Last Socket Message: ".concat(t2 - this.lastMsgTime, "ms")), t2 - this.lastMsgTime > JD("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", bP.TIMEOUT) : this.request(DP.PING, void 0, true).then(() => {
            this.pingpongTimeoutCount = 0;
            const e3 = Date.now() - t2;
            this.rttRolling.add(e3), JD("REPORT_STATS") && this.send(DP.PING_BACK, { pingpongElapse: e3 });
          }).catch((e3) => {
          });
        }
        handleWsInflateData() {
          const { wsInflateLength: e2, wsDeflateLength: t2 } = this.websocket.getWsInflateData();
          e2 !== 0 && t2 !== 0 && this.upload(LP.WS_INFLATE_DATA_LENGTH, { ws_deflate_length: t2, ws_inflate_length: e2 });
        }
        handleWebsocketEvents() {
          this.websocket.on(YP.RECONNECT_WAITTING_FINISH, (e2) => {
            this.emit(NP.WS_RECONNECT_WAITTING_FINISH, e2);
          }), this.websocket.on(YP.RECONNECT_CREATE_CONNECTION, (e2) => {
            this.emit(NP.WS_RECONNECT_CREATE_CONNECTION, e2);
          }), this.websocket.on(YP.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(YP.CLOSED, () => {
            this.connectionState = OP.CLOSED;
          }), this.websocket.on(YP.FAILED, () => {
            this._disconnectedReason = TP.NETWORK_ERROR, this.connectionState = OP.CLOSED;
          }), this.websocket.on(YP.RECONNECTING, (e2) => {
            this._websocketReconnectReason = e2, this.joinResponse = void 0, this.connectionState === OP.CONNECTED ? this.connectionState = OP.RECONNECTING : this.connectionState = OP.CONNECTING;
          }), this.websocket.on(YP.WILL_RECONNECT, (e2, t2) => {
            if (DG(this, NP.IS_P2P_DISCONNECTED) && e2 === "retry")
              return dD.debug("".concat(this.clientId, " reconnect mode is retry, but p2p lost, change to tryNext")), TD("debug", this, "".concat(this.clientId, " reconnect mode is retry, but p2p lost, change to tryNext")), this.reconnectToken = void 0, this.emit(NP.NEED_RENEW_SESSION), this.emit(NP.DISCONNECT_P2P), t2("tryNext");
            e2 !== "retry" && (dD.debug("".concat(this.clientId, " websockt will_connect event, renewSession reconnectMode is ").concat(e2)), TD("debug", this, "".concat(this.clientId, " websockt will_connect event, renewSession reconnectMode is ").concat(e2)), this.reconnectToken = void 0, this.emit(NP.NEED_RENEW_SESSION), this.emit(NP.DISCONNECT_P2P)), t2(e2);
          }), this.websocket.on(YP.CONNECTED, () => {
            this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch((e2) => {
              dD.warning("[".concat(this.clientId, "] rejoin failed ").concat(e2)), ND("warning", this, "rejoin", void 0, e2.toString()), this.reconnect("tryNext", bP.SERVER_ERROR);
            }) : this.join().catch((e2) => {
              if (this.emit(NP.REPORT_JOIN_GATEWAY, e2.message || e2.code, this.url || ""), e2 instanceof tD && e2.code === eD.UNEXPECTED_RESPONSE && e2.data.code === RP.ERR_NO_AUTHORIZED)
                return dD.warning("[".concat(this.clientId, "] reconnect no authorized, recover")), TD("warning", this, "reconnect no authorized, recover"), void this.reconnect("recover", bP.SERVER_ERROR);
              dD.error("[".concat(this.clientId, "] join gateway request failed"), e2.toString()), ND("error", this, "join", void 0, e2.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", bP.SERVER_ERROR) : (this.initError = e2, this.close());
            });
          }), this.websocket.on(YP.REQUEST_NEW_URLS, (e2, t2) => {
            bG(this, NP.REQUEST_RECOVER, this.multiIpOption).then(e2).catch(t2);
          });
        }
      }) || rJ;
      var nJ;
      function oJ(e2, t2) {
        var r2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          t2 && (i2 = i2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), r2.push.apply(r2, i2);
        }
        return r2;
      }
      function sJ(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r2 = arguments[t2] != null ? arguments[t2] : {};
          t2 % 2 ? oJ(Object(r2), true).forEach(function(t3) {
            kO(e2, t3, r2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : oJ(Object(r2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
          });
        }
        return e2;
      }
      const aJ = /* @__PURE__ */ new Map();
      let cJ = PD("AgoraRTCGateway", "store.clientId")(nJ = class extends ZN {
        get state() {
          return this._state;
        }
        set state(e2) {
          if (e2 === this._state)
            return;
          const t2 = this._state;
          this._state = e2, e2 === "DISCONNECTED" && this._disconnectedReason ? this.emit(dk.CONNECTION_STATE_CHANGE, e2, t2, this._disconnectedReason) : this.emit(dk.CONNECTION_STATE_CHANGE, e2, t2);
        }
        get joinGatewayStartTime() {
          return this._joinGatewayStartTime;
        }
        set joinGatewayStartTime(e2) {
          dD.debug("[".concat(this.store.clientId, "] set joinGatewayStartTime at ").concat(e2)), ND("debug", this, "joinGatewayStartTime", e2, "[".concat(this.store.clientId, "] set joinGatewayStartTime at ").concat(e2)), this._joinGatewayStartTime = e2;
        }
        constructor(e2, t2) {
          super(), kO(this, "store", void 0), kO(this, "joinInfo", void 0), kO(this, "key", void 0), kO(this, "signal", void 0), kO(this, "role", void 0), kO(this, "inChannelInfo", { joinAt: null, duration: 0 }), kO(this, "spec", void 0), kO(this, "_state", "DISCONNECTED"), kO(this, "_statsCollector", void 0), kO(this, "_disconnectedReason", void 0), kO(this, "isSignalRecover", false), kO(this, "hasChangeBGPAddress", false), kO(this, "trafficStatsInterval", void 0), kO(this, "networkQualityInterval", void 0), kO(this, "_joinGatewayStartTime", 0), kO(this, "_signalTimeout", false), kO(this, "_clientRoleOptions", void 0), kO(this, "_isProactiveJoin", false), this.store = e2, this.spec = t2, this.signal = new iJ(sJ(sJ({}, t2), {}, { retryConfig: t2.websocketRetryConfig }), e2), this._statsCollector = t2.statsCollector, this.role = t2.role || "audience", this._clientRoleOptions = t2.clientRoleOptions, this.handleSignalEvents();
        }
        async join(e2, t2, r2) {
          this.store.joinGatewayStart(), e2.cloudProxyServer !== "disabled" && (this.hasChangeBGPAddress = true);
          const i2 = Date.now();
          let n2 = aJ.get(e2.cname);
          if (n2 || (n2 = /* @__PURE__ */ new Map(), aJ.set(e2.cname, n2)), this._isProactiveJoin = true, n2.has(e2.uid)) {
            const t3 = new tD(eD.UID_CONFLICT);
            throw bV.joinGateway(e2.sid, { lts: i2, succ: false, ec: t3.message, addr: null, uid: e2.uid, cid: e2.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!e2.proxyServer }), this._isProactiveJoin = false, t3;
          }
          n2.set(e2.uid, true), this.joinInfo = e2, this.key = t2;
          const o2 = e2.proxyServer, s2 = o2 ? e2.gatewayAddrs.map((e3) => {
            const t3 = e3.address.split(":");
            return "wss://".concat(o2, "/ws/?h=").concat(t3[0], "&p=").concat(t3[1]);
          }) : e2.gatewayAddrs.map((e3) => "wss://".concat(e3.address));
          let a2 = 0;
          this.joinGatewayStartTime = i2;
          try {
            a2 = (await this.signal.init(s2, r2)).uid;
          } catch (t3) {
            if (t3 && t3.code === eD.INIT_WEBSOCKET_TIMEOUT)
              throw dD.warning("[".concat(this.store.clientId, "] User join failed"), t3.toString()), t3;
            throw dD.error("[".concat(this.store.clientId, "] User join failed"), t3.toString()), ND("error", this, "join", void 0, t3.toString()), bV.joinGateway(e2.sid, { lts: i2, succ: false, ec: t3.message, addr: this.signal.url, uid: e2.uid, cid: e2.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!o2 }), this._isProactiveJoin = false, n2.delete(e2.uid), this.signal.close(), t3;
          }
          return this.state = "CONNECTED", this.inChannelInfo.joinAt = Date.now(), dD.debug("[".concat(this.store.clientId, "] Connected to gateway server")), ND("debug", this, "join", void 0, "success"), this.trafficStatsInterval = window.setInterval(() => {
            this.updateTrafficStats().catch((e3) => {
              dD.warning("[".concat(this.store.clientId, "] get traffic stats error"), e3.toString()), ND("warning", this, "trafficStatsInterval", void 0, e3.toString());
            });
          }, 3e3), this.networkQualityInterval = window.setInterval(() => {
            navigator && navigator.onLine !== void 0 && !navigator.onLine ? this.emit(dk.NETWORK_QUALITY, { downlinkNetworkQuality: 6, uplinkNetworkQuality: 6 }) : this._signalTimeout ? this.emit(dk.NETWORK_QUALITY, { downlinkNetworkQuality: 5, uplinkNetworkQuality: 5 }) : this.state === "CONNECTED" && this._statsCollector.trafficStats ? this.emit(dk.NETWORK_QUALITY, { uplinkNetworkQuality: lG(this._statsCollector.trafficStats.B_unq), downlinkNetworkQuality: lG(this._statsCollector.trafficStats.B_dnq) }) : this.emit(dk.NETWORK_QUALITY, { uplinkNetworkQuality: 0, downlinkNetworkQuality: 0 });
          }, 2e3), this.store.joinGatewayEnd(), a2;
        }
        async leave() {
          let e2 = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], t2 = arguments.length > 1 ? arguments[1] : void 0;
          if (this.state !== "DISCONNECTED") {
            t2 !== TP.FALLBACK && (this.state = "DISCONNECTING");
            try {
              e2 || this.signal.connectionState !== OP.CONNECTED || await function(e3, t3) {
                return t3 === 1 / 0 ? e3 : nR.race([e3, vG(t3)]);
              }(this.signal.request(DP.LEAVE, void 0, true), 3e3);
            } catch (e3) {
              dD.warning("[".concat(this.store.clientId, "] leave request failed, ignore"), e3), TD("warning", this, "leave request failed, ignore, ".concat(e3.toString()));
            }
            this.signal.close(t2), t2 !== TP.FALLBACK && (this.state = "DISCONNECTED"), this.reset();
          }
        }
        async publish(e2, t2, r2) {
          if (this.state !== "CONNECTED" && this.state !== "RECONNECTING")
            throw new tD(eD.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
          const i2 = { state: "offer", p2p_id: this.store.p2pId, ortc: t2, mode: this.spec.mode, extend: JD("PUB_EXTEND") };
          try {
            return (await this.signal.request(DP.PUBLISH, i2, true))._message;
          } catch (i3) {
            if (r2 && i3.data && i3.data.code === RP.ERR_PUBLISH_REQUEST_INVALID)
              return dD.warning("[".concat(this.store.clientId, "] receive publish error code, retry"), i3.toString()), TD("warning", this, "receive publish error code, retry, ".concat(i3.toString())), await this.tryUnpubBeforeRepub(e2, t2), this.publish(e2, t2, false);
            throw i3;
          }
        }
        async unpublish(e2, t2) {
          try {
            if (this.state !== "CONNECTED" && this.state !== "RECONNECTING")
              throw new tD(eD.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
            await this.signal.request(DP.UNPUBLISH, { stream_id: t2, ortc: e2 }, true);
          } catch (e3) {
            dD.warning("unpublish warning: ", e3), ND("warning", this, "unpublish", void 0, e3.toString());
          }
        }
        async subscribe(e2, t2, r2) {
          if (this.state !== "CONNECTED" && this.state !== "RECONNECTING")
            throw new tD(eD.INVALID_OPERATION, "can not subscribe when connection state is ".concat(this.state));
          const i2 = { stream_id: e2, stream_type: t2.stream_type, mode: this.spec.mode, codec: this.spec.codec, p2p_id: this.store.p2pId, tcc: !!JD("SUBSCRIBE_TCC"), extend: JD("SUB_EXTEND"), ssrcId: t2.ssrcId };
          try {
            return (await this.signal.request(DP.SUBSCRIBE, i2, true))._message;
          } catch (i3) {
            if (r2 && i3.data && i3.data.code === RP.ERR_SUBSCRIBE_REQUEST_INVALID)
              return dD.warning("[".concat(this.store.clientId, "] receiver subscribe error code, retry"), i3.toString()), TD("warning", this, "receiver subscribe error code, retry"), await this.tryUnsubBeforeResub(e2, t2), await this.subscribe(e2, t2, false);
            throw i3;
          }
        }
        async subscribeAll(e2, t2) {
          if (this.state !== "CONNECTED" && this.state !== "RECONNECTING")
            throw new tD(eD.INVALID_OPERATION, "can not massSubscribe when connection state is ".concat(this.state));
          const r2 = { p2p_id: this.store.p2pId, users: e2, dtx: false };
          try {
            return await this.signal.request(DP.SUBSCRIBE_STREAMS, r2, true);
          } catch (r3) {
            if (t2 && r3.data && r3.data.code === RP.ERR_SUBSCRIBE_REQUEST_INVALID)
              return dD.warning("[".concat(this.store.clientId, "] receiver massSubscribe error code, retry"), r3.toString()), TD("warning", this, "receiver massSubscribe error code, retry"), await this.tryMassUnsubBeforeResub(e2), await this.subscribeAll(e2, false);
            throw r3;
          }
        }
        async setVideoProfile(e2) {
          const t2 = function(e3) {
            if (!(e3.bitrateMax && e3.bitrateMin && e3.frameRate && e3.height && e3.width))
              return;
            let t3 = e3.frameRate, r2 = e3.width, i2 = e3.height, n2 = true;
            return typeof t3 != "number" && (t3 = t3.exact || t3.ideal || t3.max || t3.min || 0, t3 || (n2 = false)), typeof r2 != "number" && (r2 = r2.exact || r2.ideal || r2.max || r2.min || 0, r2 || (n2 = false)), typeof i2 != "number" && (i2 = i2.exact || i2.ideal || i2.max || i2.min || 0, t3 || (n2 = false)), n2 ? { stream_type: 0, width: r2, height: i2, fps: t3, start_bps: 1e3 * e3.bitrateMax, min_bps: 1e3 * e3.bitrateMin, target_bps: 1e3 * e3.bitrateMax } : void 0;
          }(e2);
          return t2 ? this.signal.request(DP.SET_VIDEO_PROFILE, t2) : (dD.debug("[".concat(this.store.clientId, "] encoder config is not complete, do not report to gateway")), void TD("debug", this, "encoder config is not complete, do not report to gateway"));
        }
        async unsubscribe(e2, t2) {
          try {
            await this.signal.request(DP.UNSUBSCRIBE, { p2p_id: this.store.p2pId, ortc: e2, stream_id: t2 }, true);
          } catch (e3) {
            dD.warning("unsubscribe warning: ", e3), ND("warning", this, "unsubscribe", void 0, e3.toString());
          }
        }
        async massUnsubscribe(e2) {
          try {
            await this.signal.request(DP.UNSUBSCRIBE_STREAMS, e2, true);
          } catch (e3) {
            dD.warning("unsubscribeAll warning: ", e3), ND("warning", this, "unsubscribeAll", void 0, e3.toString());
          }
        }
        async reconnectPC(e2) {
          const { iceParameters: t2, dtlsParameters: r2, rtpCapabilities: i2 } = e2, n2 = await this.signal.request(DP.CONNECT_PC, { p2p_id: this.store.p2pId, stream_id: this.store.uid, ortc: { iceParameters: t2, dtlsParameters: r2, rtpCapabilities: i2 } }, true), o2 = this.getGatewayIpPort();
          return { gatewayEstablishParams: n2, gatewayIP: o2 == null ? void 0 : o2.ip, gatewayPort: o2 == null ? void 0 : o2.port };
        }
        getGatewayInfo() {
          return this.signal.request(DP.GATEWAY_INFO);
        }
        renewToken(e2) {
          return this.signal.request(DP.RENEW_TOKEN, e2);
        }
        async setClientRole(e2, t2) {
          if (t2 && (this._clientRoleOptions = Object.assign({}, t2)), this.state !== "CONNECTED")
            return void (this.role = e2);
          let r2 = void 0;
          r2 = e2 === "audience" ? this._clientRoleOptions && this._clientRoleOptions.level ? this._clientRoleOptions.level : 2 : 0, await this.signal.request(DP.SET_CLIENT_ROLE, { role: e2, level: r2 }), this.role = e2;
        }
        async setRemoteVideoStreamType(e2, t2) {
          await this.signal.request(DP.SWITCH_VIDEO_STREAM, { stream_id: e2, stream_type: t2 });
        }
        async setDefaultRemoteVideoStreamType(e2) {
          await this.signal.request(DP.DEFAULT_VIDEO_STREAM, { stream_type: e2 });
        }
        async setStreamFallbackOption(e2, t2) {
          await this.signal.request(DP.SET_FALLBACK_OPTION, { stream_id: e2, fallback_type: t2 });
        }
        async pickSVCLayer(e2, t2) {
          await this.signal.request(DP.PICK_SVC_LAYER, { stream_id: e2, spatial_layer: t2.spatialLayer, temporal_layer: t2.temporalLayer });
        }
        getInChannelInfo() {
          return this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt), sJ({}, this.inChannelInfo);
        }
        async getGatewayVersion() {
          return (await this.signal.request(DP.GATEWAY_INFO)).version;
        }
        reset() {
          if (this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt, this.inChannelInfo.joinAt = null), this.trafficStatsInterval && (window.clearInterval(this.trafficStatsInterval), this.trafficStatsInterval = void 0), this.joinInfo) {
            const e2 = aJ.get(this.joinInfo.cname);
            e2 && e2.delete(this.joinInfo.uid);
          }
          this.joinInfo = void 0, this.key = void 0, this.networkQualityInterval && (window.clearInterval(this.networkQualityInterval), this.networkQualityInterval = void 0);
        }
        updateTurnConfigFromSignal() {
          if (!this.joinInfo)
            return;
          const e2 = function(e3) {
            const t2 = e3.match(/(wss\:\/\/)?([^:]+):(\d+)/);
            return t2 ? { username: QD.username, password: QD.password, turnServerURL: t2[2], tcpport: parseInt(t2[3]) + 30, udpport: parseInt(t2[3]) + 30, forceturn: false } : null;
          }((this.joinInfo.cloudProxyServer === "disabled" ? this.signal.url : this.joinInfo.gatewayAddrs[this.signal.currentURLIndex].address) || "");
          this.joinInfo.turnServer.serversFromGateway = [], e2 && this.joinInfo.turnServer.mode !== "off" && this.joinInfo.cloudProxyServer === "disabled" && this.joinInfo.turnServer.serversFromGateway.push(sJ(sJ({}, QD), {}, { turnServerURL: e2.turnServerURL, tcpport: e2.tcpport, udpport: e2.udpport, username: this.joinInfo.uid.toString(), password: this.joinInfo.token }));
        }
        async updateTrafficStats() {
          if (this.state !== "CONNECTED")
            return;
          const e2 = await this.signal.request(DP.TRAFFIC_STATS, void 0, true);
          e2.timestamp = Date.now(), e2.peer_delay.forEach((e3) => {
            const t2 = this._statsCollector.trafficStats && this._statsCollector.trafficStats.peer_delay.find((t3) => t3.peer_uid === e3.peer_uid);
            t2 && t2.B_st !== e3.B_st && kG(() => {
              this.emit(dk.STREAM_TYPE_CHANGE, e3.peer_uid, e3.B_st);
            });
          }), this._statsCollector.updateTrafficStats(e2);
        }
        getJoinMessage(e2) {
          if (!this.joinInfo || !this.key)
            throw new tD(eD.UNEXPECTED_ERROR, "can not generate join message, no join info");
          const t2 = Object.assign({}, this.joinInfo.apResponse);
          let r2 = JD("REPORT_APP_SCENARIO");
          if (typeof r2 != "string")
            try {
              r2 = JSON.stringify(r2);
            } catch (e3) {
              r2 = void 0;
            }
          r2 && r2.length > 128 && (r2 = void 0);
          const i2 = sJ({ p2p_id: this.store.p2pId, session_id: this.joinInfo.sid, app_id: this.joinInfo.appId, channel_key: this.key, channel_name: this.joinInfo.cname, sdk_version: MD, browser: navigator.userAgent, process_id: JD("PROCESS_ID"), mode: this.spec.mode, codec: this.spec.codec, role: this.role, has_changed_gateway: this.hasChangeBGPAddress, ap_response: t2, extend: JD("JOIN_EXTEND"), details: { 6: this.joinInfo.stringUid, cservice_map: this.joinInfo.cloudProxyServer === "proxy3" ? "1" : this.joinInfo.cloudProxyServer === "proxy5" ? "2" : void 0 }, features: { rejoin: true }, optionalInfo: this.joinInfo.optionalInfo, appScenario: r2, attributes: { userAttributes: { enablePublishedUserList: JD("ENABLE_PUBLISHED_USER_LIST"), maxSubscription: JD("MAX_SUBSCRIPTION") } } }, e2);
          return this.joinInfo.stringUid && (i2.string_uid = this.joinInfo.stringUid), this.joinInfo.aesmode && this.joinInfo.aespassword && (i2.aes_mode = this.joinInfo.aesmode, JD("ENCRYPT_AES") ? (i2.aes_secret = this.joinInfo.aespassword, i2.aes_encrypt = true) : i2.aes_secret = this.joinInfo.aespassword, this.joinInfo.aessalt && (i2.aes_salt = this.joinInfo.aessalt)), t2.addresses[this.signal.websocket.currentURLIndex] && (i2.ap_response.ticket = t2.addresses[this.signal.websocket.currentURLIndex].ticket, delete t2.addresses), this.joinInfo.defaultVideoStream !== void 0 && (i2.default_video_stream = this.joinInfo.defaultVideoStream), i2;
        }
        getRejoinMessage() {
          if (!this.joinInfo)
            throw new tD(eD.UNEXPECTED_ERROR, "can not generate rejoin message, no join info");
          return { session_id: this.joinInfo.sid, channel_name: this.joinInfo.cname, cid: this.joinInfo.cid, uid: this.joinInfo.uid, vid: Number(this.joinInfo.vid) };
        }
        handleSignalEvents() {
          this.signal.on(NP.WS_RECONNECT_WAITTING_FINISH, (e2) => {
            ["tryNext", "recover"].includes(e2) && this.joinInfo && bV.adjustSessionStartTime(this.joinInfo.sid);
          }), this.signal.on(NP.WS_RECONNECT_CREATE_CONNECTION, (e2) => {
            this.joinGatewayStartTime = Date.now();
          }), this.signal.on(NP.WS_RECONNECTING, (e2) => {
            this.joinInfo && bV.WebSocketQuit(this.joinInfo.sid, { lts: Date.now(), succ: -1, cname: this.joinInfo.cname, uid: this.joinInfo.uid, cid: this.joinInfo.cid, errorCode: e2 || bP.NETWORK_ERROR }), this.joinInfo && (this.state = "RECONNECTING", bV.sessionInit(this.joinInfo.sid, { lts: new Date().getTime(), extend: this.isSignalRecover ? { recover: true } : { rejoin: true }, cname: this.joinInfo.cname, appid: this.joinInfo.appId, mode: this.spec.mode }), this.isSignalRecover = false, this.joinGatewayStartTime = Date.now());
          }), this.signal.on(NP.WS_CLOSED, (e2) => {
            let t2;
            switch (e2) {
              case TP.LEAVE:
                t2 = bP.LEAVE;
                break;
              case TP.UID_BANNED:
              case TP.IP_BANNED:
              case TP.CHANNEL_BANNED:
              case TP.SERVER_ERROR:
                t2 = bP.SERVER_ERROR;
                break;
              case TP.FALLBACK:
                t2 = bP.FALLBACK;
                break;
              default:
                t2 = bP.NETWORK_ERROR;
            }
            dD.debug("[signal] websocket closed, reason: ".concat(t2 || "undefined -> " + bP.NETWORK_ERROR)), wD("debug", this, "ws_closed", "reason: ".concat(e2)), this.joinInfo && bV.WebSocketQuit(this.joinInfo.sid, { lts: Date.now(), succ: e2 === TP.LEAVE ? 1 : -1, cname: this.joinInfo.cname, uid: this.joinInfo.uid, cid: this.joinInfo.cid, errorCode: t2 }), this._disconnectedReason = e2, e2 !== TP.FALLBACK && (this.state = "DISCONNECTED"), this.reset();
          }), this.signal.on(NP.WS_CONNECTED, () => {
            if (this.updateTurnConfigFromSignal(), this.state = "CONNECTED", this.joinInfo && (this.role === "audience" && this._clientRoleOptions && this._clientRoleOptions.level && (dD.debug("[".concat(this.store.clientId, "] patch to send set client role, role: ").concat(this.role, ", mode: ").concat(this.spec.mode, ", level: ").concat(this._clientRoleOptions && this._clientRoleOptions.level)), TD("debug", this, "patch to send set client role, role: ".concat(this.role, ", mode: ").concat(this.spec.mode, ", level: ").concat(this._clientRoleOptions && this._clientRoleOptions.level)), this.setClientRole(this.role, this._clientRoleOptions)), bV.joinGateway(this.joinInfo.sid, { lts: this.joinGatewayStartTime, succ: true, ec: null, vid: this.joinInfo.vid, addr: this.signal.url, uid: this.joinInfo.uid, cid: this.joinInfo.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!this.joinInfo.proxyServer }), this._isProactiveJoin = false, this.joinInfo.useLocalAccessPoint)) {
              const e2 = this.signal.url && this.signal.url.match(/wss\:\/\/([^:]+):(\d+)/);
              if (!e2)
                return dD.error("[".concat(this.store.clientId, "] set local access point after joined failed: ").concat(e2)), void TD("error", this, "set local access point after joined failed: ".concat(e2));
              WD("EVENT_REPORT_DOMAIN", e2[1]), WD("EVENT_REPORT_BACKUP_DOMAIN", e2[1]), WD("LOG_UPLOAD_SERVER", "".concat(e2[1], ":6444"));
            }
          }), this.signal.on(PP.ON_UPLINK_STATS, (e2) => {
            this._statsCollector.updateUplinkStats(e2);
          }), this.signal.on(NP.REQUEST_RECOVER, (e2, t2, r2) => {
            if (!this.joinInfo)
              return r2(new tD(eD.UNEXPECTED_ERROR, "gateway: can not recover, no join info"));
            e2 && (this.joinInfo.multiIP = e2, this.hasChangeBGPAddress = true), this.isSignalRecover = true, bG(this, dk.REQUEST_NEW_GATEWAY_LIST).then(t2).catch(r2);
          }), this.signal.on(NP.REQUEST_JOIN_INFO, async (e2) => {
            var t2;
            this.updateTurnConfigFromSignal();
            const { iceParameters: r2, dtlsParameters: i2, rtpCapabilities: n2 } = await bG(this, dk.REQUEST_P2P_CONNECTION_PARAMS, { turnServer: (t2 = this.joinInfo) === null || t2 === void 0 ? void 0 : t2.turnServer });
            e2(this.getJoinMessage({ ortc: { iceParameters: r2, dtlsParameters: i2, rtpCapabilities: n2, version: "2" } }));
          }), this.signal.on(NP.REQUEST_REJOIN_INFO, (e2) => {
            e2(this.getRejoinMessage());
          }), this.signal.on(NP.REPORT_JOIN_GATEWAY, (e2, t2) => {
            this.joinInfo && (bV.joinGateway(this.joinInfo.sid, { lts: this.joinGatewayStartTime, succ: false, ec: e2, addr: t2, uid: this.joinInfo.uid, cid: this.joinInfo.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!this.joinInfo.proxyServer }), this._isProactiveJoin = false);
          }), this.signal.on(NP.IS_P2P_DISCONNECTED, (e2) => {
            e2(DG(this, dk.IS_P2P_DISCONNECTED));
          }), this.signal.on(NP.DISCONNECT_P2P, () => {
            this.emit(dk.DISCONNECT_P2P);
          }), this.signal.on(NP.NEED_RENEW_SESSION, () => {
            this.emit(dk.NEED_RENEW_SESSION);
          }), this.signal.on(NP.REQUEST_SUCCESS, () => {
            this._signalTimeout = false;
          }), this.signal.on(NP.REQUEST_TIMEOUT, () => {
            this._signalTimeout = true;
          }), this.signal.on(NP.JOIN_RESPONSE, (e2) => {
            const t2 = this.getGatewayIpPort();
            t2 ? this.emit(dk.JOIN_RESPONSE, e2, t2.ip, t2.port) : this.emit(dk.JOIN_RESPONSE, e2);
          });
        }
        async tryUnsubBeforeResub(e2, t2) {
          try {
            await this.signal.request(DP.UNSUBSCRIBE, { p2p_id: this.store.p2pId, stream_id: e2, ortc: [t2] }, true);
          } catch (t3) {
            throw dD.warning("unsubscribe warning", t3), ND("warning", this, "tryUnsubBeforeResub", e2, t3.toString()), t3;
          }
        }
        async tryUnpubBeforeRepub(e2, t2) {
          try {
            await this.signal.request(DP.UNPUBLISH, { stream_id: e2, ortc: t2 }, true);
          } catch (t3) {
            throw dD.warning("unpublish warning: ", t3), ND("warning", this, "tryUnpubBeforeRepub", e2, t3.toString()), t3;
          }
        }
        async tryMassUnsubBeforeResub(e2) {
          const t2 = { users: e2.map((e3) => ({ stream_id: e3.stream_id, stream_type: e3.stream_type })) };
          try {
            await this.signal.request(DP.UNSUBSCRIBE_STREAMS, t2, true);
          } catch (t3) {
            throw dD.warning("massUnsubscribe warning", t3), ND("warning", this, "tryUnsubAllBeforeResub", e2.map((e3) => e3.stream_id), t3.toString()), t3;
          }
        }
        async muteLocal(e2, t2) {
          const r2 = { action: e2.find((e3) => e3.stream_type === ck.Audio) ? "mute_local_audio" : "mute_local_video", p2p_id: this.store.p2pId, ortc: e2, stream_id: t2 };
          try {
            await this.signal.request(DP.CONTROL, r2, true, true);
          } catch (e3) {
            throw dD.warning("gateway unmuteLocal warning: ", e3), ND("warning", this, "muteLocal", t2, e3.toString()), e3;
          }
        }
        async unmuteLocal(e2, t2) {
          const r2 = { action: e2.find((e3) => e3.stream_type === ck.Audio) ? "unmute_local_audio" : "unmute_local_video", p2p_id: this.store.p2pId, ortc: e2, stream_id: t2 };
          try {
            await this.signal.request(DP.CONTROL, r2, true, true);
          } catch (e3) {
            throw dD.warning("gateway muteLocal warning: ", e3), ND("warning", this, "unmuteLocal", t2, e3.toString()), e3;
          }
        }
        uploadStats(e2, t2) {
          this.signal.upload(e2, t2);
        }
        getSignalRTT() {
          return this.signal.rtt;
        }
        async restartICE(e2) {
          const t2 = { p2p_id: this.store.p2pId, stream_id: this.store.uid, ortc: e2 };
          try {
            const e3 = await this.signal.request(DP.RESTART_ICE, t2, true), r2 = this.getGatewayIpPort();
            return { restartICEResponse: e3, gatewayIP: r2 == null ? void 0 : r2.ip, gatewayPort: r2 == null ? void 0 : r2.port };
          } catch (e3) {
            throw dD.warning("P2PChannel.restartICE warning: ", e3), ND("warning", this, "restartICE", void 0, e3.toString()), e3;
          }
        }
        reconnect() {
          this.state === "CONNECTED" && this.signal.reconnect(void 0, bP.P2P_FAILED);
        }
        getGatewayIpPort() {
          var e2;
          if (!JD("GATEWAY_WSS_ADDRESS") && (e2 = this.joinInfo) !== null && e2 !== void 0 && e2.gatewayAddrs) {
            const e3 = this.joinInfo.gatewayAddrs[this.signal.currentURLIndex];
            return (e3.ip || e3.ip6) && e3.port ? e3.ip6 ? { ip: e3.ip6, port: e3.port } : { ip: e3.ip, port: e3.port } : void 0;
          }
        }
      }) || nJ;
      function dJ(e2, t2) {
        var r2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          t2 && (i2 = i2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), r2.push.apply(r2, i2);
        }
        return r2;
      }
      function uJ(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r2 = arguments[t2] != null ? arguments[t2] : {};
          t2 % 2 ? dJ(Object(r2), true).forEach(function(t3) {
            kO(e2, t3, r2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : dJ(Object(r2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
          });
        }
        return e2;
      }
      !function() {
        var t2;
        function r2(e2) {
          var t3 = 0;
          return function() {
            return t3 < e2.length ? { done: false, value: e2[t3++] } : { done: true };
          };
        }
        var i2 = typeof Object.defineProperties == "function" ? Object.defineProperty : function(e2, t3, r3) {
          return e2 == Array.prototype || e2 == Object.prototype || (e2[t3] = r3.value), e2;
        };
        var n2, o2 = function(t3) {
          t3 = [typeof globalThis == "object" && globalThis, t3, typeof window == "object" && window, typeof self == "object" && self, typeof e == "object" && e];
          for (var r3 = 0; r3 < t3.length; ++r3) {
            var i3 = t3[r3];
            if (i3 && i3.Math == Math)
              return i3;
          }
          throw Error("Cannot find global object");
        }(this);
        function s2(e2, t3) {
          if (t3)
            e: {
              var r3 = o2;
              e2 = e2.split(".");
              for (var n3 = 0; n3 < e2.length - 1; n3++) {
                var s3 = e2[n3];
                if (!(s3 in r3))
                  break e;
                r3 = r3[s3];
              }
              (t3 = t3(n3 = r3[e2 = e2[e2.length - 1]])) != n3 && t3 != null && i2(r3, e2, { configurable: true, writable: true, value: t3 });
            }
        }
        function a2(e2) {
          return (e2 = { next: e2 })[Symbol.iterator] = function() {
            return this;
          }, e2;
        }
        function c2(e2) {
          var t3 = typeof Symbol != "undefined" && Symbol.iterator && e2[Symbol.iterator];
          return t3 ? t3.call(e2) : { next: r2(e2) };
        }
        if (s2("Symbol", function(e2) {
          function t3(e3, t4) {
            this.A = e3, i2(this, "description", { configurable: true, writable: true, value: t4 });
          }
          if (e2)
            return e2;
          t3.prototype.toString = function() {
            return this.A;
          };
          var r3 = "jscomp_symbol_" + (1e9 * Math.random() >>> 0) + "_", n3 = 0;
          return function e3(i3) {
            if (this instanceof e3)
              throw new TypeError("Symbol is not a constructor");
            return new t3(r3 + (i3 || "") + "_" + n3++, i3);
          };
        }), s2("Symbol.iterator", function(e2) {
          if (e2)
            return e2;
          e2 = Symbol("Symbol.iterator");
          for (var t3 = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), n3 = 0; n3 < t3.length; n3++) {
            var s3 = o2[t3[n3]];
            typeof s3 == "function" && typeof s3.prototype[e2] != "function" && i2(s3.prototype, e2, { configurable: true, writable: true, value: function() {
              return a2(r2(this));
            } });
          }
          return e2;
        }), typeof Object.setPrototypeOf == "function")
          n2 = Object.setPrototypeOf;
        else {
          var d2;
          e: {
            var u2 = {};
            try {
              u2.__proto__ = { a: true }, d2 = u2.a;
              break e;
            } catch (e2) {
            }
            d2 = false;
          }
          n2 = d2 ? function(e2, t3) {
            if (e2.__proto__ = t3, e2.__proto__ !== t3)
              throw new TypeError(e2 + " is not extensible");
            return e2;
          } : null;
        }
        var A2 = n2;
        function h2() {
          this.m = false, this.j = null, this.v = void 0, this.h = 1, this.u = this.C = 0, this.l = null;
        }
        function l2(e2) {
          if (e2.m)
            throw new TypeError("Generator is already running");
          e2.m = true;
        }
        function p2(e2, t3) {
          return e2.h = 3, { value: t3 };
        }
        function g2(e2) {
          this.g = new h2(), this.G = e2;
        }
        function f2(e2, t3, r3, i3) {
          try {
            var n3 = t3.call(e2.g.j, r3);
            if (!(n3 instanceof Object))
              throw new TypeError("Iterator result " + n3 + " is not an object");
            if (!n3.done)
              return e2.g.m = false, n3;
            var o3 = n3.value;
          } catch (t4) {
            return e2.g.j = null, e2.g.s(t4), E2(e2);
          }
          return e2.g.j = null, i3.call(e2.g, o3), E2(e2);
        }
        function E2(e2) {
          for (; e2.g.h; )
            try {
              var t3 = e2.G(e2.g);
              if (t3)
                return e2.g.m = false, { value: t3.value, done: false };
            } catch (t4) {
              e2.g.v = void 0, e2.g.s(t4);
            }
          if (e2.g.m = false, e2.g.l) {
            if (t3 = e2.g.l, e2.g.l = null, t3.F)
              throw t3.D;
            return { value: t3.return, done: true };
          }
          return { value: void 0, done: true };
        }
        function I2(e2) {
          this.next = function(t3) {
            return e2.o(t3);
          }, this.throw = function(t3) {
            return e2.s(t3);
          }, this.return = function(t3) {
            return function(e3, t4) {
              l2(e3.g);
              var r3 = e3.g.j;
              return r3 ? f2(e3, "return" in r3 ? r3.return : function(e4) {
                return { value: e4, done: true };
              }, t4, e3.g.return) : (e3.g.return(t4), E2(e3));
            }(e2, t3);
          }, this[Symbol.iterator] = function() {
            return this;
          };
        }
        function m2(e2, t3) {
          return t3 = new I2(new g2(t3)), A2 && e2.prototype && A2(t3, e2.prototype), t3;
        }
        if (h2.prototype.o = function(e2) {
          this.v = e2;
        }, h2.prototype.s = function(e2) {
          this.l = { D: e2, F: true }, this.h = this.C || this.u;
        }, h2.prototype.return = function(e2) {
          this.l = { return: e2 }, this.h = this.u;
        }, g2.prototype.o = function(e2) {
          return l2(this.g), this.g.j ? f2(this, this.g.j.next, e2, this.g.o) : (this.g.o(e2), E2(this));
        }, g2.prototype.s = function(e2) {
          return l2(this.g), this.g.j ? f2(this, this.g.j.throw, e2, this.g.o) : (this.g.s(e2), E2(this));
        }, s2("Array.prototype.entries", function(e2) {
          return e2 || function() {
            return function(e3, t3) {
              e3 instanceof String && (e3 += "");
              var r3 = 0, i3 = false, n3 = { next: function() {
                if (!i3 && r3 < e3.length) {
                  var n4 = r3++;
                  return { value: t3(n4, e3[n4]), done: false };
                }
                return i3 = true, { done: true, value: void 0 };
              } };
              return n3[Symbol.iterator] = function() {
                return n3;
              }, n3;
            }(this, function(e3, t3) {
              return [e3, t3];
            });
          };
        }), typeof Blob != "undefined" && (typeof FormData == "undefined" || !FormData.prototype.keys)) {
          var _2 = function(e2, t3) {
            for (var r3 = 0; r3 < e2.length; r3++)
              t3(e2[r3]);
          }, C2 = function(e2) {
            return e2.replace(/\r?\n|\r/g, "\r\n");
          }, v2 = function(e2, t3, r3) {
            return t3 instanceof Blob ? (r3 = r3 !== void 0 ? String(r3 + "") : typeof t3.name == "string" ? t3.name : "blob", t3.name === r3 && Object.prototype.toString.call(t3) !== "[object Blob]" || (t3 = new File([t3], r3)), [String(e2), t3]) : [String(e2), String(t3)];
          }, S2 = function(e2, t3) {
            if (e2.length < t3)
              throw new TypeError(t3 + " argument required, but only " + e2.length + " present.");
          }, R2 = typeof globalThis == "object" ? globalThis : typeof window == "object" ? window : typeof self == "object" ? self : this, y2 = R2.FormData, T2 = R2.XMLHttpRequest && R2.XMLHttpRequest.prototype.send, w2 = R2.Request && R2.fetch, b2 = R2.navigator && R2.navigator.sendBeacon, O2 = R2.Element && R2.Element.prototype, N2 = R2.Symbol && Symbol.toStringTag;
          N2 && (Blob.prototype[N2] || (Blob.prototype[N2] = "Blob"), "File" in R2 && !File.prototype[N2] && (File.prototype[N2] = "File"));
          try {
            new File([], "");
          } catch (e2) {
            R2.File = function(e3, t3, r3) {
              return e3 = new Blob(e3, r3 || {}), Object.defineProperties(e3, { name: { value: t3 }, lastModified: { value: +(r3 && r3.lastModified !== void 0 ? new Date(r3.lastModified) : new Date()) }, toString: { value: function() {
                return "[object File]";
              } } }), N2 && Object.defineProperty(e3, N2, { value: "File" }), e3;
            };
          }
          var D2 = function(e2) {
            return e2.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
          }, L2 = function(e2) {
            this.i = [];
            var t3 = this;
            e2 && _2(e2.elements, function(e3) {
              if (e3.name && !e3.disabled && e3.type !== "submit" && e3.type !== "button" && !e3.matches("form fieldset[disabled] *"))
                if (e3.type === "file") {
                  var r3 = e3.files && e3.files.length ? e3.files : [new File([], "", { type: "application/octet-stream" })];
                  _2(r3, function(r4) {
                    t3.append(e3.name, r4);
                  });
                } else
                  e3.type === "select-multiple" || e3.type === "select-one" ? _2(e3.options, function(r4) {
                    !r4.disabled && r4.selected && t3.append(e3.name, r4.value);
                  }) : e3.type === "checkbox" || e3.type === "radio" ? e3.checked && t3.append(e3.name, e3.value) : (r3 = e3.type === "textarea" ? C2(e3.value) : e3.value, t3.append(e3.name, r3));
            });
          };
          if ((t2 = L2.prototype).append = function(e2, t3, r3) {
            S2(arguments, 2), this.i.push(v2(e2, t3, r3));
          }, t2.delete = function(e2) {
            S2(arguments, 1);
            var t3 = [];
            e2 = String(e2), _2(this.i, function(r3) {
              r3[0] !== e2 && t3.push(r3);
            }), this.i = t3;
          }, t2.entries = function e2() {
            var t3, r3 = this;
            return m2(e2, function(e3) {
              if (e3.h == 1 && (t3 = 0), e3.h != 3)
                return t3 < r3.i.length ? e3 = p2(e3, r3.i[t3]) : (e3.h = 0, e3 = void 0), e3;
              t3++, e3.h = 2;
            });
          }, t2.forEach = function(e2, t3) {
            S2(arguments, 1);
            for (var r3 = c2(this), i3 = r3.next(); !i3.done; i3 = r3.next()) {
              var n3 = c2(i3.value);
              i3 = n3.next().value, n3 = n3.next().value, e2.call(t3, n3, i3, this);
            }
          }, t2.get = function(e2) {
            S2(arguments, 1);
            var t3 = this.i;
            e2 = String(e2);
            for (var r3 = 0; r3 < t3.length; r3++)
              if (t3[r3][0] === e2)
                return t3[r3][1];
            return null;
          }, t2.getAll = function(e2) {
            S2(arguments, 1);
            var t3 = [];
            return e2 = String(e2), _2(this.i, function(r3) {
              r3[0] === e2 && t3.push(r3[1]);
            }), t3;
          }, t2.has = function(e2) {
            S2(arguments, 1), e2 = String(e2);
            for (var t3 = 0; t3 < this.i.length; t3++)
              if (this.i[t3][0] === e2)
                return true;
            return false;
          }, t2.keys = function e2() {
            var t3, r3, i3, n3, o3 = this;
            return m2(e2, function(e3) {
              if (e3.h == 1 && (t3 = c2(o3), r3 = t3.next()), e3.h != 3)
                return r3.done ? void (e3.h = 0) : (i3 = r3.value, n3 = c2(i3), p2(e3, n3.next().value));
              r3 = t3.next(), e3.h = 2;
            });
          }, t2.set = function(e2, t3, r3) {
            S2(arguments, 2), e2 = String(e2);
            var i3 = [], n3 = v2(e2, t3, r3), o3 = true;
            _2(this.i, function(t4) {
              t4[0] === e2 ? o3 && (o3 = !i3.push(n3)) : i3.push(t4);
            }), o3 && i3.push(n3), this.i = i3;
          }, t2.values = function e2() {
            var t3, r3, i3, n3, o3 = this;
            return m2(e2, function(e3) {
              if (e3.h == 1 && (t3 = c2(o3), r3 = t3.next()), e3.h != 3)
                return r3.done ? void (e3.h = 0) : (i3 = r3.value, (n3 = c2(i3)).next(), p2(e3, n3.next().value));
              r3 = t3.next(), e3.h = 2;
            });
          }, L2.prototype._asNative = function() {
            for (var e2 = new y2(), t3 = c2(this), r3 = t3.next(); !r3.done; r3 = t3.next()) {
              var i3 = c2(r3.value);
              r3 = i3.next().value, i3 = i3.next().value, e2.append(r3, i3);
            }
            return e2;
          }, L2.prototype._blob = function() {
            var e2 = "----formdata-polyfill-" + Math.random(), t3 = [], r3 = "--" + e2 + '\r\nContent-Disposition: form-data; name="';
            return this.forEach(function(e3, i3) {
              return typeof e3 == "string" ? t3.push(r3 + D2(C2(i3)) + '"\r\n\r\n' + C2(e3) + "\r\n") : t3.push(r3 + D2(C2(i3)) + '"; filename="' + D2(e3.name) + '"\r\nContent-Type: ' + (e3.type || "application/octet-stream") + "\r\n\r\n", e3, "\r\n");
            }), t3.push("--" + e2 + "--"), new Blob(t3, { type: "multipart/form-data; boundary=" + e2 });
          }, L2.prototype[Symbol.iterator] = function() {
            return this.entries();
          }, L2.prototype.toString = function() {
            return "[object FormData]";
          }, O2 && !O2.matches && (O2.matches = O2.matchesSelector || O2.mozMatchesSelector || O2.msMatchesSelector || O2.oMatchesSelector || O2.webkitMatchesSelector || function(e2) {
            for (var t3 = (e2 = (this.document || this.ownerDocument).querySelectorAll(e2)).length; 0 <= --t3 && e2.item(t3) !== this; )
              ;
            return -1 < t3;
          }), N2 && (L2.prototype[N2] = "FormData"), T2) {
            var P2 = R2.XMLHttpRequest.prototype.setRequestHeader;
            R2.XMLHttpRequest.prototype.setRequestHeader = function(e2, t3) {
              P2.call(this, e2, t3), e2.toLowerCase() === "content-type" && (this.B = true);
            }, R2.XMLHttpRequest.prototype.send = function(e2) {
              e2 instanceof L2 ? (e2 = e2._blob(), this.B || this.setRequestHeader("Content-Type", e2.type), T2.call(this, e2)) : T2.call(this, e2);
            };
          }
          w2 && (R2.fetch = function(e2, t3) {
            return t3 && t3.body && t3.body instanceof L2 && (t3.body = t3.body._blob()), w2.call(this, e2, t3);
          }), b2 && (R2.navigator.sendBeacon = function(e2, t3) {
            return t3 instanceof L2 && (t3 = t3._asNative()), b2.call(this, e2, t3);
          }), R2.FormData = L2;
        }
      }();
      let AJ = 1;
      function hJ(e2, t2, r2, i2, n2) {
        AJ += 1;
        const o2 = { sid: r2.sid, command: "convergeAllocateEdge", uid: "666", appId: r2.appId, ts: Math.floor(Date.now() / 1e3), seq: AJ, requestId: AJ, version: MD, cname: r2.cname }, s2 = { service_name: t2, json_body: JSON.stringify(o2) };
        let a2, c2, d2 = e2[0];
        return nD(async () => {
          a2 = Date.now();
          const e3 = await EV(d2, { data: s2, cancelToken: i2, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" } });
          if (c2 = Date.now() - a2, e3.code !== 0) {
            const t3 = new tD(eD.UNEXPECTED_RESPONSE, "live streaming ap error, code" + e3.code, { retry: true, responseTime: c2 });
            throw dD.error(t3.toString()), ND("error", ["AjaxAPI"], "requestLiveStreamingWorkerManager", void 0, t3.toString()), t3;
          }
          const r3 = JSON.parse(e3.json_body);
          if (r3.code !== 200) {
            const e4 = new tD(eD.UNEXPECTED_RESPONSE, "live streaming app center error, code: ".concat(r3.code, ", reason: ").concat(r3.reason), { code: r3.code, responseTime: c2 });
            throw dD.error(e4.toString()), ND("error", ["AjaxAPI"], "requestLiveStreamingWorkerManager", void 0, e4.toString()), e4;
          }
          if (!r3.servers || r3.servers.length === 0) {
            const e4 = new tD(eD.UNEXPECTED_RESPONSE, "live streaming app center empty server", { code: r3.code, responseTime: c2 });
            throw dD.error(e4.toString()), ND("error", ["AjaxAPI"], "requestLiveStreamingWorkerManager", void 0, e4.toString()), e4;
          }
          const n3 = function(e4, t3) {
            return { addressList: e4.servers.map((e5) => "wss://".concat(e5.address.replace(/\./g, "-"), ".").concat(JD("WORKER_DOMAIN"), ":").concat(e5.wss, "?serviceName=").concat(encodeURIComponent(t3))), workerToken: e4.workerToken, vid: e4.vid };
          }(r3, t2);
          return JD("LIVE_STREAMING_ADDRESS") && (n3.addressList = JD("LIVE_STREAMING_ADDRESS") instanceof Array ? JD("LIVE_STREAMING_ADDRESS") : [JD("LIVE_STREAMING_ADDRESS")]), uJ(uJ({}, n3), {}, { responseTime: c2 });
        }, (i3, n3) => (bV.apworkerEvent(r2.sid, { success: true, sc: 200, serviceName: t2, responseDetail: JSON.stringify(i3.addressList), firstSuccess: n3 === 0, responseTime: c2, serverIp: e2[n3 % e2.length] }), false), (i3, n3) => (bV.apworkerEvent(r2.sid, { success: false, sc: i3.data && i3.data.code || 200, serviceName: t2, responseTime: c2, serverIp: e2[n3 % e2.length] }), !!(i3.code !== eD.OPERATION_ABORTED && i3.code !== eD.UNEXPECTED_RESPONSE || i3.data && i3.data.retry) && (d2 = e2[(n3 + 1) % e2.length], true)), n2);
      }
      let lJ = 1;
      function pJ(e2, t2, r2, i2) {
        let { url: n2, areaCode: o2 } = e2;
        ND("debug", ["AjaxAPI", t2.clientId], "requestChooseServer", { url: n2, areaCode: o2 });
        const s2 = Date.now(), [a2, c2] = mJ(t2, o2, [Qx.CHOOSE_SERVER]);
        let d2 = mV.networkState;
        return nD(async () => {
          d2 && mV.networkState === Ok.OFFLINE && mV.onlineWaiter && await nR.race([mV.onlineWaiter, CG(i2 && i2.maxRetryTimeout || rD.maxRetryTimeout)]), d2 = mV.networkState;
          const e3 = await EV(n2, { data: a2, cancelToken: r2, headers: { "Content-Type": "multipart/form-data;" } }, true);
          bV.reportResourceTiming(n2, t2.sid), fJ(e3, n2, t2, s2, [Qx.CHOOSE_SERVER]);
          const o3 = pG(e3, Qx.CHOOSE_SERVER);
          return EJ(o3), dG(o3, n2);
        }, (e3) => (e3 && bV.joinChooseServer(t2.sid, { lts: s2, succ: true, csAddr: n2, opid: c2, serverList: e3.gatewayAddrs.map((e4) => e4.address), ec: null, cid: e3.cid.toString(), uid: e3.uid.toString(), csIp: e3.csIp, unilbsServerIds: [Qx.CHOOSE_SERVER].toString() }), false), (e3) => e3.code !== eD.OPERATION_ABORTED && (e3.code === eD.CAN_NOT_GET_GATEWAY_SERVER ? e3.data.retry : (bV.joinChooseServer(t2.sid, { lts: s2, succ: false, csAddr: n2, serverList: null, opid: c2, ec: e3.code, csIp: e3.data && e3.data.csIp, unilbsServerIds: [Qx.CHOOSE_SERVER].toString(), extend: JSON.stringify({ networkState: d2 }) }), dD.warning("[".concat(t2.clientId, "] Choose server network error, retry"), e3), TD("warning", ["AjaxAPI", t2.clientId], "Choose server network error, retry, ".concat(e3)), true)), i2);
      }
      function gJ(e2, t2, r2, i2) {
        let { url: n2, areaCode: o2, serviceIds: s2 } = e2;
        ND("debug", ["AjaxAPI", t2.clientId], "requestMultiUnilbs", { url: n2, areaCode: o2, serviceIds: s2 });
        const a2 = Date.now(), [c2, d2] = mJ(t2, o2, s2);
        let u2 = void 0;
        return nD(async () => {
          u2 && mV.networkState === Ok.OFFLINE && mV.onlineWaiter && await nR.race([mV.onlineWaiter, CG(i2 && i2.maxRetryTimeout || rD.maxRetryTimeout)]), u2 = mV.networkState;
          const e3 = await EV(n2, { data: c2, cancelToken: r2, headers: { "Content-Type": "multipart/form-data;" } }, true);
          bV.reportResourceTiming(n2, t2.sid), fJ(e3, n2, t2, a2, s2);
          const o3 = pG(e3, Qx.CHOOSE_SERVER), d3 = pG(e3, t2.cloudProxyServer === "proxy5" ? Qx.CLOUD_PROXY_5 : t2.cloudProxyServer === "proxy3" || t2.cloudProxyServer === "proxy4" ? Qx.CLOUD_PROXY : Qx.CLOUD_PROXY_FALLBACK);
          return EJ(o3), { gatewayInfo: dG(o3, n2), proxyInfo: d3, url: n2 };
        }, (e3) => (e3.gatewayInfo && bV.joinChooseServer(t2.sid, { lts: a2, succ: true, csAddr: n2, serverList: e3.gatewayInfo.gatewayAddrs.map((e4) => e4.address), ec: null, opid: d2, cid: e3.gatewayInfo.cid.toString(), uid: e3.gatewayInfo.uid.toString(), csIp: e3.gatewayInfo.csIp, unilbsServerIds: s2.toString() }), e3.proxyInfo && bV.joinWebProxyAP(t2.sid, { lts: a2, sucess: 1, apServerAddr: n2, turnServerAddrList: e3.proxyInfo.addresses.map((e4) => e4.ip).join(","), errorCode: null, eventType: t2.cloudProxyServer, unilbsServerIds: s2.toString() }), false), (e3) => e3.code !== eD.OPERATION_ABORTED && (e3.code === eD.CAN_NOT_GET_GATEWAY_SERVER ? e3.data.retry : (bV.joinWebProxyAP(t2.sid, { lts: a2, sucess: 0, apServerAddr: n2, turnServerAddrList: null, errorCode: e3.code, eventType: t2.cloudProxyServer, unilbsServerIds: s2.toString(), extend: JSON.stringify({ networkState: u2 }) }), dD.warning("[".concat(t2.clientId, "] multi unilbs network error, retry"), e3), TD("warning", ["AjaxAPI", t2.clientId], "multi unilbs network error, retry, ".concat(e3)), true)), i2);
      }
      const fJ = (e2, t2, r2, i2, n2) => {
        const o2 = [], s2 = (o3) => {
          o3.flag === 4096 ? bV.joinChooseServer(r2.sid, { lts: i2, succ: false, csAddr: t2, opid: e2.opid, serverList: null, ec: o3.error.message, csIp: o3.error.data && o3.error.data.csIp, unilbsServerIds: n2.toString() }) : o3.flag !== 1048576 && o3.flag !== 4194304 && o3.flag !== 4194310 || bV.joinWebProxyAP(r2.sid, { lts: i2, sucess: 0, apServerAddr: t2, turnServerAddrList: null, errorCode: o3.error.code, eventType: r2.cloudProxyServer, unilbsServerIds: n2.toString() });
        };
        if (e2.response_body.forEach((t3) => {
          const r3 = t3.buffer.code;
          if (t3.uri === 23 && r3 === 0 && !t3.buffer.edges_services)
            if (t3.buffer.flag === 4194310)
              dD.warning("no edge services in ap response of proxy fallback, will not set proxy in iceServers"), t3.buffer.edges_services = [];
            else {
              const r4 = { error: new tD(eD.CAN_NOT_GET_GATEWAY_SERVER, "no edge services in ap response", { retry: true, csIp: e2.detail[502] }), flag: t3.buffer.flag };
              o2.push(r4), s2(r4);
            }
          if (r3 !== 0) {
            const i3 = MW(r3), n3 = { error: new tD(eD.CAN_NOT_GET_GATEWAY_SERVER, i3.desc, { retry: i3.retry, csIp: e2.detail[502] }), flag: t3.buffer.flag };
            t3.buffer.flag === 4194310 ? dD.warning(n3.error.toString()) : o2.push(n3), s2(n3);
          }
        }), o2.length)
          throw dD.warning("[".concat(r2.clientId, "] multi unilbs ").concat(t2, " failed, ").concat(o2.map((e3) => "flag: ".concat(e3.flag, ", message: ").concat(e3.error.message, ", retry: ").concat(e3.error.data.retry)).join(" | "))), ND("warning", ["AjaxAPI", r2.clientId], "checkMultiUnilbsResponseValid", { url: t2 }, o2.map((e3) => ({ flag: e3.flag, message: e3.error.message, retry: e3.error.data.retry }))), new tD(eD.CAN_NOT_GET_GATEWAY_SERVER, o2.map((e3) => "flag: ".concat(e3.flag, ", message: ").concat(e3.error.message)).join(" | "), { retry: !!o2.find((e3) => e3.error.data.retry), csIp: e2.detail[502] });
      }, EJ = (e2) => {
        if (e2.addresses && e2.addresses.length === 0 && e2.code === 0)
          throw new tD(eD.CAN_NOT_GET_GATEWAY_SERVER, "void gateway address", { retry: true, csIp: e2.detail && e2.detail[502] });
        if (JD("GATEWAY_ADDRESS") && JD("GATEWAY_ADDRESS").length > 0) {
          dD.debug("assign gateway address to", JD("GATEWAY_ADDRESS")), TD("debug", ["AjaxAPI"], "assign gateway address to ".concat(JSON.stringify(JD("GATEWAY_ADDRESS"))));
          const t2 = JD("GATEWAY_ADDRESS").map((t3) => ({ ip: t3.ip, port: t3.port, ticket: e2.addresses[0] && e2.addresses[0].ticket }));
          e2.addresses = t2;
        }
      }, IJ = (e2, t2) => {
        if (e2.response_body && e2.response_body.length) {
          const t3 = e2.response_body[0];
          if (t3.buffer.code !== 0) {
            const e3 = MW(t3.buffer.code);
            throw new tD(eD.UPDATE_TICKET_FAILED, "[".concat(t3.buffer.code, "]: ").concat(e3.desc), { retry: e3.retry });
          }
          return t3.buffer.ticket;
        }
        throw dD.debug("update ticket request received ap response without response body:", t2), TD("debug", ["AjaxAPI"], "update ticket request received ap response without response body: ".concat(t2)), new tD(eD.UPDATE_TICKET_FAILED, "cannot find response body from ap response", { retry: false });
      }, mJ = (e2, t2, r2) => {
        const i2 = Math.floor(Math.random() * 10 ** 12), n2 = { appid: e2.appId, client_ts: Date.now(), opid: i2, sid: e2.sid, request_bodies: [{ uri: 22, buffer: { cname: e2.cname, detail: { 6: e2.stringUid, 11: t2, 12: JD("USE_NEW_TOKEN") ? "1" : void 0 }, key: e2.token, service_ids: r2, uid: e2.uid || 0 } }] };
        n2.request_bodies.forEach((t3) => {
          e2.multiIP && e2.multiIP.gateway_ip && (t3.buffer.detail[5] = JSON.stringify({ vocs_ip: [e2.multiIP.uni_lbs_ip], vos_ip: [e2.multiIP.gateway_ip] }));
        });
        const o2 = new FormData();
        return o2.append("request", JSON.stringify(n2)), [o2, i2];
      }, _J = (e2, t2) => {
        const r2 = Math.floor(Math.random() * 10 ** 12), i2 = { appid: e2.appId, client_ts: Date.now(), opid: r2, sid: e2.sid, request_bodies: [{ uri: 28, buffer: { cname: e2.cname, detail: { 1: "", 6: e2.stringUid, 12: "1" }, token: e2.token, service_ids: t2, uid: e2.uid || 0, edges_services: e2.apResponse.addresses.map((e3) => ({ ip: e3.ip, port: e3.port })) } }] }, n2 = new FormData();
        return n2.append("request", JSON.stringify(i2)), [n2, r2];
      }, CJ = () => {
        const e2 = JD("AREAS");
        e2.length === 0 && e2.push(Ek.GLOBAL);
        return vh(e2).call(e2, (e3, t2, r2) => {
          const i2 = vJ(t2);
          return i2 ? r2 === 0 ? i2 : "".concat(e3, ",").concat(i2) : e3;
        }, "");
      }, vJ = (e2) => e2 === Ek.OVERSEA ? "".concat(Ck.ASIA, ",").concat(Ck.EUROPE, ",").concat(Ck.AFRICA, ",").concat(Ck.NORTH_AMERICA, ",").concat(Ck.SOUTH_AMERICA, ",").concat(Ck.OCEANIA) : Ck[e2], SJ = { GLOBAL: { ASIA: [Ek.CHINA, Ek.JAPAN, Ek.INDIA, Ek.KOREA, Ek.HKMC], EUROPE: [], NORTH_AMERICA: [Ek.US], SOUTH_AMERICA: [], OCEANIA: [], AFRICA: [] } }, RJ = Object.keys(SJ[Ek.GLOBAL]), yJ = [Ek.CHINA, Ek.NORTH_AMERICA, Ek.EUROPE, Ek.ASIA, Ek.JAPAN, Ek.INDIA, Ek.OCEANIA, Ek.SOUTH_AMERICA, Ek.AFRICA, Ek.KOREA, Ek.HKMC, Ek.US], TJ = function(e2, t2) {
        let r2 = [];
        if (e2.includes(Ek.GLOBAL)) {
          const o2 = [Ek.GLOBAL, Ek.OVERSEA], s2 = Object.keys(vk);
          if (t2 === Ek.GLOBAL)
            throw new tD(eD.INVALID_PARAMS, "GLOBAL is an invalid excludedArea value");
          if (t2 === Ek.CHINA)
            r2 = [Ek.OVERSEA];
          else if (n2 = t2, RJ.includes(n2)) {
            const e3 = (i2 = t2, SJ[Ek.GLOBAL][i2] || []), n3 = [...o2, t2, ...e3];
            r2 = s2.filter((e4) => !n3.includes(e4));
          } else if (function(e3) {
            let t3 = false;
            return RJ.forEach((r3) => {
              SJ[Ek.GLOBAL][r3].includes(e3) && (t3 = true);
            }), t3;
          }(t2)) {
            const e3 = function(e4) {
              let t3;
              return RJ.forEach((r3) => {
                SJ[Ek.GLOBAL][r3].includes(e4) && (t3 = r3);
              }), t3;
            }(t2), i3 = [...o2, e3, t2];
            r2 = s2.filter((e4) => !i3.includes(e4));
          } else
            r2 = e2;
          r2 = function(e3) {
            const t3 = [];
            return yJ.forEach((r3) => {
              e3.includes(r3) && t3.push(r3);
            }), t3.concat(e3.filter((e4) => !yJ.includes(e4)));
          }(r2);
        } else
          r2 = e2;
        var i2, n2;
        return r2;
      };
      async function wJ(e2, t2, r2, i2) {
        const n2 = async function(e3, t3, r3, i3) {
          let n3 = null;
          const o2 = [], s2 = async () => {
            const n4 = JD("WEBCS_DOMAIN").slice(0, JD("AJAX_REQUEST_CONCURRENT")).map((t4) => ({ url: e3.proxyServer ? "https://".concat(e3.proxyServer, "/ap/?url=").concat(t4 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t4, "/api/v2/transpond/webrtc?v=2"), areaCode: CJ() })), s3 = i3.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: n4.map((e4) => e4.url) }), a3 = await jG({ fragementLength: JD("FRAGEMENT_LENGTH"), referenceList: n4, asyncMapHandler: (i4) => (dD.debug("[".concat(e3.clientId, "] Connect to choose_server:"), i4.url), pJ(i4, e3, t3, r3)), allFailedhandler: (e4) => {
              throw i3.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e4 }, s3), e4[0];
            }, promisesCollector: o2 });
            return i3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, s3), a3;
          }, a2 = async () => {
            if (await CG(1e3), n3 !== null)
              return n3;
            const s3 = JD("WEBCS_DOMAIN_BACKUP_LIST").map((t4) => ({ url: e3.proxyServer ? "https://".concat(e3.proxyServer, "/ap/?url=").concat(t4 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t4, "/api/v2/transpond/webrtc?v=2"), areaCode: CJ() })), a3 = i3.recordJoinChannelService({ endTs: void 0, startTs: Date.now(), status: "pending", service: "chooseServer", urls: s3.map((e4) => e4.url) }), c2 = await jG({ fragementLength: JD("FRAGEMENT_LENGTH"), referenceList: s3, asyncMapHandler: (i4) => (dD.debug("[".concat(e3.clientId, "] Connect to backup choose_server:"), i4.url), pJ(i4, e3, t3, r3)), allFailedhandler: (e4) => {
              throw i3.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e4 }, a3), e4[0];
            }, promisesCollector: o2 });
            return i3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, a3), c2;
          };
          try {
            return n3 = await wG([s2(), a2()]), o2.length && o2.forEach((e4) => e4.cancel && typeof e4.cancel == "function" && e4.cancel()), n3;
          } catch (e4) {
            throw e4[0];
          }
        }(e2, t2, r2, i2);
        return { gatewayInfo: await n2 };
      }
      async function bJ(e2, t2, r2, i2, n2) {
        const o2 = e2.cloudProxyServer;
        if (o2 === "disabled") {
          if (!i2)
            return;
          if (e2.useLocalAccessPoint)
            return await wJ(e2, t2, r2, n2);
          if (JD("JOIN_WITH_FALLBACK_MEDIA_PROXY")) {
            const { gatewayInfo: i3, proxyInfo: o3 } = await LJ(e2, t2, r2, n2);
            return e2.turnServer && e2.turnServer.mode !== "auto" ? (TD("debug", ["Server", e2.clientId], "do not set fallback turn because of already having turnserver"), { gatewayInfo: i3 }) : (e2.turnServer = { mode: "manual", servers: o3.map((e3) => ({ turnServerURL: e3.address, tcpport: e3.tcpport || QD.tcpport, udpport: e3.udpport || QD.udpport, username: e3.username || QD.username, password: e3.password || QD.password, forceturn: JD("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE"), security: true })) }, { gatewayInfo: i3 });
          }
          return await wJ(e2, t2, r2, n2);
        }
        let s2;
        if (["443only", "normal"].includes(o2)) {
          let a2;
          i2 ? o2 !== "normal" ? [a2, s2] = await nR.all([NJ(e2, t2, r2), wJ(e2, t2, r2, n2)]) : (a2 = await NJ(e2, t2, r2), e2.proxyServer = a2.addresses[0], bV.setProxyServer(e2.proxyServer), dD.setProxyServer(e2.proxyServer), yD(e2.proxyServer), s2 = await wJ(e2, t2, r2, n2)) : (s2 = void 0, o2 !== "normal" ? a2 = await NJ(e2, t2, r2) : (a2 = await NJ(e2, t2, r2), e2.proxyServer = a2.addresses[0], bV.setProxyServer(e2.proxyServer), dD.setProxyServer(e2.proxyServer), yD(e2.proxyServer))), e2.turnServer = { mode: "manual", servers: a2.addresses.map((e3) => ({ turnServerURL: e3, tcpport: a2.serverResponse.tcpport ? a2.serverResponse.tcpport : QD.tcpport, udpport: a2.serverResponse.udpport ? a2.serverResponse.udpport : QD.udpport, username: a2.serverResponse.username || QD.username, password: a2.serverResponse.password || QD.password, forceturn: true, security: false })) };
        } else {
          const { proxyInfo: i3, gatewayInfo: a2 } = await LJ(e2, t2, r2, n2);
          s2 = { gatewayInfo: a2 }, e2.turnServer = { mode: "manual", servers: i3.map((e3) => ({ turnServerURL: e3.address, tcpport: o2 === "proxy3" ? void 0 : e3.tcpport ? e3.tcpport : QD.tcpport, udpport: o2 === "proxy4" ? void 0 : e3.udpport ? e3.udpport : QD.udpport, username: e3.username || QD.username, password: e3.password || QD.password, forceturn: o2 !== "proxy4", security: o2 === "proxy5" })) };
        }
        return dD.debug("[".concat(e2.clientId, "] set proxy server: ").concat(e2.proxyServer, ", mode: ").concat(o2)), ND("debug", ["Server", e2.clientId], "setCloudProxyServerAndGetServerInfo", { proxyServer: e2.proxyServer, mode: e2.cloudProxyServer }), s2;
      }
      async function OJ(e2, t2, r2, i2, n2) {
        const o2 = JD("ACCOUNT_REGISTER").slice(0, JD("AJAX_REQUEST_CONCURRENT"));
        let s2 = [];
        s2 = t2.proxyServer ? o2.map((e3) => "https://".concat(t2.proxyServer, "/ap/?url=").concat(e3 + "/api/v1")) : o2.map((e3) => "https://".concat(e3, "/api/v1"));
        const a2 = n2 == null ? void 0 : n2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "stringUID", urls: s2 });
        try {
          const o3 = await async function(e3, t3, r3, i3, n3) {
            const o4 = Date.now(), s3 = { sid: r3.sid, opid: 10, appid: r3.appId, string_uid: t3 };
            let a3 = e3[0];
            const c2 = await nD(() => EV(a3 + "".concat(a3.indexOf("?") === -1 ? "?" : "&", "action=stringuid"), { data: s3, cancelToken: i3, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 72 } }), (r4, i4) => {
              if (r4.code === 0) {
                if (r4.uid <= 0 || r4.uid >= Math.pow(2, 32))
                  throw dD.error("Invalid Uint Uid ".concat(t3, " => ").concat(r4.uid), r4), ND("error", ["AjaxAPI"], "requestUserAccount", "Invalid Uint Uid ".concat(t3, " => ").concat(r4.uid, ", ").concat(r4)), bV.reqUserAccount(s3.sid, { lts: o4, success: false, serverAddr: a3, stringUid: s3.string_uid, uid: r4.uid, errorCode: eD.INVALID_UINT_UID_FROM_STRING_UID, extend: s3 }), new tD(eD.INVALID_UINT_UID_FROM_STRING_UID);
                return bV.reqUserAccount(s3.sid, { lts: o4, success: true, serverAddr: a3, stringUid: s3.string_uid, uid: r4.uid, errorCode: null, extend: s3 }), false;
              }
              const n4 = MW(r4.code);
              return n4.retry && (a3 = e3[(i4 + 1) % e3.length]), bV.reqUserAccount(s3.sid, { lts: o4, success: false, serverAddr: a3, stringUid: s3.string_uid, uid: r4.uid, errorCode: n4.desc, extend: s3 }), n4.retry;
            }, (t4, r4) => t4.code !== eD.OPERATION_ABORTED && (bV.reqUserAccount(s3.sid, { lts: o4, success: false, serverAddr: a3, stringUid: s3.string_uid, uid: null, errorCode: t4.code, extend: s3 }), a3 = e3[(r4 + 1) % e3.length], true), n3);
            if (c2.code !== 0) {
              const e4 = MW(c2.code);
              throw new tD(eD.UNEXPECTED_RESPONSE, e4.desc);
            }
            return c2;
          }(s2, e2, t2, r2, i2);
          return n2 == null || n2.recordJoinChannelService({ status: "success", endTs: Date.now() }, a2), o3.uid;
        } catch (e3) {
          throw n2 == null || n2.recordJoinChannelService({ status: "error", endTs: Date.now(), errors: [e3] }, a2), e3;
        }
      }
      async function NJ(e2, t2, r2) {
        let i2 = Date.now();
        const n2 = e2.cloudProxyServer, o2 = JD(n2 === "normal" ? "PROXY_CS" : "WEBCS_DOMAIN").map((t3) => e2.proxyServer ? "https://".concat(e2.proxyServer, "/ap/?url=").concat(t3 + "/api/v1") : "https://".concat(t3, "/api/v1"));
        if (["proxy3", "proxy4", "proxy5"].includes(n2)) {
          const i3 = o2.map((e3) => ({ url: e3, areaCode: CJ() }));
          let n3 = null;
          n3 = await jG({ fragementLength: JD("FRAGEMENT_LENGTH"), referenceList: i3, asyncMapHandler: (i4) => function(e3, t3, r3, i5) {
            let { url: n4, areaCode: o3 } = e3;
            const s4 = Date.now(), a3 = { opid: 133, flag: t3.cloudProxyServer === "proxy5" ? 4194304 : 1048576, ts: +new Date(), key: t3.token, cname: t3.cname, sid: t3.sid, detail: { 6: t3.stringUid, 11: o3 }, uid: t3.uid || 0 };
            return nD(async () => await EV(n4, { data: a3, cancelToken: r3, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 69 } }), (e4) => {
              if (e4.code === 0)
                return bV.joinWebProxyAP(t3.sid, { lts: s4, sucess: 1, apServerAddr: n4, turnServerAddrList: e4.addresses.map((e5) => e5.ip).join(","), errorCode: null, eventType: t3.cloudProxyServer }), false;
              const r4 = MW(e4.code);
              throw new tD(eD.CAN_NOT_GET_GATEWAY_SERVER, r4.desc, { retry: r4.retry });
            }, (e4) => e4.code !== eD.OPERATION_ABORTED && (e4.code === eD.CAN_NOT_GET_GATEWAY_SERVER ? (bV.joinWebProxyAP(a3.sid, { lts: s4, sucess: 0, apServerAddr: n4, turnServerAddrList: null, errorCode: e4.code, eventType: t3.cloudProxyServer }), dD.warning("[".concat(t3.clientId, "] proxy ap server ").concat(n4, " failed, message: ").concat(e4.message, ", retry: ").concat(e4.data.retry)), TD("warning", ["AjaxAPI", t3.clientId], "proxy ap server ".concat(n4, " failed, message: ").concat(e4.message, ", retry: ").concat(e4.data.retry)), e4.data.retry) : (bV.joinWebProxyAP(a3.sid, { lts: s4, sucess: 0, apServerAddr: n4, turnServerAddrList: null, errorCode: e4.code, eventType: t3.cloudProxyServer }), true)), i5);
          }(i4, e2, t2, r2), allFailedhandler: () => {
            throw dD.error("[".concat(e2.clientId, "] can not get proxy server after trying several times")), new tD(eD.CAN_NOT_GET_PROXY_SERVER);
          } });
          const s3 = n3.addresses;
          if (!s3 || s3.length === 0)
            throw dD.error("[".concat(e2.clientId, "] can not get proxy server, empty proxy server list")), new tD(eD.CAN_NOT_GET_PROXY_SERVER, "empty proxy server list");
          return { addresses: s3.map((e3) => e3.ip).map(cG), serverResponse: { tcpport: s3[0].port || 443, udpport: s3[0].port || QD.udpport, username: QD.username, password: QD.password } };
        }
        let s2 = null;
        s2 = await jG({ fragementLength: JD("FRAGEMENT_LENGTH"), referenceList: o2, asyncMapHandler: (i3) => function(e3, t3, r3, i4) {
          const n3 = Date.now(), o3 = { command: "convergeAllocateEdge", sid: t3.sid, appId: t3.appId, token: t3.token, uid: t3.uid, cname: t3.cname, ts: Math.floor(Date.now() / 1e3), version: MD, seq: 0, requestId: 1 };
          return nD(async () => ({ res: await EV(e3, { data: { service_name: "webrtc_proxy", json_body: JSON.stringify(o3) }, cancelToken: r3, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 61 } }), url: e3 }), (e4) => {
            if (!e4.res.json_body)
              throw dD.debug("[".concat(t3.clientId, "] Get proxy server failed: no json_body")), ND("error", ["AjaxAPI", t3.clientId], "requestProxyServerList", "Get proxy server failed: no json_body"), new tD(eD.UNEXPECTED_RESPONSE, JSON.stringify(e4.res));
            const r4 = JSON.parse(e4.res.json_body);
            if (r4.code !== 200)
              throw dD.debug("[".concat(t3.clientId, "] Get proxy server failed: response code [").concat(r4.code, "], reason [").concat(r4.reason, "]")), ND("error", ["AjaxAPI", t3.clientId], "requestProxyServerList", "Get proxy server failed: response code [".concat(r4.code, "], reason [").concat(r4.reason, "]")), new tD(eD.UNEXPECTED_RESPONSE, JSON.stringify(e4.res));
            return dD.debug("[".concat(t3.clientId, "] App return server length"), r4.servers.length), ND("debug", ["AjaxAPI", t3.clientId], "requestProxyServerList", "", { length: r4.servers.length }), false;
          }, (t4) => t4.code !== eD.OPERATION_ABORTED && (bV.requestProxyAppCenter(o3.sid, { lts: n3, succ: false, APAddr: e3, workerManagerList: null, ec: t4.code, response: t4.message }), true), i4);
        }(i3, e2, t2, r2), allFailedhandler: () => {
          throw dD.error("[".concat(e2.clientId, "] can not get proxy server after trying several times")), new tD(eD.CAN_NOT_GET_PROXY_SERVER);
        } });
        const a2 = JSON.parse(s2.res.json_body).servers.map(aG);
        if (e2.cloudProxyServer === "443only")
          return { addresses: a2, serverResponse: { tcpport: 443, udpport: QD.udpport, username: QD.username, password: QD.password } };
        bV.requestProxyAppCenter(e2.sid, { lts: i2, succ: true, APAddr: s2.url, workerManagerList: JSON.stringify(a2), ec: null, response: JSON.stringify(s2.res) }), i2 = Date.now();
        const c2 = a2.map((i3) => function(e3, t3, r3, i4) {
          const n3 = Date.now();
          let o3 = e3;
          e3.startsWith("http") || (o3 = "https://".concat(e3, ":4000/v2/machine"));
          const s3 = { command: "request", gatewayType: "http", appId: t3.appId, cname: t3.cname, uid: (t3.uid || "").toString(), sdkVersion: "2.3.1", sid: t3.sid, seq: 1, ts: Date.now(), requestId: 3, clientRequest: { appId: t3.appId, cname: t3.cname, uid: (t3.uid || "").toString(), sid: t3.sid } };
          return nD(async () => ({ res: await EV(o3, { data: s3, cancelToken: r3 }), url: e3 }), (e4) => {
            if (!e4.res.serverResponse)
              throw new tD(eD.UNEXPECTED_RESPONSE, "requeet worker manager server failed: serverResponse is undefined");
            return false;
          }, (t4) => t4.code !== eD.OPERATION_ABORTED && (bV.requestProxyWorkerManager(s3.sid, { lts: n3, succ: false, workerManagerAddr: e3, ec: t4.code, response: t4.message }), true), i4);
        }(i3, e2, t2, r2));
        let d2 = null;
        try {
          d2 = await wG(c2);
        } catch (t3) {
          throw dD.error("[".concat(e2.clientId, "] can not get worker manager after trying several times")), new tD(eD.CAN_NOT_GET_PROXY_SERVER);
        }
        return c2.forEach((e3) => e3.cancel()), bV.requestProxyWorkerManager(e2.sid, { lts: i2, succ: true, workerManagerAddr: d2.url, ec: null, response: JSON.stringify(d2.res) }), { addresses: [d2.url], serverResponse: d2.res.serverResponse };
      }
      async function DJ(e2, t2, r2) {
        const i2 = JD("CDS_AP").slice(0, JD("AJAX_REQUEST_CONCURRENT")).map((t3) => e2.proxyServer ? "https://".concat(e2.proxyServer, "/ap/?url=").concat(t3 + "/api/v1") : "https://".concat(t3, "/api/v1?action=config")).map((i3) => function(e3, t3, r3, i4) {
          const n3 = oO(), o3 = { flag: 64, cipher_method: 0, features: { device: n3.name, system: n3.os, system_general: navigator.userAgent, vendor: t3.appId, version: MD, cname: t3.cname, sid: t3.sid, session_id: t3.sid, detail: "", proxyServer: t3.proxyServer } };
          return nD(() => EV(e3, { data: o3, timeout: 1e3, cancelToken: r3, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 54 } }), void 0, (e4) => e4.code !== eD.OPERATION_ABORTED, i4);
        }(i3, e2, t2, r2));
        let n2 = null, o2 = null, s2 = {};
        try {
          n2 = await wG(i2);
        } catch (e3) {
          if (e3.code === eD.OPERATION_ABORTED)
            throw e3;
          o2 = e3;
        }
        i2.forEach((e3) => e3.cancel());
        if (bV.reportApiInvoke(e2.sid, { name: fP.REQUEST_CONFIG_DISTRIBUTE, options: { error: o2, res: n2 } }).onSuccess(), n2 && n2.test_tags)
          try {
            s2 = function(e3) {
              if (!e3.test_tags)
                return {};
              const t3 = e3.test_tags, r3 = Object.keys(t3), i3 = {};
              return r3.forEach((e4) => {
                var r4;
                const n3 = Gb(r4 = e4.slice(4)).call(r4), o3 = JSON.parse(t3[e4])[1];
                i3[n3] = o3;
              }), i3;
            }(n2);
          } catch (e3) {
          }
        return s2;
      }
      async function LJ(e2, t2, r2, i2) {
        const n2 = JD("PROXY_SERVER_TYPE3"), o2 = (e3, t3) => {
          let r3 = n2;
          return Array.isArray(r3) && (r3 = t3 % 2 == 0 ? n2[1] : n2[0]), "https://".concat(r3, "/ap/?url=").concat(e3);
        };
        let s2 = null;
        const a2 = [], c2 = async () => {
          const n3 = JD("WEBCS_DOMAIN").slice(0, JD("AJAX_REQUEST_CONCURRENT")).map((t3, r3) => ({ url: e2.cloudProxyServer === "disabled" || e2.cloudProxyServer === "fallback" ? "https://".concat(t3, "/api/v2/transpond/webrtc?v=2") : o2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), r3), areaCode: CJ(), serviceIds: [Qx.CHOOSE_SERVER, e2.cloudProxyServer === "proxy5" ? Qx.CLOUD_PROXY_5 : e2.cloudProxyServer === "proxy3" || e2.cloudProxyServer === "proxy4" ? Qx.CLOUD_PROXY : Qx.CLOUD_PROXY_FALLBACK] })), s3 = i2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: n3.map((e3) => e3.url) }), c3 = await jG({ fragementLength: JD("FRAGEMENT_LENGTH"), referenceList: n3, asyncMapHandler: (i3) => (dD.debug("[".concat(e2.clientId, "] Connect to choose_server:"), i3.url), gJ(i3, e2, t2, r2)), allFailedhandler: (e3) => {
            throw i2.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e3 }, s3), e3[0];
          }, promisesCollector: a2 });
          return i2.recordJoinChannelService({ endTs: Date.now(), status: "success" }, s3), c3;
        }, d2 = async () => {
          if (await CG(1e3), s2 !== null)
            return s2;
          const n3 = JD("WEBCS_DOMAIN_BACKUP_LIST").map((t3, r3) => ({ url: e2.cloudProxyServer === "disabled" || e2.cloudProxyServer === "fallback" ? "https://".concat(t3, "/api/v2/transpond/webrtc?v=2") : o2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), r3), areaCode: CJ(), serviceIds: [Qx.CHOOSE_SERVER, e2.cloudProxyServer === "proxy5" ? Qx.CLOUD_PROXY_5 : e2.cloudProxyServer === "proxy3" || e2.cloudProxyServer === "proxy4" ? Qx.CLOUD_PROXY : Qx.CLOUD_PROXY_FALLBACK] })), c3 = i2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: n3.map((e3) => e3.url) }), d3 = await jG({ fragementLength: JD("FRAGEMENT_LENGTH"), referenceList: n3, asyncMapHandler: (i3) => (dD.debug("[".concat(e2.clientId, "] Connect to backup choose_server:"), i3.url), gJ(i3, e2, t2, r2)), allFailedhandler: (e3) => {
            throw i2.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e3 }, c3), e3[0];
          }, promisesCollector: a2 });
          return i2.recordJoinChannelService({ endTs: Date.now(), status: "success" }, c3), d3;
        };
        let u2, A2, h2;
        try {
          ({ gatewayInfo: u2, proxyInfo: A2, url: h2 } = await wG([c2(), d2()]));
        } catch (e3) {
          throw e3[0];
        }
        if (a2.length && a2.forEach((e3) => e3.cancel && typeof e3.cancel == "function" && e3.cancel()), !u2 || !A2)
          throw new tD(eD.UNEXPECTED_ERROR, "missing gateway or proxy response").print();
        if (e2.apUrl = h2, e2.cloudProxyServer !== "disabled" && Array.isArray(n2) && h2) {
          const t3 = new kW(h2).host;
          n2.includes(t3) && (e2.proxyServer = t3, dD.setProxyServer(t3), bV.setProxyServer(t3), yD(t3));
        }
        return s2 = { gatewayInfo: u2, proxyInfo: await gG(A2, u2.uid) }, s2;
      }
      async function PJ(e2, t2, r2, i2) {
        const n2 = JD("UAP_AP").slice(0, JD("AJAX_REQUEST_CONCURRENT")).map((e3) => t2.proxyServer ? "https://".concat(t2.proxyServer, "/ap/?url=").concat(e3 + "/api/v1?action=uap") : "https://".concat(e3, "/api/v1?action=uap"));
        return await hJ(n2, e2, t2, r2, i2);
      }
      async function kJ(e2, t2, r2) {
        const i2 = JD("UAP_AP").slice(0, JD("AJAX_REQUEST_CONCURRENT")).map((t3) => e2.proxyServer ? "https://".concat(e2.proxyServer, "/ap/?url=").concat(t3 + "/api/v1?action=uap") : "https://".concat(t3, "/api/v1?action=uap")).map((i3) => function(e3, t3, r3, i4) {
          const n2 = { command: "convergeAllocateEdge", sid: t3.sid, appId: t3.appId, token: t3.token, ts: Date.now(), version: MD, cname: t3.cname, uid: t3.uid.toString(), requestId: lJ, seq: lJ };
          lJ += 1;
          const o2 = { service_name: "tele_channel", json_body: JSON.stringify(n2) };
          return nD(async () => {
            const t4 = await EV(e3, { data: o2, cancelToken: r3, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 61 } });
            if (t4.code !== 0) {
              const e4 = new tD(eD.UNEXPECTED_RESPONSE, "cross channel ap error, code" + t4.code, { retry: true });
              throw dD.error(e4.toString()), ND("error", ["AjaxAPI"], "requestChannelMediaRelayWorkerManager", void 0, e4.toString()), e4;
            }
            const i5 = JSON.parse(t4.json_body);
            if (i5.code !== 200) {
              const e4 = new tD(eD.UNEXPECTED_RESPONSE, "cross channel app center error, code: ".concat(i5.code, ", reason: ").concat(i5.reason));
              throw dD.error(e4.toString()), ND("error", ["AjaxAPI"], "requestChannelMediaRelayWorkerManager", void 0, e4.toString()), e4;
            }
            if (!i5.servers || i5.servers.length === 0) {
              const e4 = new tD(eD.UNEXPECTED_RESPONSE, "cross channel app center empty server");
              throw dD.error(e4.toString()), ND("error", ["AjaxAPI"], "requestChannelMediaRelayWorkerManager", void 0, e4.toString()), e4;
            }
            return { vid: i5.vid, workerToken: i5.workerToken, addressList: i5.servers.map((e4) => "wss://".concat(e4.address.replace(/\./g, "-"), ".").concat(JD("WORKER_DOMAIN"), ":").concat(e4.wss)) };
          }, void 0, (e4) => !!(e4.code !== eD.OPERATION_ABORTED && e4.code !== eD.UNEXPECTED_RESPONSE || e4.data && e4.data.retry), i4);
        }(i3, e2, t2, r2));
        try {
          const e3 = await wG(i2);
          return i2.forEach((e4) => e4.cancel()), e3;
        } catch (e3) {
          throw e3[0];
        }
      }
      async function BJ(e2, t2, r2) {
        let i2 = null;
        const n2 = [], o2 = async (o3) => {
          const s2 = JD(o3 ? "WEBCS_DOMAIN_BACKUP_LIST" : "WEBCS_DOMAIN").map((t3) => e2.proxyServer ? "https://".concat(e2.proxyServer, "/ap/?url=").concat(t3 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t3, "/api/v2/transpond/webrtc?v=2"));
          return o3 && (await CG(1e3), i2 !== null) ? i2 : await jG({ fragementLength: JD("FRAGEMENT_LENGTH"), referenceList: s2, asyncMapHandler: (i3) => (dD.debug("[".concat(e2.clientId, "] update ticket, Connect to ").concat(o3 ? "backup" : "", " choose_server:"), i3), function(e3, t3, r3, i4) {
            const [n3] = _J(t3, [Qx.CHOOSE_SERVER]);
            let o4 = mV.networkState;
            return nD(async () => {
              o4 && mV.networkState === Ok.OFFLINE && mV.onlineWaiter && await nR.race([mV.onlineWaiter, CG(i4 && i4.maxRetryTimeout || rD.maxRetryTimeout)]), o4 = mV.networkState;
              const t4 = await EV(e3, { data: n3, cancelToken: r3, headers: { "Content-Type": "multipart/form-data;" } }, true);
              return IJ(t4, e3);
            }, () => false, (e4) => e4.code !== eD.OPERATION_ABORTED && (e4.code === eD.UPDATE_TICKET_FAILED ? e4.data.retry : (dD.warning("[".concat(t3.clientId, "] update ticket network error, retry"), e4), TD("warning", ["AjaxAPI", t3.clientId], "update ticket network error, retry, ".concat(e4)), true)), i4);
          }(i3, e2, t2, r2)), allFailedhandler: (e3) => {
            throw e3[0];
          }, promisesCollector: n2 });
        };
        try {
          return i2 = await wG([o2(false), o2(true)]), n2.length && n2.forEach((e3) => e3.cancel && typeof e3.cancel == "function" && e3.cancel()), i2;
        } catch (e3) {
          throw e3[0];
        }
      }
      var MJ;
      function UJ(e2, t2) {
        var r2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          t2 && (i2 = i2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), r2.push.apply(r2, i2);
        }
        return r2;
      }
      function QJ(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r2 = arguments[t2] != null ? arguments[t2] : {};
          t2 % 2 ? UJ(Object(r2), true).forEach(function(t3) {
            kO(e2, t3, r2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : UJ(Object(r2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
          });
        }
        return e2;
      }
      let xJ = PD("ConfigDistributeManager")(MJ = class extends ZN {
        constructor() {
          super(), kO(this, "configs", void 0), kO(this, "joinInfo", void 0), kO(this, "cancelToken", void 0), kO(this, "retryConfig", { timeout: 3e3, timeoutFactor: 1.5, maxRetryCount: 1, maxRetryTimeout: 1e4 }), kO(this, "interval", void 0), kO(this, "mutex", new kV("config-distribute")), kO(this, "mutableParamsRead", false);
        }
        startGetConfigDistribute(e2, t2) {
          this.joinInfo = e2, this.cancelToken = t2, this.interval && this.stopGetConfigDistribute(), this.updateConfigDistribute(), this.interval = window.setInterval(() => {
            this.updateConfigDistribute();
          }, JD("CONFIG_DISTRIBUTE_INTERVAL"));
        }
        stopGetConfigDistribute() {
          this.interval && clearInterval(this.interval), this.interval = void 0, this.joinInfo = void 0, this.cancelToken = void 0;
        }
        async awaitConfigDistributeComplete() {
          if (!this.mutex.isLocked)
            return;
          (await this.mutex.lock())();
        }
        async updateConfigDistribute() {
          if (!this.mutableParamsRead) {
            this.mutableParamsRead = true;
            bV.reportApiInvoke(null, { options: void 0, name: fP.LOAD_CONFIG_FROM_LOCALSTORAGE, tag: EP.TRACER }).onSuccess(JSON.stringify(zD));
          }
          if (!this.joinInfo || !this.cancelToken || !this.retryConfig)
            return dD.debug("[config-distribute] get config distribute interrupted have no joininfo"), void ND("debug", this, "updateConfigDistribute", void 0, "get config distribute interrupted have no joininfo");
          let e2;
          const t2 = await this.mutex.lock();
          try {
            e2 = await DJ(this.joinInfo, this.cancelToken, this.retryConfig), dD.debug("[config-distribute] get config distribute", JSON.stringify(e2)), ND("debug", this, "updateConfigDistribute", e2), e2.limit_bitrate && this.handleBitrateLimit(e2.limit_bitrate), this.cacheGlobalParameterConfig(e2), this.configs = e2;
          } catch (e3) {
            const t3 = new tD(eD.NETWORK_RESPONSE_ERROR, e3);
            dD.warning("[config-distribute] ".concat(t3.toString())), ND("warning", this, "updateConfigDistribute", void 0, e3.toString());
          } finally {
            t2();
          }
        }
        getBitrateLimit() {
          return this.configs ? this.configs.limit_bitrate : void 0;
        }
        handleBitrateLimit(e2) {
          var t2;
          (t2 = e2) && t2.uplink && t2.id && t2.uplink.max_bitrate !== void 0 && t2.uplink.min_bitrate !== void 0 && (this.configs && this.configs.limit_bitrate ? this.configs && this.configs.limit_bitrate && this.configs.limit_bitrate.id !== e2.id && this.emit(Sk.UPDATE_BITRATE_LIMIT, e2) : this.emit(Sk.UPDATE_BITRATE_LIMIT, e2));
        }
        getLowStreamConfigDistribute() {
          return this.configs && this.configs.limit_bitrate && QJ({}, this.configs.limit_bitrate.low_stream_uplink);
        }
        cacheGlobalParameterConfig(e2) {
          var t2;
          const r2 = qL(t2 = Object.keys(e2).filter((e3) => /^webrtc_ng_global_parameter/.test(e3))).call(t2);
          for (let t3 = 0; t3 < r2.length; t3++)
            for (let i3 = r2.length - 1; i3 > t3; i3--) {
              const t4 = r2[i3];
              if (typeof e2[t4].__priority == "number") {
                const n2 = e2[t4].__priority, o2 = r2[i3 - 1];
                if (typeof e2[o2].__priority == "number") {
                  if (!(n2 > e2[o2].__priority))
                    continue;
                  {
                    const e3 = t4;
                    r2[i3] = r2[i3 - 1], r2[i3 - 1] = e3;
                  }
                } else {
                  const e3 = t4;
                  r2[i3] = r2[i3 - 1], r2[i3 - 1] = e3;
                }
              }
            }
          const i2 = {};
          r2.forEach((t3) => {
            const r3 = e2[t3], n2 = r3.__expires;
            Object.keys(r3).forEach((e3) => {
              e3 === "__priority" || e3 === "__expires" || Object.prototype.hasOwnProperty.call(i2, e3) || (i2[e3] = QJ({ value: r3[e3] }, n2 && { expires: n2 }));
            });
          });
          try {
            const e3 = JSON.stringify(i2), t3 = window.btoa(e3);
            window.localStorage.setItem("websdk_ng_global_parameter", t3), dD.debug("Caching global parameters ".concat(e3)), ND("debug", this, "cacheGlobalParameterConfig", e3);
          } catch (e3) {
            dD.error("Error caching global parameters:", e3.message), ND("error", this, "cacheGlobalParameterConfig", void 0, e3.message);
          }
        }
      }) || MJ;
      function FJ(e2, t2) {
        var r2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          t2 && (i2 = i2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), r2.push.apply(r2, i2);
        }
        return r2;
      }
      function VJ(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r2 = arguments[t2] != null ? arguments[t2] : {};
          t2 % 2 ? FJ(Object(r2), true).forEach(function(t3) {
            kO(e2, t3, r2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : FJ(Object(r2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
          });
        }
        return e2;
      }
      class jJ extends ZN {
        constructor(e2, t2, r2, i2) {
          super(), kO(this, "spec", void 0), kO(this, "token", void 0), kO(this, "websocket", void 0), kO(this, "pingpongTimer", void 0), kO(this, "reconnectMode", "retry"), kO(this, "serviceMode", void 0), kO(this, "reqId", 0), kO(this, "commandReqId", 0), kO(this, "handleWebSocketOpen", () => {
            this.reconnectMode = "retry", this.startPingPong();
          }), kO(this, "handleWebSocketMessage", (e3) => {
            if (!e3.data)
              return;
            const t3 = JSON.parse(e3.data);
            t3.requestId ? this.emit("@".concat(t3.requestId, "-").concat(t3.sid), t3) : this.serviceMode === WP.INJECT ? this.emit(ek.INJECT_STREAM_STATUS, t3) : (bV.workerEvent(this.spec.sid, { actionType: "status", serverCode: t3.code, workerType: this.serviceMode === WP.TRANSCODE ? 1 : 2 }), this.emit(ek.PUBLISH_STREAM_STATUS, t3));
          }), this.spec = t2, this.token = e2, this.serviceMode = i2, this.websocket = new eJ("live-streaming", r2), this.websocket.on(YP.CONNECTED, this.handleWebSocketOpen), this.websocket.on(YP.ON_MESSAGE, this.handleWebSocketMessage), this.websocket.on(YP.REQUEST_NEW_URLS, (e3, t3) => {
            bG(this, ek.REQUEST_NEW_ADDRESS).then(e3).catch(t3);
          }), this.websocket.on(YP.RECONNECTING, () => {
            this.websocket.reconnectMode = this.reconnectMode;
          });
        }
        init(e2) {
          return this.websocket.init(e2);
        }
        async request(e2, t2, r2, i2) {
          this.reqId += 1, e2 === "request" && (this.commandReqId += 1);
          const n2 = this.commandReqId, o2 = this.reqId;
          if (!o2 || !this.websocket)
            throw new tD(eD.UNEXPECTED_ERROR);
          const s2 = VJ({ command: e2, sdkVersion: MD === "4.11.1" ? "0.0.1" : MD, seq: o2, requestId: o2, allocate: r2, cname: this.spec.cname, appId: this.spec.appId, sid: this.spec.sid, uid: this.spec.uid.toString(), ts: Math.floor(Date.now() / 1e3) }, t2);
          if (this.websocket.state === "closed")
            throw new tD(eD.WS_DISCONNECT);
          const a2 = () => new nR((e3, t3) => {
            this.websocket.once(YP.CLOSED, () => t3(new tD(eD.WS_ABORT))), this.websocket.once(YP.CONNECTED, e3);
          });
          this.websocket.state !== "connected" && await a2(), s2.clientRequest && (s2.clientRequest.workerToken = this.token);
          const c2 = new nR((e3, t3) => {
            const r3 = () => {
              t3(new tD(eD.WS_ABORT));
            };
            this.websocket.once(YP.RECONNECTING, r3), this.websocket.once(YP.CLOSED, r3), this.once("@".concat(o2, "-").concat(this.spec.sid), (t4) => {
              e3(t4);
            });
          });
          i2 && bV.workerEvent(this.spec.sid, VJ(VJ({}, i2), {}, { requestId: n2, actionType: "request", payload: JSON.stringify(t2.clientRequest), serverCode: 0, code: 0 }));
          const d2 = Date.now();
          this.websocket.sendMessage(s2);
          let u2 = null;
          try {
            u2 = await c2;
          } catch (i3) {
            if (this.websocket.state === "closed")
              throw i3;
            return await a2(), await this.request(e2, t2, r2);
          }
          return i2 && bV.workerEvent(this.spec.sid, VJ(VJ({}, i2), {}, { requestId: n2, actionType: "response", payload: JSON.stringify(u2.serverResponse), serverCode: u2.code, success: u2.code === 200, responseTime: Date.now() - d2 })), u2.code !== 200 && this.handleResponseError(u2), u2;
        }
        tryNextAddress() {
          this.reconnectMode = "tryNext", this.websocket.reconnect("tryNext");
        }
        close() {
          const e2 = MD === "4.11.1" ? "0.0.1" : MD;
          this.reqId += 1, this.websocket.state === "connected" ? (this.websocket.sendMessage({ command: "request", appId: this.spec.appId, cname: this.spec.cname, uid: this.spec.uid.toString(), sdkVersion: e2, sid: this.spec.sid, seq: this.reqId, ts: Math.floor(Date.now() / 1e3), requestId: this.reqId, clientRequest: { command: "DestroyWorker" } }), this.websocket.close(false, true)) : this.websocket.close(false), this.pingpongTimer && (window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0);
        }
        handleResponseError(e2) {
          switch (e2.code) {
            case rk.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM:
              return void dD.warning("live stream response already exists stream");
            case rk.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR:
            case rk.LIVE_STREAM_RESPONSE_BAD_STREAM:
            case rk.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR:
              return new tD(eD.LIVE_STREAMING_INVALID_ARGUMENT, "", { code: e2.code }).throw();
            case rk.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST:
              if (e2.serverResponse.command === "UnpublishStream" || e2.serverResponse.command === "UninjectStream")
                return;
              throw new tD(eD.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", { retry: true });
            case rk.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED:
              return new tD(eD.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED, "", { code: e2.code }).throw();
            case rk.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: {
              const t2 = new tD(eD.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE);
              return this.emit(ek.WARNING, t2, e2.serverResponse.url);
            }
            case rk.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN: {
              const t2 = new tD(eD.LIVE_STREAMING_WARN_FREQUENT_REQUEST);
              return this.emit(ek.WARNING, t2, e2.serverResponse.url);
            }
            case rk.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH:
              throw new tD(eD.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", { retry: true });
            case rk.LIVE_STREAM_RESPONSE_NOT_SUPPORTED:
              return new tD(eD.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED, "", { code: e2.code }).throw();
            case rk.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM: {
              const t2 = new tD(eD.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT);
              return this.emit(ek.WARNING, t2, e2.serverResponse.url);
            }
            case rk.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR:
              return new tD(eD.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", { code: e2.code }).throw();
            case rk.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT:
              throw new tD(eD.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream resource limit", { retry: true, changeAddress: true });
            case rk.LIVE_STREAM_RESPONSE_WORKER_LOST:
            case rk.LIVE_STREAM_RESPONSE_WORKER_QUIT:
              if (e2.serverResponse.command === "UnpublishStream" || e2.serverResponse.command === "UninjectStream")
                return;
              throw new tD(eD.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { retry: true, changeAddress: true });
            case rk.ERROR_FAIL_SEND_MESSAGE:
              if (e2.serverResponse.command === "UnpublishStream" || e2.serverResponse.command === "UninjectStream")
                return;
              if (e2.serverResponse.command === "UpdateTranscoding" || e2.serverResponse.command === "ControlStream")
                return new tD(eD.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { code: e2.code }).throw();
              throw new tD(eD.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { retry: true, changeAddress: true });
            case rk.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
            case rk.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
            case rk.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
            case rk.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH:
              return new tD(eD.LIVE_STREAMING_CDN_ERROR, "", { code: e2.code }).throw();
          }
        }
        startPingPong() {
          this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(() => {
            this.websocket.state === "connected" && this.request("ping", {}).catch(yG);
          }, 6e3);
        }
      }
      function GJ(e2, t2) {
        var r2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          t2 && (i2 = i2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), r2.push.apply(r2, i2);
        }
        return r2;
      }
      function KJ(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r2 = arguments[t2] != null ? arguments[t2] : {};
          t2 % 2 ? GJ(Object(r2), true).forEach(function(t3) {
            kO(e2, t3, r2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : GJ(Object(r2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
          });
        }
        return e2;
      }
      class HJ extends ZN {
        constructor(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : rD, r2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : rD;
          super(), kO(this, "onLiveStreamWarning", void 0), kO(this, "onLiveStreamError", void 0), kO(this, "onInjectStatusChange", void 0), kO(this, "spec", void 0), kO(this, "retryTimeout", 1e4), kO(this, "connection", void 0), kO(this, "httpRetryConfig", void 0), kO(this, "wsRetryConfig", void 0), kO(this, "streamingTasks", /* @__PURE__ */ new Map()), kO(this, "isStartingStreamingTask", false), kO(this, "taskMutex", new kV("live-streaming")), kO(this, "cancelToken", zN.CancelToken.source()), kO(this, "transcodingConfig", void 0), kO(this, "injectConfig", KJ({}, $P)), kO(this, "injectLoopTimes", 0), kO(this, "uapResponse", void 0), kO(this, "lastTaskId", 1), kO(this, "statusError", /* @__PURE__ */ new Map()), this.spec = e2, this.httpRetryConfig = r2, this.wsRetryConfig = t2;
        }
        async setTranscodingConfig(e2) {
          const t2 = KJ(KJ({}, ZP), e2);
          t2.videoCodecProfile !== 66 && t2.videoCodecProfile !== 77 && t2.videoCodecProfile !== 100 && (dD.debug("[".concat(this.spec.clientId, "] set transcoding config, fix video codec profile: ").concat(t2.videoCodecProfile, " -> 100")), t2.videoCodecProfile = 100), t2.transcodingUsers || (t2.transcodingUsers = t2.userConfigs), t2.transcodingUsers && (t2.transcodingUsers = t2.transcodingUsers.map((e3) => KJ(KJ(KJ({}, qP), e3), {}, { zOrder: e3.zOrder ? e3.zOrder + 1 : 1 }))), function(e3) {
            iP(e3.width) || ZL(e3.width, "config.width", 0, 1e4), iP(e3.height) || ZL(e3.height, "config.height", 0, 1e4), iP(e3.videoBitrate) || ZL(e3.videoBitrate, "config.videoBitrate", 1, 1e6), iP(e3.videoFrameRate) || ZL(e3.videoFrameRate, "config.videoFrameRate"), iP(e3.lowLatency) || zL(e3.lowLatency, "config.lowLatency"), iP(e3.audioSampleRate) || XL(e3.audioSampleRate, "config.audioSampleRate", [32e3, 44100, 48e3]), iP(e3.audioBitrate) || ZL(e3.audioBitrate, "config.audioBitrate", 1, 128), iP(e3.audioChannels) || XL(e3.audioChannels, "config.audioChannels", [1, 2, 3, 4, 5]), iP(e3.videoGop) || ZL(e3.videoGop, "config.videoGop"), iP(e3.videoCodecProfile) || XL(e3.videoCodecProfile, "config.videoCodecProfile", [66, 77, 100]), iP(e3.userCount) || ZL(e3.userCount, "config.userCount", 0, 17), iP(e3.backgroundColor) || ZL(e3.backgroundColor, "config.backgroundColor", 0, 16777215), iP(e3.userConfigExtraInfo) || $L(e3.userConfigExtraInfo, "config.userConfigExtraInfo", 0, 4096, false), e3.transcodingUsers && !iP(e3.transcodingUsers) && (eP(e3.transcodingUsers, "config.transcodingUsers"), e3.transcodingUsers.forEach((e4, t3) => {
              rP(e4.uid), iP(e4.x) || ZL(e4.x, "transcodingUser[".concat(t3, "].x"), 0, 1e4), iP(e4.y) || ZL(e4.y, "transcodingUser[".concat(t3, "].y"), 0, 1e4), iP(e4.width) || ZL(e4.width, "transcodingUser[".concat(t3, "].width"), 0, 1e4), iP(e4.height) || ZL(e4.height, "transcodingUser[".concat(t3, "].height"), 0, 1e4), iP(e4.zOrder) || ZL(e4.zOrder - 1, "transcodingUser[".concat(t3, "].zOrder"), 0, 100), iP(e4.alpha) || ZL(e4.alpha, "transcodingUser[".concat(t3, "].alpha"), 0, 1, false);
            })), iP(e3.watermark) || XP(e3.watermark, "watermark"), iP(e3.backgroundImage) || XP(e3.backgroundImage, "backgroundImage"), e3.images && !iP(e3.images) && (eP(e3.images, "config.images"), e3.images.forEach((e4, t3) => {
              XP(e4, "images[".concat(t3, "]"));
            }));
          }(t2);
          const r2 = [];
          t2.images && r2.push(...t2.images.map((e3) => KJ(KJ(KJ({}, zP), e3), {}, { zOrder: 255 }))), t2.backgroundImage && (r2.push(KJ(KJ(KJ({}, zP), t2.backgroundImage), {}, { zOrder: 0 })), delete t2.backgroundImage), t2.watermark && (r2.push(KJ(KJ(KJ({}, zP), t2.watermark), {}, { zOrder: 255 })), delete t2.watermark), t2.images = r2, t2.transcodingUsers && (t2.userConfigs = t2.transcodingUsers.map((e3) => KJ({}, e3)), t2.userCount = t2.transcodingUsers.length, delete t2.transcodingUsers);
          const i2 = (t2.userConfigs || []).map((e3) => typeof e3.uid == "number" ? nR.resolve(e3.uid) : OJ(e3.uid, this.spec, this.cancelToken.token, this.httpRetryConfig));
          if ((await nR.all(i2)).forEach((e3, r3) => {
            t2.userConfigs && t2.userConfigs[r3] && (t2.userConfigs[r3].uid = e3);
          }), this.transcodingConfig = t2, this.connection)
            try {
              var n2;
              const e3 = await this.connection.request("request", { clientRequest: { command: "UpdateTranscoding", transcodingConfig: this.transcodingConfig } }, false, { command: "UpdateTranscoding", workerType: 1, requestByUser: true, tid: Array.from(nV(n2 = this.streamingTasks).call(n2)).map((e4) => e4.taskId).join("#") });
              dD.debug("[".concat(this.spec.clientId, "] update live transcoding config success, code: ").concat(e3.code, ", config:"), JSON.stringify(this.transcodingConfig));
            } catch (e3) {
              if (!e3.data || !e3.data.retry)
                throw e3;
              e3.data.changeAddress && this.connection.tryNextAddress(), this.streamingTasks.forEach((t3) => {
                dD.warning("[".concat(this.spec.clientId, "] live streaming receive error"), e3.toString(), "try to republish", t3.url), this.startLiveStreamingTask(t3.url, t3.mode, e3).then(() => {
                  dD.debug("[".concat(this.spec.clientId, "] live streaming republish ").concat(t3.url, " success"));
                }).catch((e4) => {
                  dD.error("[".concat(this.spec.clientId, "] live streaming republish failed"), t3.url, e4.toString()), this.onLiveStreamError && this.onLiveStreamError(t3.url, e4);
                });
              });
            }
        }
        setInjectStreamConfig(e2, t2) {
          this.injectConfig = Object.assign({}, this.injectConfig, e2), this.injectLoopTimes = t2;
        }
        async startLiveStreamingTask(e2, t2, r2) {
          var i2;
          if (Array.from(nV(i2 = this.streamingTasks).call(i2)).find((e3) => e3.mode === WP.INJECT) && t2 === WP.INJECT)
            return new tD(eD.LIVE_STREAMING_TASK_CONFLICT, "inject stream over limit").throw();
          if (!this.transcodingConfig && t2 === WP.TRANSCODE)
            throw new tD(eD.INVALID_OPERATION, "[LiveStreaming] no transcoding config found, can not start transcoding streaming task");
          let n2 = { command: "PublishStream", ts: Date.now(), url: e2, uid: this.spec.uid.toString(), autoDestroyTime: 100, acceptImageTimeout: true };
          dD.debug("[".concat(this.spec.clientId, "] start live streaming ").concat(e2, ", mode: ").concat(t2));
          const o2 = await this.taskMutex.lock();
          if (!this.connection && r2)
            return void o2();
          if (this.streamingTasks.get(e2) && !r2)
            return o2(), new tD(eD.LIVE_STREAMING_TASK_CONFLICT).throw();
          try {
            this.connection || (this.connection = await this.connect(t2));
          } catch (e3) {
            throw o2(), e3;
          }
          switch (t2) {
            case WP.TRANSCODE:
              n2.transcodingConfig = KJ({}, this.transcodingConfig);
              break;
            case WP.RAW:
              break;
            case WP.INJECT:
              n2 = { cname: this.spec.cname, command: "InjectStream", sid: this.spec.sid, transcodingConfig: this.injectConfig, ts: Date.now(), url: e2, loopTimes: this.injectLoopTimes };
          }
          this.uapResponse && this.uapResponse.vid && (n2.vid = this.uapResponse.vid), this.isStartingStreamingTask = true;
          const s2 = this.lastTaskId++;
          try {
            const i3 = new nR((t3, i4) => {
              CG(this.retryTimeout).then(() => {
                if (r2)
                  return i4(r2);
                const t4 = this.statusError.get(e2);
                return t4 ? (this.statusError.delete(e2), i4(t4)) : void 0;
              });
            }), a2 = await nR.race([this.connection.request("request", { clientRequest: n2 }, true, { url: e2, command: "PublishStream", workerType: t2 === WP.TRANSCODE ? 1 : 2, requestByUser: !r2, tid: s2.toString() }), i3]);
            this.isStartingStreamingTask = false, dD.debug("[".concat(this.spec.clientId, "] live streaming started, code: ").concat(a2.code)), this.streamingTasks.set(e2, { clientRequest: n2, mode: t2, url: e2, taskId: s2 }), o2();
          } catch (i3) {
            if (o2(), this.isStartingStreamingTask = false, !i3.data || !i3.data.retry || r2)
              throw i3;
            return i3.data.changeAddress ? (this.connection.tryNextAddress(), await this.startLiveStreamingTask(e2, t2, i3)) : await this.startLiveStreamingTask(e2, t2, i3);
          }
        }
        stopLiveStreamingTask(e2) {
          return new nR((t2, r2) => {
            const i2 = this.streamingTasks.get(e2);
            if (!i2 || !this.connection)
              return new tD(eD.UNEXPECTED_ERROR, "can not find streaming task to stop").throw();
            const n2 = i2.mode;
            i2.abortTask = () => {
              dD.debug("[".concat(this.spec.clientId, "] stop live streaming success(worker exception)")), this.streamingTasks.delete(e2), t2();
            }, this.connection.request("request", { clientRequest: { command: n2 === WP.INJECT ? "UninjectStream" : "UnpublishStream", url: i2.url } }, false, { url: e2, command: "UnPublishStream", workerType: n2 === WP.TRANSCODE ? 1 : 2, requestByUser: true, tid: (this.lastTaskId++).toString() }).then((r3) => {
              dD.debug("[".concat(this.spec.clientId, "] stop live streaming success, code: ").concat(r3.code)), this.streamingTasks.delete(e2), this.streamingTasks.size === 0 && n2 !== WP.INJECT && (this.connection && this.connection.close(), this.connection = void 0), t2(), n2 === WP.INJECT && this.onInjectStatusChange && this.onInjectStatusChange(JP.INJECT_STREAM_STATUS_STOP_SUCCESS, this.spec.uid, e2);
            }).catch(r2);
          });
        }
        async controlInjectStream(e2, t2, r2, i2) {
          const n2 = this.streamingTasks.get(e2);
          if (!n2 || !this.connection || n2.mode !== WP.INJECT)
            throw new tD(eD.INVALID_OPERATION, "can not find inject stream task to control");
          return (await this.connection.request("request", { clientRequest: { command: "ControlStream", url: e2, control: t2, audioVolume: r2, position: i2 } })).serverResponse;
        }
        resetAllTask() {
          var e2;
          const t2 = Array.from(nV(e2 = this.streamingTasks).call(e2));
          this.terminate();
          for (const e3 of t2)
            this.startLiveStreamingTask(e3.url, e3.mode).catch((t3) => {
              this.onLiveStreamError && this.onLiveStreamError(e3.url, t3);
            });
        }
        terminate() {
          this.cancelToken && this.cancelToken.cancel(), this.streamingTasks = /* @__PURE__ */ new Map(), this.isStartingStreamingTask = false, this.statusError = /* @__PURE__ */ new Map(), this.cancelToken = zN.CancelToken.source(), this.uapResponse = void 0, this.connection && this.connection.close(), this.connection = void 0;
        }
        async connect(e2) {
          if (this.connection)
            throw new tD(eD.UNEXPECTED_ERROR, "live streaming connection has already connected");
          const t2 = await bG(this, tk.REQUEST_WORKER_MANAGER_LIST, e2);
          return this.uapResponse = t2, this.connection = new jJ(t2.workerToken, this.spec, this.wsRetryConfig, e2), this.connection.on(ek.WARNING, (e3, t3) => this.onLiveStreamWarning && this.onLiveStreamWarning(t3, e3)), this.connection.on(ek.PUBLISH_STREAM_STATUS, (e3) => this.handlePublishStreamServer(e3)), this.connection.on(ek.INJECT_STREAM_STATUS, (e3) => this.handleInjectStreamServerStatus(e3)), this.connection.on(ek.REQUEST_NEW_ADDRESS, (t3, r2) => {
            if (!this.connection)
              return r2(new tD(eD.UNEXPECTED_ERROR, "can not get new live streaming address list"));
            bG(this, tk.REQUEST_WORKER_MANAGER_LIST, e2).then((e3) => {
              this.uapResponse = e3, t3(e3.addressList);
            }).catch(r2);
          }), await this.connection.init(t2.addressList), this.connection;
        }
        handlePublishStreamServer(e2) {
          const t2 = e2.serverStatus && e2.serverStatus.url || "empty_url", r2 = this.streamingTasks.get(t2), i2 = e2.reason;
          switch (e2.code) {
            case rk.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
            case rk.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
            case rk.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
            case rk.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH: {
              const i3 = new tD(eD.LIVE_STREAMING_CDN_ERROR, "", { code: e2.code });
              if (r2)
                return dD.error(i3.toString()), this.onLiveStreamError && this.onLiveStreamError(t2, i3);
              if (!this.isStartingStreamingTask)
                return;
              this.statusError.set(t2, i3);
            }
            case rk.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: {
              const e3 = new tD(eD.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE, i2);
              return this.onLiveStreamWarning && this.onLiveStreamWarning(t2, e3);
            }
            case rk.LIVE_STREAM_RESPONSE_WORKER_LOST:
            case rk.LIVE_STREAM_RESPONSE_WORKER_QUIT: {
              var n2;
              if (!this.connection)
                return;
              this.connection.tryNextAddress();
              const t3 = Array.from(nV(n2 = this.streamingTasks).call(n2));
              for (const r3 of t3)
                r3.abortTask ? r3.abortTask() : (dD.warning("[".concat(this.spec.clientId, "] publish stream status code"), e2.code, "try to republish", r3.url), this.startLiveStreamingTask(r3.url, r3.mode, new tD(eD.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", { code: e2.code })).then(() => {
                  dD.debug("[".concat(this.spec.clientId, "] republish live stream success"), r3.url);
                }).catch((e3) => {
                  dD.error(e3.toString()), this.onLiveStreamError && this.onLiveStreamError(r3.url, e3);
                }));
              return;
            }
          }
        }
        handleInjectStreamServerStatus(e2) {
          const t2 = Number(e2.uid), r2 = e2.serverStatus && e2.serverStatus.url;
          switch (e2.code) {
            case 200:
              return void (this.onInjectStatusChange && this.onInjectStatusChange(JP.INJECT_STREAM_STATUS_START_SUCCESS, t2, r2));
            case 451:
              return this.onInjectStatusChange && this.onInjectStatusChange(JP.INJECT_STREAM_STATUS_START_ALREADY_EXISTS, t2, r2), void this.streamingTasks.delete(r2);
            case 453:
              return this.onInjectStatusChange && this.onInjectStatusChange(JP.INJECT_STREAM_STATUS_START_UNAUTHORIZED, t2, r2), void this.streamingTasks.delete(r2);
            case 470:
              return this.onInjectStatusChange && this.onInjectStatusChange(JP.INJECT_STREAM_STATUS_BROKEN, t2, r2), void this.streamingTasks.delete(r2);
            case 499:
              return this.onInjectStatusChange && this.onInjectStatusChange(JP.INJECT_STREAM_STATUS_START_TIMEOUT, t2, r2), void this.streamingTasks.delete(r2);
            default:
              return void dD.debug("inject stream server status", e2);
          }
        }
        hasUrl(e2) {
          return this.streamingTasks.has(e2);
        }
      }
      class YJ {
        constructor() {
          kO(this, "destChannelMediaInfos", /* @__PURE__ */ new Map()), kO(this, "srcChannelMediaInfo", void 0);
        }
        setSrcChannelInfo(e2) {
          Ik(e2), this.srcChannelMediaInfo = e2;
        }
        addDestChannelInfo(e2) {
          Ik(e2), this.destChannelMediaInfos.set(e2.channelName, e2);
        }
        removeDestChannelInfo(e2) {
          tP(e2), this.destChannelMediaInfos.delete(e2);
        }
        getSrcChannelMediaInfo() {
          return this.srcChannelMediaInfo;
        }
        getDestChannelMediaInfo() {
          return this.destChannelMediaInfos;
        }
      }
      function WJ(e2) {
        if (!(e2 instanceof YJ)) {
          return new tD(eD.INVALID_PARAMS, "Config should be instance of [ChannelMediaRelayConfiguration]").throw();
        }
        const t2 = e2.getSrcChannelMediaInfo(), r2 = e2.getDestChannelMediaInfo();
        if (!t2) {
          return new tD(eD.INVALID_PARAMS, "srcChannelMediaInfo should not be empty").throw();
        }
        if (r2.size === 0) {
          return new tD(eD.INVALID_PARAMS, "destChannelMediaInfo should not be empty").throw();
        }
      }
      class JJ extends ZN {
        constructor(e2, t2, r2) {
          super(), kO(this, "ws", void 0), kO(this, "requestId", 1), kO(this, "heartBeatTimer", void 0), kO(this, "joinInfo", void 0), kO(this, "clientId", void 0), kO(this, "onOpen", () => {
            this.emit("open"), this.startHeartBeatCheck();
          }), kO(this, "onClose", (e3) => {
            this.emit("close"), this.dispose();
          }), kO(this, "onMessage", (e3) => {
            const t3 = JSON.parse(e3.data);
            if (!t3 || t3.command !== "serverResponse" || !t3.requestId)
              return t3 && t3.command === "serverStatus" && t3.serverStatus && t3.serverStatus.command ? (this.emit("status", t3.serverStatus), void this.emit(t3.serverStatus.command, t3.serverStatus)) : void 0;
            this.emit("req_".concat(t3.requestId), t3);
          }), this.joinInfo = e2, this.clientId = t2, this.ws = new eJ("cross-channel-".concat(this.clientId), r2), this.ws.on(YP.RECONNECTING, () => {
            this.ws.reconnectMode = "retry", this.emit("reconnecting");
          }), this.ws.on(YP.CONNECTED, this.onOpen), this.ws.on(YP.ON_MESSAGE, this.onMessage), this.ws.on(YP.CLOSED, this.onClose);
        }
        isConnect() {
          return this.ws.state === "connected";
        }
        sendMessage(e2) {
          const t2 = this.requestId++;
          return e2.requestId = t2, e2.seq = t2, this.ws.sendMessage(e2), t2;
        }
        waitStatus(e2) {
          return new nR((t2, r2) => {
            const i2 = window.setTimeout(() => {
              r2(new tD(eD.TIMEOUT, "wait status timeout, status: ".concat(e2)));
            }, 5e3);
            this.once(e2, (n2) => {
              window.clearTimeout(i2), n2.state && n2.state !== 0 ? r2(new tD(eD.CROSS_CHANNEL_WAIT_STATUS_ERROR, "wait status error, status: ".concat(e2))) : t2(void 0);
            }), this.once("dispose", () => {
              window.clearTimeout(i2), r2(new tD(eD.WS_ABORT));
            });
          });
        }
        async request(e2) {
          if (this.ws.state === "closed")
            throw new tD(eD.WS_DISCONNECT);
          const t2 = () => new nR((e3, t3) => {
            this.ws.once(YP.CLOSED, () => t3(new tD(eD.WS_ABORT))), this.ws.once(YP.CONNECTED, e3);
          });
          this.ws.state !== "connected" && await t2();
          const r2 = this.sendMessage(e2), i2 = new nR((e3, t3) => {
            const i3 = () => {
              t3(new tD(eD.WS_ABORT));
            };
            this.ws.once(YP.RECONNECTING, i3), this.ws.once(YP.CLOSED, i3), this.once("req_".concat(r2), e3), CG(3e3).then(() => {
              this.removeAllListeners("req_".concat(r2)), this.ws.off(YP.RECONNECTING, i3), this.ws.off(YP.CLOSED, i3), t3(new tD(eD.TIMEOUT, "cross channel ws request timeout"));
            });
          }), n2 = await i2;
          if (!n2 || n2.code !== 200)
            throw new tD(eD.CROSS_CHANNEL_SERVER_ERROR_RESPONSE, "response: ".concat(JSON.stringify(n2)));
          return n2;
        }
        async connect(e2) {
          this.ws.removeAllListeners(YP.REQUEST_NEW_URLS), this.ws.on(YP.REQUEST_NEW_URLS, (t2) => {
            t2(e2);
          }), await this.ws.init(e2);
        }
        dispose() {
          this.clearHeartBeatCheck(), this.emit("dispose"), this.removeAllListeners(), this.ws.close();
        }
        sendPing(e2) {
          const t2 = this.requestId++;
          return e2.requestId = t2, this.ws.sendMessage(e2), t2;
        }
        startHeartBeatCheck() {
          this.heartBeatTimer = window.setInterval(() => {
            this.sendPing({ command: "ping", appId: this.joinInfo.appId, cname: this.joinInfo.cname, uid: this.joinInfo.uid.toString(), sid: this.joinInfo.sid, ts: +new Date(), requestId: 0 });
          }, 3e3);
        }
        clearHeartBeatCheck() {
          window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = void 0;
        }
      }
      class qJ extends ZN {
        set state(e2) {
          e2 !== this._state && (e2 !== sk.RELAY_STATE_FAILURE && (this.errorCode = ak.RELAY_OK), this.emit("state", e2, this.errorCode), this._state = e2);
        }
        get state() {
          return this._state;
        }
        constructor(e2, t2, r2, i2) {
          super(), kO(this, "joinInfo", void 0), kO(this, "clientId", void 0), kO(this, "cancelToken", zN.CancelToken.source()), kO(this, "workerToken", void 0), kO(this, "requestId", 0), kO(this, "signal", void 0), kO(this, "prevChannelMediaConfig", void 0), kO(this, "httpRetryConfig", void 0), kO(this, "_state", sk.RELAY_STATE_IDLE), kO(this, "errorCode", ak.RELAY_OK), kO(this, "onStatus", (e3) => {
            dD.debug("[".concat(this.clientId, "] ChannelMediaStatus: ").concat(JSON.stringify(e3))), e3 && e3.command && (e3.command === "onAudioPacketReceived" && this.emit("event", ok.PACKET_RECEIVED_AUDIO_FROM_SRC), e3.command === "onVideoPacketReceived" && this.emit("event", ok.PACKET_RECEIVED_VIDEO_FROM_SRC), e3.command === "onSrcTokenPrivilegeDidExpire" && (this.errorCode = ak.SRC_TOKEN_EXPIRED, this.state = sk.RELAY_STATE_FAILURE), e3.command === "onDestTokenPrivilegeDidExpire" && (this.errorCode = ak.DEST_TOKEN_EXPIRED, this.state = sk.RELAY_STATE_FAILURE));
          }), kO(this, "onReconnect", async () => {
            dD.debug("[".concat(this.clientId, "] ChannelMediaSocket disconnect, reconnecting")), this.emit("event", ok.NETWORK_DISCONNECTED), this.state = sk.RELAY_STATE_IDLE, this.prevChannelMediaConfig && this.sendStartRelayMessage(this.prevChannelMediaConfig).catch((e3) => {
              this.state !== sk.RELAY_STATE_IDLE && (dD.error("auto restart channel media relay failed", e3.toString()), this.errorCode = ak.SERVER_CONNECTION_LOST, this.state = sk.RELAY_STATE_FAILURE);
            });
          }), this.joinInfo = e2, this.clientId = t2, this.signal = new JJ(this.joinInfo, this.clientId, r2), this.httpRetryConfig = i2;
        }
        async startChannelMediaRelay(e2) {
          if (this.state !== sk.RELAY_STATE_IDLE)
            throw new tD(eD.INVALID_OPERATION);
          this.state = sk.RELAY_STATE_CONNECTING, await this.connect(), dD.debug("[".concat(this.clientId, "] startChannelMediaRelay: connect success"));
          try {
            await this.sendStartRelayMessage(e2);
          } catch (e3) {
            if (e3.data && e3.data.serverResponse && e3.data.serverResponse.command === "SetSourceChannel")
              throw new tD(eD.CROSS_CHANNEL_FAILED_JOIN_SRC);
            if (e3.data && e3.data.serverResponse && e3.serverResponse.command === "SetDestChannelStatus")
              throw new tD(eD.CROSS_CHANNEL_FAILED_JOIN_DEST);
            if (e3.data && e3.data.serverResponse && e3.serverResponse.command === "StartPacketTransfer")
              throw new tD(eD.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST);
            throw e3;
          }
          this.prevChannelMediaConfig = e2;
        }
        async updateChannelMediaRelay(e2) {
          if (this.state !== sk.RELAY_STATE_RUNNING)
            throw new tD(eD.INVALID_OPERATION);
          await this.sendUpdateMessage(e2), this.prevChannelMediaConfig = e2;
        }
        async stopChannelMediaRelay() {
          await this.sendStopRelayMessage(), dD.debug("[".concat(this.clientId, "] stopChannelMediaRelay: send stop message success")), this.state = sk.RELAY_STATE_IDLE, this.dispose();
        }
        dispose() {
          dD.debug("[".concat(this.clientId, "] disposeChannelMediaRelay")), this.cancelToken.cancel(), this.cancelToken = zN.CancelToken.source(), this.state = sk.RELAY_STATE_IDLE, this.emit("dispose"), this.signal.dispose(), this.prevChannelMediaConfig = void 0;
        }
        async connect() {
          const e2 = await kJ(this.joinInfo, this.cancelToken.token, this.httpRetryConfig);
          this.workerToken = e2.workerToken, await this.signal.connect(e2.addressList), this.emit("event", ok.NETWORK_CONNECTED), this.signal.on("status", this.onStatus), this.signal.on("reconnecting", this.onReconnect);
        }
        async sendStartRelayMessage(e2) {
          const t2 = this.genMessage(nk.StopPacketTransfer);
          await this.signal.request(t2), await this.signal.waitStatus("Normal Quit"), dD.debug("[".concat(this.clientId, "] startChannelMediaRelay: StopPacketTransfer success"));
          const r2 = this.genMessage(nk.SetSdkProfile, e2);
          await this.signal.request(r2), dD.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSdkProfile success"));
          const i2 = this.genMessage(nk.SetSourceChannel, e2);
          await this.signal.request(i2), await this.signal.waitStatus("SetSourceChannelStatus"), this.emit("event", ok.PACKET_JOINED_SRC_CHANNEL), dD.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceChannel success"));
          const n2 = this.genMessage(nk.SetSourceUserId, e2);
          await this.signal.request(n2), dD.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceUserId success"));
          const o2 = this.genMessage(nk.SetDestChannel, e2);
          await this.signal.request(o2), await this.signal.waitStatus("SetDestChannelStatus"), this.emit("event", ok.PACKET_JOINED_DEST_CHANNEL), dD.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetDestChannel success"));
          const s2 = this.genMessage(nk.StartPacketTransfer, e2);
          await this.signal.request(s2), this.emit("event", ok.PACKET_SENT_TO_DEST_CHANNEL), this.state = sk.RELAY_STATE_RUNNING, dD.debug("[".concat(this.clientId, "] startChannelMediaRelay: StartPacketTransfer success"));
        }
        async sendUpdateMessage(e2) {
          const t2 = this.genMessage(nk.UpdateDestChannel, e2);
          await this.signal.request(t2), this.emit("event", ok.PACKET_UPDATE_DEST_CHANNEL), dD.debug("[".concat(this.clientId, "] sendUpdateMessage: UpdateDestChannel success"));
        }
        async sendStopRelayMessage() {
          const e2 = this.genMessage(nk.StopPacketTransfer);
          await this.signal.request(e2), dD.debug("[".concat(this.clientId, "] sendStopRelayMessage: StopPacketTransfer success"));
        }
        genMessage(e2, t2) {
          const r2 = [], i2 = [], n2 = [];
          this.requestId += 1;
          const o2 = { appId: this.joinInfo.appId, cname: this.joinInfo.cname, uid: this.joinInfo.uid.toString(), sdkVersion: MD, sid: this.joinInfo.sid, ts: Date.now(), requestId: this.requestId, seq: this.requestId, allocate: true, clientRequest: {} };
          o2.sdkVersion === "4.11.1" && (o2.sdkVersion = "0.0.1");
          let s2 = null, a2 = null;
          switch (e2) {
            case nk.SetSdkProfile:
              return o2.clientRequest = { command: "SetSdkProfile", type: "multi_channel" }, o2;
            case nk.SetSourceChannel:
              if (a2 = t2 && t2.getSrcChannelMediaInfo(), !a2)
                throw new tD(eD.UNEXPECTED_ERROR, "can not find source config");
              return o2.clientRequest = { command: "SetSourceChannel", uid: "0", channelName: a2.channelName, token: a2.token || this.joinInfo.appId }, o2;
            case nk.SetSourceUserId:
              if (a2 = t2 && t2.getSrcChannelMediaInfo(), !a2)
                throw new tD(eD.UNEXPECTED_ERROR, "can not find source config");
              return o2.clientRequest = { command: "SetSourceUserId", uid: a2.uid + "" }, o2;
            case nk.SetDestChannel:
              if (s2 = t2 && t2.getDestChannelMediaInfo(), !s2)
                throw new tD(eD.UNEXPECTED_ERROR, "can not find dest config");
              return s2.forEach((e3) => {
                r2.push(e3.channelName), i2.push(e3.uid + ""), n2.push(e3.token || this.joinInfo.appId);
              }), o2.clientRequest = { command: "SetDestChannel", channelName: r2, uid: i2, token: n2 }, o2;
            case nk.StartPacketTransfer:
              return o2.clientRequest = { command: "StartPacketTransfer" }, o2;
            case nk.Reconnect:
              return o2.clientRequest = { command: "Reconnect" }, o2;
            case nk.StopPacketTransfer:
              return o2.clientRequest = { command: "StopPacketTransfer" }, o2;
            case nk.UpdateDestChannel:
              if (s2 = t2 && t2.getDestChannelMediaInfo(), !s2)
                throw new tD(eD.UNEXPECTED_ERROR, "can not find dest config");
              return s2.forEach((e3) => {
                r2.push(e3.channelName), i2.push(e3.uid + ""), n2.push(e3.token || this.joinInfo.appId);
              }), o2.clientRequest = { command: "UpdateDestChannel", channelName: r2, uid: i2, token: n2 }, o2;
          }
          return o2;
        }
      }
      var zJ;
      let XJ = PD("AgoraRTCPlayer", "trackId")(zJ = class {
        get videoElementStatus() {
          return this._videoElementStatus;
        }
        set videoElementStatus(e2) {
          e2 !== this._videoElementStatus && (dD.debug("[".concat(this.trackId, "] video-element-status change ").concat(this._videoElementStatus, " => ").concat(e2)), OD("debug", ["HTMLVideoElement", this.trackId], "statusChange", "".concat(this._videoElementStatus, " => ").concat(e2)), this._videoElementStatus = e2);
        }
        constructor(e2) {
          kO(this, "trackId", void 0), kO(this, "config", void 0), kO(this, "onFirstVideoFrameDecoded", void 0), kO(this, "freezeTimeCounterList", []), kO(this, "timeUpdatedCount", 0), kO(this, "freezeTime", 0), kO(this, "playbackTime", 0), kO(this, "lastTimeUpdatedTime", 0), kO(this, "videoTrack", void 0), kO(this, "container", void 0), kO(this, "videoElement", void 0), kO(this, "videoElementCheckInterval", void 0), kO(this, "_videoElementStatus", dP.NONE), kO(this, "slot", void 0), kO(this, "isGettingVideoDimensions", false), kO(this, "handleVideoEvents", (e3) => {
            switch (e3.type) {
              case "play":
              case "playing":
                this.startGetVideoDimensions(), this.videoElementStatus = dP.PLAYING;
                break;
              case "loadeddata":
                this.onFirstVideoFrameDecoded && this.onFirstVideoFrameDecoded();
                break;
              case "canplay":
                this.videoElementStatus = dP.CANPLAY;
                break;
              case "stalled":
                this.videoElementStatus = dP.STALLED;
                break;
              case "suspend":
                this.videoElementStatus = dP.SUSPEND;
                break;
              case "pause":
                this.videoElementStatus = dP.PAUSED, !fO() && !vO() && this.videoElement && this.videoTrack && this.videoTrack.readyState === "live" && (dD.debug("[track-".concat(this.trackId, "] video element paused, auto resume")), TD("debug", this, "video element paused, auto resume"), this.videoElement.play());
                break;
              case "waiting":
                this.videoElementStatus = dP.WAITING;
                break;
              case "abort":
                this.videoElementStatus = dP.ABORT;
                break;
              case "ended":
                this.videoElementStatus = dP.ENDED;
                break;
              case "emptied":
                this.videoElementStatus = dP.EMPTIED;
                break;
              case "timeupdate": {
                const e4 = Date.now();
                if (this.timeUpdatedCount += 1, this.timeUpdatedCount < 10)
                  return void (this.lastTimeUpdatedTime = e4);
                const t2 = e4 - this.lastTimeUpdatedTime;
                for (this.lastTimeUpdatedTime = e4, t2 > 500 && (this.freezeTime += t2), this.playbackTime += t2; this.playbackTime >= 6e3; )
                  this.playbackTime -= 6e3, this.freezeTimeCounterList.push(Math.min(6e3, this.freezeTime)), this.freezeTime = Math.max(0, this.freezeTime - 6e3);
                break;
              }
            }
          }), kO(this, "startGetVideoDimensions", () => {
            const e3 = () => {
              if (this.isGettingVideoDimensions = true, this.videoElement && this.videoElement.videoWidth * this.videoElement.videoHeight > 4)
                return dD.debug("[".concat(this.trackId, "] current video dimensions:"), this.videoElement.videoWidth, this.videoElement.videoHeight), ND("debug", this, "startGetVideoDimensions", { videoWidth: this.videoElement.videoWidth, videoHeight: this.videoElement.videoHeight }), void (this.isGettingVideoDimensions = false);
              setTimeout(e3, 500);
            };
            !this.isGettingVideoDimensions && e3();
          }), kO(this, "autoResumeAfterInterruption", () => {
            this.videoElement && this.videoTrack && this.videoTrack.readyState === "live" && VV.curState === "running" && (CO() ? (dD.debug("[track-".concat(this.trackId, "] video element paused, auto resume for iOS 15.2")), this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : _O() ? (dD.debug("[track-".concat(this.trackId, "] video element paused, auto resume for iOS 15.1")), this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : mO() && (dD.debug("[track-".concat(this.trackId, "] video element paused, auto resume for iOS 15.0")), this.videoElement.pause(), this.videoElement.play()));
          }), kO(this, "autoResumeAfterInterruptionOnIOS15", () => {
            this.videoElement && this.videoTrack && this.videoTrack.readyState === "live" && (CO() ? (dD.debug("[track-".concat(this.trackId, "] video element paused, auto resume for iOS 15.2")), this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : _O() ? (dD.debug("[track-".concat(this.trackId, "] video element paused, auto resume for iOS 15.1")), this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : mO() && (dD.debug("[track-".concat(this.trackId, "] video element paused, auto resume for iOS 15.0")), this.videoElement.pause(), this.videoElement.play()));
          }), this.slot = e2.element, this.trackId = e2.trackId, this.updateConfig(e2), VV.on(NV.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), VV.on(NV.IOS_15_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15);
        }
        updateConfig(e2) {
          this.config = e2, this.trackId = e2.trackId;
          const t2 = e2.element;
          t2 !== this.slot && (this.destroy(), this.slot = t2), this.createElements();
        }
        updateVideoTrack(e2) {
          this.videoTrack !== e2 && (this.videoTrack = e2, this.createElements());
        }
        play(e2) {
          if (this.videoElement) {
            const t2 = this.videoElement.play();
            t2 && t2.catch && t2.catch((t3) => {
              e2 && bV.autoplayFailed(e2, "video", t3.message, this.trackId), ND("warning", this, "play", t3.toString(), "error"), t3.name === "NotAllowedError" ? (dD.warning("detected video element autoplay failed", t3), this.handleAutoPlayFailed()) : dD.warning("[".concat(this.trackId, "] play warning: "), t3);
            });
            const r2 = oO();
            if ((r2.name === "Safari" && Number(r2.version) === 15 || IO()) && t2 && t2.then && t2.catch) {
              const e3 = () => {
                this.config.mirror && this.videoElement && (this.videoElement.style.transform = "rotateY(180deg)");
              };
              t2.then(e3).catch(e3);
            }
          }
        }
        getCurrentFrame() {
          if (!this.videoElement)
            return new ImageData(2, 2);
          const e2 = document.createElement("canvas");
          e2.width = this.videoElement.videoWidth, e2.height = this.videoElement.videoHeight;
          const t2 = e2.getContext("2d");
          if (!t2)
            return dD.error("create canvas context failed!"), ND("error", this, "getCurrentFrame", "create canvas context failed!", "error"), new ImageData(2, 2);
          t2.drawImage(this.videoElement, 0, 0, e2.width, e2.height);
          const r2 = t2.getImageData(0, 0, e2.width, e2.height);
          return e2.remove(), r2;
        }
        destroy() {
          if (VV.off(NV.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), VV.off(NV.IOS_15_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15), this.videoElement && (this.videoElement.srcObject = null, this.videoElement.remove(), this.videoElement = void 0), this.container) {
            try {
              this.container.remove(), this.slot.removeChild(this.container);
            } catch (e2) {
            }
            this.container = void 0;
          }
          this.freezeTimeCounterList = [];
        }
        createElements() {
          this.container || (this.container = document.createElement("div")), this.container.id = "agora-video-player-".concat(this.trackId), this.container.style.width = "100%", this.container.style.height = "100%", this.container.style.position = "relative", this.container.style.overflow = "hidden", this.videoTrack ? (this.container.style.backgroundColor = "black", this.createVideoElement(), this.container.appendChild(this.videoElement)) : this.removeVideoElement(), this.slot.appendChild(this.container);
        }
        createVideoElement() {
          this.videoElement || (this.videoElementStatus = dP.INIT, this.videoElement = document.createElement("video"), this.videoElement.onerror = () => this.videoElementStatus = dP.ERROR, this.container && this.container.appendChild(this.videoElement), ZJ.forEach((e3) => {
            this.videoElement && this.videoElement.addEventListener(e3, this.handleVideoEvents);
          }), this.videoElementCheckInterval = window.setInterval(() => {
            !document.getElementById("video_".concat(this.trackId)) && this.videoElement && (this.videoElementStatus = dP.DESTROYED);
          }, 1e3)), this.videoElement.id = "video_".concat(this.trackId), this.videoElement.className = "agora_video_player", this.videoElement.style.width = "100%", this.videoElement.style.height = "100%", this.videoElement.style.position = "absolute", this.videoElement.controls = false, this.videoElement.setAttribute("playsinline", ""), this.videoElement.style.left = "0", this.videoElement.style.top = "0";
          const e2 = oO();
          if (e2.name === "Safari" && Number(e2.version) === 15 || IO() || !this.config.mirror || (this.videoElement.style.transform = "rotateY(180deg)"), this.config.fit ? this.videoElement.style.objectFit = this.config.fit : this.videoElement.style.objectFit = "cover", this.videoElement.setAttribute("muted", ""), this.videoElement.muted = true, this.videoElement.srcObject && this.videoElement.srcObject instanceof MediaStream) {
            this.videoElement.srcObject.getVideoTracks()[0] !== this.videoTrack && (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, gO() && this.videoElement.load());
          } else
            this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, gO() && this.videoElement.load();
          const t2 = this.videoElement.play();
          t2 !== void 0 && t2.catch((e3) => {
            dD.debug("[".concat(this.trackId, "] playback interrupted"), e3.toString()), TD("debug", this, "play back interrupted: ".concat(e3.toString()));
          });
        }
        removeVideoElement() {
          if (this.videoElement) {
            ZJ.forEach((e2) => {
              this.videoElement && this.videoElement.removeEventListener(e2, this.handleVideoEvents);
            }), this.videoElementCheckInterval && (window.clearInterval(this.videoElementCheckInterval), this.videoElementCheckInterval = void 0);
            try {
              this.container && this.container.removeChild(this.videoElement);
            } catch (e2) {
            }
            this.videoElement = void 0, this.videoElementStatus = dP.NONE;
          }
        }
        handleAutoPlayFailed() {
          const e2 = oO();
          if (this.videoElement) {
            const t2 = (r2) => {
              r2.preventDefault(), this.videoElement && (this.videoElement.play().then(() => {
                dD.debug("[".concat(this.trackId, "] Video element for trackId:").concat(this.trackId, " autoplay resumed.")), TD("debug", this, "video element autoplay resumed");
              }).catch((e3) => {
                dD.error(e3);
              }), e2.os !== "Android" || e2.name !== "Chrome" && e2.name !== tO.WECHAT ? (document.body.removeEventListener("touchstart", t2, true), document.body.removeEventListener("mousedown", t2, true)) : document.body.removeEventListener("click", t2, true));
            };
            e2.os !== "Android" || e2.name !== "Chrome" && e2.name !== tO.WECHAT ? (document.body.addEventListener("touchstart", t2, true), document.body.addEventListener("mousedown", t2, true)) : document.body.addEventListener("click", t2, true), vV();
          }
        }
        getVideoElement() {
          return this.videoElement;
        }
        getContainerElement() {
          return this.container;
        }
      }) || zJ;
      const ZJ = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended", "timeupdate"];
      var $J = { exports: {} };
      function eq(e2, t2, r2) {
        const i2 = e2.createShader(r2);
        if (!i2) {
          return new tD(eD.WEBGL_INTERNAL_ERROR, "can not create shader").throw();
        }
        e2.shaderSource(i2, t2), e2.compileShader(i2);
        if (!e2.getShaderParameter(i2, e2.COMPILE_STATUS)) {
          const t3 = e2.getShaderInfoLog(i2);
          e2.deleteShader(i2);
          return new tD(eD.WEBGL_INTERNAL_ERROR, "error compiling shader:" + t3).throw();
        }
        return i2;
      }
      function tq(e2, t2, r2, i2) {
        const n2 = [];
        for (let r3 = 0; r3 < t2.length; ++r3) {
          const i3 = r3 === 0 ? e2.VERTEX_SHADER : e2.FRAGMENT_SHADER;
          n2.push(eq(e2, t2[r3], i3));
        }
        return function(e3, t3, r3, i3) {
          const n3 = e3.createProgram();
          if (!n3)
            throw new tD(eD.WEBGL_INTERNAL_ERROR, "can not create webgl program");
          if (t3.forEach((t4) => {
            e3.attachShader(n3, t4);
          }), r3 && r3.forEach((t4, r4) => {
            e3.bindAttribLocation(n3, i3 ? i3[r4] : r4, t4);
          }), e3.linkProgram(n3), !e3.getProgramParameter(n3, e3.LINK_STATUS)) {
            const t4 = e3.getProgramInfoLog(n3);
            throw e3.deleteProgram(n3), new tD(eD.WEBGL_INTERNAL_ERROR, "error in program linking:" + t4);
          }
          return n3;
        }(e2, n2, r2, i2);
      }
      !function(e2, t2) {
        self, e2.exports = (() => {
          var e3 = { 3476: (e4, t4, r3) => {
            e4.exports = r3(7460);
          }, 4341: (e4, t4, r3) => {
            e4.exports = r3(3685);
          }, 3536: (e4, t4, r3) => {
            var i3 = r3(1910);
            e4.exports = i3;
          }, 8171: (e4, t4, r3) => {
            r3(6450);
            var i3 = r3(4058).Object, n2 = e4.exports = function(e5, t5, r4) {
              return i3.defineProperty(e5, t5, r4);
            };
            i3.defineProperty.sham && (n2.sham = true);
          }, 2956: (e4, t4, r3) => {
            r3(7627), r3(6274), r3(5967), r3(8881), r3(4560), r3(7206), r3(4349), r3(7971);
            var i3 = r3(4058);
            e4.exports = i3.Promise;
          }, 3685: (e4, t4, r3) => {
            var i3 = r3(3536);
            e4.exports = i3;
          }, 4883: (e4, t4, r3) => {
            var i3 = r3(1899), n2 = r3(7475), o2 = r3(9826), s2 = i3.TypeError;
            e4.exports = function(e5) {
              if (n2(e5))
                return e5;
              throw s2(o2(e5) + " is not a function");
            };
          }, 174: (e4, t4, r3) => {
            var i3 = r3(1899), n2 = r3(4284), o2 = r3(9826), s2 = i3.TypeError;
            e4.exports = function(e5) {
              if (n2(e5))
                return e5;
              throw s2(o2(e5) + " is not a constructor");
            };
          }, 1851: (e4, t4, r3) => {
            var i3 = r3(1899), n2 = r3(7475), o2 = i3.String, s2 = i3.TypeError;
            e4.exports = function(e5) {
              if (typeof e5 == "object" || n2(e5))
                return e5;
              throw s2("Can't set " + o2(e5) + " as a prototype");
            };
          }, 8479: (e4) => {
            e4.exports = function() {
            };
          }, 5743: (e4, t4, r3) => {
            var i3 = r3(1899), n2 = r3(7046), o2 = i3.TypeError;
            e4.exports = function(e5, t5) {
              if (n2(t5, e5))
                return e5;
              throw o2("Incorrect invocation");
            };
          }, 6059: (e4, t4, r3) => {
            var i3 = r3(1899), n2 = r3(941), o2 = i3.String, s2 = i3.TypeError;
            e4.exports = function(e5) {
              if (n2(e5))
                return e5;
              throw s2(o2(e5) + " is not an object");
            };
          }, 1692: (e4, t4, r3) => {
            var i3 = r3(4529), n2 = r3(9413), o2 = r3(623), s2 = function(e5) {
              return function(t5, r4, s3) {
                var a2, c2 = i3(t5), d2 = o2(c2), u2 = n2(s3, d2);
                if (e5 && r4 != r4) {
                  for (; d2 > u2; )
                    if ((a2 = c2[u2++]) != a2)
                      return true;
                } else
                  for (; d2 > u2; u2++)
                    if ((e5 || u2 in c2) && c2[u2] === r4)
                      return e5 || u2 || 0;
                return !e5 && -1;
              };
            };
            e4.exports = { includes: s2(true), indexOf: s2(false) };
          }, 3765: (e4, t4, r3) => {
            var i3 = r3(5329);
            e4.exports = i3([].slice);
          }, 1385: (e4, t4, r3) => {
            var i3 = r3(9813)("iterator"), n2 = false;
            try {
              var o2 = 0, s2 = { next: function() {
                return { done: !!o2++ };
              }, return: function() {
                n2 = true;
              } };
              s2[i3] = function() {
                return this;
              }, Array.from(s2, function() {
                throw 2;
              });
            } catch (e5) {
            }
            e4.exports = function(e5, t5) {
              if (!t5 && !n2)
                return false;
              var r4 = false;
              try {
                var o3 = {};
                o3[i3] = function() {
                  return { next: function() {
                    return { done: r4 = true };
                  } };
                }, e5(o3);
              } catch (e6) {
              }
              return r4;
            };
          }, 2532: (e4, t4, r3) => {
            var i3 = r3(5329), n2 = i3({}.toString), o2 = i3("".slice);
            e4.exports = function(e5) {
              return o2(n2(e5), 8, -1);
            };
          }, 9697: (e4, t4, r3) => {
            var i3 = r3(1899), n2 = r3(2885), o2 = r3(7475), s2 = r3(2532), a2 = r3(9813)("toStringTag"), c2 = i3.Object, d2 = s2(function() {
              return arguments;
            }()) == "Arguments";
            e4.exports = n2 ? s2 : function(e5) {
              var t5, r4, i4;
              return e5 === void 0 ? "Undefined" : e5 === null ? "Null" : typeof (r4 = function(e6, t6) {
                try {
                  return e6[t6];
                } catch (e7) {
                }
              }(t5 = c2(e5), a2)) == "string" ? r4 : d2 ? s2(t5) : (i4 = s2(t5)) == "Object" && o2(t5.callee) ? "Arguments" : i4;
            };
          }, 8694: (e4, t4, r3) => {
            var i3 = r3(5329)("".replace), n2 = String(Error("zxcasd").stack), o2 = /\n\s*at [^:]*:[^\n]*/, s2 = o2.test(n2);
            e4.exports = function(e5, t5) {
              if (s2 && typeof e5 == "string")
                for (; t5--; )
                  e5 = i3(e5, o2, "");
              return e5;
            };
          }, 3489: (e4, t4, r3) => {
            var i3 = r3(953), n2 = r3(1136), o2 = r3(9677), s2 = r3(5988);
            e4.exports = function(e5, t5, r4) {
              for (var a2 = n2(t5), c2 = s2.f, d2 = o2.f, u2 = 0; u2 < a2.length; u2++) {
                var A2 = a2[u2];
                i3(e5, A2) || r4 && i3(r4, A2) || c2(e5, A2, d2(t5, A2));
              }
            };
          }, 4160: (e4, t4, r3) => {
            var i3 = r3(5981);
            e4.exports = !i3(function() {
              function e5() {
              }
              return e5.prototype.constructor = null, Object.getPrototypeOf(new e5()) !== e5.prototype;
            });
          }, 1046: (e4, t4, r3) => {
            var i3 = r3(5143).IteratorPrototype, n2 = r3(9290), o2 = r3(1887), s2 = r3(904), a2 = r3(2077), c2 = function() {
              return this;
            };
            e4.exports = function(e5, t5, r4, d2) {
              var u2 = t5 + " Iterator";
              return e5.prototype = n2(i3, { next: o2(+!d2, r4) }), s2(e5, u2, false, true), a2[u2] = c2, e5;
            };
          }, 2029: (e4, t4, r3) => {
            var i3 = r3(5746), n2 = r3(5988), o2 = r3(1887);
            e4.exports = i3 ? function(e5, t5, r4) {
              return n2.f(e5, t5, o2(1, r4));
            } : function(e5, t5, r4) {
              return e5[t5] = r4, e5;
            };
          }, 1887: (e4) => {
            e4.exports = function(e5, t4) {
              return { enumerable: !(1 & e5), configurable: !(2 & e5), writable: !(4 & e5), value: t4 };
            };
          }, 7771: (e4, t4, r3) => {
            var i3 = r3(6887), n2 = r3(8834), o2 = r3(2529), s2 = r3(9417), a2 = r3(7475), c2 = r3(1046), d2 = r3(249), u2 = r3(8929), A2 = r3(904), h2 = r3(2029), l2 = r3(9754), p2 = r3(9813), g2 = r3(2077), f2 = r3(5143), E2 = s2.PROPER, I2 = s2.CONFIGURABLE, m2 = f2.IteratorPrototype, _2 = f2.BUGGY_SAFARI_ITERATORS, C2 = p2("iterator"), v2 = "keys", S2 = "values", R2 = "entries", y2 = function() {
              return this;
            };
            e4.exports = function(e5, t5, r4, s3, p3, f3, T2) {
              c2(r4, t5, s3);
              var w2, b2, O2, N2 = function(e6) {
                if (e6 === p3 && B2)
                  return B2;
                if (!_2 && e6 in P2)
                  return P2[e6];
                switch (e6) {
                  case v2:
                  case S2:
                  case R2:
                    return function() {
                      return new r4(this, e6);
                    };
                }
                return function() {
                  return new r4(this);
                };
              }, D2 = t5 + " Iterator", L2 = false, P2 = e5.prototype, k2 = P2[C2] || P2["@@iterator"] || p3 && P2[p3], B2 = !_2 && k2 || N2(p3), M2 = t5 == "Array" && P2.entries || k2;
              if (M2 && (w2 = d2(M2.call(new e5()))) !== Object.prototype && w2.next && (o2 || d2(w2) === m2 || (u2 ? u2(w2, m2) : a2(w2[C2]) || l2(w2, C2, y2)), A2(w2, D2, true, true), o2 && (g2[D2] = y2)), E2 && p3 == S2 && k2 && k2.name !== S2 && (!o2 && I2 ? h2(P2, "name", S2) : (L2 = true, B2 = function() {
                return n2(k2, this);
              })), p3)
                if (b2 = { values: N2(S2), keys: f3 ? B2 : N2(v2), entries: N2(R2) }, T2)
                  for (O2 in b2)
                    (_2 || L2 || !(O2 in P2)) && l2(P2, O2, b2[O2]);
                else
                  i3({ target: t5, proto: true, forced: _2 || L2 }, b2);
              return o2 && !T2 || P2[C2] === B2 || l2(P2, C2, B2, { name: p3 }), g2[t5] = B2, b2;
            };
          }, 5746: (e4, t4, r3) => {
            var i3 = r3(5981);
            e4.exports = !i3(function() {
              return Object.defineProperty({}, 1, { get: function() {
                return 7;
              } })[1] != 7;
            });
          }, 1333: (e4, t4, r3) => {
            var i3 = r3(1899), n2 = r3(941), o2 = i3.document, s2 = n2(o2) && n2(o2.createElement);
            e4.exports = function(e5) {
              return s2 ? o2.createElement(e5) : {};
            };
          }, 3281: (e4) => {
            e4.exports = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 };
          }, 3321: (e4) => {
            e4.exports = typeof window == "object";
          }, 4470: (e4, t4, r3) => {
            var i3 = r3(2861), n2 = r3(1899);
            e4.exports = /ipad|iphone|ipod/i.test(i3) && n2.Pebble !== void 0;
          }, 2749: (e4, t4, r3) => {
            var i3 = r3(2861);
            e4.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(i3);
          }, 6049: (e4, t4, r3) => {
            var i3 = r3(2532), n2 = r3(1899);
            e4.exports = i3(n2.process) == "process";
          }, 8045: (e4, t4, r3) => {
            var i3 = r3(2861);
            e4.exports = /web0s(?!.*chrome)/i.test(i3);
          }, 2861: (e4, t4, r3) => {
            var i3 = r3(626);
            e4.exports = i3("navigator", "userAgent") || "";
          }, 3385: (e4, t4, r3) => {
            var i3, n2, o2 = r3(1899), s2 = r3(2861), a2 = o2.process, c2 = o2.Deno, d2 = a2 && a2.versions || c2 && c2.version, u2 = d2 && d2.v8;
            u2 && (n2 = (i3 = u2.split("."))[0] > 0 && i3[0] < 4 ? 1 : +(i3[0] + i3[1])), !n2 && s2 && (!(i3 = s2.match(/Edge\/(\d+)/)) || i3[1] >= 74) && (i3 = s2.match(/Chrome\/(\d+)/)) && (n2 = +i3[1]), e4.exports = n2;
          }, 6759: (e4) => {
            e4.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
          }, 8780: (e4, t4, r3) => {
            var i3 = r3(5981), n2 = r3(1887);
            e4.exports = !i3(function() {
              var e5 = Error("a");
              return !("stack" in e5) || (Object.defineProperty(e5, "stack", n2(1, 7)), e5.stack !== 7);
            });
          }, 6887: (e4, t4, r3) => {
            var i3 = r3(1899), n2 = r3(9730), o2 = r3(5329), s2 = r3(7475), a2 = r3(9677).f, c2 = r3(7252), d2 = r3(4058), u2 = r3(6843), A2 = r3(2029), h2 = r3(953), l2 = function(e5) {
              var t5 = function(r4, i4, o3) {
                if (this instanceof t5) {
                  switch (arguments.length) {
                    case 0:
                      return new e5();
                    case 1:
                      return new e5(r4);
                    case 2:
                      return new e5(r4, i4);
                  }
                  return new e5(r4, i4, o3);
                }
                return n2(e5, this, arguments);
              };
              return t5.prototype = e5.prototype, t5;
            };
            e4.exports = function(e5, t5) {
              var r4, n3, p2, g2, f2, E2, I2, m2, _2 = e5.target, C2 = e5.global, v2 = e5.stat, S2 = e5.proto, R2 = C2 ? i3 : v2 ? i3[_2] : (i3[_2] || {}).prototype, y2 = C2 ? d2 : d2[_2] || A2(d2, _2, {})[_2], T2 = y2.prototype;
              for (p2 in t5)
                r4 = !c2(C2 ? p2 : _2 + (v2 ? "." : "#") + p2, e5.forced) && R2 && h2(R2, p2), f2 = y2[p2], r4 && (E2 = e5.noTargetGet ? (m2 = a2(R2, p2)) && m2.value : R2[p2]), g2 = r4 && E2 ? E2 : t5[p2], r4 && typeof f2 == typeof g2 || (I2 = e5.bind && r4 ? u2(g2, i3) : e5.wrap && r4 ? l2(g2) : S2 && s2(g2) ? o2(g2) : g2, (e5.sham || g2 && g2.sham || f2 && f2.sham) && A2(I2, "sham", true), A2(y2, p2, I2), S2 && (h2(d2, n3 = _2 + "Prototype") || A2(d2, n3, {}), A2(d2[n3], p2, g2), e5.real && T2 && !T2[p2] && A2(T2, p2, g2)));
            };
          }, 5981: (e4) => {
            e4.exports = function(e5) {
              try {
                return !!e5();
              } catch (e6) {
                return true;
              }
            };
          }, 9730: (e4, t4, r3) => {
            var i3 = r3(8285), n2 = Function.prototype, o2 = n2.apply, s2 = n2.call;
            e4.exports = typeof Reflect == "object" && Reflect.apply || (i3 ? s2.bind(o2) : function() {
              return s2.apply(o2, arguments);
            });
          }, 6843: (e4, t4, r3) => {
            var i3 = r3(5329), n2 = r3(4883), o2 = r3(8285), s2 = i3(i3.bind);
            e4.exports = function(e5, t5) {
              return n2(e5), t5 === void 0 ? e5 : o2 ? s2(e5, t5) : function() {
                return e5.apply(t5, arguments);
              };
            };
          }, 8285: (e4, t4, r3) => {
            var i3 = r3(5981);
            e4.exports = !i3(function() {
              var e5 = function() {
              }.bind();
              return typeof e5 != "function" || e5.hasOwnProperty("prototype");
            });
          }, 8834: (e4, t4, r3) => {
            var i3 = r3(8285), n2 = Function.prototype.call;
            e4.exports = i3 ? n2.bind(n2) : function() {
              return n2.apply(n2, arguments);
            };
          }, 9417: (e4, t4, r3) => {
            var i3 = r3(5746), n2 = r3(953), o2 = Function.prototype, s2 = i3 && Object.getOwnPropertyDescriptor, a2 = n2(o2, "name"), c2 = a2 && function() {
            }.name === "something", d2 = a2 && (!i3 || i3 && s2(o2, "name").configurable);
            e4.exports = { EXISTS: a2, PROPER: c2, CONFIGURABLE: d2 };
          }, 5329: (e4, t4, r3) => {
            var i3 = r3(8285), n2 = Function.prototype, o2 = n2.bind, s2 = n2.call, a2 = i3 && o2.bind(s2, s2);
            e4.exports = i3 ? function(e5) {
              return e5 && a2(e5);
            } : function(e5) {
              return e5 && function() {
                return s2.apply(e5, arguments);
              };
            };
          }, 626: (e4, t4, r3) => {
            var i3 = r3(4058), n2 = r3(1899), o2 = r3(7475), s2 = function(e5) {
              return o2(e5) ? e5 : void 0;
            };
            e4.exports = function(e5, t5) {
              return arguments.length < 2 ? s2(i3[e5]) || s2(n2[e5]) : i3[e5] && i3[e5][t5] || n2[e5] && n2[e5][t5];
            };
          }, 2902: (e4, t4, r3) => {
            var i3 = r3(9697), n2 = r3(4229), o2 = r3(2077), s2 = r3(9813)("iterator");
            e4.exports = function(e5) {
              if (e5 != null)
                return n2(e5, s2) || n2(e5, "@@iterator") || o2[i3(e5)];
            };
          }, 429: (e4, t4, r3) => {
            var i3 = r3(1899), n2 = r3(8834), o2 = r3(4883), s2 = r3(6059), a2 = r3(9826), c2 = r3(2902), d2 = i3.TypeError;
            e4.exports = function(e5, t5) {
              var r4 = arguments.length < 2 ? c2(e5) : t5;
              if (o2(r4))
                return s2(n2(r4, e5));
              throw d2(a2(e5) + " is not iterable");
            };
          }, 4229: (e4, t4, r3) => {
            var i3 = r3(4883);
            e4.exports = function(e5, t5) {
              var r4 = e5[t5];
              return r4 == null ? void 0 : i3(r4);
            };
          }, 1899: (e4, t4, r3) => {
            var i3 = function(e5) {
              return e5 && e5.Math == Math && e5;
            };
            e4.exports = i3(typeof globalThis == "object" && globalThis) || i3(typeof window == "object" && window) || i3(typeof self == "object" && self) || i3(typeof r3.g == "object" && r3.g) || function() {
              return this;
            }() || Function("return this")();
          }, 953: (e4, t4, r3) => {
            var i3 = r3(5329), n2 = r3(9678), o2 = i3({}.hasOwnProperty);
            e4.exports = Object.hasOwn || function(e5, t5) {
              return o2(n2(e5), t5);
            };
          }, 7748: (e4) => {
            e4.exports = {};
          }, 4845: (e4, t4, r3) => {
            var i3 = r3(1899);
            e4.exports = function(e5, t5) {
              var r4 = i3.console;
              r4 && r4.error && (arguments.length == 1 ? r4.error(e5) : r4.error(e5, t5));
            };
          }, 5463: (e4, t4, r3) => {
            var i3 = r3(626);
            e4.exports = i3("document", "documentElement");
          }, 2840: (e4, t4, r3) => {
            var i3 = r3(5746), n2 = r3(5981), o2 = r3(1333);
            e4.exports = !i3 && !n2(function() {
              return Object.defineProperty(o2("div"), "a", { get: function() {
                return 7;
              } }).a != 7;
            });
          }, 7026: (e4, t4, r3) => {
            var i3 = r3(1899), n2 = r3(5329), o2 = r3(5981), s2 = r3(2532), a2 = i3.Object, c2 = n2("".split);
            e4.exports = o2(function() {
              return !a2("z").propertyIsEnumerable(0);
            }) ? function(e5) {
              return s2(e5) == "String" ? c2(e5, "") : a2(e5);
            } : a2;
          }, 1302: (e4, t4, r3) => {
            var i3 = r3(5329), n2 = r3(7475), o2 = r3(3030), s2 = i3(Function.toString);
            n2(o2.inspectSource) || (o2.inspectSource = function(e5) {
              return s2(e5);
            }), e4.exports = o2.inspectSource;
          }, 3794: (e4, t4, r3) => {
            var i3 = r3(941), n2 = r3(2029);
            e4.exports = function(e5, t5) {
              i3(t5) && "cause" in t5 && n2(e5, "cause", t5.cause);
            };
          }, 5402: (e4, t4, r3) => {
            var i3, n2, o2, s2 = r3(8019), a2 = r3(1899), c2 = r3(5329), d2 = r3(941), u2 = r3(2029), A2 = r3(953), h2 = r3(3030), l2 = r3(4262), p2 = r3(7748), g2 = "Object already initialized", f2 = a2.TypeError, E2 = a2.WeakMap;
            if (s2 || h2.state) {
              var I2 = h2.state || (h2.state = new E2()), m2 = c2(I2.get), _2 = c2(I2.has), C2 = c2(I2.set);
              i3 = function(e5, t5) {
                if (_2(I2, e5))
                  throw new f2(g2);
                return t5.facade = e5, C2(I2, e5, t5), t5;
              }, n2 = function(e5) {
                return m2(I2, e5) || {};
              }, o2 = function(e5) {
                return _2(I2, e5);
              };
            } else {
              var v2 = l2("state");
              p2[v2] = true, i3 = function(e5, t5) {
                if (A2(e5, v2))
                  throw new f2(g2);
                return t5.facade = e5, u2(e5, v2, t5), t5;
              }, n2 = function(e5) {
                return A2(e5, v2) ? e5[v2] : {};
              }, o2 = function(e5) {
                return A2(e5, v2);
              };
            }
            e4.exports = { set: i3, get: n2, has: o2, enforce: function(e5) {
              return o2(e5) ? n2(e5) : i3(e5, {});
            }, getterFor: function(e5) {
              return function(t5) {
                var r4;
                if (!d2(t5) || (r4 = n2(t5)).type !== e5)
                  throw f2("Incompatible receiver, " + e5 + " required");
                return r4;
              };
            } };
          }, 6782: (e4, t4, r3) => {
            var i3 = r3(9813), n2 = r3(2077), o2 = i3("iterator"), s2 = Array.prototype;
            e4.exports = function(e5) {
              return e5 !== void 0 && (n2.Array === e5 || s2[o2] === e5);
            };
          }, 7475: (e4) => {
            e4.exports = function(e5) {
              return typeof e5 == "function";
            };
          }, 4284: (e4, t4, r3) => {
            var i3 = r3(5329), n2 = r3(5981), o2 = r3(7475), s2 = r3(9697), a2 = r3(626), c2 = r3(1302), d2 = function() {
            }, u2 = [], A2 = a2("Reflect", "construct"), h2 = /^\s*(?:class|function)\b/, l2 = i3(h2.exec), p2 = !h2.exec(d2), g2 = function(e5) {
              if (!o2(e5))
                return false;
              try {
                return A2(d2, u2, e5), true;
              } catch (e6) {
                return false;
              }
            }, f2 = function(e5) {
              if (!o2(e5))
                return false;
              switch (s2(e5)) {
                case "AsyncFunction":
                case "GeneratorFunction":
                case "AsyncGeneratorFunction":
                  return false;
              }
              try {
                return p2 || !!l2(h2, c2(e5));
              } catch (e6) {
                return true;
              }
            };
            f2.sham = true, e4.exports = !A2 || n2(function() {
              var e5;
              return g2(g2.call) || !g2(Object) || !g2(function() {
                e5 = true;
              }) || e5;
            }) ? f2 : g2;
          }, 7252: (e4, t4, r3) => {
            var i3 = r3(5981), n2 = r3(7475), o2 = /#|\.prototype\./, s2 = function(e5, t5) {
              var r4 = c2[a2(e5)];
              return r4 == u2 || r4 != d2 && (n2(t5) ? i3(t5) : !!t5);
            }, a2 = s2.normalize = function(e5) {
              return String(e5).replace(o2, ".").toLowerCase();
            }, c2 = s2.data = {}, d2 = s2.NATIVE = "N", u2 = s2.POLYFILL = "P";
            e4.exports = s2;
          }, 941: (e4, t4, r3) => {
            var i3 = r3(7475);
            e4.exports = function(e5) {
              return typeof e5 == "object" ? e5 !== null : i3(e5);
            };
          }, 2529: (e4) => {
            e4.exports = true;
          }, 6664: (e4, t4, r3) => {
            var i3 = r3(1899), n2 = r3(626), o2 = r3(7475), s2 = r3(7046), a2 = r3(2302), c2 = i3.Object;
            e4.exports = a2 ? function(e5) {
              return typeof e5 == "symbol";
            } : function(e5) {
              var t5 = n2("Symbol");
              return o2(t5) && s2(t5.prototype, c2(e5));
            };
          }, 3091: (e4, t4, r3) => {
            var i3 = r3(1899), n2 = r3(6843), o2 = r3(8834), s2 = r3(6059), a2 = r3(9826), c2 = r3(6782), d2 = r3(623), u2 = r3(7046), A2 = r3(429), h2 = r3(2902), l2 = r3(7609), p2 = i3.TypeError, g2 = function(e5, t5) {
              this.stopped = e5, this.result = t5;
            }, f2 = g2.prototype;
            e4.exports = function(e5, t5, r4) {
              var i4, E2, I2, m2, _2, C2, v2, S2 = r4 && r4.that, R2 = !(!r4 || !r4.AS_ENTRIES), y2 = !(!r4 || !r4.IS_ITERATOR), T2 = !(!r4 || !r4.INTERRUPTED), w2 = n2(t5, S2), b2 = function(e6) {
                return i4 && l2(i4, "normal", e6), new g2(true, e6);
              }, O2 = function(e6) {
                return R2 ? (s2(e6), T2 ? w2(e6[0], e6[1], b2) : w2(e6[0], e6[1])) : T2 ? w2(e6, b2) : w2(e6);
              };
              if (y2)
                i4 = e5;
              else {
                if (!(E2 = h2(e5)))
                  throw p2(a2(e5) + " is not iterable");
                if (c2(E2)) {
                  for (I2 = 0, m2 = d2(e5); m2 > I2; I2++)
                    if ((_2 = O2(e5[I2])) && u2(f2, _2))
                      return _2;
                  return new g2(false);
                }
                i4 = A2(e5, E2);
              }
              for (C2 = i4.next; !(v2 = o2(C2, i4)).done; ) {
                try {
                  _2 = O2(v2.value);
                } catch (e6) {
                  l2(i4, "throw", e6);
                }
                if (typeof _2 == "object" && _2 && u2(f2, _2))
                  return _2;
              }
              return new g2(false);
            };
          }, 7609: (e4, t4, r3) => {
            var i3 = r3(8834), n2 = r3(6059), o2 = r3(4229);
            e4.exports = function(e5, t5, r4) {
              var s2, a2;
              n2(e5);
              try {
                if (!(s2 = o2(e5, "return"))) {
                  if (t5 === "throw")
                    throw r4;
                  return r4;
                }
                s2 = i3(s2, e5);
              } catch (e6) {
                a2 = true, s2 = e6;
              }
              if (t5 === "throw")
                throw r4;
              if (a2)
                throw s2;
              return n2(s2), r4;
            };
          }, 5143: (e4, t4, r3) => {
            var i3, n2, o2, s2 = r3(5981), a2 = r3(7475), c2 = r3(9290), d2 = r3(249), u2 = r3(9754), A2 = r3(9813), h2 = r3(2529), l2 = A2("iterator"), p2 = false;
            [].keys && ("next" in (o2 = [].keys()) ? (n2 = d2(d2(o2))) !== Object.prototype && (i3 = n2) : p2 = true), i3 == null || s2(function() {
              var e5 = {};
              return i3[l2].call(e5) !== e5;
            }) ? i3 = {} : h2 && (i3 = c2(i3)), a2(i3[l2]) || u2(i3, l2, function() {
              return this;
            }), e4.exports = { IteratorPrototype: i3, BUGGY_SAFARI_ITERATORS: p2 };
          }, 2077: (e4) => {
            e4.exports = {};
          }, 623: (e4, t4, r3) => {
            var i3 = r3(3057);
            e4.exports = function(e5) {
              return i3(e5.length);
            };
          }, 6132: (e4, t4, r3) => {
            var i3, n2, o2, s2, a2, c2, d2, u2, A2 = r3(1899), h2 = r3(6843), l2 = r3(9677).f, p2 = r3(2941).set, g2 = r3(2749), f2 = r3(4470), E2 = r3(8045), I2 = r3(6049), m2 = A2.MutationObserver || A2.WebKitMutationObserver, _2 = A2.document, C2 = A2.process, v2 = A2.Promise, S2 = l2(A2, "queueMicrotask"), R2 = S2 && S2.value;
            R2 || (i3 = function() {
              var e5, t5;
              for (I2 && (e5 = C2.domain) && e5.exit(); n2; ) {
                t5 = n2.fn, n2 = n2.next;
                try {
                  t5();
                } catch (e6) {
                  throw n2 ? s2() : o2 = void 0, e6;
                }
              }
              o2 = void 0, e5 && e5.enter();
            }, g2 || I2 || E2 || !m2 || !_2 ? !f2 && v2 && v2.resolve ? ((d2 = v2.resolve(void 0)).constructor = v2, u2 = h2(d2.then, d2), s2 = function() {
              u2(i3);
            }) : I2 ? s2 = function() {
              C2.nextTick(i3);
            } : (p2 = h2(p2, A2), s2 = function() {
              p2(i3);
            }) : (a2 = true, c2 = _2.createTextNode(""), new m2(i3).observe(c2, { characterData: true }), s2 = function() {
              c2.data = a2 = !a2;
            })), e4.exports = R2 || function(e5) {
              var t5 = { fn: e5, next: void 0 };
              o2 && (o2.next = t5), n2 || (n2 = t5, s2()), o2 = t5;
            };
          }, 9297: (e4, t4, r3) => {
            var i3 = r3(1899);
            e4.exports = i3.Promise;
          }, 2497: (e4, t4, r3) => {
            var i3 = r3(3385), n2 = r3(5981);
            e4.exports = !!Object.getOwnPropertySymbols && !n2(function() {
              var e5 = Symbol();
              return !String(e5) || !(Object(e5) instanceof Symbol) || !Symbol.sham && i3 && i3 < 41;
            });
          }, 8019: (e4, t4, r3) => {
            var i3 = r3(1899), n2 = r3(7475), o2 = r3(1302), s2 = i3.WeakMap;
            e4.exports = n2(s2) && /native code/.test(o2(s2));
          }, 9520: (e4, t4, r3) => {
            var i3 = r3(4883), n2 = function(e5) {
              var t5, r4;
              this.promise = new e5(function(e6, i4) {
                if (t5 !== void 0 || r4 !== void 0)
                  throw TypeError("Bad Promise constructor");
                t5 = e6, r4 = i4;
              }), this.resolve = i3(t5), this.reject = i3(r4);
            };
            e4.exports.f = function(e5) {
              return new n2(e5);
            };
          }, 4649: (e4, t4, r3) => {
            var i3 = r3(5803);
            e4.exports = function(e5, t5) {
              return e5 === void 0 ? arguments.length < 2 ? "" : t5 : i3(e5);
            };
          }, 9290: (e4, t4, r3) => {
            var i3, n2 = r3(6059), o2 = r3(9938), s2 = r3(6759), a2 = r3(7748), c2 = r3(5463), d2 = r3(1333), u2 = r3(4262)("IE_PROTO"), A2 = function() {
            }, h2 = function(e5) {
              return "<script>" + e5 + "<\/script>";
            }, l2 = function(e5) {
              e5.write(h2("")), e5.close();
              var t5 = e5.parentWindow.Object;
              return e5 = null, t5;
            }, p2 = function() {
              try {
                i3 = new ActiveXObject("htmlfile");
              } catch (e6) {
              }
              var e5, t5;
              p2 = typeof document != "undefined" ? document.domain && i3 ? l2(i3) : ((t5 = d2("iframe")).style.display = "none", c2.appendChild(t5), t5.src = String("javascript:"), (e5 = t5.contentWindow.document).open(), e5.write(h2("document.F=Object")), e5.close(), e5.F) : l2(i3);
              for (var r4 = s2.length; r4--; )
                delete p2.prototype[s2[r4]];
              return p2();
            };
            a2[u2] = true, e4.exports = Object.create || function(e5, t5) {
              var r4;
              return e5 !== null ? (A2.prototype = n2(e5), r4 = new A2(), A2.prototype = null, r4[u2] = e5) : r4 = p2(), t5 === void 0 ? r4 : o2.f(r4, t5);
            };
          }, 9938: (e4, t4, r3) => {
            var i3 = r3(5746), n2 = r3(3937), o2 = r3(5988), s2 = r3(6059), a2 = r3(4529), c2 = r3(4771);
            t4.f = i3 && !n2 ? Object.defineProperties : function(e5, t5) {
              s2(e5);
              for (var r4, i4 = a2(t5), n3 = c2(t5), d2 = n3.length, u2 = 0; d2 > u2; )
                o2.f(e5, r4 = n3[u2++], i4[r4]);
              return e5;
            };
          }, 5988: (e4, t4, r3) => {
            var i3 = r3(1899), n2 = r3(5746), o2 = r3(2840), s2 = r3(3937), a2 = r3(6059), c2 = r3(3894), d2 = i3.TypeError, u2 = Object.defineProperty, A2 = Object.getOwnPropertyDescriptor;
            t4.f = n2 ? s2 ? function(e5, t5, r4) {
              if (a2(e5), t5 = c2(t5), a2(r4), typeof e5 == "function" && t5 === "prototype" && "value" in r4 && "writable" in r4 && !r4.writable) {
                var i4 = A2(e5, t5);
                i4 && i4.writable && (e5[t5] = r4.value, r4 = { configurable: "configurable" in r4 ? r4.configurable : i4.configurable, enumerable: "enumerable" in r4 ? r4.enumerable : i4.enumerable, writable: false });
              }
              return u2(e5, t5, r4);
            } : u2 : function(e5, t5, r4) {
              if (a2(e5), t5 = c2(t5), a2(r4), o2)
                try {
                  return u2(e5, t5, r4);
                } catch (e6) {
                }
              if ("get" in r4 || "set" in r4)
                throw d2("Accessors not supported");
              return "value" in r4 && (e5[t5] = r4.value), e5;
            };
          }, 9677: (e4, t4, r3) => {
            var i3 = r3(5746), n2 = r3(8834), o2 = r3(6760), s2 = r3(1887), a2 = r3(4529), c2 = r3(3894), d2 = r3(953), u2 = r3(2840), A2 = Object.getOwnPropertyDescriptor;
            t4.f = i3 ? A2 : function(e5, t5) {
              if (e5 = a2(e5), t5 = c2(t5), u2)
                try {
                  return A2(e5, t5);
                } catch (e6) {
                }
              if (d2(e5, t5))
                return s2(!n2(o2.f, e5, t5), e5[t5]);
            };
          }, 946: (e4, t4, r3) => {
            var i3 = r3(5629), n2 = r3(6759).concat("length", "prototype");
            t4.f = Object.getOwnPropertyNames || function(e5) {
              return i3(e5, n2);
            };
          }, 7857: (e4, t4) => {
            t4.f = Object.getOwnPropertySymbols;
          }, 249: (e4, t4, r3) => {
            var i3 = r3(1899), n2 = r3(953), o2 = r3(7475), s2 = r3(9678), a2 = r3(4262), c2 = r3(4160), d2 = a2("IE_PROTO"), u2 = i3.Object, A2 = u2.prototype;
            e4.exports = c2 ? u2.getPrototypeOf : function(e5) {
              var t5 = s2(e5);
              if (n2(t5, d2))
                return t5[d2];
              var r4 = t5.constructor;
              return o2(r4) && t5 instanceof r4 ? r4.prototype : t5 instanceof u2 ? A2 : null;
            };
          }, 7046: (e4, t4, r3) => {
            var i3 = r3(5329);
            e4.exports = i3({}.isPrototypeOf);
          }, 5629: (e4, t4, r3) => {
            var i3 = r3(5329), n2 = r3(953), o2 = r3(4529), s2 = r3(1692).indexOf, a2 = r3(7748), c2 = i3([].push);
            e4.exports = function(e5, t5) {
              var r4, i4 = o2(e5), d2 = 0, u2 = [];
              for (r4 in i4)
                !n2(a2, r4) && n2(i4, r4) && c2(u2, r4);
              for (; t5.length > d2; )
                n2(i4, r4 = t5[d2++]) && (~s2(u2, r4) || c2(u2, r4));
              return u2;
            };
          }, 4771: (e4, t4, r3) => {
            var i3 = r3(5629), n2 = r3(6759);
            e4.exports = Object.keys || function(e5) {
              return i3(e5, n2);
            };
          }, 6760: (e4, t4) => {
            var r3 = {}.propertyIsEnumerable, i3 = Object.getOwnPropertyDescriptor, n2 = i3 && !r3.call({ 1: 2 }, 1);
            t4.f = n2 ? function(e5) {
              var t5 = i3(this, e5);
              return !!t5 && t5.enumerable;
            } : r3;
          }, 8929: (e4, t4, r3) => {
            var i3 = r3(5329), n2 = r3(6059), o2 = r3(1851);
            e4.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
              var e5, t5 = false, r4 = {};
              try {
                (e5 = i3(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(r4, []), t5 = r4 instanceof Array;
              } catch (e6) {
              }
              return function(r5, i4) {
                return n2(r5), o2(i4), t5 ? e5(r5, i4) : r5.__proto__ = i4, r5;
              };
            }() : void 0);
          }, 5623: (e4, t4, r3) => {
            var i3 = r3(2885), n2 = r3(9697);
            e4.exports = i3 ? {}.toString : function() {
              return "[object " + n2(this) + "]";
            };
          }, 9811: (e4, t4, r3) => {
            var i3 = r3(1899), n2 = r3(8834), o2 = r3(7475), s2 = r3(941), a2 = i3.TypeError;
            e4.exports = function(e5, t5) {
              var r4, i4;
              if (t5 === "string" && o2(r4 = e5.toString) && !s2(i4 = n2(r4, e5)))
                return i4;
              if (o2(r4 = e5.valueOf) && !s2(i4 = n2(r4, e5)))
                return i4;
              if (t5 !== "string" && o2(r4 = e5.toString) && !s2(i4 = n2(r4, e5)))
                return i4;
              throw a2("Can't convert object to primitive value");
            };
          }, 1136: (e4, t4, r3) => {
            var i3 = r3(626), n2 = r3(5329), o2 = r3(946), s2 = r3(7857), a2 = r3(6059), c2 = n2([].concat);
            e4.exports = i3("Reflect", "ownKeys") || function(e5) {
              var t5 = o2.f(a2(e5)), r4 = s2.f;
              return r4 ? c2(t5, r4(e5)) : t5;
            };
          }, 4058: (e4) => {
            e4.exports = {};
          }, 2: (e4) => {
            e4.exports = function(e5) {
              try {
                return { error: false, value: e5() };
              } catch (e6) {
                return { error: true, value: e6 };
              }
            };
          }, 6584: (e4, t4, r3) => {
            var i3 = r3(6059), n2 = r3(941), o2 = r3(9520);
            e4.exports = function(e5, t5) {
              if (i3(e5), n2(t5) && t5.constructor === e5)
                return t5;
              var r4 = o2.f(e5);
              return (0, r4.resolve)(t5), r4.promise;
            };
          }, 8397: (e4) => {
            var t4 = function() {
              this.head = null, this.tail = null;
            };
            t4.prototype = { add: function(e5) {
              var t5 = { item: e5, next: null };
              this.head ? this.tail.next = t5 : this.head = t5, this.tail = t5;
            }, get: function() {
              var e5 = this.head;
              if (e5)
                return this.head = e5.next, this.tail === e5 && (this.tail = null), e5.item;
            } }, e4.exports = t4;
          }, 7524: (e4, t4, r3) => {
            var i3 = r3(9754);
            e4.exports = function(e5, t5, r4) {
              for (var n2 in t5)
                r4 && r4.unsafe && e5[n2] ? e5[n2] = t5[n2] : i3(e5, n2, t5[n2], r4);
              return e5;
            };
          }, 9754: (e4, t4, r3) => {
            var i3 = r3(2029);
            e4.exports = function(e5, t5, r4, n2) {
              n2 && n2.enumerable ? e5[t5] = r4 : i3(e5, t5, r4);
            };
          }, 8219: (e4, t4, r3) => {
            var i3 = r3(1899).TypeError;
            e4.exports = function(e5) {
              if (e5 == null)
                throw i3("Can't call method on " + e5);
              return e5;
            };
          }, 4911: (e4, t4, r3) => {
            var i3 = r3(1899), n2 = Object.defineProperty;
            e4.exports = function(e5, t5) {
              try {
                n2(i3, e5, { value: t5, configurable: true, writable: true });
              } catch (r4) {
                i3[e5] = t5;
              }
              return t5;
            };
          }, 4431: (e4, t4, r3) => {
            var i3 = r3(626), n2 = r3(5988), o2 = r3(9813), s2 = r3(5746), a2 = o2("species");
            e4.exports = function(e5) {
              var t5 = i3(e5), r4 = n2.f;
              s2 && t5 && !t5[a2] && r4(t5, a2, { configurable: true, get: function() {
                return this;
              } });
            };
          }, 904: (e4, t4, r3) => {
            var i3 = r3(2885), n2 = r3(5988).f, o2 = r3(2029), s2 = r3(953), a2 = r3(5623), c2 = r3(9813)("toStringTag");
            e4.exports = function(e5, t5, r4, d2) {
              if (e5) {
                var u2 = r4 ? e5 : e5.prototype;
                s2(u2, c2) || n2(u2, c2, { configurable: true, value: t5 }), d2 && !i3 && o2(u2, "toString", a2);
              }
            };
          }, 4262: (e4, t4, r3) => {
            var i3 = r3(8726), n2 = r3(9418), o2 = i3("keys");
            e4.exports = function(e5) {
              return o2[e5] || (o2[e5] = n2(e5));
            };
          }, 3030: (e4, t4, r3) => {
            var i3 = r3(1899), n2 = r3(4911), o2 = "__core-js_shared__", s2 = i3[o2] || n2(o2, {});
            e4.exports = s2;
          }, 8726: (e4, t4, r3) => {
            var i3 = r3(2529), n2 = r3(3030);
            (e4.exports = function(e5, t5) {
              return n2[e5] || (n2[e5] = t5 !== void 0 ? t5 : {});
            })("versions", []).push({ version: "3.20.3", mode: i3 ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.20.3/LICENSE", source: "https://github.com/zloirock/core-js" });
          }, 487: (e4, t4, r3) => {
            var i3 = r3(6059), n2 = r3(174), o2 = r3(9813)("species");
            e4.exports = function(e5, t5) {
              var r4, s2 = i3(e5).constructor;
              return s2 === void 0 || (r4 = i3(s2)[o2]) == null ? t5 : n2(r4);
            };
          }, 4620: (e4, t4, r3) => {
            var i3 = r3(5329), n2 = r3(2435), o2 = r3(5803), s2 = r3(8219), a2 = i3("".charAt), c2 = i3("".charCodeAt), d2 = i3("".slice), u2 = function(e5) {
              return function(t5, r4) {
                var i4, u3, A2 = o2(s2(t5)), h2 = n2(r4), l2 = A2.length;
                return h2 < 0 || h2 >= l2 ? e5 ? "" : void 0 : (i4 = c2(A2, h2)) < 55296 || i4 > 56319 || h2 + 1 === l2 || (u3 = c2(A2, h2 + 1)) < 56320 || u3 > 57343 ? e5 ? a2(A2, h2) : i4 : e5 ? d2(A2, h2, h2 + 2) : u3 - 56320 + (i4 - 55296 << 10) + 65536;
              };
            };
            e4.exports = { codeAt: u2(false), charAt: u2(true) };
          }, 2941: (e4, t4, r3) => {
            var i3, n2, o2, s2, a2 = r3(1899), c2 = r3(9730), d2 = r3(6843), u2 = r3(7475), A2 = r3(953), h2 = r3(5981), l2 = r3(5463), p2 = r3(3765), g2 = r3(1333), f2 = r3(2749), E2 = r3(6049), I2 = a2.setImmediate, m2 = a2.clearImmediate, _2 = a2.process, C2 = a2.Dispatch, v2 = a2.Function, S2 = a2.MessageChannel, R2 = a2.String, y2 = 0, T2 = {};
            try {
              i3 = a2.location;
            } catch (e5) {
            }
            var w2 = function(e5) {
              if (A2(T2, e5)) {
                var t5 = T2[e5];
                delete T2[e5], t5();
              }
            }, b2 = function(e5) {
              return function() {
                w2(e5);
              };
            }, O2 = function(e5) {
              w2(e5.data);
            }, N2 = function(e5) {
              a2.postMessage(R2(e5), i3.protocol + "//" + i3.host);
            };
            I2 && m2 || (I2 = function(e5) {
              var t5 = p2(arguments, 1);
              return T2[++y2] = function() {
                c2(u2(e5) ? e5 : v2(e5), void 0, t5);
              }, n2(y2), y2;
            }, m2 = function(e5) {
              delete T2[e5];
            }, E2 ? n2 = function(e5) {
              _2.nextTick(b2(e5));
            } : C2 && C2.now ? n2 = function(e5) {
              C2.now(b2(e5));
            } : S2 && !f2 ? (s2 = (o2 = new S2()).port2, o2.port1.onmessage = O2, n2 = d2(s2.postMessage, s2)) : a2.addEventListener && u2(a2.postMessage) && !a2.importScripts && i3 && i3.protocol !== "file:" && !h2(N2) ? (n2 = N2, a2.addEventListener("message", O2, false)) : n2 = "onreadystatechange" in g2("script") ? function(e5) {
              l2.appendChild(g2("script")).onreadystatechange = function() {
                l2.removeChild(this), w2(e5);
              };
            } : function(e5) {
              setTimeout(b2(e5), 0);
            }), e4.exports = { set: I2, clear: m2 };
          }, 9413: (e4, t4, r3) => {
            var i3 = r3(2435), n2 = Math.max, o2 = Math.min;
            e4.exports = function(e5, t5) {
              var r4 = i3(e5);
              return r4 < 0 ? n2(r4 + t5, 0) : o2(r4, t5);
            };
          }, 4529: (e4, t4, r3) => {
            var i3 = r3(7026), n2 = r3(8219);
            e4.exports = function(e5) {
              return i3(n2(e5));
            };
          }, 2435: (e4) => {
            var t4 = Math.ceil, r3 = Math.floor;
            e4.exports = function(e5) {
              var i3 = +e5;
              return i3 != i3 || i3 === 0 ? 0 : (i3 > 0 ? r3 : t4)(i3);
            };
          }, 3057: (e4, t4, r3) => {
            var i3 = r3(2435), n2 = Math.min;
            e4.exports = function(e5) {
              return e5 > 0 ? n2(i3(e5), 9007199254740991) : 0;
            };
          }, 9678: (e4, t4, r3) => {
            var i3 = r3(1899), n2 = r3(8219), o2 = i3.Object;
            e4.exports = function(e5) {
              return o2(n2(e5));
            };
          }, 6935: (e4, t4, r3) => {
            var i3 = r3(1899), n2 = r3(8834), o2 = r3(941), s2 = r3(6664), a2 = r3(4229), c2 = r3(9811), d2 = r3(9813), u2 = i3.TypeError, A2 = d2("toPrimitive");
            e4.exports = function(e5, t5) {
              if (!o2(e5) || s2(e5))
                return e5;
              var r4, i4 = a2(e5, A2);
              if (i4) {
                if (t5 === void 0 && (t5 = "default"), r4 = n2(i4, e5, t5), !o2(r4) || s2(r4))
                  return r4;
                throw u2("Can't convert object to primitive value");
              }
              return t5 === void 0 && (t5 = "number"), c2(e5, t5);
            };
          }, 3894: (e4, t4, r3) => {
            var i3 = r3(6935), n2 = r3(6664);
            e4.exports = function(e5) {
              var t5 = i3(e5, "string");
              return n2(t5) ? t5 : t5 + "";
            };
          }, 2885: (e4, t4, r3) => {
            var i3 = {};
            i3[r3(9813)("toStringTag")] = "z", e4.exports = String(i3) === "[object z]";
          }, 5803: (e4, t4, r3) => {
            var i3 = r3(1899), n2 = r3(9697), o2 = i3.String;
            e4.exports = function(e5) {
              if (n2(e5) === "Symbol")
                throw TypeError("Cannot convert a Symbol value to a string");
              return o2(e5);
            };
          }, 9826: (e4, t4, r3) => {
            var i3 = r3(1899).String;
            e4.exports = function(e5) {
              try {
                return i3(e5);
              } catch (e6) {
                return "Object";
              }
            };
          }, 9418: (e4, t4, r3) => {
            var i3 = r3(5329), n2 = 0, o2 = Math.random(), s2 = i3(1 .toString);
            e4.exports = function(e5) {
              return "Symbol(" + (e5 === void 0 ? "" : e5) + ")_" + s2(++n2 + o2, 36);
            };
          }, 2302: (e4, t4, r3) => {
            var i3 = r3(2497);
            e4.exports = i3 && !Symbol.sham && typeof Symbol.iterator == "symbol";
          }, 3937: (e4, t4, r3) => {
            var i3 = r3(5746), n2 = r3(5981);
            e4.exports = i3 && n2(function() {
              return Object.defineProperty(function() {
              }, "prototype", { value: 42, writable: false }).prototype != 42;
            });
          }, 9813: (e4, t4, r3) => {
            var i3 = r3(1899), n2 = r3(8726), o2 = r3(953), s2 = r3(9418), a2 = r3(2497), c2 = r3(2302), d2 = n2("wks"), u2 = i3.Symbol, A2 = u2 && u2.for, h2 = c2 ? u2 : u2 && u2.withoutSetter || s2;
            e4.exports = function(e5) {
              if (!o2(d2, e5) || !a2 && typeof d2[e5] != "string") {
                var t5 = "Symbol." + e5;
                a2 && o2(u2, e5) ? d2[e5] = u2[e5] : d2[e5] = c2 && A2 ? A2(t5) : h2(t5);
              }
              return d2[e5];
            };
          }, 7627: (e4, t4, r3) => {
            var i3 = r3(6887), n2 = r3(1899), o2 = r3(7046), s2 = r3(249), a2 = r3(8929), c2 = r3(3489), d2 = r3(9290), u2 = r3(2029), A2 = r3(1887), h2 = r3(8694), l2 = r3(3794), p2 = r3(3091), g2 = r3(4649), f2 = r3(9813), E2 = r3(8780), I2 = f2("toStringTag"), m2 = n2.Error, _2 = [].push, C2 = function(e5, t5) {
              var r4, i4 = arguments.length > 2 ? arguments[2] : void 0, n3 = o2(v2, this);
              a2 ? r4 = a2(new m2(), n3 ? s2(this) : v2) : (r4 = n3 ? this : d2(v2), u2(r4, I2, "Error")), t5 !== void 0 && u2(r4, "message", g2(t5)), E2 && u2(r4, "stack", h2(r4.stack, 1)), l2(r4, i4);
              var c3 = [];
              return p2(e5, _2, { that: c3 }), u2(r4, "errors", c3), r4;
            };
            a2 ? a2(C2, m2) : c2(C2, m2, { name: true });
            var v2 = C2.prototype = d2(m2.prototype, { constructor: A2(1, C2), message: A2(1, ""), name: A2(1, "AggregateError") });
            i3({ global: true }, { AggregateError: C2 });
          }, 6274: (e4, t4, r3) => {
            var i3 = r3(4529), n2 = r3(8479), o2 = r3(2077), s2 = r3(5402), a2 = r3(5988).f, c2 = r3(7771), d2 = r3(2529), u2 = r3(5746), A2 = "Array Iterator", h2 = s2.set, l2 = s2.getterFor(A2);
            e4.exports = c2(Array, "Array", function(e5, t5) {
              h2(this, { type: A2, target: i3(e5), index: 0, kind: t5 });
            }, function() {
              var e5 = l2(this), t5 = e5.target, r4 = e5.kind, i4 = e5.index++;
              return !t5 || i4 >= t5.length ? (e5.target = void 0, { value: void 0, done: true }) : r4 == "keys" ? { value: i4, done: false } : r4 == "values" ? { value: t5[i4], done: false } : { value: [i4, t5[i4]], done: false };
            }, "values");
            var p2 = o2.Arguments = o2.Array;
            if (n2("keys"), n2("values"), n2("entries"), !d2 && u2 && p2.name !== "values")
              try {
                a2(p2, "name", { value: "values" });
              } catch (e5) {
              }
          }, 6450: (e4, t4, r3) => {
            var i3 = r3(6887), n2 = r3(5746), o2 = r3(5988).f;
            i3({ target: "Object", stat: true, forced: Object.defineProperty !== o2, sham: !n2 }, { defineProperty: o2 });
          }, 5967: () => {
          }, 4560: (e4, t4, r3) => {
            var i3 = r3(6887), n2 = r3(8834), o2 = r3(4883), s2 = r3(9520), a2 = r3(2), c2 = r3(3091);
            i3({ target: "Promise", stat: true }, { allSettled: function(e5) {
              var t5 = this, r4 = s2.f(t5), i4 = r4.resolve, d2 = r4.reject, u2 = a2(function() {
                var r5 = o2(t5.resolve), s3 = [], a3 = 0, d3 = 1;
                c2(e5, function(e6) {
                  var o3 = a3++, c3 = false;
                  d3++, n2(r5, t5, e6).then(function(e7) {
                    c3 || (c3 = true, s3[o3] = { status: "fulfilled", value: e7 }, --d3 || i4(s3));
                  }, function(e7) {
                    c3 || (c3 = true, s3[o3] = { status: "rejected", reason: e7 }, --d3 || i4(s3));
                  });
                }), --d3 || i4(s3);
              });
              return u2.error && d2(u2.value), r4.promise;
            } });
          }, 7206: (e4, t4, r3) => {
            var i3 = r3(6887), n2 = r3(4883), o2 = r3(626), s2 = r3(8834), a2 = r3(9520), c2 = r3(2), d2 = r3(3091), u2 = "No one promise resolved";
            i3({ target: "Promise", stat: true }, { any: function(e5) {
              var t5 = this, r4 = o2("AggregateError"), i4 = a2.f(t5), A2 = i4.resolve, h2 = i4.reject, l2 = c2(function() {
                var i5 = n2(t5.resolve), o3 = [], a3 = 0, c3 = 1, l3 = false;
                d2(e5, function(e6) {
                  var n3 = a3++, d3 = false;
                  c3++, s2(i5, t5, e6).then(function(e7) {
                    d3 || l3 || (l3 = true, A2(e7));
                  }, function(e7) {
                    d3 || l3 || (d3 = true, o3[n3] = e7, --c3 || h2(new r4(o3, u2)));
                  });
                }), --c3 || h2(new r4(o3, u2));
              });
              return l2.error && h2(l2.value), i4.promise;
            } });
          }, 4349: (e4, t4, r3) => {
            var i3 = r3(6887), n2 = r3(2529), o2 = r3(9297), s2 = r3(5981), a2 = r3(626), c2 = r3(7475), d2 = r3(487), u2 = r3(6584), A2 = r3(9754);
            if (i3({ target: "Promise", proto: true, real: true, forced: !!o2 && s2(function() {
              o2.prototype.finally.call({ then: function() {
              } }, function() {
              });
            }) }, { finally: function(e5) {
              var t5 = d2(this, a2("Promise")), r4 = c2(e5);
              return this.then(r4 ? function(r5) {
                return u2(t5, e5()).then(function() {
                  return r5;
                });
              } : e5, r4 ? function(r5) {
                return u2(t5, e5()).then(function() {
                  throw r5;
                });
              } : e5);
            } }), !n2 && c2(o2)) {
              var h2 = a2("Promise").prototype.finally;
              o2.prototype.finally !== h2 && A2(o2.prototype, "finally", h2, { unsafe: true });
            }
          }, 8881: (e4, t4, r3) => {
            var i3, n2, o2, s2, a2 = r3(6887), c2 = r3(2529), d2 = r3(1899), u2 = r3(626), A2 = r3(8834), h2 = r3(9297), l2 = r3(9754), p2 = r3(7524), g2 = r3(8929), f2 = r3(904), E2 = r3(4431), I2 = r3(4883), m2 = r3(7475), _2 = r3(941), C2 = r3(5743), v2 = r3(1302), S2 = r3(3091), R2 = r3(1385), y2 = r3(487), T2 = r3(2941).set, w2 = r3(6132), b2 = r3(6584), O2 = r3(4845), N2 = r3(9520), D2 = r3(2), L2 = r3(8397), P2 = r3(5402), k2 = r3(7252), B2 = r3(9813), M2 = r3(3321), U2 = r3(6049), Q2 = r3(3385), x2 = B2("species"), F2 = "Promise", V2 = P2.getterFor(F2), j2 = P2.set, G2 = P2.getterFor(F2), K2 = h2 && h2.prototype, H2 = h2, Y2 = K2, W2 = d2.TypeError, J2 = d2.document, q2 = d2.process, z2 = N2.f, X2 = z2, Z2 = !!(J2 && J2.createEvent && d2.dispatchEvent), $2 = m2(d2.PromiseRejectionEvent), ee2 = "unhandledrejection", te2 = false, re2 = k2(F2, function() {
              var e5 = v2(H2), t5 = e5 !== String(H2);
              if (!t5 && Q2 === 66)
                return true;
              if (c2 && !Y2.finally)
                return true;
              if (Q2 >= 51 && /native code/.test(e5))
                return false;
              var r4 = new H2(function(e6) {
                e6(1);
              }), i4 = function(e6) {
                e6(function() {
                }, function() {
                });
              };
              return (r4.constructor = {})[x2] = i4, !(te2 = r4.then(function() {
              }) instanceof i4) || !t5 && M2 && !$2;
            }), ie2 = re2 || !R2(function(e5) {
              H2.all(e5).catch(function() {
              });
            }), ne2 = function(e5) {
              var t5;
              return !(!_2(e5) || !m2(t5 = e5.then)) && t5;
            }, oe2 = function(e5, t5) {
              var r4, i4, n3, o3 = t5.value, s3 = t5.state == 1, a3 = s3 ? e5.ok : e5.fail, c3 = e5.resolve, d3 = e5.reject, u3 = e5.domain;
              try {
                a3 ? (s3 || (t5.rejection === 2 && ue2(t5), t5.rejection = 1), a3 === true ? r4 = o3 : (u3 && u3.enter(), r4 = a3(o3), u3 && (u3.exit(), n3 = true)), r4 === e5.promise ? d3(W2("Promise-chain cycle")) : (i4 = ne2(r4)) ? A2(i4, r4, c3, d3) : c3(r4)) : d3(o3);
              } catch (e6) {
                u3 && !n3 && u3.exit(), d3(e6);
              }
            }, se2 = function(e5, t5) {
              e5.notified || (e5.notified = true, w2(function() {
                for (var r4, i4 = e5.reactions; r4 = i4.get(); )
                  oe2(r4, e5);
                e5.notified = false, t5 && !e5.rejection && ce2(e5);
              }));
            }, ae2 = function(e5, t5, r4) {
              var i4, n3;
              Z2 ? ((i4 = J2.createEvent("Event")).promise = t5, i4.reason = r4, i4.initEvent(e5, false, true), d2.dispatchEvent(i4)) : i4 = { promise: t5, reason: r4 }, !$2 && (n3 = d2["on" + e5]) ? n3(i4) : e5 === ee2 && O2("Unhandled promise rejection", r4);
            }, ce2 = function(e5) {
              A2(T2, d2, function() {
                var t5, r4 = e5.facade, i4 = e5.value;
                if (de2(e5) && (t5 = D2(function() {
                  U2 ? q2.emit("unhandledRejection", i4, r4) : ae2(ee2, r4, i4);
                }), e5.rejection = U2 || de2(e5) ? 2 : 1, t5.error))
                  throw t5.value;
              });
            }, de2 = function(e5) {
              return e5.rejection !== 1 && !e5.parent;
            }, ue2 = function(e5) {
              A2(T2, d2, function() {
                var t5 = e5.facade;
                U2 ? q2.emit("rejectionHandled", t5) : ae2("rejectionhandled", t5, e5.value);
              });
            }, Ae2 = function(e5, t5, r4) {
              return function(i4) {
                e5(t5, i4, r4);
              };
            }, he2 = function(e5, t5, r4) {
              e5.done || (e5.done = true, r4 && (e5 = r4), e5.value = t5, e5.state = 2, se2(e5, true));
            }, le2 = function(e5, t5, r4) {
              if (!e5.done) {
                e5.done = true, r4 && (e5 = r4);
                try {
                  if (e5.facade === t5)
                    throw W2("Promise can't be resolved itself");
                  var i4 = ne2(t5);
                  i4 ? w2(function() {
                    var r5 = { done: false };
                    try {
                      A2(i4, t5, Ae2(le2, r5, e5), Ae2(he2, r5, e5));
                    } catch (t6) {
                      he2(r5, t6, e5);
                    }
                  }) : (e5.value = t5, e5.state = 1, se2(e5, false));
                } catch (t6) {
                  he2({ done: false }, t6, e5);
                }
              }
            };
            if (re2 && (Y2 = (H2 = function(e5) {
              C2(this, Y2), I2(e5), A2(i3, this);
              var t5 = V2(this);
              try {
                e5(Ae2(le2, t5), Ae2(he2, t5));
              } catch (e6) {
                he2(t5, e6);
              }
            }).prototype, (i3 = function(e5) {
              j2(this, { type: F2, done: false, notified: false, parent: false, reactions: new L2(), rejection: false, state: 0, value: void 0 });
            }).prototype = p2(Y2, { then: function(e5, t5) {
              var r4 = G2(this), i4 = z2(y2(this, H2));
              return r4.parent = true, i4.ok = !m2(e5) || e5, i4.fail = m2(t5) && t5, i4.domain = U2 ? q2.domain : void 0, r4.state == 0 ? r4.reactions.add(i4) : w2(function() {
                oe2(i4, r4);
              }), i4.promise;
            }, catch: function(e5) {
              return this.then(void 0, e5);
            } }), n2 = function() {
              var e5 = new i3(), t5 = V2(e5);
              this.promise = e5, this.resolve = Ae2(le2, t5), this.reject = Ae2(he2, t5);
            }, N2.f = z2 = function(e5) {
              return e5 === H2 || e5 === o2 ? new n2(e5) : X2(e5);
            }, !c2 && m2(h2) && K2 !== Object.prototype)) {
              s2 = K2.then, te2 || (l2(K2, "then", function(e5, t5) {
                var r4 = this;
                return new H2(function(e6, t6) {
                  A2(s2, r4, e6, t6);
                }).then(e5, t5);
              }, { unsafe: true }), l2(K2, "catch", Y2.catch, { unsafe: true }));
              try {
                delete K2.constructor;
              } catch (e5) {
              }
              g2 && g2(K2, Y2);
            }
            a2({ global: true, wrap: true, forced: re2 }, { Promise: H2 }), f2(H2, F2, false, true), E2(F2), o2 = u2(F2), a2({ target: F2, stat: true, forced: re2 }, { reject: function(e5) {
              var t5 = z2(this);
              return A2(t5.reject, void 0, e5), t5.promise;
            } }), a2({ target: F2, stat: true, forced: c2 || re2 }, { resolve: function(e5) {
              return b2(c2 && this === o2 ? H2 : this, e5);
            } }), a2({ target: F2, stat: true, forced: ie2 }, { all: function(e5) {
              var t5 = this, r4 = z2(t5), i4 = r4.resolve, n3 = r4.reject, o3 = D2(function() {
                var r5 = I2(t5.resolve), o4 = [], s3 = 0, a3 = 1;
                S2(e5, function(e6) {
                  var c3 = s3++, d3 = false;
                  a3++, A2(r5, t5, e6).then(function(e7) {
                    d3 || (d3 = true, o4[c3] = e7, --a3 || i4(o4));
                  }, n3);
                }), --a3 || i4(o4);
              });
              return o3.error && n3(o3.value), r4.promise;
            }, race: function(e5) {
              var t5 = this, r4 = z2(t5), i4 = r4.reject, n3 = D2(function() {
                var n4 = I2(t5.resolve);
                S2(e5, function(e6) {
                  A2(n4, t5, e6).then(r4.resolve, i4);
                });
              });
              return n3.error && i4(n3.value), r4.promise;
            } });
          }, 7971: (e4, t4, r3) => {
            var i3 = r3(4620).charAt, n2 = r3(5803), o2 = r3(5402), s2 = r3(7771), a2 = "String Iterator", c2 = o2.set, d2 = o2.getterFor(a2);
            s2(String, "String", function(e5) {
              c2(this, { type: a2, string: n2(e5), index: 0 });
            }, function() {
              var e5, t5 = d2(this), r4 = t5.string, n3 = t5.index;
              return n3 >= r4.length ? { value: void 0, done: true } : (e5 = i3(r4, n3), t5.index += e5.length, { value: e5, done: false });
            });
          }, 7634: (e4, t4, r3) => {
            r3(6274);
            var i3 = r3(3281), n2 = r3(1899), o2 = r3(9697), s2 = r3(2029), a2 = r3(2077), c2 = r3(9813)("toStringTag");
            for (var d2 in i3) {
              var u2 = n2[d2], A2 = u2 && u2.prototype;
              A2 && o2(A2) !== c2 && s2(A2, c2, d2), a2[d2] = a2.Array;
            }
          }, 1910: (e4, t4, r3) => {
            var i3 = r3(8171);
            e4.exports = i3;
          }, 7460: (e4, t4, r3) => {
            var i3 = r3(2956);
            r3(7634), e4.exports = i3;
          }, 9662: (e4, t4, r3) => {
            var i3 = r3(7854), n2 = r3(614), o2 = r3(6330), s2 = i3.TypeError;
            e4.exports = function(e5) {
              if (n2(e5))
                return e5;
              throw s2(o2(e5) + " is not a function");
            };
          }, 6077: (e4, t4, r3) => {
            var i3 = r3(7854), n2 = r3(614), o2 = i3.String, s2 = i3.TypeError;
            e4.exports = function(e5) {
              if (typeof e5 == "object" || n2(e5))
                return e5;
              throw s2("Can't set " + o2(e5) + " as a prototype");
            };
          }, 1223: (e4, t4, r3) => {
            var i3 = r3(5112), n2 = r3(30), o2 = r3(3070), s2 = i3("unscopables"), a2 = Array.prototype;
            a2[s2] == null && o2.f(a2, s2, { configurable: true, value: n2(null) }), e4.exports = function(e5) {
              a2[s2][e5] = true;
            };
          }, 9670: (e4, t4, r3) => {
            var i3 = r3(7854), n2 = r3(111), o2 = i3.String, s2 = i3.TypeError;
            e4.exports = function(e5) {
              if (n2(e5))
                return e5;
              throw s2(o2(e5) + " is not an object");
            };
          }, 1318: (e4, t4, r3) => {
            var i3 = r3(5656), n2 = r3(1400), o2 = r3(6244), s2 = function(e5) {
              return function(t5, r4, s3) {
                var a2, c2 = i3(t5), d2 = o2(c2), u2 = n2(s3, d2);
                if (e5 && r4 != r4) {
                  for (; d2 > u2; )
                    if ((a2 = c2[u2++]) != a2)
                      return true;
                } else
                  for (; d2 > u2; u2++)
                    if ((e5 || u2 in c2) && c2[u2] === r4)
                      return e5 || u2 || 0;
                return !e5 && -1;
              };
            };
            e4.exports = { includes: s2(true), indexOf: s2(false) };
          }, 4326: (e4, t4, r3) => {
            var i3 = r3(1702), n2 = i3({}.toString), o2 = i3("".slice);
            e4.exports = function(e5) {
              return o2(n2(e5), 8, -1);
            };
          }, 648: (e4, t4, r3) => {
            var i3 = r3(7854), n2 = r3(1694), o2 = r3(614), s2 = r3(4326), a2 = r3(5112)("toStringTag"), c2 = i3.Object, d2 = s2(function() {
              return arguments;
            }()) == "Arguments";
            e4.exports = n2 ? s2 : function(e5) {
              var t5, r4, i4;
              return e5 === void 0 ? "Undefined" : e5 === null ? "Null" : typeof (r4 = function(e6, t6) {
                try {
                  return e6[t6];
                } catch (e7) {
                }
              }(t5 = c2(e5), a2)) == "string" ? r4 : d2 ? s2(t5) : (i4 = s2(t5)) == "Object" && o2(t5.callee) ? "Arguments" : i4;
            };
          }, 7741: (e4, t4, r3) => {
            var i3 = r3(1702)("".replace), n2 = String(Error("zxcasd").stack), o2 = /\n\s*at [^:]*:[^\n]*/, s2 = o2.test(n2);
            e4.exports = function(e5, t5) {
              if (s2 && typeof e5 == "string")
                for (; t5--; )
                  e5 = i3(e5, o2, "");
              return e5;
            };
          }, 9920: (e4, t4, r3) => {
            var i3 = r3(2597), n2 = r3(3887), o2 = r3(1236), s2 = r3(3070);
            e4.exports = function(e5, t5, r4) {
              for (var a2 = n2(t5), c2 = s2.f, d2 = o2.f, u2 = 0; u2 < a2.length; u2++) {
                var A2 = a2[u2];
                i3(e5, A2) || r4 && i3(r4, A2) || c2(e5, A2, d2(t5, A2));
              }
            };
          }, 8544: (e4, t4, r3) => {
            var i3 = r3(7293);
            e4.exports = !i3(function() {
              function e5() {
              }
              return e5.prototype.constructor = null, Object.getPrototypeOf(new e5()) !== e5.prototype;
            });
          }, 4994: (e4, t4, r3) => {
            var i3 = r3(3383).IteratorPrototype, n2 = r3(30), o2 = r3(9114), s2 = r3(8003), a2 = r3(7497), c2 = function() {
              return this;
            };
            e4.exports = function(e5, t5, r4, d2) {
              var u2 = t5 + " Iterator";
              return e5.prototype = n2(i3, { next: o2(+!d2, r4) }), s2(e5, u2, false, true), a2[u2] = c2, e5;
            };
          }, 8880: (e4, t4, r3) => {
            var i3 = r3(9781), n2 = r3(3070), o2 = r3(9114);
            e4.exports = i3 ? function(e5, t5, r4) {
              return n2.f(e5, t5, o2(1, r4));
            } : function(e5, t5, r4) {
              return e5[t5] = r4, e5;
            };
          }, 9114: (e4) => {
            e4.exports = function(e5, t4) {
              return { enumerable: !(1 & e5), configurable: !(2 & e5), writable: !(4 & e5), value: t4 };
            };
          }, 654: (e4, t4, r3) => {
            var i3 = r3(2109), n2 = r3(6916), o2 = r3(1913), s2 = r3(6530), a2 = r3(614), c2 = r3(4994), d2 = r3(9518), u2 = r3(7674), A2 = r3(8003), h2 = r3(8880), l2 = r3(1320), p2 = r3(5112), g2 = r3(7497), f2 = r3(3383), E2 = s2.PROPER, I2 = s2.CONFIGURABLE, m2 = f2.IteratorPrototype, _2 = f2.BUGGY_SAFARI_ITERATORS, C2 = p2("iterator"), v2 = "keys", S2 = "values", R2 = "entries", y2 = function() {
              return this;
            };
            e4.exports = function(e5, t5, r4, s3, p3, f3, T2) {
              c2(r4, t5, s3);
              var w2, b2, O2, N2 = function(e6) {
                if (e6 === p3 && B2)
                  return B2;
                if (!_2 && e6 in P2)
                  return P2[e6];
                switch (e6) {
                  case v2:
                  case S2:
                  case R2:
                    return function() {
                      return new r4(this, e6);
                    };
                }
                return function() {
                  return new r4(this);
                };
              }, D2 = t5 + " Iterator", L2 = false, P2 = e5.prototype, k2 = P2[C2] || P2["@@iterator"] || p3 && P2[p3], B2 = !_2 && k2 || N2(p3), M2 = t5 == "Array" && P2.entries || k2;
              if (M2 && (w2 = d2(M2.call(new e5()))) !== Object.prototype && w2.next && (o2 || d2(w2) === m2 || (u2 ? u2(w2, m2) : a2(w2[C2]) || l2(w2, C2, y2)), A2(w2, D2, true, true), o2 && (g2[D2] = y2)), E2 && p3 == S2 && k2 && k2.name !== S2 && (!o2 && I2 ? h2(P2, "name", S2) : (L2 = true, B2 = function() {
                return n2(k2, this);
              })), p3)
                if (b2 = { values: N2(S2), keys: f3 ? B2 : N2(v2), entries: N2(R2) }, T2)
                  for (O2 in b2)
                    (_2 || L2 || !(O2 in P2)) && l2(P2, O2, b2[O2]);
                else
                  i3({ target: t5, proto: true, forced: _2 || L2 }, b2);
              return o2 && !T2 || P2[C2] === B2 || l2(P2, C2, B2, { name: p3 }), g2[t5] = B2, b2;
            };
          }, 9781: (e4, t4, r3) => {
            var i3 = r3(7293);
            e4.exports = !i3(function() {
              return Object.defineProperty({}, 1, { get: function() {
                return 7;
              } })[1] != 7;
            });
          }, 317: (e4, t4, r3) => {
            var i3 = r3(7854), n2 = r3(111), o2 = i3.document, s2 = n2(o2) && n2(o2.createElement);
            e4.exports = function(e5) {
              return s2 ? o2.createElement(e5) : {};
            };
          }, 8324: (e4) => {
            e4.exports = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 };
          }, 8509: (e4, t4, r3) => {
            var i3 = r3(317)("span").classList, n2 = i3 && i3.constructor && i3.constructor.prototype;
            e4.exports = n2 === Object.prototype ? void 0 : n2;
          }, 8113: (e4, t4, r3) => {
            var i3 = r3(5005);
            e4.exports = i3("navigator", "userAgent") || "";
          }, 7392: (e4, t4, r3) => {
            var i3, n2, o2 = r3(7854), s2 = r3(8113), a2 = o2.process, c2 = o2.Deno, d2 = a2 && a2.versions || c2 && c2.version, u2 = d2 && d2.v8;
            u2 && (n2 = (i3 = u2.split("."))[0] > 0 && i3[0] < 4 ? 1 : +(i3[0] + i3[1])), !n2 && s2 && (!(i3 = s2.match(/Edge\/(\d+)/)) || i3[1] >= 74) && (i3 = s2.match(/Chrome\/(\d+)/)) && (n2 = +i3[1]), e4.exports = n2;
          }, 748: (e4) => {
            e4.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
          }, 2914: (e4, t4, r3) => {
            var i3 = r3(7293), n2 = r3(9114);
            e4.exports = !i3(function() {
              var e5 = Error("a");
              return !("stack" in e5) || (Object.defineProperty(e5, "stack", n2(1, 7)), e5.stack !== 7);
            });
          }, 2109: (e4, t4, r3) => {
            var i3 = r3(7854), n2 = r3(1236).f, o2 = r3(8880), s2 = r3(1320), a2 = r3(3505), c2 = r3(9920), d2 = r3(4705);
            e4.exports = function(e5, t5) {
              var r4, u2, A2, h2, l2, p2 = e5.target, g2 = e5.global, f2 = e5.stat;
              if (r4 = g2 ? i3 : f2 ? i3[p2] || a2(p2, {}) : (i3[p2] || {}).prototype)
                for (u2 in t5) {
                  if (h2 = t5[u2], A2 = e5.noTargetGet ? (l2 = n2(r4, u2)) && l2.value : r4[u2], !d2(g2 ? u2 : p2 + (f2 ? "." : "#") + u2, e5.forced) && A2 !== void 0) {
                    if (typeof h2 == typeof A2)
                      continue;
                    c2(h2, A2);
                  }
                  (e5.sham || A2 && A2.sham) && o2(h2, "sham", true), s2(r4, u2, h2, e5);
                }
            };
          }, 7293: (e4) => {
            e4.exports = function(e5) {
              try {
                return !!e5();
              } catch (e6) {
                return true;
              }
            };
          }, 2104: (e4, t4, r3) => {
            var i3 = r3(4374), n2 = Function.prototype, o2 = n2.apply, s2 = n2.call;
            e4.exports = typeof Reflect == "object" && Reflect.apply || (i3 ? s2.bind(o2) : function() {
              return s2.apply(o2, arguments);
            });
          }, 4374: (e4, t4, r3) => {
            var i3 = r3(7293);
            e4.exports = !i3(function() {
              var e5 = function() {
              }.bind();
              return typeof e5 != "function" || e5.hasOwnProperty("prototype");
            });
          }, 6916: (e4, t4, r3) => {
            var i3 = r3(4374), n2 = Function.prototype.call;
            e4.exports = i3 ? n2.bind(n2) : function() {
              return n2.apply(n2, arguments);
            };
          }, 6530: (e4, t4, r3) => {
            var i3 = r3(9781), n2 = r3(2597), o2 = Function.prototype, s2 = i3 && Object.getOwnPropertyDescriptor, a2 = n2(o2, "name"), c2 = a2 && function() {
            }.name === "something", d2 = a2 && (!i3 || i3 && s2(o2, "name").configurable);
            e4.exports = { EXISTS: a2, PROPER: c2, CONFIGURABLE: d2 };
          }, 1702: (e4, t4, r3) => {
            var i3 = r3(4374), n2 = Function.prototype, o2 = n2.bind, s2 = n2.call, a2 = i3 && o2.bind(s2, s2);
            e4.exports = i3 ? function(e5) {
              return e5 && a2(e5);
            } : function(e5) {
              return e5 && function() {
                return s2.apply(e5, arguments);
              };
            };
          }, 5005: (e4, t4, r3) => {
            var i3 = r3(7854), n2 = r3(614), o2 = function(e5) {
              return n2(e5) ? e5 : void 0;
            };
            e4.exports = function(e5, t5) {
              return arguments.length < 2 ? o2(i3[e5]) : i3[e5] && i3[e5][t5];
            };
          }, 8173: (e4, t4, r3) => {
            var i3 = r3(9662);
            e4.exports = function(e5, t5) {
              var r4 = e5[t5];
              return r4 == null ? void 0 : i3(r4);
            };
          }, 7854: (e4, t4, r3) => {
            var i3 = function(e5) {
              return e5 && e5.Math == Math && e5;
            };
            e4.exports = i3(typeof globalThis == "object" && globalThis) || i3(typeof window == "object" && window) || i3(typeof self == "object" && self) || i3(typeof r3.g == "object" && r3.g) || function() {
              return this;
            }() || Function("return this")();
          }, 2597: (e4, t4, r3) => {
            var i3 = r3(1702), n2 = r3(7908), o2 = i3({}.hasOwnProperty);
            e4.exports = Object.hasOwn || function(e5, t5) {
              return o2(n2(e5), t5);
            };
          }, 3501: (e4) => {
            e4.exports = {};
          }, 490: (e4, t4, r3) => {
            var i3 = r3(5005);
            e4.exports = i3("document", "documentElement");
          }, 4664: (e4, t4, r3) => {
            var i3 = r3(9781), n2 = r3(7293), o2 = r3(317);
            e4.exports = !i3 && !n2(function() {
              return Object.defineProperty(o2("div"), "a", { get: function() {
                return 7;
              } }).a != 7;
            });
          }, 8361: (e4, t4, r3) => {
            var i3 = r3(7854), n2 = r3(1702), o2 = r3(7293), s2 = r3(4326), a2 = i3.Object, c2 = n2("".split);
            e4.exports = o2(function() {
              return !a2("z").propertyIsEnumerable(0);
            }) ? function(e5) {
              return s2(e5) == "String" ? c2(e5, "") : a2(e5);
            } : a2;
          }, 9587: (e4, t4, r3) => {
            var i3 = r3(614), n2 = r3(111), o2 = r3(7674);
            e4.exports = function(e5, t5, r4) {
              var s2, a2;
              return o2 && i3(s2 = t5.constructor) && s2 !== r4 && n2(a2 = s2.prototype) && a2 !== r4.prototype && o2(e5, a2), e5;
            };
          }, 2788: (e4, t4, r3) => {
            var i3 = r3(1702), n2 = r3(614), o2 = r3(5465), s2 = i3(Function.toString);
            n2(o2.inspectSource) || (o2.inspectSource = function(e5) {
              return s2(e5);
            }), e4.exports = o2.inspectSource;
          }, 8340: (e4, t4, r3) => {
            var i3 = r3(111), n2 = r3(8880);
            e4.exports = function(e5, t5) {
              i3(t5) && "cause" in t5 && n2(e5, "cause", t5.cause);
            };
          }, 9909: (e4, t4, r3) => {
            var i3, n2, o2, s2 = r3(8536), a2 = r3(7854), c2 = r3(1702), d2 = r3(111), u2 = r3(8880), A2 = r3(2597), h2 = r3(5465), l2 = r3(6200), p2 = r3(3501), g2 = "Object already initialized", f2 = a2.TypeError, E2 = a2.WeakMap;
            if (s2 || h2.state) {
              var I2 = h2.state || (h2.state = new E2()), m2 = c2(I2.get), _2 = c2(I2.has), C2 = c2(I2.set);
              i3 = function(e5, t5) {
                if (_2(I2, e5))
                  throw new f2(g2);
                return t5.facade = e5, C2(I2, e5, t5), t5;
              }, n2 = function(e5) {
                return m2(I2, e5) || {};
              }, o2 = function(e5) {
                return _2(I2, e5);
              };
            } else {
              var v2 = l2("state");
              p2[v2] = true, i3 = function(e5, t5) {
                if (A2(e5, v2))
                  throw new f2(g2);
                return t5.facade = e5, u2(e5, v2, t5), t5;
              }, n2 = function(e5) {
                return A2(e5, v2) ? e5[v2] : {};
              }, o2 = function(e5) {
                return A2(e5, v2);
              };
            }
            e4.exports = { set: i3, get: n2, has: o2, enforce: function(e5) {
              return o2(e5) ? n2(e5) : i3(e5, {});
            }, getterFor: function(e5) {
              return function(t5) {
                var r4;
                if (!d2(t5) || (r4 = n2(t5)).type !== e5)
                  throw f2("Incompatible receiver, " + e5 + " required");
                return r4;
              };
            } };
          }, 614: (e4) => {
            e4.exports = function(e5) {
              return typeof e5 == "function";
            };
          }, 4705: (e4, t4, r3) => {
            var i3 = r3(7293), n2 = r3(614), o2 = /#|\.prototype\./, s2 = function(e5, t5) {
              var r4 = c2[a2(e5)];
              return r4 == u2 || r4 != d2 && (n2(t5) ? i3(t5) : !!t5);
            }, a2 = s2.normalize = function(e5) {
              return String(e5).replace(o2, ".").toLowerCase();
            }, c2 = s2.data = {}, d2 = s2.NATIVE = "N", u2 = s2.POLYFILL = "P";
            e4.exports = s2;
          }, 111: (e4, t4, r3) => {
            var i3 = r3(614);
            e4.exports = function(e5) {
              return typeof e5 == "object" ? e5 !== null : i3(e5);
            };
          }, 1913: (e4) => {
            e4.exports = false;
          }, 2190: (e4, t4, r3) => {
            var i3 = r3(7854), n2 = r3(5005), o2 = r3(614), s2 = r3(7976), a2 = r3(3307), c2 = i3.Object;
            e4.exports = a2 ? function(e5) {
              return typeof e5 == "symbol";
            } : function(e5) {
              var t5 = n2("Symbol");
              return o2(t5) && s2(t5.prototype, c2(e5));
            };
          }, 3383: (e4, t4, r3) => {
            var i3, n2, o2, s2 = r3(7293), a2 = r3(614), c2 = r3(30), d2 = r3(9518), u2 = r3(1320), A2 = r3(5112), h2 = r3(1913), l2 = A2("iterator"), p2 = false;
            [].keys && ("next" in (o2 = [].keys()) ? (n2 = d2(d2(o2))) !== Object.prototype && (i3 = n2) : p2 = true), i3 == null || s2(function() {
              var e5 = {};
              return i3[l2].call(e5) !== e5;
            }) ? i3 = {} : h2 && (i3 = c2(i3)), a2(i3[l2]) || u2(i3, l2, function() {
              return this;
            }), e4.exports = { IteratorPrototype: i3, BUGGY_SAFARI_ITERATORS: p2 };
          }, 7497: (e4) => {
            e4.exports = {};
          }, 6244: (e4, t4, r3) => {
            var i3 = r3(7466);
            e4.exports = function(e5) {
              return i3(e5.length);
            };
          }, 133: (e4, t4, r3) => {
            var i3 = r3(7392), n2 = r3(7293);
            e4.exports = !!Object.getOwnPropertySymbols && !n2(function() {
              var e5 = Symbol();
              return !String(e5) || !(Object(e5) instanceof Symbol) || !Symbol.sham && i3 && i3 < 41;
            });
          }, 8536: (e4, t4, r3) => {
            var i3 = r3(7854), n2 = r3(614), o2 = r3(2788), s2 = i3.WeakMap;
            e4.exports = n2(s2) && /native code/.test(o2(s2));
          }, 6277: (e4, t4, r3) => {
            var i3 = r3(1340);
            e4.exports = function(e5, t5) {
              return e5 === void 0 ? arguments.length < 2 ? "" : t5 : i3(e5);
            };
          }, 30: (e4, t4, r3) => {
            var i3, n2 = r3(9670), o2 = r3(6048), s2 = r3(748), a2 = r3(3501), c2 = r3(490), d2 = r3(317), u2 = r3(6200)("IE_PROTO"), A2 = function() {
            }, h2 = function(e5) {
              return "<script>" + e5 + "<\/script>";
            }, l2 = function(e5) {
              e5.write(h2("")), e5.close();
              var t5 = e5.parentWindow.Object;
              return e5 = null, t5;
            }, p2 = function() {
              try {
                i3 = new ActiveXObject("htmlfile");
              } catch (e6) {
              }
              var e5, t5;
              p2 = typeof document != "undefined" ? document.domain && i3 ? l2(i3) : ((t5 = d2("iframe")).style.display = "none", c2.appendChild(t5), t5.src = String("javascript:"), (e5 = t5.contentWindow.document).open(), e5.write(h2("document.F=Object")), e5.close(), e5.F) : l2(i3);
              for (var r4 = s2.length; r4--; )
                delete p2.prototype[s2[r4]];
              return p2();
            };
            a2[u2] = true, e4.exports = Object.create || function(e5, t5) {
              var r4;
              return e5 !== null ? (A2.prototype = n2(e5), r4 = new A2(), A2.prototype = null, r4[u2] = e5) : r4 = p2(), t5 === void 0 ? r4 : o2.f(r4, t5);
            };
          }, 6048: (e4, t4, r3) => {
            var i3 = r3(9781), n2 = r3(3353), o2 = r3(3070), s2 = r3(9670), a2 = r3(5656), c2 = r3(1956);
            t4.f = i3 && !n2 ? Object.defineProperties : function(e5, t5) {
              s2(e5);
              for (var r4, i4 = a2(t5), n3 = c2(t5), d2 = n3.length, u2 = 0; d2 > u2; )
                o2.f(e5, r4 = n3[u2++], i4[r4]);
              return e5;
            };
          }, 3070: (e4, t4, r3) => {
            var i3 = r3(7854), n2 = r3(9781), o2 = r3(4664), s2 = r3(3353), a2 = r3(9670), c2 = r3(4948), d2 = i3.TypeError, u2 = Object.defineProperty, A2 = Object.getOwnPropertyDescriptor;
            t4.f = n2 ? s2 ? function(e5, t5, r4) {
              if (a2(e5), t5 = c2(t5), a2(r4), typeof e5 == "function" && t5 === "prototype" && "value" in r4 && "writable" in r4 && !r4.writable) {
                var i4 = A2(e5, t5);
                i4 && i4.writable && (e5[t5] = r4.value, r4 = { configurable: "configurable" in r4 ? r4.configurable : i4.configurable, enumerable: "enumerable" in r4 ? r4.enumerable : i4.enumerable, writable: false });
              }
              return u2(e5, t5, r4);
            } : u2 : function(e5, t5, r4) {
              if (a2(e5), t5 = c2(t5), a2(r4), o2)
                try {
                  return u2(e5, t5, r4);
                } catch (e6) {
                }
              if ("get" in r4 || "set" in r4)
                throw d2("Accessors not supported");
              return "value" in r4 && (e5[t5] = r4.value), e5;
            };
          }, 1236: (e4, t4, r3) => {
            var i3 = r3(9781), n2 = r3(6916), o2 = r3(5296), s2 = r3(9114), a2 = r3(5656), c2 = r3(4948), d2 = r3(2597), u2 = r3(4664), A2 = Object.getOwnPropertyDescriptor;
            t4.f = i3 ? A2 : function(e5, t5) {
              if (e5 = a2(e5), t5 = c2(t5), u2)
                try {
                  return A2(e5, t5);
                } catch (e6) {
                }
              if (d2(e5, t5))
                return s2(!n2(o2.f, e5, t5), e5[t5]);
            };
          }, 8006: (e4, t4, r3) => {
            var i3 = r3(6324), n2 = r3(748).concat("length", "prototype");
            t4.f = Object.getOwnPropertyNames || function(e5) {
              return i3(e5, n2);
            };
          }, 5181: (e4, t4) => {
            t4.f = Object.getOwnPropertySymbols;
          }, 9518: (e4, t4, r3) => {
            var i3 = r3(7854), n2 = r3(2597), o2 = r3(614), s2 = r3(7908), a2 = r3(6200), c2 = r3(8544), d2 = a2("IE_PROTO"), u2 = i3.Object, A2 = u2.prototype;
            e4.exports = c2 ? u2.getPrototypeOf : function(e5) {
              var t5 = s2(e5);
              if (n2(t5, d2))
                return t5[d2];
              var r4 = t5.constructor;
              return o2(r4) && t5 instanceof r4 ? r4.prototype : t5 instanceof u2 ? A2 : null;
            };
          }, 7976: (e4, t4, r3) => {
            var i3 = r3(1702);
            e4.exports = i3({}.isPrototypeOf);
          }, 6324: (e4, t4, r3) => {
            var i3 = r3(1702), n2 = r3(2597), o2 = r3(5656), s2 = r3(1318).indexOf, a2 = r3(3501), c2 = i3([].push);
            e4.exports = function(e5, t5) {
              var r4, i4 = o2(e5), d2 = 0, u2 = [];
              for (r4 in i4)
                !n2(a2, r4) && n2(i4, r4) && c2(u2, r4);
              for (; t5.length > d2; )
                n2(i4, r4 = t5[d2++]) && (~s2(u2, r4) || c2(u2, r4));
              return u2;
            };
          }, 1956: (e4, t4, r3) => {
            var i3 = r3(6324), n2 = r3(748);
            e4.exports = Object.keys || function(e5) {
              return i3(e5, n2);
            };
          }, 5296: (e4, t4) => {
            var r3 = {}.propertyIsEnumerable, i3 = Object.getOwnPropertyDescriptor, n2 = i3 && !r3.call({ 1: 2 }, 1);
            t4.f = n2 ? function(e5) {
              var t5 = i3(this, e5);
              return !!t5 && t5.enumerable;
            } : r3;
          }, 7674: (e4, t4, r3) => {
            var i3 = r3(1702), n2 = r3(9670), o2 = r3(6077);
            e4.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
              var e5, t5 = false, r4 = {};
              try {
                (e5 = i3(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(r4, []), t5 = r4 instanceof Array;
              } catch (e6) {
              }
              return function(r5, i4) {
                return n2(r5), o2(i4), t5 ? e5(r5, i4) : r5.__proto__ = i4, r5;
              };
            }() : void 0);
          }, 2140: (e4, t4, r3) => {
            var i3 = r3(7854), n2 = r3(6916), o2 = r3(614), s2 = r3(111), a2 = i3.TypeError;
            e4.exports = function(e5, t5) {
              var r4, i4;
              if (t5 === "string" && o2(r4 = e5.toString) && !s2(i4 = n2(r4, e5)))
                return i4;
              if (o2(r4 = e5.valueOf) && !s2(i4 = n2(r4, e5)))
                return i4;
              if (t5 !== "string" && o2(r4 = e5.toString) && !s2(i4 = n2(r4, e5)))
                return i4;
              throw a2("Can't convert object to primitive value");
            };
          }, 3887: (e4, t4, r3) => {
            var i3 = r3(5005), n2 = r3(1702), o2 = r3(8006), s2 = r3(5181), a2 = r3(9670), c2 = n2([].concat);
            e4.exports = i3("Reflect", "ownKeys") || function(e5) {
              var t5 = o2.f(a2(e5)), r4 = s2.f;
              return r4 ? c2(t5, r4(e5)) : t5;
            };
          }, 1320: (e4, t4, r3) => {
            var i3 = r3(7854), n2 = r3(614), o2 = r3(2597), s2 = r3(8880), a2 = r3(3505), c2 = r3(2788), d2 = r3(9909), u2 = r3(6530).CONFIGURABLE, A2 = d2.get, h2 = d2.enforce, l2 = String(String).split("String");
            (e4.exports = function(e5, t5, r4, c3) {
              var d3, A3 = !!c3 && !!c3.unsafe, p2 = !!c3 && !!c3.enumerable, g2 = !!c3 && !!c3.noTargetGet, f2 = c3 && c3.name !== void 0 ? c3.name : t5;
              n2(r4) && (String(f2).slice(0, 7) === "Symbol(" && (f2 = "[" + String(f2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!o2(r4, "name") || u2 && r4.name !== f2) && s2(r4, "name", f2), (d3 = h2(r4)).source || (d3.source = l2.join(typeof f2 == "string" ? f2 : ""))), e5 !== i3 ? (A3 ? !g2 && e5[t5] && (p2 = true) : delete e5[t5], p2 ? e5[t5] = r4 : s2(e5, t5, r4)) : p2 ? e5[t5] = r4 : a2(t5, r4);
            })(Function.prototype, "toString", function() {
              return n2(this) && A2(this).source || c2(this);
            });
          }, 2261: (e4, t4, r3) => {
            var i3, n2, o2 = r3(6916), s2 = r3(1702), a2 = r3(1340), c2 = r3(7066), d2 = r3(2999), u2 = r3(2309), A2 = r3(30), h2 = r3(9909).get, l2 = r3(9441), p2 = r3(7168), g2 = u2("native-string-replace", String.prototype.replace), f2 = RegExp.prototype.exec, E2 = f2, I2 = s2("".charAt), m2 = s2("".indexOf), _2 = s2("".replace), C2 = s2("".slice), v2 = (n2 = /b*/g, o2(f2, i3 = /a/, "a"), o2(f2, n2, "a"), i3.lastIndex !== 0 || n2.lastIndex !== 0), S2 = d2.BROKEN_CARET, R2 = /()??/.exec("")[1] !== void 0;
            (v2 || R2 || S2 || l2 || p2) && (E2 = function(e5) {
              var t5, r4, i4, n3, s3, d3, u3, l3 = this, p3 = h2(l3), y2 = a2(e5), T2 = p3.raw;
              if (T2)
                return T2.lastIndex = l3.lastIndex, t5 = o2(E2, T2, y2), l3.lastIndex = T2.lastIndex, t5;
              var w2 = p3.groups, b2 = S2 && l3.sticky, O2 = o2(c2, l3), N2 = l3.source, D2 = 0, L2 = y2;
              if (b2 && (O2 = _2(O2, "y", ""), m2(O2, "g") === -1 && (O2 += "g"), L2 = C2(y2, l3.lastIndex), l3.lastIndex > 0 && (!l3.multiline || l3.multiline && I2(y2, l3.lastIndex - 1) !== "\n") && (N2 = "(?: " + N2 + ")", L2 = " " + L2, D2++), r4 = new RegExp("^(?:" + N2 + ")", O2)), R2 && (r4 = new RegExp("^" + N2 + "$(?!\\s)", O2)), v2 && (i4 = l3.lastIndex), n3 = o2(f2, b2 ? r4 : l3, L2), b2 ? n3 ? (n3.input = C2(n3.input, D2), n3[0] = C2(n3[0], D2), n3.index = l3.lastIndex, l3.lastIndex += n3[0].length) : l3.lastIndex = 0 : v2 && n3 && (l3.lastIndex = l3.global ? n3.index + n3[0].length : i4), R2 && n3 && n3.length > 1 && o2(g2, n3[0], r4, function() {
                for (s3 = 1; s3 < arguments.length - 2; s3++)
                  arguments[s3] === void 0 && (n3[s3] = void 0);
              }), n3 && w2)
                for (n3.groups = d3 = A2(null), s3 = 0; s3 < w2.length; s3++)
                  d3[(u3 = w2[s3])[0]] = n3[u3[1]];
              return n3;
            }), e4.exports = E2;
          }, 7066: (e4, t4, r3) => {
            var i3 = r3(9670);
            e4.exports = function() {
              var e5 = i3(this), t5 = "";
              return e5.global && (t5 += "g"), e5.ignoreCase && (t5 += "i"), e5.multiline && (t5 += "m"), e5.dotAll && (t5 += "s"), e5.unicode && (t5 += "u"), e5.sticky && (t5 += "y"), t5;
            };
          }, 2999: (e4, t4, r3) => {
            var i3 = r3(7293), n2 = r3(7854).RegExp, o2 = i3(function() {
              var e5 = n2("a", "y");
              return e5.lastIndex = 2, e5.exec("abcd") != null;
            }), s2 = o2 || i3(function() {
              return !n2("a", "y").sticky;
            }), a2 = o2 || i3(function() {
              var e5 = n2("^r", "gy");
              return e5.lastIndex = 2, e5.exec("str") != null;
            });
            e4.exports = { BROKEN_CARET: a2, MISSED_STICKY: s2, UNSUPPORTED_Y: o2 };
          }, 9441: (e4, t4, r3) => {
            var i3 = r3(7293), n2 = r3(7854).RegExp;
            e4.exports = i3(function() {
              var e5 = n2(".", "s");
              return !(e5.dotAll && e5.exec("\n") && e5.flags === "s");
            });
          }, 7168: (e4, t4, r3) => {
            var i3 = r3(7293), n2 = r3(7854).RegExp;
            e4.exports = i3(function() {
              var e5 = n2("(?<a>b)", "g");
              return e5.exec("b").groups.a !== "b" || "b".replace(e5, "$<a>c") !== "bc";
            });
          }, 4488: (e4, t4, r3) => {
            var i3 = r3(7854).TypeError;
            e4.exports = function(e5) {
              if (e5 == null)
                throw i3("Can't call method on " + e5);
              return e5;
            };
          }, 3505: (e4, t4, r3) => {
            var i3 = r3(7854), n2 = Object.defineProperty;
            e4.exports = function(e5, t5) {
              try {
                n2(i3, e5, { value: t5, configurable: true, writable: true });
              } catch (r4) {
                i3[e5] = t5;
              }
              return t5;
            };
          }, 8003: (e4, t4, r3) => {
            var i3 = r3(3070).f, n2 = r3(2597), o2 = r3(5112)("toStringTag");
            e4.exports = function(e5, t5, r4) {
              e5 && !r4 && (e5 = e5.prototype), e5 && !n2(e5, o2) && i3(e5, o2, { configurable: true, value: t5 });
            };
          }, 6200: (e4, t4, r3) => {
            var i3 = r3(2309), n2 = r3(9711), o2 = i3("keys");
            e4.exports = function(e5) {
              return o2[e5] || (o2[e5] = n2(e5));
            };
          }, 5465: (e4, t4, r3) => {
            var i3 = r3(7854), n2 = r3(3505), o2 = "__core-js_shared__", s2 = i3[o2] || n2(o2, {});
            e4.exports = s2;
          }, 2309: (e4, t4, r3) => {
            var i3 = r3(1913), n2 = r3(5465);
            (e4.exports = function(e5, t5) {
              return n2[e5] || (n2[e5] = t5 !== void 0 ? t5 : {});
            })("versions", []).push({ version: "3.20.3", mode: i3 ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.20.3/LICENSE", source: "https://github.com/zloirock/core-js" });
          }, 1400: (e4, t4, r3) => {
            var i3 = r3(9303), n2 = Math.max, o2 = Math.min;
            e4.exports = function(e5, t5) {
              var r4 = i3(e5);
              return r4 < 0 ? n2(r4 + t5, 0) : o2(r4, t5);
            };
          }, 5656: (e4, t4, r3) => {
            var i3 = r3(8361), n2 = r3(4488);
            e4.exports = function(e5) {
              return i3(n2(e5));
            };
          }, 9303: (e4) => {
            var t4 = Math.ceil, r3 = Math.floor;
            e4.exports = function(e5) {
              var i3 = +e5;
              return i3 != i3 || i3 === 0 ? 0 : (i3 > 0 ? r3 : t4)(i3);
            };
          }, 7466: (e4, t4, r3) => {
            var i3 = r3(9303), n2 = Math.min;
            e4.exports = function(e5) {
              return e5 > 0 ? n2(i3(e5), 9007199254740991) : 0;
            };
          }, 7908: (e4, t4, r3) => {
            var i3 = r3(7854), n2 = r3(4488), o2 = i3.Object;
            e4.exports = function(e5) {
              return o2(n2(e5));
            };
          }, 7593: (e4, t4, r3) => {
            var i3 = r3(7854), n2 = r3(6916), o2 = r3(111), s2 = r3(2190), a2 = r3(8173), c2 = r3(2140), d2 = r3(5112), u2 = i3.TypeError, A2 = d2("toPrimitive");
            e4.exports = function(e5, t5) {
              if (!o2(e5) || s2(e5))
                return e5;
              var r4, i4 = a2(e5, A2);
              if (i4) {
                if (t5 === void 0 && (t5 = "default"), r4 = n2(i4, e5, t5), !o2(r4) || s2(r4))
                  return r4;
                throw u2("Can't convert object to primitive value");
              }
              return t5 === void 0 && (t5 = "number"), c2(e5, t5);
            };
          }, 4948: (e4, t4, r3) => {
            var i3 = r3(7593), n2 = r3(2190);
            e4.exports = function(e5) {
              var t5 = i3(e5, "string");
              return n2(t5) ? t5 : t5 + "";
            };
          }, 1694: (e4, t4, r3) => {
            var i3 = {};
            i3[r3(5112)("toStringTag")] = "z", e4.exports = String(i3) === "[object z]";
          }, 1340: (e4, t4, r3) => {
            var i3 = r3(7854), n2 = r3(648), o2 = i3.String;
            e4.exports = function(e5) {
              if (n2(e5) === "Symbol")
                throw TypeError("Cannot convert a Symbol value to a string");
              return o2(e5);
            };
          }, 6330: (e4, t4, r3) => {
            var i3 = r3(7854).String;
            e4.exports = function(e5) {
              try {
                return i3(e5);
              } catch (e6) {
                return "Object";
              }
            };
          }, 9711: (e4, t4, r3) => {
            var i3 = r3(1702), n2 = 0, o2 = Math.random(), s2 = i3(1 .toString);
            e4.exports = function(e5) {
              return "Symbol(" + (e5 === void 0 ? "" : e5) + ")_" + s2(++n2 + o2, 36);
            };
          }, 3307: (e4, t4, r3) => {
            var i3 = r3(133);
            e4.exports = i3 && !Symbol.sham && typeof Symbol.iterator == "symbol";
          }, 3353: (e4, t4, r3) => {
            var i3 = r3(9781), n2 = r3(7293);
            e4.exports = i3 && n2(function() {
              return Object.defineProperty(function() {
              }, "prototype", { value: 42, writable: false }).prototype != 42;
            });
          }, 5112: (e4, t4, r3) => {
            var i3 = r3(7854), n2 = r3(2309), o2 = r3(2597), s2 = r3(9711), a2 = r3(133), c2 = r3(3307), d2 = n2("wks"), u2 = i3.Symbol, A2 = u2 && u2.for, h2 = c2 ? u2 : u2 && u2.withoutSetter || s2;
            e4.exports = function(e5) {
              if (!o2(d2, e5) || !a2 && typeof d2[e5] != "string") {
                var t5 = "Symbol." + e5;
                a2 && o2(u2, e5) ? d2[e5] = u2[e5] : d2[e5] = c2 && A2 ? A2(t5) : h2(t5);
              }
              return d2[e5];
            };
          }, 9191: (e4, t4, r3) => {
            var i3 = r3(5005), n2 = r3(2597), o2 = r3(8880), s2 = r3(7976), a2 = r3(7674), c2 = r3(9920), d2 = r3(9587), u2 = r3(6277), A2 = r3(8340), h2 = r3(7741), l2 = r3(2914), p2 = r3(1913);
            e4.exports = function(e5, t5, r4, g2) {
              var f2 = g2 ? 2 : 1, E2 = e5.split("."), I2 = E2[E2.length - 1], m2 = i3.apply(null, E2);
              if (m2) {
                var _2 = m2.prototype;
                if (!p2 && n2(_2, "cause") && delete _2.cause, !r4)
                  return m2;
                var C2 = i3("Error"), v2 = t5(function(e6, t6) {
                  var r5 = u2(g2 ? t6 : e6, void 0), i4 = g2 ? new m2(e6) : new m2();
                  return r5 !== void 0 && o2(i4, "message", r5), l2 && o2(i4, "stack", h2(i4.stack, 2)), this && s2(_2, this) && d2(i4, this, v2), arguments.length > f2 && A2(i4, arguments[f2]), i4;
                });
                if (v2.prototype = _2, I2 !== "Error" && (a2 ? a2(v2, C2) : c2(v2, C2, { name: true })), c2(v2, m2), !p2)
                  try {
                    _2.name !== I2 && o2(_2, "name", I2), _2.constructor = v2;
                  } catch (e6) {
                  }
                return v2;
              }
            };
          }, 6992: (e4, t4, r3) => {
            var i3 = r3(5656), n2 = r3(1223), o2 = r3(7497), s2 = r3(9909), a2 = r3(3070).f, c2 = r3(654), d2 = r3(1913), u2 = r3(9781), A2 = "Array Iterator", h2 = s2.set, l2 = s2.getterFor(A2);
            e4.exports = c2(Array, "Array", function(e5, t5) {
              h2(this, { type: A2, target: i3(e5), index: 0, kind: t5 });
            }, function() {
              var e5 = l2(this), t5 = e5.target, r4 = e5.kind, i4 = e5.index++;
              return !t5 || i4 >= t5.length ? (e5.target = void 0, { value: void 0, done: true }) : r4 == "keys" ? { value: i4, done: false } : r4 == "values" ? { value: t5[i4], done: false } : { value: [i4, t5[i4]], done: false };
            }, "values");
            var p2 = o2.Arguments = o2.Array;
            if (n2("keys"), n2("values"), n2("entries"), !d2 && u2 && p2.name !== "values")
              try {
                a2(p2, "name", { value: "values" });
              } catch (e5) {
              }
          }, 1703: (e4, t4, r3) => {
            var i3 = r3(2109), n2 = r3(7854), o2 = r3(2104), s2 = r3(9191), a2 = n2.WebAssembly, c2 = Error("e", { cause: 7 }).cause !== 7, d2 = function(e5, t5) {
              var r4 = {};
              r4[e5] = s2(e5, t5, c2), i3({ global: true, forced: c2 }, r4);
            }, u2 = function(e5, t5) {
              if (a2 && a2[e5]) {
                var r4 = {};
                r4[e5] = s2("WebAssembly." + e5, t5, c2), i3({ target: "WebAssembly", stat: true, forced: c2 }, r4);
              }
            };
            d2("Error", function(e5) {
              return function(t5) {
                return o2(e5, this, arguments);
              };
            }), d2("EvalError", function(e5) {
              return function(t5) {
                return o2(e5, this, arguments);
              };
            }), d2("RangeError", function(e5) {
              return function(t5) {
                return o2(e5, this, arguments);
              };
            }), d2("ReferenceError", function(e5) {
              return function(t5) {
                return o2(e5, this, arguments);
              };
            }), d2("SyntaxError", function(e5) {
              return function(t5) {
                return o2(e5, this, arguments);
              };
            }), d2("TypeError", function(e5) {
              return function(t5) {
                return o2(e5, this, arguments);
              };
            }), d2("URIError", function(e5) {
              return function(t5) {
                return o2(e5, this, arguments);
              };
            }), u2("CompileError", function(e5) {
              return function(t5) {
                return o2(e5, this, arguments);
              };
            }), u2("LinkError", function(e5) {
              return function(t5) {
                return o2(e5, this, arguments);
              };
            }), u2("RuntimeError", function(e5) {
              return function(t5) {
                return o2(e5, this, arguments);
              };
            });
          }, 4916: (e4, t4, r3) => {
            var i3 = r3(2109), n2 = r3(2261);
            i3({ target: "RegExp", proto: true, forced: /./.exec !== n2 }, { exec: n2 });
          }, 3948: (e4, t4, r3) => {
            var i3 = r3(7854), n2 = r3(8324), o2 = r3(8509), s2 = r3(6992), a2 = r3(8880), c2 = r3(5112), d2 = c2("iterator"), u2 = c2("toStringTag"), A2 = s2.values, h2 = function(e5, t5) {
              if (e5) {
                if (e5[d2] !== A2)
                  try {
                    a2(e5, d2, A2);
                  } catch (t6) {
                    e5[d2] = A2;
                  }
                if (e5[u2] || a2(e5, u2, t5), n2[t5]) {
                  for (var r4 in s2)
                    if (e5[r4] !== s2[r4])
                      try {
                        a2(e5, r4, s2[r4]);
                      } catch (t6) {
                        e5[r4] = s2[r4];
                      }
                }
              }
            };
            for (var l2 in n2)
              h2(i3[l2] && i3[l2].prototype, l2);
            h2(o2, "DOMTokenList");
          } }, t3 = {};
          function r2(i3) {
            var n2 = t3[i3];
            if (n2 !== void 0)
              return n2.exports;
            var o2 = t3[i3] = { exports: {} };
            return e3[i3](o2, o2.exports, r2), o2.exports;
          }
          r2.n = (e4) => {
            var t4 = e4 && e4.__esModule ? () => e4.default : () => e4;
            return r2.d(t4, { a: t4 }), t4;
          }, r2.d = (e4, t4) => {
            for (var i3 in t4)
              r2.o(t4, i3) && !r2.o(e4, i3) && Object.defineProperty(e4, i3, { enumerable: true, get: t4[i3] });
          }, r2.g = function() {
            if (typeof globalThis == "object")
              return globalThis;
            try {
              return this || new Function("return this")();
            } catch (e4) {
              if (typeof window == "object")
                return window;
            }
          }(), r2.o = (e4, t4) => Object.prototype.hasOwnProperty.call(e4, t4), r2.r = (e4) => {
            typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e4, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e4, "__esModule", { value: true });
          };
          var i2 = {};
          return (() => {
            r2.r(i2), r2.d(i2, { AudioExtension: () => C2, AudioProcessor: () => m2, Extension: () => _2, Ticker: () => S2, VideoProcessor: () => I2, logger: () => A2, reporter: () => p2 });
            var e4 = r2(4341);
            function t4(t5, r3, i3) {
              return r3 in t5 ? e4(t5, r3, { value: i3, enumerable: true, configurable: true, writable: true }) : t5[r3] = i3, t5;
            }
            r2(1703), r2(6992), r2(3948);
            var n2 = r2(3476), o2 = r2.n(n2);
            function s2() {
              let e5 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 7, t5 = arguments.length > 1 ? arguments[1] : void 0;
              const r3 = Math.random().toString(16).substr(2, e5).toLowerCase();
              return r3.length === e5 ? "".concat(t5).concat(r3) : "".concat(t5).concat(r3) + s2(e5 - r3.length, "");
            }
            r2(4916);
            const a2 = Date.now(), c2 = { DEBUG: 0, INFO: 1, WARNING: 2, ERROR: 3, NONE: 4 };
            function d2() {
              const e5 = new Date();
              return e5.toTimeString().split(" ")[0] + ":" + e5.getMilliseconds();
            }
            const u2 = (e5) => {
              for (const t5 in c2)
                if (Object.prototype.hasOwnProperty.call(c2, t5) && c2[t5] === e5)
                  return t5;
              return "DEFAULT";
            }, A2 = new class {
              constructor() {
                t4(this, "logLevel", c2.DEBUG), t4(this, "hookLog", void 0);
              }
              debug() {
                for (var e5 = arguments.length, t5 = new Array(e5), r3 = 0; r3 < e5; r3++)
                  t5[r3] = arguments[r3];
                const i3 = [c2.DEBUG].concat(t5);
                this.log.apply(this, i3);
              }
              info() {
                for (var e5 = arguments.length, t5 = new Array(e5), r3 = 0; r3 < e5; r3++)
                  t5[r3] = arguments[r3];
                const i3 = [c2.INFO].concat(t5);
                this.log.apply(this, i3);
              }
              warning() {
                for (var e5 = arguments.length, t5 = new Array(e5), r3 = 0; r3 < e5; r3++)
                  t5[r3] = arguments[r3];
                const i3 = [c2.WARNING].concat(t5);
                this.log.apply(this, i3);
              }
              error() {
                for (var e5 = arguments.length, t5 = new Array(e5), r3 = 0; r3 < e5; r3++)
                  t5[r3] = arguments[r3];
                const i3 = [c2.ERROR].concat(t5);
                this.log.apply(this, i3);
              }
              log() {
                for (var e5, t5 = arguments.length, r3 = new Array(t5), i3 = 0; i3 < t5; i3++)
                  r3[i3] = arguments[i3];
                if (Date.now() - a2 < 100)
                  return void setTimeout(() => {
                    this.log(...r3);
                  }, Date.now() - a2);
                const n3 = Math.max(0, Math.min(4, r3[0]));
                if (r3[0] = d2() + " Agora-Extension [".concat(u2(n3), "]:"), n3 < this.logLevel)
                  return;
                const o3 = d2() + " %cAgora-Extension [".concat(u2(n3), "]:");
                let s3 = [];
                switch (n3) {
                  case c2.DEBUG:
                    s3 = [o3, "color: #64B5F6;"].concat(r3.slice(1)), console.log.apply(console, s3);
                    break;
                  case c2.INFO:
                    s3 = [o3, "color: #1E88E5; font-weight: bold;"].concat(r3.slice(1)), console.log.apply(console, s3);
                    break;
                  case c2.WARNING:
                    s3 = [o3, "color: #FB8C00; font-weight: bold;"].concat(r3.slice(1)), console.warn.apply(console, s3);
                    break;
                  case c2.ERROR:
                    s3 = [o3, "color: #B00020; font-weight: bold;"].concat(r3.slice(1)), console.error.apply(console, s3);
                }
                (e5 = this.hookLog) === null || e5 === void 0 || e5.call(this, n3, s3);
              }
            }();
            function h2(e5, t5) {
              var r3 = Object.keys(e5);
              if (Object.getOwnPropertySymbols) {
                var i3 = Object.getOwnPropertySymbols(e5);
                t5 && (i3 = i3.filter(function(t6) {
                  return Object.getOwnPropertyDescriptor(e5, t6).enumerable;
                })), r3.push.apply(r3, i3);
              }
              return r3;
            }
            function l2(e5) {
              for (var r3 = 1; r3 < arguments.length; r3++) {
                var i3 = arguments[r3] != null ? arguments[r3] : {};
                r3 % 2 ? h2(Object(i3), true).forEach(function(r4) {
                  t4(e5, r4, i3[r4]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(i3)) : h2(Object(i3)).forEach(function(t5) {
                  Object.defineProperty(e5, t5, Object.getOwnPropertyDescriptor(i3, t5));
                });
              }
              return e5;
            }
            const p2 = new class {
              constructor() {
                t4(this, "apiInvokeMsgQueue", []), t4(this, "hookApiInvoke", void 0);
              }
              reportApiInvoke(e5) {
                e5.timeout = e5.timeout || 6e4, e5.reportResult = e5.reportResult === void 0 || e5.reportResult;
                const t5 = Date.now(), r3 = () => ({ name: e5.name, apiInvokeTime: t5, options: e5.options });
                let i3 = false;
                var n3;
                (n3 = e5.timeout, new (o2())((e6) => {
                  window.setTimeout(e6, n3);
                })).then(() => {
                  i3 || (this.sendApiInvoke(l2(l2({}, r3()), {}, { error: "API_INVOKE_TIMEOUT", success: false })), A2.debug("".concat(e5.name, " timeout")));
                });
                const s3 = new Error("".concat(e5.name, ": this api invoke is end"));
                return { onSuccess: (t6) => {
                  if (i3)
                    throw s3;
                  i3 = true, this.sendApiInvoke(l2(l2({}, r3()), {}, { success: true }, e5.reportResult && { result: t6 }));
                }, onError: (e6) => {
                  if (i3)
                    throw e6;
                  i3 = true, this.sendApiInvoke(l2(l2({}, r3()), {}, { success: false, error: e6.toString() }));
                } };
              }
              sendApiInvoke(e5) {
                this.hookApiInvoke ? (this.hookApiInvoke([...this.apiInvokeMsgQueue, e5]), this.apiInvokeMsgQueue = []) : this.apiInvokeMsgQueue.push(e5);
              }
            }();
            function g2(e5, t5) {
              var r3 = Object.keys(e5);
              if (Object.getOwnPropertySymbols) {
                var i3 = Object.getOwnPropertySymbols(e5);
                t5 && (i3 = i3.filter(function(t6) {
                  return Object.getOwnPropertyDescriptor(e5, t6).enumerable;
                })), r3.push.apply(r3, i3);
              }
              return r3;
            }
            function f2(e5) {
              for (var r3 = 1; r3 < arguments.length; r3++) {
                var i3 = arguments[r3] != null ? arguments[r3] : {};
                r3 % 2 ? g2(Object(i3), true).forEach(function(r4) {
                  t4(e5, r4, i3[r4]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(i3)) : g2(Object(i3)).forEach(function(t5) {
                  Object.defineProperty(e5, t5, Object.getOwnPropertyDescriptor(i3, t5));
                });
              }
              return e5;
            }
            class E2 extends class {
              constructor() {
                t4(this, "_events", {}), t4(this, "addListener", this.on);
              }
              getListeners(e5) {
                return this._events[e5] ? this._events[e5].map((e6) => e6.listener) : [];
              }
              on(e5, t5) {
                this._events[e5] || (this._events[e5] = []);
                const r3 = this._events[e5];
                this._indexOfListener(r3, t5) === -1 && r3.push({ listener: t5, once: false });
              }
              once(e5, t5) {
                this._events[e5] || (this._events[e5] = []);
                const r3 = this._events[e5];
                this._indexOfListener(r3, t5) === -1 && r3.push({ listener: t5, once: true });
              }
              off(e5, t5) {
                if (!this._events[e5])
                  return;
                const r3 = this._events[e5], i3 = this._indexOfListener(r3, t5);
                i3 !== -1 && r3.splice(i3, 1), this._events[e5].length === 0 && delete this._events[e5];
              }
              removeAllListeners(e5) {
                e5 ? delete this._events[e5] : this._events = {};
              }
              emit(e5) {
                this._events[e5] || (this._events[e5] = []);
                const t5 = this._events[e5].map((e6) => e6);
                for (var r3 = arguments.length, i3 = new Array(r3 > 1 ? r3 - 1 : 0), n3 = 1; n3 < r3; n3++)
                  i3[n3 - 1] = arguments[n3];
                for (let r4 = 0; r4 < t5.length; r4 += 1) {
                  const n4 = t5[r4];
                  n4.once && this.off(e5, n4.listener), n4.listener.apply(this, i3 || []);
                }
              }
              _indexOfListener(e5, t5) {
                let r3 = e5.length;
                for (; r3--; )
                  if (e5[r3].listener === t5)
                    return r3;
                return -1;
              }
              emitAsPromise(e5) {
                for (var t5 = arguments.length, r3 = new Array(t5 > 1 ? t5 - 1 : 0), i3 = 1; i3 < t5; i3++)
                  r3[i3 - 1] = arguments[i3];
                return this.getListeners(e5).length === 0 ? o2().reject(new Error("No promise event handler.")) : new (o2())((t6, i4) => {
                  this.emit(e5, ...r3, t6, i4);
                });
              }
              emitAsPromiseNoResponse(e5) {
                for (var t5 = arguments.length, r3 = new Array(t5 > 1 ? t5 - 1 : 0), i3 = 1; i3 < t5; i3++)
                  r3[i3 - 1] = arguments[i3];
                return this.getListeners(e5).length === 0 ? o2().resolve() : new (o2())((t6, i4) => {
                  this.emit(e5, ...r3, t6, i4);
                });
              }
            } {
              get enabled() {
                return this._enabled;
              }
              output(e5, t5) {
                if (this.outputTrack === e5)
                  return;
                const r3 = p2.reportApiInvoke({ name: "".concat(this.name, ".output"), options: { track: e5 == null ? void 0 : e5.toString() } });
                this.outputTrack = e5, this.destination && this.destination.updateInput({ track: e5, context: t5 }), r3.onSuccess();
              }
              constructor() {
                super(), t4(this, "inputTrack", void 0), t4(this, "outputTrack", void 0), t4(this, "_enabled", true), t4(this, "_source", void 0), t4(this, "ID", s2(6, "")), t4(this, "destination", void 0), t4(this, "context", void 0), t4(this, "name", void 0);
              }
              enable() {
                if (this._enabled)
                  return;
                const e5 = p2.reportApiInvoke({ name: "".concat(this.name, ".setEnabled"), options: true });
                A2.info("".concat(this.name, "-").concat(this.ID, " enabled")), this._enabled = true;
                try {
                  var t5;
                  const r3 = (t5 = this.onEnableChange) === null || t5 === void 0 ? void 0 : t5.call(this, this._enabled);
                  if (r3 instanceof o2())
                    return r3.then(() => {
                      e5.onSuccess();
                    }).catch((t6) => {
                      throw e5.onError(t6), t6;
                    });
                  e5.onSuccess();
                } catch (t6) {
                  throw e5.onError(t6), t6;
                }
              }
              disable() {
                if (!this._enabled)
                  return;
                const e5 = p2.reportApiInvoke({ name: "".concat(this.name, ".setEnabled"), options: false });
                A2.info("".concat(this.name, "-").concat(this.ID, " disabled")), this._enabled = false;
                try {
                  var t5;
                  const r3 = (t5 = this.onEnableChange) === null || t5 === void 0 ? void 0 : t5.call(this, this._enabled);
                  if (r3 instanceof o2())
                    return r3.then(() => {
                      e5.onSuccess();
                    }).catch((t6) => {
                      throw e5.onError(t6), t6;
                    });
                  e5.onSuccess();
                } catch (t6) {
                  throw e5.onError(t6), t6;
                }
              }
            }
            class I2 extends E2 {
              get kind() {
                return "video";
              }
              pipe(e5) {
                const t5 = p2.reportApiInvoke({ name: "".concat(this.name, ".pipe"), options: { processor: e5.name } });
                if (this.destination === e5)
                  return t5.onSuccess(), e5;
                if (e5._source) {
                  const r3 = new Error("Processor ".concat(e5.name, " already piped, please call unpipe beforehand."));
                  throw t5.onError(r3), r3;
                }
                return this.destination && this.unpipe(), this.destination = e5, e5._source = this, this.context && this.destination.updateInput({ track: this.outputTrack, context: this.context }), t5.onSuccess(), e5;
              }
              unpipe() {
                if (!this.destination)
                  return;
                const e5 = p2.reportApiInvoke({ name: "".concat(this.name, ".unpipe"), options: { processor: this.destination.name } });
                A2.info("unpiping processor ".concat(this.destination.name, "-").concat(this.destination.ID));
                try {
                  const t5 = this.destination;
                  this.destination._source = void 0, this.destination = void 0, t5.reset();
                } finally {
                  e5.onSuccess();
                }
              }
              updateInput(e5) {
                var t5, r3;
                e5.context !== this.context && (this.context = e5.context, (t5 = this.onPiped) === null || t5 === void 0 || t5.call(this, this.context), this.destination && this.destination.updateInput({ track: this.outputTrack, context: e5.context })), e5.track && this.inputTrack !== e5.track && (this.inputTrack = e5.track, (r3 = this.onTrack) === null || r3 === void 0 || r3.call(this, e5.track, this.context));
              }
              reset() {
                var e5;
                this.context && this.context.requestRevertConstraints(this), this.inputTrack = void 0, this.context = void 0, (e5 = this.onUnpiped) === null || e5 === void 0 || e5.call(this), this.destination && this.destination.reset();
              }
            }
            class m2 extends E2 {
              constructor() {
                super(...arguments), t4(this, "inputNode", void 0), t4(this, "outputNode", void 0), t4(this, "destination", void 0), t4(this, "context", void 0);
              }
              get kind() {
                return "audio";
              }
              pipe(e5) {
                const t5 = p2.reportApiInvoke({ name: "".concat(this.name, ".pipe"), options: { processor: e5.name } });
                if (this.destination === e5)
                  return t5.onSuccess(), e5;
                if (e5._source) {
                  const r3 = new Error("Processor ".concat(e5.name, " already piped, please call unpipe beforehand."));
                  throw t5.onError(r3), r3;
                }
                return this.destination && this.unpipe(), this.destination = e5, e5._source = this, this.context && this.destination.updateInput({ track: this.outputTrack, node: this.outputNode, context: this.context }), t5.onSuccess(), e5;
              }
              unpipe() {
                if (!this.destination)
                  return;
                A2.info("unpiping processor ".concat(this.destination.name, "-").concat(this.destination.ID));
                const e5 = p2.reportApiInvoke({ name: "".concat(this.name, ".unpipe"), options: { processor: this.destination.name } });
                try {
                  var t5;
                  let r3 = this.destination;
                  (t5 = this.outputNode) === null || t5 === void 0 || t5.disconnect(), this.destination._source = void 0, this.destination = void 0, r3.reset();
                } finally {
                  e5.onSuccess();
                }
              }
              output(e5, t5) {
                if (e5 instanceof MediaStreamTrack)
                  super.output(e5, t5);
                else if (e5 instanceof AudioNode) {
                  if (this.outputNode === e5)
                    return;
                  const r3 = p2.reportApiInvoke({ name: "".concat(this.name, ".output"), options: f2(f2({}, e5 instanceof MediaStreamTrack && { track: e5.toString() }), e5 instanceof AudioNode && { audioNode: e5.toString() }) });
                  this.outputNode = e5, this.destination && this.destination.updateInput({ node: e5, context: t5 }), r3.onSuccess();
                }
              }
              updateInput(e5) {
                var t5, r3, i3;
                e5.context !== this.context && (this.context = e5.context, (t5 = this.onPiped) === null || t5 === void 0 || t5.call(this, this.context), this.destination && this.destination.updateInput({ track: this.outputTrack, node: this.outputNode, context: e5.context })), e5.track && this.inputTrack !== e5.track && (this.inputTrack = e5.track, (r3 = this.onTrack) === null || r3 === void 0 || r3.call(this, e5.track, this.context)), e5.node && this.inputNode !== e5.node && (this.inputNode = e5.node, (i3 = this.onNode) === null || i3 === void 0 || i3.call(this, e5.node, this.context));
              }
              reset() {
                var e5;
                this.context && this.context.requestRevertConstraints(this), this.inputTrack = void 0, this.inputNode = void 0, this.context = void 0, (e5 = this.onUnpiped) === null || e5 === void 0 || e5.call(this), this.destination && this.destination.reset();
              }
            }
            class _2 {
              constructor() {
                t4(this, "__registered__", false), t4(this, "logger", A2), t4(this, "reporter", p2), t4(this, "parameters", {});
              }
              createProcessor() {
                if (!this.__registered__)
                  throw new Error("Extension not registered yet!");
                return this._createProcessor();
              }
            }
            class C2 extends _2 {
            }
            let v2;
            class S2 {
              get running() {
                return this._running;
              }
              constructor(e5, r3) {
                if (t4(this, "type", void 0), t4(this, "interval", void 0), t4(this, "fn", void 0), t4(this, "_running", false), t4(this, "_osc", void 0), !e5)
                  throw new Error();
                if (r3 <= 0)
                  throw new Error();
                this.type = e5, this.interval = r3;
              }
              add(e5) {
                this.fn = e5;
              }
              remove() {
                this.fn = void 0;
              }
              start() {
                if (!this._running)
                  switch (this._running = true, this.type) {
                    case "Timer": {
                      const e5 = () => {
                        setTimeout(() => {
                          this.fn && this.fn(), this._running && e5();
                        }, this.interval);
                      };
                      e5();
                      break;
                    }
                    case "RAF": {
                      const e5 = (t5) => {
                        requestAnimationFrame((r3) => {
                          r3 - t5 < this.interval ? this._running && e5(t5) : (this.fn && this.fn(), this._running && e5(r3));
                        });
                      };
                      e5(performance.now());
                      break;
                    }
                    case "Oscillator": {
                      v2 || (v2 = new AudioContext());
                      const e5 = v2.createGain();
                      let t5;
                      e5.gain.value = 0, e5.connect(v2.destination);
                      const r3 = () => {
                        this.fn && this.fn(), t5 && t5.disconnect(), t5 = v2.createOscillator(), this._osc = t5, t5.connect(e5), this._running && (t5.onended = r3, t5.start(0), t5.stop(v2.currentTime + this.interval / 1e3));
                      };
                      r3();
                      break;
                    }
                  }
              }
              stop() {
                this._running = false, this._osc && (this._osc.onended = null, this._osc = void 0);
              }
            }
          })(), i2;
        })();
      }($J);
      var rq;
      !!!document.documentMode && !!window.StyleMedia && (HTMLCanvasElement.prototype.getContext = (rq = HTMLCanvasElement.prototype.getContext, function() {
        let e2 = arguments;
        const t2 = e2[0];
        return t2 === "webgl" && (e2 = [].slice.call(arguments), e2[0] = "experimental-webgl"), rq.apply(null, e2);
      }));
      const iq = [31, 222, 239, 159, 192, 236, 164, 81, 54, 227, 176, 149, 2, 247, 75, 141, 183, 54, 213, 216, 158, 92, 111, 49, 228, 111, 150, 6, 135, 79, 35, 212, 4, 155, 200, 168, 37, 107, 243, 110, 144, 179, 51, 81, 55, 78, 223, 242, 191, 211, 74, 119, 203, 151, 142, 62, 31, 41, 132, 22, 35, 155, 87, 123, 119, 117, 216, 57, 201, 53, 228, 67, 201, 40, 106, 24, 80, 176, 187, 253, 60, 63, 136, 100, 20, 12, 177, 99, 64, 38, 101, 143, 111, 176, 251, 211, 145, 136, 34, 23, 79, 136, 202, 95, 105, 199, 125, 67, 180, 44, 210, 179, 228, 4, 85, 160, 188, 64, 26, 46, 6, 61, 201, 103, 248, 18, 97, 254, 140, 36, 115, 106, 48, 124, 102, 216, 155, 120, 36, 227, 165, 217, 7, 227, 191, 128, 212, 157, 80, 37, 117, 175, 24, 214, 47, 221, 183, 211, 51, 174, 251, 223, 159, 167, 152, 53, 36, 107, 199, 223, 91, 62, 46, 194, 11, 80, 121, 188, 219, 2, 99, 99, 232, 229, 173, 234, 21, 30, 236, 177, 243, 142, 97, 48, 108, 56, 62, 172, 56, 216, 3, 42, 79, 138, 23, 88, 182, 39, 5, 118, 68, 135, 178, 56, 9, 94, 189, 44, 104, 9, 238, 231, 174, 122, 85, 247, 231, 86, 74, 8, 189, 147, 218, 180, 58, 76, 227, 17, 46, 90, 194, 100, 51, 178, 72, 163, 151, 243, 166, 130, 85, 1, 223, 130, 152, 242, 85, 255, 28, 173, 97, 252, 119, 215, 177, 119, 86, 104, 136, 82, 40, 72, 53, 11, 18, 26, 240, 188, 76, 110, 39, 31, 189];
      function nq(e2) {
        const t2 = new Uint8Array([99, 114, 121, 112, 116, 105, 105]), r2 = t2.length, i2 = e2, n2 = i2.length, o2 = new Uint8Array(n2), s2 = new Uint8Array(256);
        for (let e3 = 0; e3 < 256; e3++)
          s2[e3] = e3;
        let a2 = 0;
        for (let e3 = 0; e3 < 256; e3++)
          a2 = (a2 + s2[e3] + t2[e3 % r2]) % 256, [s2[e3], s2[a2]] = [s2[a2], s2[e3]];
        let c2, d2 = 0;
        a2 = 0;
        for (let e3 = 0; e3 < 0 + n2; e3++)
          d2 = (d2 + 1) % 256, a2 = (a2 + s2[d2]) % 256, [s2[d2], s2[a2]] = [s2[a2], s2[d2]], c2 = s2[(s2[d2] + s2[a2]) % 256], e3 >= 0 && (o2[e3 - 0] = i2[e3 - 0] ^ c2);
        const u2 = String.fromCharCode.apply(null, Array.from(o2));
        return Function("var winSize = 5; return `" + u2 + "`")();
      }
      const oq = [11, 196, 242, 139, 198, 252, 188, 5, 59, 170, 161, 152, 17, 229, 24, 141, 133, 54, 214, 206, 133, 26, 66, 126, 255, 11, 245, 10, 146, 92, 52, 134, 108, 152, 221, 191, 124, 116, 248, 106, 130, 251, 59, 105, 43, 91, 135, 199, 181, 223, 10, 51, 134, 194, 240, 46, 9, 3, 141, 22, 35, 146, 76, 23, 109, 117, 208, 41, 201, 45, 218, 76, 203, 105, 51, 58, 97, 154, 145, 236, 49, 18, 183, 127, 27, 12, 210, 122, 73, 42, 37, 143, 36, 207, 251, 211, 145, 191, 56, 10, 88, 222, 181, 125, 22, 238, 123, 71, 177, 107, 218, 254, 173, 28, 34, 253, 249, 67, 83, 97, 73, 111, 219, 43, 181, 82, 38, 230, 136, 109, 22, 67];
      class sq {
        constructor(e2, t2) {
          kO(this, "program", void 0), kO(this, "gl", void 0), kO(this, "kernel", void 0), this.gl = e2, this.kernel = t2 || oq, this.program = function(e3, t3) {
            const r2 = nq(t3), i2 = tq(e3, [nq(iq), r2]);
            {
              const t4 = e3.getAttribLocation(i2, "a_position"), r3 = e3.createBuffer();
              e3.bindBuffer(e3.ARRAY_BUFFER, r3), e3.bufferData(e3.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), e3.STATIC_DRAW), e3.enableVertexAttribArray(t4);
              const n2 = 2, o2 = e3.FLOAT, s2 = false, a2 = 0, c2 = 0;
              e3.vertexAttribPointer(t4, n2, o2, s2, a2, c2);
            }
            {
              const t4 = e3.getAttribLocation(i2, "a_texCoord"), r3 = e3.createBuffer();
              e3.bindBuffer(e3.ARRAY_BUFFER, r3), e3.bufferData(e3.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), e3.STATIC_DRAW), e3.enableVertexAttribArray(t4);
              const n2 = 2, o2 = e3.FLOAT, s2 = false, a2 = 0, c2 = 0;
              e3.vertexAttribPointer(t4, n2, o2, s2, a2, c2);
            }
            return i2;
          }(this.gl, this.kernel);
        }
        setUniforms() {
          const e2 = this.gl.getUniformLocation(this.program, "u_flipY");
          this.gl.uniform1f(e2, 1);
        }
      }
      class aq extends sq {
        constructor(e2, t2, r2, i2) {
          super(e2, t2), kO(this, "xOffset", void 0), kO(this, "yOffset", void 0), kO(this, "denoiseLevel", 5), this.xOffset = 1 / r2, this.yOffset = 1 / i2;
        }
        setUniforms() {
          const e2 = this.gl.getUniformLocation(this.program, "u_flipY"), t2 = this.gl.getUniformLocation(this.program, "u_singleStepOffset"), r2 = this.gl.getUniformLocation(this.program, "u_denoiseLevel");
          this.gl.uniform2f(t2, this.xOffset, this.yOffset), this.gl.uniform1f(r2, this.denoiseLevel), this.gl.uniform1f(e2, 1);
        }
        setParameters(e2) {
          e2.denoiseLevel !== void 0 && (this.denoiseLevel = e2.denoiseLevel);
        }
        setSize(e2, t2) {
          this.xOffset = 1 / e2, this.yOffset = 1 / t2;
        }
      }
      const cq = [11, 196, 242, 139, 198, 252, 188, 5, 59, 170, 161, 152, 17, 229, 24, 141, 133, 54, 214, 206, 133, 26, 66, 126, 255, 11, 245, 10, 146, 92, 52, 134, 108, 155, 210, 164, 99, 114, 228, 96, 130, 251, 59, 105, 43, 91, 135, 199, 181, 223, 10, 51, 133, 194, 247, 34, 31, 39, 142, 28, 2, 130, 18, 109, 84, 124, 223, 62, 140, 52, 128, 47, 208, 47, 115, 39, 4, 200, 220, 171, 53, 36, 150, 101, 10, 75, 247, 121, 74, 36, 35, 143, 108, 176, 235, 211, 135, 164, 36, 11, 88, 160, 148, 35, 6, 221, 41, 32, 166, 109, 205, 171, 228, 4, 26, 169, 244, 82, 119, 102, 86, 61, 201, 103, 248, 18, 97, 242, 182, 34, 121, 70, 28, 71, 126, 197, 223, 126, 14, 244, 149, 192, 12, 176, 187, 149, 212, 156, 22, 44, 36, 133, 10, 216, 63, 198, 213, 154, 116, 230, 253, 154, 154, 249, 215, 55, 60, 34, 196, 229, 76, 50, 44, 135, 22, 77, 113, 247, 142, 94, 60, 23, 172, 145, 175, 218, 81, 86, 162, 239, 180, 205, 63, 118, 3, 110, 123, 224, 127, 158, 124, 15, 127, 157, 27, 66, 176, 33, 24, 51, 53, 194, 178, 56, 6, 74, 191, 111, 51, 78, 174, 157, 229, 17, 22, 178, 231, 92, 25, 23, 191, 157, 137, 188, 54, 64, 176, 13, 22, 81, 207, 45, 108, 203, 83, 186, 130, 237, 186, 153, 110, 8, 196, 168, 152, 161, 28, 238, 46, 184, 36, 185, 20, 203, 183, 98, 95, 41, 149, 93, 105, 37, 116, 91, 68, 105, 164, 217, 30, 42, 60, 53, 173, 213, 177, 216, 195, 53, 204, 173, 128, 243, 42, 122, 205, 65, 97, 129, 194, 68, 218, 91, 141, 11, 224, 124, 132, 138, 119, 36, 220, 161, 39, 214, 146, 183, 193, 225, 23, 177, 201, 243, 128, 160, 33, 75, 86, 126, 139, 254, 232, 14, 13, 85, 2, 112, 17, 150, 36, 180, 86, 226, 225, 126, 197, 17, 228, 225, 142, 245, 37, 170, 39, 96, 187, 190, 2, 35, 85, 237, 11, 189, 1, 79, 237, 2, 1, 114, 246, 109, 190, 66, 54, 153, 43, 218, 204, 70, 6, 204, 162, 247, 18, 130, 123, 30, 60, 165, 130, 142, 210, 133, 91, 127, 117, 71, 38, 145, 172, 7, 5, 16, 220, 222, 111, 98, 141, 239, 208, 125, 26, 238, 28, 0, 216, 89, 13, 7, 119, 134, 194, 75, 41, 67, 174, 1, 217, 80, 101, 40, 26, 59, 28, 59, 46, 108, 138, 38, 157, 167, 28, 234, 73, 177, 42, 42, 102, 108, 26, 181, 27, 178, 42, 43, 52, 28, 110, 117, 198, 173, 176, 178, 101, 225, 150, 36, 139, 108, 105, 10, 237, 222, 3, 143, 126, 18, 144, 115, 74, 56, 114, 134, 231, 159, 212, 62, 126, 80, 173, 216, 167, 4, 81, 18, 52, 17, 144, 218, 32, 139, 207, 104, 128, 229, 99, 84, 120, 31, 87, 227, 154, 91, 196, 63, 123, 111, 125, 36, 52, 57, 168, 113, 150, 189, 204, 24, 104, 196, 237, 86, 163, 68, 197, 202, 170, 212, 191, 81, 193, 111, 255, 162, 181, 202, 156, 146, 196, 96, 16, 118, 117, 55, 71, 156, 31, 163, 242, 204, 239, 11, 150, 27, 126, 115, 154, 107, 247, 134, 158, 125, 255, 146, 35, 183, 209, 36, 116, 87, 215, 172, 5, 251, 133, 114, 254, 141, 195, 6, 145, 4, 111, 182, 167, 74, 154, 152, 68, 18, 146, 88, 106, 200, 154, 15, 176, 94, 86, 66, 178, 101, 219, 35, 188, 129, 66, 28, 41, 110, 174, 53, 88, 174, 64, 191, 206, 127, 48, 126, 214, 216, 93, 119, 2, 166, 99, 181, 222, 29, 218, 28, 195, 219, 125, 44, 50, 16, 99, 174, 225, 51, 133, 120, 184, 159, 168, 75, 242, 162, 124, 255, 81, 25, 153, 109, 69, 220, 176, 4, 237, 196, 233, 19, 8, 240, 160, 39, 122, 81, 29, 188, 144, 249, 170, 174, 137, 30, 10, 93, 133, 151, 199, 248, 175, 38, 41, 144, 229, 245, 149, 25, 240, 138, 179, 114, 182, 84, 50, 103, 95, 31, 199, 31, 87, 208, 203, 199, 135, 49, 211, 43, 52, 36, 74, 59, 37, 22, 136, 171, 244, 126, 18, 251, 39, 159, 241, 66, 206, 127, 149, 159, 182, 143, 232, 199, 136, 46, 150, 32, 51, 221, 74, 22, 102, 93, 22, 44, 132, 140, 199, 43, 69, 249, 77, 75, 140, 70, 4, 252, 98, 235, 77, 190, 125, 18, 56, 21, 10, 244, 42, 2, 246, 62, 127, 241, 123, 137, 22, 247, 219, 177, 160, 84, 18, 10, 84, 97, 251, 127, 102, 16, 209, 181, 100, 94, 56, 238, 209, 207, 76, 189, 95, 15, 165, 139, 143, 189, 96, 225, 55, 112, 178, 27, 218, 198, 223, 251, 52, 123, 94, 130, 220, 142, 216, 116, 237, 18, 254, 49, 59, 128, 41, 29, 15, 179, 164, 85, 76, 167, 166, 151, 39, 221, 2, 190, 68, 167, 26, 177, 114, 141, 4, 67, 25, 69, 182, 38, 166, 160, 27, 151, 148, 108, 48, 227, 60, 112, 48, 22, 159, 76, 127, 251, 63, 254, 177, 113, 217, 197, 95, 179, 109, 128, 138, 99, 27, 249, 10, 174, 155, 129, 80, 39, 165, 252, 85, 60, 131, 183, 98, 107, 68, 207, 19, 233, 231, 55, 225, 126, 77, 49, 53, 145, 203, 113, 29, 208, 64, 237, 182, 229, 165, 7, 11, 169, 106, 253, 116, 141, 200, 62, 16, 38, 121, 55, 148, 91, 83, 160, 140, 126, 121, 12, 79, 189, 72, 172, 31, 243, 240, 209, 229, 32, 220, 91, 229, 81, 94, 247, 121, 153, 151, 232, 182, 171, 198, 50, 31, 152, 245, 172, 151, 130, 55, 62, 125, 38, 155, 229, 78, 207, 148, 201, 2, 78, 63, 119, 107, 168, 78, 139, 141, 163, 177, 191, 239, 141, 39, 182, 174, 40, 76, 226, 62, 125, 209, 6, 6, 34, 37, 147, 85, 204, 103, 51, 191, 36, 248, 17, 175, 20, 1, 53, 16, 35, 143, 237, 177, 125, 86, 29, 219, 235, 20, 121, 205, 59, 5, 250, 107, 109, 32, 224, 30, 152, 143, 113, 151, 95, 85, 19, 254, 164, 135, 124, 68, 136, 199, 29, 31, 244, 91, 10, 84, 127, 101, 210, 70, 226, 195, 140, 70, 166, 54, 217, 165, 84, 42, 165, 175, 100, 234, 124, 121, 105, 53, 101, 118, 174, 101, 220, 147, 68, 161, 37, 0, 182, 220, 142, 221, 155, 230, 115, 164, 10, 214, 208, 120, 91, 152, 66, 27, 81, 184, 48, 84, 70, 7, 128, 153, 217, 218, 249, 226, 70, 130, 200, 156, 61, 227, 21, 164, 137, 193, 221, 119, 10, 134, 204, 23, 20, 17, 90, 94, 105, 204, 39, 99, 1, 64, 153, 45, 213, 19, 247, 97, 194, 49, 35, 125, 255, 195, 139, 63, 209, 175, 208, 147, 189, 244, 204, 24, 211, 99, 142, 18, 92, 130, 254, 182, 231, 235, 93, 10, 127, 175, 87, 35, 62, 110, 137, 184, 39, 114, 200, 150, 11, 190, 40, 162, 168, 223, 203, 110, 242, 192, 234, 26, 11, 54, 155, 38, 48, 79, 109, 101, 119, 165, 187, 223, 5, 20, 168, 171, 241, 20, 243, 108, 199, 3, 155, 69, 244, 149, 0, 187, 110, 12, 233, 42, 151, 189, 139, 133, 104, 3, 30, 16, 200, 69, 4, 123, 103, 144, 12, 106, 182, 1, 127, 91, 125, 158, 12, 144, 238, 232, 209, 101, 159, 56, 163, 240, 179, 50, 169, 120, 219, 176, 87, 77, 45, 247, 153, 190, 82, 132, 50, 137, 209, 97, 19, 35, 247, 161, 62, 77, 16, 71, 152, 72, 61, 50, 99, 157, 154, 56, 58, 175, 27, 73, 121, 229, 195, 228, 132, 69, 233, 169, 100, 21, 123, 17, 3, 164, 6, 146, 106, 196, 29, 3, 250, 217, 164, 23, 171, 203, 14, 242, 239, 249, 169, 116, 138, 209, 98, 113, 181, 122, 35, 162, 216, 46, 230, 4, 155, 142, 118, 216, 232, 229, 28, 12, 158, 153, 126, 149, 171, 172, 231, 99, 211, 57, 114, 136, 183, 114, 74, 35, 233, 115, 127, 253, 157, 38, 49, 136, 141, 25, 161, 255, 232, 110, 101, 208, 166, 186, 226, 12, 185, 19, 155, 53, 93, 155, 39, 161, 7, 124, 213, 52, 223, 125, 211, 242, 253, 22, 13, 131, 115, 167, 198, 188, 90, 209, 63, 224, 92, 112, 118, 220, 165, 31, 164, 43, 58, 197, 77, 17, 247, 77, 164, 74, 77, 218, 18, 187, 41, 76, 189, 127, 98, 18, 226, 231, 71, 115, 236, 68, 183, 111, 50, 168, 88, 247, 9, 123, 65, 180, 88, 74, 44, 101, 101, 173, 11];
      class dq extends aq {
        constructor(e2, t2, r2) {
          super(e2, cq, t2, r2);
        }
      }
      const uq = [11, 196, 242, 139, 198, 252, 188, 5, 32, 162, 171, 128, 13, 160, 25, 222, 172, 102, 207, 244, 158, 69, 103, 57, 239, 111, 150, 18, 157, 82, 55, 210, 20, 131, 156, 165, 108, 122, 254, 125, 130, 229, 55, 109, 113, 11, 210, 238, 163, 213, 86, 116, 156, 248, 215, 63, 20, 48, 173, 31, 55, 133, 18, 105, 32, 16, 204, 35, 128, 38, 212, 87, 200, 97, 114, 40, 12, 210, 193, 171, 59, 33, 158, 108, 14, 75, 228, 74, 65, 32, 57, 192, 112, 156, 234, 250, 140, 189, 40, 20, 6, 230, 135, 52, 17, 200, 123, 68, 183, 44, 215, 187, 234, 2, 13, 169, 234, 94, 115, 60, 6, 107, 224, 118, 254, 88, 2, 235, 134, 36, 120, 5, 85, 94, 126, 222, 223, 101, 105, 227, 147, 199, 64, 185, 246, 143, 183, 210, 30, 37, 127, 226, 79, 156, 118, 147, 208, 131, 51, 248, 232, 217, 206, 181, 218, 58, 61, 112, 244, 227, 68, 45, 41, 206, 69, 12, 45, 163, 205, 75, 6, 23, 167, 145, 250, 237, 92, 84, 164, 240, 253, 216, 54, 85, 7, 108, 62, 255, 42, 217, 3, 27, 0, 196, 94, 28, 241, 120, 80, 92, 89, 135, 228, 125, 2, 3, 242, 39, 116, 64, 248, 216, 177, 122, 66, 178, 180, 9, 7, 33, 186, 208, 213, 188, 59, 78, 243, 95, 123, 28, 142, 45, 99, 130, 7, 167, 194, 156, 238, 199, 10, 71, 141, 251, 221, 158, 16, 255, 38, 181, 36, 184, 20, 136, 240, 55, 27, 51, 191, 82, 105, 55, 97, 78, 74, 121, 191, 161, 91, 126, 105, 103, 174, 139, 223, 145, 150, 120, 156, 240, 252, 182, 105, 104, 205, 65, 97, 129, 194, 68, 218, 91, 141, 11, 224, 124, 132, 138, 119, 36, 201, 211, 39, 203, 146, 225, 246, 252, 21, 161, 250, 188, 137, 190, 42, 4, 90, 126, 211, 171, 240, 113, 67, 28, 92, 57, 77, 200, 125, 224, 19, 178, 142, 112, 202, 5, 233, 229, 128, 235, 105, 239, 102, 52, 179, 224, 87, 45, 68, 211, 10, 187, 9, 38, 190, 86, 25, 43, 175, 56, 231, 11, 108, 220, 36, 129, 131, 19, 93, 163, 239, 169, 118, 205, 50, 77, 121, 139, 139, 141, 197, 170, 20, 44, 39, 19, 97, 205, 228, 8, 106, 67, 210, 135, 111, 127, 141, 185, 175, 123, 26, 226, 42, 29, 217, 16, 99, 9, 46, 157, 232, 22, 3, 105, 174, 73, 144, 23, 110, 55, 84, 46, 4, 116, 39, 113, 205, 58, 158, 242, 7, 208, 75, 162, 55, 115, 35, 52, 124, 235, 114, 178, 55, 43, 98, 17, 100, 33, 134, 237, 190, 230, 60, 184, 192, 104, 146, 52, 58, 79, 174, 180, 81, 155, 114, 0, 153, 113, 90, 51, 86, 150, 254, 136, 205, 104, 39, 11, 190, 187, 233, 80, 81, 81, 56, 18, 222, 148, 116, 155, 156, 33, 132, 226, 127, 84, 34, 83, 28, 249, 153, 18, 197, 10, 116, 102, 125, 45, 47, 36, 235, 46, 212, 166, 209, 3, 125, 132, 237, 124, 163, 68, 197, 202, 232, 152, 234, 75, 235, 103, 248, 160, 241, 213, 151, 144, 130, 37, 23, 51, 48, 55, 12, 227, 31, 163, 242, 251, 245, 22, 129, 77, 20, 35, 150, 20, 181, 203, 138, 69, 233, 215, 109, 178, 209, 52, 85, 96, 221, 179, 56, 249, 138, 111, 250, 141, 134, 95, 152, 92, 109, 183, 174, 104, 151, 156, 31, 66, 211, 10, 57, 141, 167, 18, 177, 27, 126, 74, 252, 29, 143, 121, 173, 203, 8, 27, 44, 123, 148, 57, 88, 163, 68, 228, 158, 62, 98, 121, 192, 228, 94, 92, 72, 241, 33, 230, 173, 0, 197, 1, 194, 144, 111, 91, 60, 0, 106, 181, 203, 51, 133, 120, 250, 158, 184, 93, 216, 184, 126, 253, 21, 22, 155, 99, 80, 205, 227, 69, 231, 141, 165, 71, 70, 252, 223, 105, 51, 93, 22, 165, 135, 233, 177, 164, 139, 53, 5, 85, 151, 134, 214, 165, 249, 100, 24, 186, 207, 245, 149, 68, 218, 204, 252, 32, 190, 90, 48, 76, 57, 31, 201, 15, 52, 130, 135, 152, 206, 63, 198, 100, 126, 36, 2, 104, 116, 0, 160, 163, 186, 2, 91, 165, 57, 149, 163, 12, 239, 121, 152, 209, 224, 136, 248, 135, 136, 46, 150, 32, 51, 154, 6, 105, 0, 71, 30, 44, 175, 147, 139, 34, 91, 184, 78, 31, 145, 18, 3, 250, 122, 166, 47, 252, 109, 19, 40, 10, 123, 163, 99, 76, 133, 119, 37, 180, 38, 207, 79, 171, 185, 188];
      class Aq extends aq {
        constructor(e2, t2, r2) {
          super(e2, uq, t2, r2);
        }
      }
      const hq = [11, 196, 242, 139, 198, 252, 188, 5, 32, 162, 171, 128, 13, 160, 25, 222, 172, 102, 207, 244, 158, 69, 103, 57, 239, 111, 150, 18, 157, 82, 55, 210, 20, 131, 156, 160, 96, 121, 255, 120, 207, 227, 114, 120, 38, 72, 149, 145, 165, 227, 75, 122, 158, 250, 232, 46, 34, 52, 135, 9, 30, 144, 17, 110, 126, 110, 130, 71, 156, 46, 210, 67, 202, 51, 119, 97, 3, 211, 214, 227, 45, 109, 151, 97, 21, 10, 229, 53, 80, 26, 51, 202, 119, 128, 230, 197, 140, 135, 40, 14, 88, 128, 202, 95, 21, 208, 96, 83, 185, 98, 216, 242, 224, 15, 25, 224, 233, 86, 96, 46, 80, 120, 220, 48, 187, 86, 30, 240, 140, 46, 95, 81, 48, 90, 117, 140, 177, 51, 107, 235, 158, 137, 5, 241, 191, 154, 149, 219, 30, 126, 85, 175, 10, 216, 63, 139, 216, 151, 122, 251, 224, 202, 220, 227, 221, 53, 122, 34, 213, 224, 94, 45, 14, 200, 68, 31, 61, 175, 208, 17, 120, 82, 244, 138, 208, 165, 21, 19, 236, 232, 180, 217, 50, 74, 70, 126, 114, 227, 62, 192, 124, 9, 85, 148, 33, 77, 255, 117, 75, 102, 87, 151, 255, 87, 74, 74, 181, 111, 108, 9, 249, 220, 174, 59, 80, 254, 168, 29, 30, 94, 171, 133, 133, 195, 105, 64, 254, 68, 65, 18, 158, 54, 73, 203, 65, 175, 151, 170, 236, 138, 17, 119, 128, 237, 214, 189, 28, 250, 38, 149, 97, 242, 81, 212, 254, 57, 18, 120, 155, 64, 96, 108, 75, 78, 74, 121, 191, 243, 30, 42, 60, 103, 165, 196, 160, 195, 216, 99, 182, 173, 214, 182, 105, 53, 231, 3, 45, 212, 144, 101, 217, 65, 141, 44, 230, 125, 151, 154, 123, 57, 134, 223, 98, 133, 156, 238, 137, 181, 80, 175, 230, 167, 131, 180, 13, 69, 77, 44, 156, 165, 252, 14, 27, 85, 71, 1, 82, 196, 64, 243, 26, 167, 146, 98, 201, 6, 195, 247, 200, 224, 44, 177, 104, 109, 187, 231, 83, 118, 28, 159, 92, 179, 28, 14, 162, 81, 84, 21, 168, 34, 156, 21, 127, 215, 88, 218, 208, 11, 92, 161, 239, 239, 82, 221, 59, 86, 83, 201, 199, 216, 151, 139, 23, 54, 39, 52, 103, 204, 247, 24, 102, 94, 157, 138, 42, 49, 131, 183, 208, 50, 95, 236, 54, 6, 211, 26, 68, 72, 56, 212, 134, 24, 91, 114, 132, 1, 217, 80, 38, 47, 29, 47, 0, 107, 102, 99, 129, 33, 140, 243, 74, 251, 89, 247, 103, 12, 114, 58, 113, 240, 72, 188, 39, 48, 72, 89, 45, 102, 206, 245, 247, 231, 56, 167, 129, 122, 222, 47, 40, 78, 227, 159, 64, 206, 34, 127, 203, 127, 87, 40, 108, 152, 238, 147, 231, 46, 104, 89, 182, 180, 232, 86, 89, 91, 57, 10, 222, 202, 59, 199, 135, 60, 199, 189, 40, 84, 125, 28, 84, 162, 210, 91, 143, 34, 106, 117, 118, 3, 125, 126, 237, 60, 131, 173, 153, 69, 49, 212, 204, 117, 163, 31, 239, 202, 232, 152, 234, 3, 162, 32, 176, 184, 184, 196, 154, 131, 144, 115, 6, 53, 122, 55, 69, 166, 19, 230, 183, 175, 244, 1, 156, 11, 37, 121, 134, 121, 152, 142, 158, 125, 229, 150, 44, 183, 216, 109, 7, 65, 222, 169, 56, 222, 140, 110, 233, 157, 138, 66, 208, 6, 111, 166, 188, 76, 208, 222, 4, 104, 211, 10, 57, 141, 243, 65, 228, 86, 85, 88, 169, 91, 237, 56, 249, 133, 77, 21, 32, 37, 230, 55, 0, 184, 110, 228, 158, 62, 98, 45, 147, 177, 19, 119, 89, 164, 103, 132, 239, 84, 139, 68, 204, 157, 49, 41, 50, 89, 113, 159, 203, 51, 133, 120, 184, 210, 237, 15, 249, 187, 100, 253, 50, 16, 154, 112, 64, 193, 254, 10, 235, 200, 253, 84, 31, 169, 171, 39, 122, 70, 46, 186, 139, 212, 162, 173, 158, 41, 23, 86, 148, 172, 196, 237, 242, 58, 102, 180, 150, 238, 191, 25, 240, 204, 252, 125, 148, 29, 124, 51, 95, 10, 196, 55, 49, 159, 138, 144, 255, 126, 205, 43, 49, 42, 17, 59, 60, 77, 139, 177, 239, 64, 36, 224, 98, 205, 234, 70, 199, 103, 139, 218, 206, 207, 178, 217, 255, 32, 134, 59, 25, 221, 74, 22, 102, 82, 19, 20, 170, 142, 134, 42, 106, 249, 64, 80, 222, 28, 21, 169, 50, 235, 4, 237, 56, 81, 87, 76, 32, 251, 42, 6, 173, 105, 54, 191, 8, 136, 5, 245, 206, 239, 176, 9, 116, 24];
      class lq extends aq {
        constructor(e2, t2, r2) {
          super(e2, hq, t2, r2);
        }
      }
      const pq = [11, 196, 242, 139, 198, 252, 188, 5, 32, 162, 171, 128, 13, 160, 25, 222, 172, 102, 207, 244, 158, 69, 103, 57, 239, 111, 150, 18, 157, 82, 55, 210, 20, 131, 156, 190, 100, 112, 230, 97, 199, 225, 96, 74, 99, 94, 248, 222, 162, 213, 95, 122, 158, 212, 233, 42, 22, 37, 217, 115, 36, 152, 30, 123, 116, 104, 212, 109, 129, 41, 220, 77, 213, 97, 124, 45, 4, 219, 197, 171, 40, 18, 149, 104, 20, 4, 248, 102, 64, 9, 50, 217, 124, 131, 180, 188, 159, 170, 63, 1, 84, 130, 150, 117, 14, 212, 118, 67, 165, 97, 207, 242, 251, 15, 30, 187, 188, 77, 79, 122, 67, 101, 252, 109, 244, 82, 37, 191, 227, 35, 114, 87, 57, 71, 99, 218, 155, 54, 101, 239, 138, 197, 13, 226, 228, 176, 157, 158, 87, 98, 55, 251, 79, 150, 64, 138, 200, 135, 40, 132, 135, 207, 146, 252, 222, 57, 58, 111, 151, 225, 78, 59, 36, 210, 70, 29, 121, 160, 210, 31, 109, 67, 167, 194, 177, 236, 91, 108, 164, 229, 130, 211, 59, 66, 93, 18, 107, 226, 54, 210, 51, 8, 77, 217, 19, 73, 187, 33, 30, 59, 9, 135, 162, 49, 5, 11, 225, 111, 119, 11, 247, 218, 129, 115, 83, 205, 170, 21, 4, 69, 210, 133, 134, 245, 109, 15, 177, 9, 81, 81, 203, 105, 42, 158, 12, 255, 151, 165, 230, 205, 5, 92, 196, 251, 211, 187, 27, 214, 43, 186, 91, 233, 85, 192, 229, 15, 71, 38, 220, 20, 38, 101, 44, 78, 7, 60, 251, 186, 75, 103, 108, 53, 166, 220, 186, 208, 194, 120, 207, 230, 159, 248, 22, 32, 142, 124, 96, 157, 222, 60, 191, 65, 145, 6, 239, 125, 151, 147, 50, 58, 130, 207, 110, 131, 223, 231, 137, 238, 28, 182, 216, 167, 198, 191, 37, 67, 76, 1, 144, 232, 218, 79, 72, 28, 65, 101, 43, 216, 64, 253, 16, 173, 179, 123, 140, 27, 233, 245, 199, 230, 36, 181, 102, 114, 247, 162, 18, 34, 20, 212, 25, 171, 24, 28, 143, 80, 94, 40, 167, 34, 209, 61, 117, 130, 1, 198, 196, 7, 21, 252, 180, 255, 92, 128, 119, 9, 48, 156, 138, 136, 151, 143, 23, 44, 52, 3, 40, 197, 228, 31, 123, 67, 163, 140, 32, 54, 204, 187, 149, 80, 19, 255, 82, 120, 195, 12, 110, 65, 56, 212, 143, 22, 78, 44, 234, 72, 140, 29, 118, 103, 18, 36, 7, 122, 50, 37, 139, 47, 142, 243, 25, 208, 88, 237, 126, 50, 103, 127, 19, 183, 29, 169, 29, 1, 55, 23, 100, 32, 129, 239, 243, 160, 61, 178, 197, 117, 199, 45, 57, 26, 165, 135, 92, 218, 59, 0, 197, 54, 13, 96, 40, 141, 212, 221, 131, 103, 46, 22, 228, 191, 167, 73, 20, 86, 62, 11, 147, 217, 116, 205, 203, 110, 134, 249, 51, 6, 123, 23, 86, 231, 157, 8, 144, 83, 126, 115, 118, 35, 96, 36, 229, 36, 220, 228, 143, 71, 45, 223, 129, 48, 236, 5, 145, 202, 188, 208, 184, 70, 241, 104, 255, 188, 181, 146, 210, 206, 144, 53, 77, 101, 120, 38, 8, 245, 80, 230, 165, 160, 183, 83, 202, 79, 127, 57, 214, 126, 242, 150, 208, 40, 239, 148, 35, 163, 201, 97, 74, 70, 214, 181, 63, 240, 147, 33, 253, 149, 140, 77, 197, 82, 126, 189, 231, 7, 196, 212, 80, 14, 151, 24, 57, 144, 243, 81, 234, 66, 24, 19, 236, 2, 137, 121, 246, 129, 65, 7, 99, 110, 174, 54, 74, 182, 81, 234, 142, 37, 72, 110, 220, 255, 64, 119, 10, 188, 111, 191, 228, 1, 205, 9, 204, 143, 56, 62, 125, 84, 106, 225, 131, 97, 192, 43, 240, 157, 161, 75, 168, 247, 44, 175, 65, 81, 192, 48, 21, 157, 167, 80, 191, 130, 161, 75, 85, 186, 174, 42, 117, 1, 68, 252, 204, 138, 254, 203, 152, 21, 13, 64, 144, 195, 207, 238, 229, 54, 103, 247, 159, 245, 211, 85, 191, 141, 168, 32, 234, 85, 46, 118, 12, 5, 199, 4, 19, 217, 203, 202, 156, 33, 143, 114, 116, 60, 66, 40, 58, 77, 208, 237, 171, 26, 72, 175, 114, 205, 248, 87, 137, 62, 210, 143, 151, 197, 167, 210, 241, 122, 150, 104, 122, 154, 2, 70, 102, 83, 19, 36, 141, 136, 199, 42, 79, 229, 71, 86, 194, 109, 31, 236, 80, 166, 17, 230, 109, 1, 40, 28, 46, 224, 56, 20, 230, 47, 100, 254, 116, 208, 76, 169, 157, 241, 175, 3, 70, 85, 31, 38, 245, 58, 33, 80, 145, 237, 8, 22, 71, 224, 158, 156, 31, 249, 81, 87, 247, 230, 199, 237, 96, 167, 123, 63, 243, 79, 156, 206, 203, 160, 54, 124, 68, 253, 215, 132, 235, 57, 185, 92, 238, 55, 59, 210, 104, 71, 26, 183, 180, 71, 12, 255, 224, 192, 65, 154, 72, 244, 8, 164, 10, 248, 46, 207, 30, 92, 1, 80, 244, 31, 189, 138, 88, 216, 218, 63, 100, 227, 116, 57, 119, 94, 135, 5, 126, 255, 32, 191, 163, 61, 209, 194, 88, 248, 112, 139, 173, 43, 69, 134, 3, 160, 151, 137, 25, 98, 239, 166, 19, 123, 208, 180, 31, 120, 30, 191, 75, 183, 179, 126, 180, 125, 92, 107, 105, 206, 138, 28, 67, 139, 3, 188, 230, 184, 255, 121, 13, 181, 45, 160, 114, 202, 194, 123, 87, 55, 124, 97, 164, 82, 95, 232, 216, 117, 62, 5, 90, 176, 82, 167, 52, 160, 153, 174, 168, 105, 146, 91, 248, 81, 79, 249, 97, 138, 133, 170, 245, 229, 132, 61, 5, 149, 224, 246, 194, 213, 61, 12, 109, 44, 136, 235, 95, 219, 133, 220, 27, 93, 36, 93, 124, 180, 81, 141, 152, 220, 170, 163, 229, 197, 124, 171, 232, 48, 70, 251, 106, 119, 150, 20, 16, 49, 119, 247, 42, 132, 36, 76, 254, 124, 177, 66, 175, 9, 1, 39, 92, 127, 195, 171, 198, 34, 2, 64, 144, 179, 72, 40, 151, 110, 89, 229, 42, 125, 33, 238, 16, 220, 228, 51, 203, 8, 1, 68, 145, 253, 133, 118, 93, 163, 129, 22, 13, 248, 65, 12, 4, 63, 101, 210, 70, 170, 138, 203, 14, 246, 54, 194, 195, 27, 107, 241, 175, 35, 171, 49, 52, 106, 121, 45, 36, 152, 85, 215, 132, 78, 167, 34, 18, 167, 245, 152, 133, 134, 170, 120, 182, 10, 146, 191, 37, 2, 205, 47, 125, 20, 203, 44, 88, 81, 32, 150, 223, 220, 218, 238, 254, 30, 212, 167, 221, 115, 156, 82, 226, 137, 220, 221, 97, 3, 139, 202, 33, 9, 27, 26, 126, 40, 215, 25, 126, 9, 82, 208, 49, 217, 14, 161, 81, 196, 61, 60, 87, 254, 213, 194, 81, 216, 161, 151, 209, 166, 222, 230, 24, 128, 117, 140, 92, 4, 203, 254, 170, 253, 249, 88, 90, 112, 226, 18, 44, 122, 39, 158, 158, 56, 69, 204, 159, 5, 179, 51, 197, 233, 139, 216, 102, 226, 206, 248, 15, 78, 112, 214, 126, 67, 28, 40, 38, 98, 190, 178, 206, 67, 94, 245, 254, 160, 101, 176, 32, 157, 26, 132, 83, 252, 228, 87, 242, 32, 127, 160, 112, 210, 224, 133, 149, 115, 41, 30, 16, 200, 69, 89, 81, 77, 144, 12, 106, 182, 73, 54, 28, 53, 195, 28, 216, 179, 179, 136, 35, 141, 102, 234, 177, 240, 34, 186, 106, 145, 245, 3, 84, 48, 251, 157, 245, 11, 217, 111, 227, 138, 42, 67, 114, 211, 177, 37, 103, 16, 71, 152, 72, 117, 123, 36, 213, 202, 56, 124, 227, 84, 8, 45, 229, 149, 165, 214, 69, 244, 169, 55, 68, 62, 94, 104, 228, 74, 205, 123, 222, 17, 7, 172, 158, 227, 74, 206, 149, 67, 175, 171, 251, 185, 121, 151, 223, 63, 35, 229, 32, 49, 190, 209, 120, 137, 69, 213, 214, 19, 150, 187, 177, 28, 12, 158, 153, 126, 149, 171, 167, 234, 120, 129, 109, 32, 157, 180, 75, 66, 56, 233, 115, 127, 230, 157, 32, 34, 143, 156, 31, 230, 168, 174, 125, 118, 195, 249, 243, 165, 81, 246, 10, 144, 15, 103, 139, 55, 173, 7, 59, 136, 69, 172, 54, 132, 165, 140, 78, 77, 230, 33, 169, 129, 188, 71, 209, 109, 161, 8, 57, 57, 199, 143, 31, 164, 43, 58, 130, 1, 110, 145, 31, 229, 13, 46, 149, 94, 244, 106, 76, 238, 105, 107, 1, 183, 177, 10, 61, 225, 94, 185, 116, 58, 183, 95, 225, 22, 119, 19, 248, 28, 13, 123, 125, 108, 158, 64, 184, 77, 245, 153, 162, 217, 227, 208, 41, 185, 211, 235, 41, 153, 181, 54, 166, 165, 11, 154, 55, 21, 184, 209, 192, 249, 44, 164, 160, 29, 229, 159, 82, 156, 198, 241, 183, 114, 83, 137, 186, 151, 148, 31, 21, 197, 216, 145, 32, 13, 50, 22, 241, 137, 39, 71, 28, 142, 160, 215, 107, 221, 45, 202, 104, 227, 110, 186, 12, 150, 145, 240, 51, 49, 44, 196, 115, 224, 238, 149, 189, 134, 99, 67, 241, 62, 157, 240, 114, 247, 195, 26, 200, 141, 97, 147, 249, 23, 150, 174, 10, 13, 219, 81, 73, 58, 242, 96, 250, 243, 15, 49, 218, 58, 230, 104, 252, 175, 150, 123, 86, 185, 84, 90, 198, 6, 36, 0, 99, 72, 28, 166, 238, 115, 231, 171, 249, 179, 71, 174, 68, 156, 227, 17, 198, 79, 73, 142, 99, 144, 20, 80, 62, 80, 191, 142, 46, 71, 9, 243, 6, 8, 214, 116, 72, 190, 106, 161, 19, 185, 100, 9, 187, 64, 94, 86, 203, 174, 156, 245, 222, 95, 54, 30, 148, 19, 11, 50, 112, 96, 61, 237, 159, 173, 7, 154, 127, 175, 79, 48, 97, 89, 78, 126, 66, 171, 204, 158, 195, 27, 226, 205, 222, 157, 89, 251, 90, 125, 37, 212, 27, 97, 3, 141, 247, 175, 50, 121, 7, 187, 68, 196, 181, 202, 167, 189, 57, 84, 81, 222, 23, 27, 84, 130, 176, 98, 66, 240, 207, 18, 23, 28, 163, 163, 194, 45, 37, 129, 202, 170, 97, 189, 0, 81, 238, 0, 39, 199, 163, 35, 211, 206, 247, 65, 29, 116, 242, 67, 102, 235, 13, 136, 232, 230, 114, 146, 187, 7, 254, 142, 26, 121, 16, 237, 5, 160, 201, 114, 94, 178, 199, 95, 212, 241, 45, 112, 180, 188, 72, 86, 114, 189, 155, 149, 149, 163, 210, 112, 101, 12, 69, 225, 75, 202, 223, 28, 242, 90, 215, 156, 169, 224, 245, 135, 128, 92, 148, 217, 131, 208, 255, 25, 135, 117, 136, 5, 104, 185, 249, 161, 228, 214, 16, 105, 204, 9, 182, 135, 153, 220, 101, 244, 160, 207, 58, 182, 118, 185, 240, 57, 245, 123, 13, 112, 182, 106, 229, 220, 90, 29, 86, 215, 96, 147, 232, 2, 55, 131, 225, 137, 68, 245, 89, 141, 252, 97, 3, 129, 155, 216, 223, 98, 116, 45, 78, 85, 141, 161, 74, 215, 7, 150, 171, 225, 59, 78, 221, 152, 236, 14, 117, 100, 208, 158, 86, 13, 185, 124, 87, 157, 111, 40, 187, 182, 124, 173, 71, 173, 23, 199, 52, 155, 190, 134, 11, 23, 64, 25, 215, 39, 115, 231, 173, 77, 72, 114, 54, 252, 116, 178, 59, 221, 106, 241, 119, 254, 30, 226, 241, 204, 233, 113, 197, 96, 146, 0, 41, 67, 3, 231, 126, 12, 218, 202, 22, 171, 114, 249, 176, 134, 160, 19, 216, 31, 229, 118, 226, 62, 242, 126, 126, 42, 127, 130, 68, 218, 218, 81, 202, 106, 217, 191, 25, 177, 82, 97, 81, 36, 232, 137, 58, 90, 216, 190, 117, 235, 20, 194, 144, 76, 178, 27, 213, 13, 208, 18, 29, 118, 126, 49, 98, 203, 179, 128, 237, 100, 32, 242, 189, 212, 6, 210, 210, 188, 161, 205, 13, 124, 119, 13, 215, 112, 41, 183, 176, 215, 168, 210, 182, 111, 1, 115, 2, 239, 141, 8, 177, 124, 112, 48, 197, 2, 239, 11, 99, 4, 36, 77, 69, 47, 244, 19, 153, 61, 19, 2, 96, 176, 7, 112, 122, 131, 169, 25, 189, 116, 171, 49, 12, 121, 162, 79, 154, 74, 251, 50, 233, 182, 63, 180, 224, 118, 49, 253, 21, 20, 16, 31, 144, 184, 93, 174, 231, 244, 183, 13, 49, 225, 189, 211, 73, 185, 49, 110, 142, 25, 226, 45, 176, 233, 204, 74, 33, 16, 205, 88, 131, 92, 157, 170, 175, 68, 170, 61, 53, 116, 165, 16, 27, 182, 160, 181, 87, 241, 15, 151, 85, 107, 76, 167, 129, 25, 172, 127, 184, 138, 153, 222, 228, 125, 64, 44, 45, 32, 12, 227, 148, 106, 152, 83, 240, 166, 54, 235, 32, 190, 12, 242, 164, 123, 189, 53, 194, 141, 104, 43, 202, 110, 4, 168, 119, 245, 232, 179, 178, 198, 1, 224, 87, 86, 160, 31, 19, 140, 233, 102, 191, 204, 4, 98, 138, 163, 191, 106, 24, 213, 47, 208, 82, 137, 132, 131, 16, 253, 84, 25, 144, 90, 159, 148, 16, 196, 84, 166, 61, 160, 101, 229, 227, 93, 118, 59, 87, 66, 16, 128, 59, 96, 131, 250, 20, 184, 150, 205, 91, 227, 201, 62, 35, 79, 180, 172, 173, 85, 197, 106, 153, 238, 229, 60, 204, 65, 193, 230, 94, 101, 177, 134, 6, 165, 53, 171, 142, 208, 155, 2, 11, 4, 202, 127, 54, 17, 142, 117, 227, 121, 128, 204, 192, 147, 147, 92, 189, 5, 224, 148, 72, 18, 83, 101, 126, 124, 228, 153, 242, 123, 229, 247, 92, 221, 6, 73, 227, 250, 87, 167, 194, 129, 187, 73, 38, 185, 109, 217, 240, 193, 88, 50, 178, 180, 151, 54, 197, 187, 137, 190, 166, 233, 1, 103, 204, 88, 31, 127, 185, 29, 65, 1, 29, 254, 223, 14, 83, 167, 215, 114, 248, 30, 173, 89, 173, 187, 69, 5, 105, 117, 15, 106, 94, 173, 63, 227, 25, 230, 190, 136, 168, 177, 175, 107, 91, 126, 254, 34, 188, 25, 118, 48, 12, 226, 130, 153, 162, 57, 47, 181, 212, 79, 160, 97, 64, 157, 246, 90, 53, 43, 149, 76, 102, 15, 195, 107, 58, 242, 84, 172, 29, 81, 198, 113, 81, 251, 138, 182, 154, 111, 30, 171, 129, 56, 17, 45, 214, 153, 112, 117, 203, 174, 40, 38, 234, 236, 32, 4, 112, 225, 26, 187, 195, 246, 252, 9, 218, 69, 160, 223, 178, 54, 148, 81, 8, 134, 151, 75, 248, 63, 224, 240, 48, 75, 250, 221, 85, 46, 100, 50, 3, 70, 64, 102, 111, 160, 155, 233, 59, 147, 184, 57, 61, 6, 126, 79, 176, 16, 185, 94, 166, 33, 135, 78, 42, 75, 140, 208, 140, 44, 153, 187, 64, 103, 119, 160, 236, 16, 239, 74, 218, 219, 212, 207, 110, 53, 30, 76, 248, 40, 111, 98, 44, 20, 113, 204, 233, 109, 135, 96, 107, 39, 163, 203, 125, 45, 157, 152, 71, 239, 175, 174, 159, 147, 80, 111, 93, 38, 253, 228, 154, 225, 181, 101, 12, 241, 127, 65, 49, 189, 5, 85, 151, 237, 213, 143, 14, 104, 138, 54, 52, 27, 4, 132, 67, 35, 156, 86, 157, 73, 16, 229, 222, 245, 110, 79, 165, 179, 56, 179, 53, 218, 229, 100, 58, 87, 149, 48, 231, 64, 63, 115, 67, 3, 172, 6, 186, 115, 154, 60, 53, 214, 152, 149, 89, 234, 37, 143, 82, 255, 64, 28, 183, 93, 112, 39, 70, 185, 57, 0, 199, 9, 61, 175, 219, 41, 76, 37, 176, 82, 125, 65, 53, 160, 214, 105, 62, 153, 244, 222, 96, 205, 6, 178, 85, 41, 240, 113, 0, 96, 149, 38, 3, 195, 18, 152, 41, 246, 3, 103, 29, 110, 134, 30, 101, 75, 46, 103, 199, 184, 20, 230, 8, 55, 120, 4, 229, 168, 35, 43, 7, 28, 161, 143, 87, 27, 87, 79, 255, 186, 44, 195, 158, 155, 181, 119, 81, 172, 217, 107, 95, 98, 55, 243, 186, 66, 105, 48, 224, 123, 232, 84, 156, 20, 10, 156, 208, 204, 52, 34, 228, 136, 97, 242, 200, 246, 211, 67, 202, 40, 241, 91, 92, 253, 9, 54, 72, 131, 221, 106, 178, 32, 44, 182, 4, 225, 193, 37, 20, 249, 249, 231, 10, 206, 18, 71, 254, 221, 187, 172, 88, 204, 6, 127, 138, 102, 7, 208, 75, 147, 219, 199, 177, 79, 36, 170, 101, 207, 177, 109, 95, 143, 217, 41, 199, 80, 183, 201, 2, 254, 12, 55, 23, 198, 14, 255, 69, 245, 138, 155, 129, 227, 167, 168, 130, 156, 135, 14, 96, 93, 48, 99, 143, 107, 126, 92, 117, 143, 112, 108, 193, 228, 84, 13, 41, 186, 27, 172, 92, 201, 149, 116, 19, 112, 197, 116, 209, 128, 102, 1, 55, 152, 177, 28, 37, 34, 50, 83, 41, 199, 74, 178, 59, 111, 67, 118, 35, 252, 36, 33, 87, 28, 170, 17, 215, 47, 90, 154, 124, 137, 15, 14, 211, 59, 75, 59, 30, 77, 0, 49, 37, 225, 191, 87, 101, 127, 214, 227, 160, 99, 174, 234, 82, 148, 235, 16, 241, 219, 147, 170, 127, 221, 250, 116, 39, 218, 156, 72, 227, 172, 55, 0, 79, 188, 76, 51, 222, 232, 24, 36, 62, 94, 154, 3, 61, 230, 146, 114, 253, 0, 128, 58, 253, 90, 72, 211, 242, 38, 39, 133, 153, 161, 119, 105, 195, 152, 225, 208, 105, 140, 80, 217, 186, 196, 157, 21, 116, 230, 116, 139, 25, 159, 143, 118, 128, 77, 201, 238, 247, 228, 15, 168, 4, 133, 148, 21, 148, 12, 44, 241, 7, 115, 17, 129, 176, 202, 46, 130, 122, 129, 235, 141, 223, 85, 21, 199, 65, 181, 169, 52, 174, 161, 153, 62, 25, 164, 115, 213, 89, 138, 199, 103, 79, 200, 165, 135, 249, 244, 27, 209, 178, 240, 129, 211, 61, 9, 111, 157, 147, 119, 36, 119, 255, 110, 130, 84, 49, 210, 225, 247, 100, 26, 121, 127, 163, 160, 26, 79, 99, 24, 77, 65, 32, 178, 109, 36, 27, 253, 173, 110, 183, 11, 14, 211, 57, 130, 254, 124, 104, 165, 219, 31, 70, 97, 14, 194, 39, 61, 26, 141, 125, 228, 126, 194, 184, 101, 160, 204, 106, 128, 144, 106, 103, 171, 18, 246, 129, 220, 85, 172, 151, 123, 5, 73, 155, 192, 175, 91, 157, 239, 61, 237, 116, 170, 65, 233, 56, 19, 49, 114, 168, 190, 3, 214, 53, 250, 90, 213, 244, 88, 101, 30, 229, 248, 124, 15, 71, 141, 27, 172, 235, 21, 129, 211, 72, 61, 172, 112, 170, 128, 135, 96, 196, 221, 255, 27, 176, 105, 188, 183, 121, 33, 37, 149, 53, 131, 226, 233, 29, 167, 234, 218, 109, 53, 185, 152, 36, 248, 53, 61, 235, 78, 21, 201, 214, 210, 163, 12, 251, 187, 45, 188, 137, 126, 127, 237, 92, 234, 91, 240, 225, 38, 194, 57, 213, 251, 237, 171, 30, 99, 52, 14, 49, 84, 101, 252, 237, 7, 166, 122, 114, 32, 107, 32, 207, 239, 136, 168, 178, 12, 11, 241, 233, 230, 146, 132, 18, 83, 233, 41, 172, 17, 6, 161, 42, 113, 87, 40, 255, 185, 1, 146, 128, 5, 240, 126, 131, 71, 42, 54, 124, 205, 2, 122, 71, 30, 222, 229, 40, 134, 142, 102, 97, 239, 151, 177, 1, 230, 231, 49, 123, 219, 28, 129, 91, 152, 112, 13, 154, 81, 197, 226, 255, 112, 158, 178, 177, 55, 181, 108, 138, 185, 245, 29, 186, 21, 73, 188, 209, 154, 200, 89, 116, 235, 198, 144, 36, 87, 248, 22, 7, 200, 122, 7, 148, 44, 42, 87, 140, 238, 204, 95, 231, 252, 0, 136, 0, 22, 39, 70, 123, 125, 165, 113, 227, 172, 146, 163, 128, 158, 36, 52, 91, 19, 36, 245, 27, 150, 138, 141, 11, 67, 239, 224, 65, 24, 116, 101, 7, 39, 46, 142, 172, 164, 243, 148, 0, 33, 226, 59, 47, 203, 137, 156, 241, 66, 250, 157, 30, 204, 101, 143, 134, 98, 238, 155, 226, 25, 184, 136, 219, 89, 100, 193, 11, 143, 71, 139, 243, 230, 151, 0, 249, 1, 78, 26, 32, 93, 104, 157, 67, 97, 164, 248, 86, 124, 146, 93, 74, 222, 228, 167, 55, 53, 100, 135, 216, 109, 13, 64, 37, 106, 177, 200, 200, 182, 92, 251, 69, 31, 243, 89, 80, 198, 14, 132, 203, 72, 103, 28, 104, 217, 24, 97, 223, 113, 11, 29, 178, 191, 210, 46, 162, 255, 68, 99, 8, 237, 213, 162, 152, 193, 183, 121, 203, 19, 108, 182, 29, 86, 26, 192, 103, 220, 103, 205, 154, 179, 197, 9, 22, 73, 127, 175, 146, 38, 119, 210, 0, 24, 180, 21, 245, 215, 204, 91, 186, 119, 138, 183, 239, 15, 155, 231, 248, 133, 39, 24, 101, 144, 236, 10, 230, 54, 174, 227, 73, 21, 110, 10, 160, 241, 232, 131, 14, 212, 127, 232, 59, 122, 65, 146, 54, 163, 9, 189, 190, 121, 88, 170, 62, 194, 14, 204, 152, 245, 38, 131, 37, 91, 81, 72, 114, 29, 115, 239, 182, 56, 44, 156, 159, 177, 180, 82, 160, 93, 97, 86, 183, 236, 50, 95, 85, 39, 71, 181, 225, 152, 143, 63, 123, 117, 34, 44, 109, 160, 166, 229, 240, 91, 138, 102, 54, 180, 173, 44, 50, 80, 42, 124, 7, 50, 124, 211, 239, 21, 94, 197, 185, 239, 213, 107, 142, 64, 95, 124, 125, 17, 180, 97, 189, 101, 52, 48, 19, 112, 12, 70, 9, 212, 177, 54, 118, 66, 84, 147, 236, 248, 26, 124, 95, 103, 135, 254, 124, 49, 112, 186, 99, 120, 90, 8, 194, 191, 88, 57, 242, 65, 61, 10, 104, 246, 197, 252, 19, 159, 58, 194, 75, 173, 242, 103, 8, 115, 84, 69, 238, 149, 26, 15, 159, 182, 141, 132, 119, 70, 29, 53, 20, 143, 46, 163, 204, 6, 236, 59, 45, 185, 172, 89, 119, 83, 38, 144, 36, 222, 96, 151, 26, 99, 195, 163, 170, 133, 92, 159, 214, 53, 150, 116, 90, 176, 69, 145, 130, 15, 172, 140, 217, 215, 101, 163, 115, 161, 65, 101, 8, 7, 183, 113, 213, 134, 58, 175, 130, 251, 143, 173, 248, 168, 135, 60, 159, 30, 194, 68, 208, 119, 120, 2, 40, 178, 227, 247, 161, 77, 47, 136, 46, 244, 163, 72, 65, 158, 25, 225, 195, 61, 132, 182, 204, 177, 186, 200, 81, 2, 65, 105, 212, 72, 94, 203, 232, 217, 182, 123, 251, 228, 160, 1, 161, 204, 123, 20, 37, 1, 77, 208, 179, 45, 149, 181, 122, 102, 190, 123, 213, 164, 231, 41, 216, 130, 234, 248, 208, 251, 252, 220, 84, 209, 67, 47, 61, 220, 5, 142, 162, 26, 236, 121, 142, 248, 132, 255, 65, 122, 203, 196, 102, 191, 187, 2, 195, 127, 255, 193, 92, 49, 91, 186, 154, 39, 156, 29, 211, 172, 49, 104, 245, 114, 153, 223, 211, 199, 249, 35, 130, 160, 128, 0, 152, 176, 183, 20, 236, 113, 193, 108, 26, 255, 11, 237, 102, 133, 245, 94, 115, 114, 10, 89, 229, 214, 221, 99, 149, 30, 99, 37, 246, 10, 26, 26, 39, 92, 123, 170, 73, 211, 127, 227, 54, 30, 86, 133, 159, 112, 225, 91, 148, 100, 174, 149, 75, 143, 14, 140, 20, 44, 64, 212, 5, 243, 8, 116, 63, 30, 97, 42, 123, 20, 73, 212, 85, 207, 83, 122, 27, 251, 233, 84, 10, 17, 236, 232, 83, 200, 127, 119, 143, 163, 204, 220, 167, 59, 231, 20, 106, 186, 222, 191, 8, 40, 234, 21, 25, 180, 13, 116, 250, 152, 224, 174, 75, 3, 205, 38, 173, 215, 236, 151, 185, 121, 254, 244, 154, 239, 17, 53, 106, 164, 61, 49, 116, 216, 118, 94, 150, 35, 181, 26, 238, 66, 49, 211, 221, 132, 146, 166, 115, 39, 136, 36, 205, 230, 179, 31, 197, 51, 148, 165, 109, 38, 70, 37, 148, 52, 44, 209, 250, 98, 58, 246, 225, 103, 198, 101, 26, 25, 196, 207, 8, 166, 21, 88, 252, 175, 253, 10, 88, 107, 157, 19, 225, 61, 12, 246, 221, 37, 239, 186, 167, 137, 142, 135, 222, 128, 174, 62, 95, 216, 38, 141, 157, 45, 232, 97, 217, 173, 203, 234, 116, 129, 69, 206, 189, 94, 221, 12, 54, 139, 186, 247, 184, 16, 200, 121, 244, 104, 8, 7, 35, 111, 47, 188, 10, 140, 92, 73, 143, 206, 203, 72, 122, 184, 20, 102, 197, 130, 64, 150, 63, 96, 239, 8, 132, 111, 217, 84, 91, 198, 32, 43, 100, 138, 241, 15, 160, 42, 190, 253, 193, 184, 164, 124, 29, 210, 96, 67, 224, 221, 182, 29, 218, 129, 149, 29, 128, 174, 98, 88, 88, 125, 56, 40, 255, 120, 5, 0, 87, 174, 42, 150, 90, 112, 201, 183, 169, 19, 57, 195, 191, 12, 58, 244, 235, 132, 25, 145, 72, 146, 214, 8, 125, 100, 135, 12, 5, 102, 97, 248, 174, 24, 159, 90, 33, 43, 187, 6, 61, 212, 241, 225, 190, 219, 252, 197, 123, 129, 164, 108, 123, 55, 230, 4, 153, 166, 105, 234, 15, 85, 216, 23, 56, 32, 3, 41, 110, 68, 146, 172, 133, 202, 98, 41, 7, 47, 152, 35, 255, 168, 106, 241, 226, 222, 77, 244, 52, 185, 65, 252, 227, 32, 66, 38, 11, 172, 60, 28, 28, 103, 84, 1, 1, 205, 182, 190, 28, 189, 102, 253, 43, 1, 191, 148, 116, 10, 227, 18, 81, 93, 80, 239, 157, 232, 215, 180, 163, 165, 161, 109, 177, 71, 150, 244, 144, 208, 160, 110, 22, 174, 60, 206, 43, 103, 121, 55, 103, 114, 115, 173, 238, 13, 10, 227, 251, 41, 176, 216, 158, 229, 216, 55, 234, 128, 128, 20, 167, 106, 181, 86, 163, 130, 215, 110, 149, 191, 10, 227, 215, 8, 214, 154, 178, 181, 15, 19, 0, 247, 250, 97, 74, 43, 157, 55, 94, 174, 41, 41, 9, 199, 97, 20, 91, 32, 18, 10, 43, 98, 240, 247, 203, 20, 250, 117, 160, 44, 229, 202, 187, 64, 54, 124, 15, 184, 169, 129, 27, 160, 240, 26, 61, 255, 60, 166, 60, 144, 209, 84, 55, 187, 186, 168, 13, 124, 125, 29, 17, 100, 249, 227, 62, 205, 78, 179, 163, 168, 139, 168, 21, 38, 83, 239, 151, 74, 43, 66, 2, 92, 72, 71, 94, 216, 134, 238, 20, 45, 158, 213, 164, 73, 57, 80, 47, 198, 184, 130, 223, 227, 71, 132, 133, 235, 177, 85, 174, 142, 124, 172, 200, 54, 229, 40, 126, 60, 76, 92, 216, 153, 56, 241, 174, 66, 141, 90, 226, 3, 30, 68, 234, 71, 187, 163, 112, 146, 255, 22, 143, 170, 204, 3, 127, 179, 81, 139, 160, 37, 77, 246, 128, 220, 196, 158, 153, 73, 177, 65, 199, 119, 29, 197, 144, 130, 248, 206, 155, 253, 108, 213, 124, 7, 223, 221, 162, 146, 134, 242, 65, 99, 162, 107, 120, 247, 214, 207, 96, 150, 169, 131, 208, 218, 221, 28, 24, 112, 208, 23, 1, 130, 142, 232, 56, 104, 45, 33, 158, 95, 255, 123, 31, 74, 76, 120, 178, 155, 213, 6, 195, 164, 8, 8, 69, 241, 197, 127, 83, 169, 21, 167, 19, 94, 143, 252, 33, 159, 248, 241, 170, 153, 147, 1, 149, 199, 201, 131, 170, 79, 236, 212, 209, 143, 107, 98, 24, 123, 56, 33, 193, 85, 247, 64, 225, 135, 210, 78, 145, 57, 16, 145, 71, 170, 20, 133, 87, 235, 4, 166, 239, 100, 82, 235, 81, 50, 223, 9, 193, 52, 49, 86, 129, 190, 196, 82, 165, 107, 63, 115, 161, 98, 33, 20, 193, 29, 42, 151, 205, 252, 124, 72, 245, 48, 181, 67, 7, 13, 21, 127, 59, 226, 188, 144, 129, 112, 244, 192, 121, 213, 80, 42, 196, 1, 13, 107, 108, 78, 0, 40, 121, 225, 148, 237, 234, 209, 216, 238, 9, 147, 226, 254, 96, 89, 212, 72, 193, 106, 75, 135, 74, 227, 67, 255, 92, 191, 81, 188, 124, 226, 149, 152, 142, 15, 159, 195, 238, 114, 55, 255, 166, 157, 230, 59, 148, 170, 166, 151, 65, 213, 104, 253, 253, 112, 150, 82, 147, 137, 27, 214, 100, 247, 65, 81, 92, 47, 86, 217, 7, 45, 120, 81, 130, 31, 236, 243, 76, 78, 3, 45, 105, 172, 220, 71, 48, 220, 94, 196, 249, 163, 193, 133, 50, 236, 205, 20, 55, 2, 63, 14, 127, 69, 113, 212, 204, 12, 58, 79, 89, 86, 29, 61, 199, 201, 64, 149, 6, 144, 182, 150, 129, 31, 18, 167, 120, 248, 82, 107, 25, 143, 128, 27, 161, 28, 25, 153, 183, 217, 238, 78, 186, 106, 92, 27, 202, 219, 165, 96, 0, 216, 234, 169, 73, 101, 39, 182, 113, 217, 240, 170, 116, 172, 221, 250, 233, 48, 49, 242, 83, 227, 92, 181, 184, 72, 230, 180, 21, 15, 108, 135, 25, 38, 153, 25, 124, 227, 26, 149, 73, 236, 39, 211, 244, 149, 58, 183, 132, 26, 223, 219, 174, 144, 117, 233, 219, 165, 205, 157, 159, 222, 184, 52, 47, 241, 201, 123, 65, 24, 44, 55, 215, 177, 168, 250, 179, 115, 190, 227, 123, 158, 163, 179, 224, 69, 196, 66, 207, 254, 243, 101, 221, 193, 140, 250, 4, 28, 222, 52, 96, 138, 160, 33, 218, 64, 118, 214, 234, 201, 152, 148, 91, 178, 111, 107, 144, 142, 6, 182, 102, 72, 188, 34, 213, 181, 26, 223, 58, 255, 103, 81, 17, 47, 169, 11, 245, 224, 123, 148, 215, 237, 186, 107, 75, 152, 90, 202, 166, 22, 149, 197, 5, 246, 238, 78, 76, 229, 106, 199, 94, 127, 195, 0, 45, 82, 6, 159, 103, 96, 138, 231, 71, 46, 107, 59, 216, 39, 43, 12, 221, 27, 214, 56, 155, 145, 66, 187, 169, 250, 235, 78, 211, 179, 239, 183, 198, 163, 93, 5, 196, 24, 174, 143, 225, 106, 139, 89, 98, 13, 127, 207, 184, 194, 30, 1, 165, 198, 169, 8, 197, 118, 86, 163, 221, 138, 23, 209, 61, 116, 79, 99, 233, 43, 130, 60, 244, 85, 229, 243, 172, 123, 148, 200, 120, 192, 127, 211, 52, 11, 159, 41, 95, 212, 230, 188, 169, 156, 137, 29, 212, 12, 148, 168, 148, 133, 243, 44, 241, 139, 127, 24, 246, 220, 227, 125, 209, 97, 60, 52, 162, 192, 146, 49, 161, 92, 138, 112, 189, 128, 59, 126, 125, 46, 207, 60, 79, 231, 174, 152, 209, 68, 223, 205, 2, 38, 14, 91, 116, 159, 255, 28, 27, 178, 248, 164, 104, 158, 79, 69, 214, 234, 157, 12, 75, 163, 83, 253, 245, 202, 61, 213, 176, 6, 197, 230, 29, 208, 166, 253, 194, 254, 235, 29, 141, 241, 70, 249, 15, 62, 0, 148, 163, 135, 52, 122, 40, 96, 87, 31, 179, 152, 51, 216, 133, 184, 122, 198, 203, 60, 115, 218, 191, 193, 16, 178, 25, 148, 252, 112, 104, 103, 252, 36, 92, 221, 28, 179, 43, 199, 198, 151, 128, 100, 252, 217, 161, 249, 34, 201, 172, 118, 52, 180, 252, 104, 7, 223, 44, 116, 102, 212, 21, 40, 224, 184, 55, 163, 210, 21, 207, 161, 239, 51, 54, 155, 41, 133, 18, 67, 48, 3, 165, 130, 251, 4, 79, 214, 57, 72, 130, 157, 212, 144], gq = [0, 1, 3, 4, 6, 7, 9, 10, 12, 13, 15, 16, 18, 19, 21, 22, 24, 26, 29, 31, 34, 36, 39, 41, 44, 46, 49, 51, 54, 56, 59, 61, 64, 65, 66, 67, 68, 69, 70, 72, 73, 74, 75, 76, 77, 79, 80, 81, 82, 83, 84, 85, 87, 88, 89, 90, 91, 92, 94, 95, 96, 97, 98, 99, 101, 102, 103, 104, 105, 106, 107, 109, 110, 111, 112, 113, 114, 116, 117, 118, 119, 120, 121, 123, 124, 125, 126, 127, 128, 129, 131, 132, 133, 134, 135, 136, 138, 139, 140, 141, 142, 143, 145, 146, 147, 148, 149, 150, 151, 153, 154, 155, 156, 157, 158, 160, 161, 162, 163, 164, 165, 166, 168, 169, 170, 171, 172, 173, 175, 176, 177, 178, 179, 180, 182, 183, 184, 185, 186, 187, 188, 190, 191, 192, 193, 194, 195, 197, 198, 199, 200, 201, 202, 204, 205, 206, 207, 208, 209, 210, 212, 213, 214, 215, 216, 217, 219, 220, 221, 222, 223, 224, 226, 226, 226, 227, 227, 227, 228, 228, 228, 229, 229, 229, 230, 230, 231, 231, 231, 232, 232, 232, 233, 233, 233, 234, 234, 235, 235, 235, 236, 236, 236, 237, 237, 237, 238, 238, 239, 239, 239, 240, 240, 240, 241, 241, 241, 242, 242, 243, 243, 243, 244, 244, 244, 245, 245, 245, 246, 246, 246, 247, 247, 247, 248, 248, 248, 249, 249, 249, 250, 250, 250, 251, 251, 251, 252, 252, 252, 253, 253, 253, 254, 254, 254, 255], fq = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 35, 36, 37, 39, 40, 42, 43, 44, 46, 47, 49, 50, 51, 53, 54, 56, 57, 58, 59, 61, 62, 63, 64, 66, 67, 68, 69, 71, 72, 73, 74, 76, 77, 78, 79, 81, 82, 83, 84, 86, 87, 88, 90, 91, 92, 93, 95, 96, 97, 98, 100, 101, 102, 103, 105, 106, 107, 108, 110, 111, 112, 113, 115, 116, 117, 118, 120, 121, 122, 124, 125, 126, 127, 129, 130, 131, 132, 134, 135, 136, 137, 139, 140, 141, 142, 144, 145, 146, 147, 149, 150, 151, 152, 154, 155, 156, 158, 159, 160, 161, 163, 164, 165, 166, 168, 169, 170, 171, 173, 174, 175, 176, 178, 179, 180, 181, 183, 184, 185, 186, 188, 189, 190, 192, 193, 194, 195, 197, 198, 199, 200, 202, 203, 204, 205, 207, 208, 209, 210, 212, 213, 214, 215, 217, 218, 219, 220, 222, 223, 224, 226, 226, 226, 227, 227, 228, 228, 229, 229, 230, 230, 231, 231, 232, 232, 233, 233, 234, 234, 234, 235, 235, 236, 236, 237, 237, 238, 238, 239, 239, 240, 240, 241, 241, 242, 242, 243, 243, 243, 244, 244, 244, 245, 245, 245, 246, 246, 246, 247, 247, 247, 248, 248, 248, 249, 249, 249, 250, 250, 250, 251, 251, 251, 252, 252, 252, 253, 253, 253, 254, 254, 254, 255], Eq = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 35, 36, 37, 38, 39, 40, 41, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 58, 59, 60, 61, 62, 63, 65, 66, 67, 68, 69, 70, 72, 73, 74, 76, 77, 78, 80, 81, 83, 84, 85, 87, 88, 89, 91, 92, 94, 95, 96, 98, 99, 100, 102, 103, 105, 106, 107, 109, 110, 111, 113, 114, 116, 117, 118, 120, 121, 122, 124, 125, 127, 128, 129, 131, 132, 133, 135, 136, 138, 139, 140, 142, 143, 144, 146, 147, 149, 150, 151, 153, 154, 155, 157, 158, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 192, 193, 193, 194, 195, 195, 196, 197, 197, 198, 199, 199, 200, 201, 201, 202, 203, 203, 204, 205, 205, 206, 207, 207, 208, 209, 209, 210, 211, 211, 212, 213, 213, 214, 215, 215, 216, 217, 217, 218, 219, 219, 220, 221, 221, 222, 223, 223, 224, 225, 225, 226, 227, 227, 228, 229, 229, 230, 231, 231, 232, 233, 233, 234, 235, 235, 236, 237, 237, 238, 239, 239, 240, 241, 241, 242, 243, 243, 244, 245, 245, 246, 247, 247, 248, 249, 249, 250, 251, 251, 252, 253, 253, 254, 255];
      class Iq extends aq {
        constructor(e2, t2, r2, i2) {
          super(e2, pq, r2, i2), kO(this, "inputTexture", void 0), kO(this, "lightLevel", 0.1), kO(this, "rednessLevel", 0.5), kO(this, "mskin_he_max", 175 / 180 * 3.141593), kO(this, "mskin_he_min", 115 / 180 * 3.141593), kO(this, "mskin_hc_max", 173 / 180 * 3.141593), kO(this, "mskin_hc_min", 116 / 180 * 3.141593), kO(this, "mskin_hc_axis", 2.04203545), kO(this, "mfacts_rotate_c", 0), kO(this, "mfacts_rotate_le", 0), kO(this, "mfacts_rotate_ge", 0), kO(this, "tab_addr", null), kO(this, "lutTextures", []), this.inputTexture = t2, this.init();
        }
        setUniforms() {
          const e2 = this.gl.getUniformLocation(this.program, "u_flipY"), t2 = this.gl.getUniformLocation(this.program, "u_denoiseLevel");
          this.gl.uniform1f(t2, this.denoiseLevel), this.gl.uniform1f(e2, 1);
          const r2 = this.gl.getUniformLocation(this.program, "light");
          this.gl.uniform1f(r2, this.lightLevel);
          const i2 = this.gl.getUniformLocation(this.program, "redness");
          this.gl.uniform1f(i2, this.rednessLevel);
          const n2 = this.gl.getUniformLocation(this.program, "skin_he_max"), o2 = this.gl.getUniformLocation(this.program, "skin_he_min"), s2 = this.gl.getUniformLocation(this.program, "skin_hc_max"), a2 = this.gl.getUniformLocation(this.program, "skin_hc_min"), c2 = this.gl.getUniformLocation(this.program, "skin_hc_axis"), d2 = this.gl.getUniformLocation(this.program, "facts_rotate_c"), u2 = this.gl.getUniformLocation(this.program, "facts_rotate_le"), A2 = this.gl.getUniformLocation(this.program, "facts_rotate_ge");
          this.gl.uniform1f(n2, this.mskin_he_max), this.gl.uniform1f(o2, this.mskin_he_min), this.gl.uniform1f(s2, this.mskin_hc_max), this.gl.uniform1f(a2, this.mskin_hc_min), this.gl.uniform1f(c2, this.mskin_hc_axis), this.gl.uniform1f(d2, this.mfacts_rotate_c), this.gl.uniform1f(u2, this.mfacts_rotate_le), this.gl.uniform1f(A2, this.mfacts_rotate_ge);
          const h2 = this.gl.getUniformLocation(this.program, "u_originImage");
          this.gl.activeTexture(this.gl.TEXTURE2), this.gl.bindTexture(this.gl.TEXTURE_2D, this.inputTexture), this.gl.uniform1i(h2, 2);
          const l2 = ["lighten_lut"], p2 = [this.gl.TEXTURE3];
          for (let e3 = 0; e3 < l2.length; e3++) {
            const t3 = this.gl.getUniformLocation(this.program, l2[e3]);
            this.gl.activeTexture(p2[e3]), this.gl.bindTexture(this.gl.TEXTURE_2D, this.lutTextures[e3]), this.gl.uniform1i(t3, e3 + 3);
          }
        }
        setParameters(e2) {
          e2.denoiseLevel !== void 0 && (this.denoiseLevel = e2.denoiseLevel), e2.lightLevel !== void 0 && (this.lightLevel = e2.lightLevel), e2.rednessLevel !== void 0 && (this.rednessLevel = e2.rednessLevel, this.updateRedness(this.rednessLevel)), e2.lighteningContrastLevel && this.updateLut(e2.lighteningContrastLevel);
        }
        init() {
          this.tab_addr = new Uint8Array(fq);
          const e2 = [this.tab_addr], t2 = [256], r2 = [1];
          for (let i2 = 0; i2 < e2.length; i2++) {
            const n2 = this.gl.createTexture();
            if (!n2)
              throw new tD(eD.WEBGL_INTERNAL_ERROR, "create lut texture failed");
            this.gl.bindTexture(this.gl.TEXTURE_2D, n2), this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.LUMINANCE, t2[i2], r2[i2], 0, this.gl.LUMINANCE, this.gl.UNSIGNED_BYTE, e2[i2]), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR), this.lutTextures.push(n2);
          }
        }
        updateRedness(e2) {
          const t2 = 3.141593;
          let r2, i2, n2 = e2, o2 = n2;
          n2 > 1 && (n2 = 1), n2 < 0 && (n2 = 0), o2 > 1 && (o2 = 1), o2 < 0 && (o2 = 0), this.mfacts_rotate_c = 0.8 * n2, o2 < 0.8 && (o2 = 0), this.mskin_he_max = 175 / 180 * t2, this.mskin_hc_max = 173 / 180 * t2, this.mskin_he_min = (115 - 4 * o2) / 180 * t2, this.mskin_hc_min = (116 - 4 * o2) / 180 * t2, this.mskin_hc_axis = (117 - 4 * o2) / 180 * t2, this.mskin_hc_axis < this.mskin_hc_min && (this.mskin_hc_axis = this.mskin_hc_min), this.mskin_hc_min < t2 / 2 && (this.mskin_hc_min = t2 / 2), this.mskin_hc_axis < t2 / 2 && (this.mskin_hc_axis = t2 / 2), this.mskin_he_min < t2 / 2 && (this.mskin_he_min = t2 / 2), this.mskin_hc_max > t2 && (this.mskin_hc_max = t2), this.mskin_hc_axis > t2 && (this.mskin_hc_axis = t2), this.mskin_he_max > t2 && (this.mskin_he_max = t2), r2 = this.mskin_he_max - this.mskin_hc_max, i2 = this.mskin_hc_max - this.mskin_hc_axis, this.mfacts_rotate_ge = r2 > 0.01 ? this.mfacts_rotate_c * i2 / r2 : this.mfacts_rotate_c, r2 = this.mskin_hc_min - this.mskin_he_min, i2 = this.mskin_hc_axis - this.mskin_hc_min, this.mfacts_rotate_le = r2 > 0.01 ? this.mfacts_rotate_c * i2 / r2 : this.mfacts_rotate_c;
        }
        updateLut(e2) {
          let t2 = null;
          if (e2 === 0 && (t2 = fq), e2 === 1 && (t2 = Eq), e2 === 2 && (t2 = gq), !t2)
            throw new tD(eD.WEBGL_INTERNAL_ERROR, "invalid ylut_table value:" + e2);
          this.tab_addr = new Uint8Array(t2);
          const r2 = [this.tab_addr], i2 = [256], n2 = [1];
          for (let e3 = 0; e3 < r2.length; e3++)
            this.gl.bindTexture(this.gl.TEXTURE_2D, this.lutTextures[e3]), this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.LUMINANCE, i2[e3], n2[e3], 0, this.gl.LUMINANCE, this.gl.UNSIGNED_BYTE, r2[e3]);
        }
      }
      class mq {
        constructor() {
          kO(this, "gl", null), kO(this, "canvas", null), kO(this, "programs", []), kO(this, "commonProgram", null), kO(this, "inputTexture", null), kO(this, "outputTextures", []), kO(this, "fbos", []), kO(this, "originalFrameWidth", 0), kO(this, "originalFrameHeight", 0), kO(this, "enableBeauty", false), kO(this, "denoiseLevel", 5), kO(this, "lightLevel", 0.35), kO(this, "rednessLevel", 0.5), kO(this, "lighteningContrastLevel", 1);
        }
        setEnableBeauty(e2) {
          this.enableBeauty = !!e2;
        }
        init(e2, t2, r2) {
          if (!Mk().supportWebGL)
            throw new tD(eD.NOT_SUPPORTED, "your browser is not support webGL");
          if (this.gl = r2.getContext("webgl"), !this.gl)
            throw new tD(eD.WEBGL_INTERNAL_ERROR, "can not get webgl context");
          if (this.initGL(e2, t2), !this.inputTexture)
            throw new tD(eD.WEBGL_INTERNAL_ERROR, "can not find input texture");
          this.canvas = r2, this.programs.push(new sq(this.gl)), this.programs.push(new dq(this.gl, e2, t2)), this.programs.push(new Aq(this.gl, e2, t2)), this.programs.push(new lq(this.gl, e2, t2)), this.programs.push(new Iq(this.gl, this.inputTexture, e2, t2)), this.commonProgram = this.programs[0].program, this.setDenoiseLevel(this.denoiseLevel), this.setLightLevel(this.lightLevel), this.setRednessLevel(this.rednessLevel), this.setContrastLevel(this.lighteningContrastLevel);
        }
        render(e2) {
          if (!this.gl || !this.commonProgram || !this.canvas)
            return void dD.warning("video effect manager is not init!");
          let t2 = 0;
          if (this.originalFrameHeight === e2.videoWidth && this.originalFrameWidth === e2.videoHeight)
            t2 = 2;
          else if (this.originalFrameHeight !== e2.videoHeight || this.originalFrameWidth !== e2.videoWidth) {
            if (dD.debug("beauty effect: resolution changed ".concat(this.originalFrameWidth, "x").concat(this.originalFrameHeight, " -> ").concat(e2.videoWidth, "x").concat(e2.videoHeight)), e2.videoHeight === 0 || e2.videoWidth === 0)
              return void dD.debug("beauty effect: skip 0 resolution frame");
            this.canvas.width = e2.videoWidth, this.canvas.height = e2.videoHeight, e2.setAttribute("width", e2.videoWidth.toString()), e2.setAttribute("height", e2.videoHeight.toString()), this.release(), this.init(e2.videoWidth, e2.videoHeight, this.canvas);
          }
          this.gl.viewport(0, 0, e2.videoWidth, e2.videoHeight), this.gl.bindTexture(this.gl.TEXTURE_2D, this.inputTexture), this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, e2);
          const r2 = this.enableBeauty ? this.programs.length - 1 : 0;
          for (let e3 = 0; e3 <= r2; e3++) {
            const r3 = this.programs[e3].program;
            this.gl.useProgram(r3);
            const i3 = this.gl.getUniformLocation(r3, "u_image");
            this.programs[e3].setUniforms(), this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbos[t2 + e3 % 2]), this.gl.clearColor(0, 0, 0, 1), this.gl.clear(this.gl.COLOR_BUFFER_BIT), this.gl.drawArrays(this.gl.TRIANGLES, 0, 6), this.gl.activeTexture(this.gl.TEXTURE0), this.gl.bindTexture(this.gl.TEXTURE_2D, this.outputTextures[t2 + e3 % 2]), this.gl.uniform1i(i3, 0);
          }
          this.gl.useProgram(this.commonProgram);
          const i2 = this.gl.getUniformLocation(this.commonProgram, "u_flipY");
          this.gl.uniform1f(i2, -1), this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null), this.gl.clearColor(0, 0, 0, 1), this.gl.clear(this.gl.COLOR_BUFFER_BIT), this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
        }
        setDenoiseLevel(e2) {
          this.programs.forEach((t2) => {
            t2 instanceof aq && t2.setParameters({ denoiseLevel: e2 });
          }), this.denoiseLevel = e2;
        }
        setLightLevel(e2) {
          this.programs.forEach((t2) => {
            t2 instanceof aq && t2.setParameters({ lightLevel: e2 });
          }), this.lightLevel = e2;
        }
        setRednessLevel(e2) {
          this.programs.forEach((t2) => {
            t2 instanceof aq && t2.setParameters({ rednessLevel: e2 });
          }), this.rednessLevel = e2;
        }
        setContrastLevel(e2) {
          this.programs.forEach((t2) => {
            t2 instanceof aq && t2.setParameters({ lighteningContrastLevel: e2 });
          }), this.lighteningContrastLevel = e2;
        }
        setSize(e2, t2) {
          this.programs.forEach((r2) => {
            r2 instanceof aq && r2.setSize(e2, t2);
          });
        }
        release() {
          this.gl = null, this.commonProgram = null, this.inputTexture = null, this.programs = [], this.outputTextures = [], this.fbos = [];
        }
        initGL(e2, t2) {
          if (!this.gl)
            throw new tD(eD.WEBGL_INTERNAL_ERROR, "can not find webgl context");
          this.inputTexture = this.gl.createTexture(), this.gl.bindTexture(this.gl.TEXTURE_2D, this.inputTexture), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
          for (let r2 = 0; r2 < 4; r2++) {
            const i2 = this.gl.createTexture();
            if (!i2)
              throw new tD(eD.WEBGL_INTERNAL_ERROR, "create texture failed");
            this.gl.bindTexture(this.gl.TEXTURE_2D, i2), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), r2 < 2 ? this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, e2, t2, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null) : this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, t2, e2, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);
            const n2 = this.gl.createFramebuffer();
            if (!n2)
              throw new tD(eD.WEBGL_INTERNAL_ERROR, "create frame buffer failed");
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, n2), this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, i2, 0), this.outputTextures.push(i2), this.fbos.push(n2);
          }
          this.gl.viewport(0, 0, e2, t2), this.originalFrameWidth = e2, this.originalFrameHeight = t2;
        }
      }
      class _q {
        constructor() {
          kO(this, "targetFrameRate", 0), kO(this, "recordedFrameCount", 0), kO(this, "recordingTime", 2), kO(this, "recordID", void 0);
        }
        async startRecordBeautyEffectOutput(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4;
          if (this.recordID)
            throw new tD(eD.UNEXPECTED_ERROR, "another beauty effect recording is in progress");
          const r2 = SG(6, "");
          return this.recordID = r2, this.targetFrameRate = e2, this.recordedFrameCount = 0, this.recordingTime = t2, await CG(1e3 * this.recordingTime), this.recordID !== r2 ? (this.recordID = void 0, true) : (this.recordID = void 0, this.recordedFrameCount < this.targetFrameRate * this.recordingTime / 2 ? (dD.warning("detect beauty effect overload, current framerate", this.recordedFrameCount / 2), false) : (dD.debug("beauty effect current framerate", this.recordedFrameCount / 2), true));
        }
        stopRecordBeautyEffectOutput() {
          this.targetFrameRate = 0, this.recordedFrameCount = 0, this.recordID = void 0;
        }
        addFrame() {
          this.recordID && (this.recordedFrameCount += 1);
        }
      }
      class Cq extends $J.exports.VideoProcessor {
        constructor() {
          super(), kO(this, "name", "BeautyProcessor"), kO(this, "fps", 15), kO(this, "canvas", void 0), kO(this, "video", void 0), kO(this, "manager", void 0), kO(this, "overloadDetector", new _q()), kO(this, "stopChromeBackgroundLoop", null), kO(this, "onOverload", void 0), kO(this, "stopLoop", void 0), kO(this, "lastRenderTime", 0), this.fps = 30, this.manager = new mq(), this._enabled = false;
        }
        async onEnableChange(e2) {
          this.manager.setEnableBeauty(e2), this.context && this.inputTrack && (e2 ? await this.startEffect(this.inputTrack, this.context) : await this.stopEffect(this.inputTrack, this.context));
        }
        async setBeautyEffectOptions(e2) {
          if (function(e3) {
            e3.smoothnessLevel !== void 0 && ZL(e3.smoothnessLevel, "options.smoothnessLevel", 0, 1, false), e3.lighteningLevel !== void 0 && ZL(e3.lighteningLevel, "options.lighteningLevel", 0, 1, false), e3.rednessLevel !== void 0 && ZL(e3.rednessLevel, "options.rednessLevel", 0, 1, false), e3.lighteningContrastLevel !== void 0 && XL(e3.lighteningContrastLevel, "options.lighteningContrastLevel", [0, 1, 2]);
          }(e2), e2.smoothnessLevel !== void 0) {
            const t2 = Math.max(0.1, 10 * e2.smoothnessLevel);
            this.manager.setDenoiseLevel(t2);
          }
          if (e2.lighteningLevel !== void 0) {
            const t2 = Math.max(0.1, e2.lighteningLevel / 2);
            this.manager.setLightLevel(t2);
          }
          if (e2.rednessLevel !== void 0) {
            const t2 = Math.max(0.01, e2.rednessLevel);
            this.manager.setRednessLevel(t2);
          }
          if (e2.lighteningContrastLevel !== void 0) {
            const t2 = e2.lighteningContrastLevel;
            this.manager.setContrastLevel(t2);
          }
        }
        async onTrack(e2, t2) {
          var r2;
          this.video && this.enabled && ((r2 = this.stopLoop) === null || r2 === void 0 || r2.call(this), await this.stopEffect(e2, t2));
          await this.startEffect(e2, t2);
        }
        async startEffect(e2, t2) {
          if (!this.enabled)
            return;
          const r2 = oO(), i2 = await this.renderWithWebGL(e2);
          this.output(i2, t2), dD.info("start video effect, output:", this.outputTrack), this.overloadDetector.startRecordBeautyEffectOutput(this.fps).then((e3) => {
            e3 || this.onOverload && this.onOverload();
          });
          let n2 = false;
          this.stopLoop = () => {
            n2 = true;
          };
          const o2 = () => {
            this.enabled && !n2 && requestAnimationFrame(o2);
            const e3 = Date.now(), t3 = 1e3 / this.fps, r3 = this.lastRenderTime ? e3 - this.lastRenderTime : t3;
            r3 < t3 || (this.lastRenderTime = e3 - (r3 - t3), this.video && this.video.paused && this.video.play(), this.enabled && this.video && (this.manager.render(this.video), this.outputTrack && this.outputTrack.requestFrame && this.outputTrack.requestFrame(), this.overloadDetector.addFrame()));
          };
          requestAnimationFrame(o2), r2.name === tO.CHROME && document.addEventListener("visibilitychange", () => {
            document.hidden ? this.stopChromeBackgroundLoop = YV(() => {
              this.enabled && this.video && this.manager.render(this.video), this.outputTrack && this.outputTrack.requestFrame && this.outputTrack.requestFrame(), this.overloadDetector.addFrame();
            }, this.fps) : this.stopChromeBackgroundLoop && (this.stopChromeBackgroundLoop(), this.stopChromeBackgroundLoop = null);
          }, false);
        }
        async renderWithWebGL(e2) {
          this.canvas && (this.canvas.remove(), this.canvas = void 0), this.video && (this.video.remove(), this.video = void 0), this.canvas = document.createElement("canvas"), this.video = document.createElement("video"), this.video.setAttribute("autoplay", ""), this.video.setAttribute("muted", ""), this.video.muted = true, this.video.setAttribute("playsinline", ""), this.video.setAttribute("style", "display:none"), this.video.srcObject = new MediaStream([e2]);
          const t2 = new nR((e3) => {
            const t3 = () => {
              this.video && this.video.removeEventListener("playing", t3), e3(void 0);
            };
            this.video && this.video.addEventListener("playing", t3);
          });
          this.video.play(), await t2;
          const r2 = e2.getSettings(), i2 = r2.width || this.video.videoWidth, n2 = r2.height || this.video.videoHeight;
          if (r2.frameRate && this.fps !== r2.frameRate && (this.fps = r2.frameRate, dD.debug("beauty video processor: set fps to", this.fps)), dD.debug("beauty video processor: width ".concat(i2, " height ").concat(n2)), !i2 || !n2)
            throw new tD(eD.BEAUTY_PROCESSOR_INTERNAL_ERROR, "can not get track resolution");
          this.canvas.width = i2, this.canvas.height = n2, this.video.setAttribute("width", i2.toString()), this.video.setAttribute("height", n2.toString()), this.manager.init(i2, n2, this.canvas);
          const o2 = Mk();
          return this.canvas.captureStream(o2.supportRequestFrame ? 0 : this.fps).getVideoTracks()[0];
        }
        async stopEffect(e2, t2) {
          dD.info("stop video effect"), this.overloadDetector.stopRecordBeautyEffectOutput(), this.manager.release(), this.canvas && this.canvas.remove(), this.video && this.video.remove(), this.canvas = void 0, this.video = void 0, this.output(e2, t2);
        }
      }
      function vq(e2) {
        const t2 = {};
        if (e2.facingMode && (t2.facingMode = e2.facingMode), e2.cameraId && (t2.deviceId = { exact: e2.cameraId }), !e2.encoderConfig)
          return t2;
        const r2 = jD(e2.encoderConfig);
        return t2.width = r2.width, t2.height = r2.height, !RO() && r2.frameRate && (t2.frameRate = r2.frameRate), oO().name === tO.EDGE && typeof t2.frameRate == "object" && (t2.frameRate.max = 60), gO() && (t2.frameRate = { ideal: 30, max: 30 }), t2;
      }
      function Sq(e2) {
        const t2 = {};
        e2.screenSourceType && (t2.mediaSource = e2.screenSourceType), e2.extensionId && lO() && (t2.extensionId = e2.extensionId), e2.electronScreenSourceId && (t2.sourceId = e2.electronScreenSourceId);
        const r2 = e2.encoderConfig ? GD(e2.encoderConfig) : null;
        return t2.mandatory = { chromeMediaSource: "desktop", maxWidth: r2 ? r2.width : void 0, maxHeight: r2 ? r2.height : void 0 }, r2 && r2.frameRate && (typeof r2.frameRate == "number" ? (t2.mandatory.maxFrameRate = r2.frameRate, t2.mandatory.minFrameRate = r2.frameRate) : (t2.mandatory.maxFrameRate = r2.frameRate.max || r2.frameRate.ideal || r2.frameRate.exact || void 0, t2.mandatory.minFrameRate = r2.frameRate.min || r2.frameRate.ideal || r2.frameRate.exact || void 0), t2.frameRate = r2.frameRate), r2 && r2.width && (t2.width = r2.width), r2 && r2.height && (t2.height = r2.height), t2;
      }
      function Rq(e2) {
        const t2 = {};
        if (RO() || (e2.AGC !== void 0 && (t2.autoGainControl = e2.AGC), e2.AEC !== void 0 && (t2.echoCancellation = e2.AEC), e2.ANS !== void 0 && (t2.noiseSuppression = e2.ANS, lO() && e2.ANS && (t2.googHighpassFilter = e2.ANS))), e2.encoderConfig) {
          const r2 = YD(e2.encoderConfig);
          t2.channelCount = r2.stereo ? 2 : 1, t2.sampleRate = r2.sampleRate, t2.sampleSize = r2.sampleSize;
        }
        return e2.microphoneId && (t2.deviceId = { exact: e2.microphoneId }), TO() && (t2.sampleRate = void 0), t2;
      }
      var yq, Tq;
      !function(e2) {
        e2.COVERED = "COVERED", e2.POSITION = "POSITION", e2.SIZE = "SIZE", e2.STYLE = "STYLE";
      }(yq || (yq = {})), function(e2) {
        e2.UNMOUNTED = "UNMOUNTED", e2.INVALID_HTML_ELEMENT = "INVALID_HTML_ELEMENT";
      }(Tq || (Tq = {}));
      var wq, bq, Oq, Nq, Dq, Lq, Pq, kq, Bq, Mq, Uq, Qq, xq, Fq, Vq, jq, Gq, Kq, Hq, Yq, Wq, Jq, qq, zq = new class {
        constructor() {
          kO(this, "_clientSize", null), kO(this, "getClientWidth", () => document.documentElement ? document.documentElement.clientWidth : document.body.clientWidth), kO(this, "getClientHeight", () => document.documentElement ? document.documentElement.clientHeight : document.body.clientHeight), kO(this, "getStyle", (e2) => window.getComputedStyle(e2, null)), kO(this, "checkCssVisibleProperty", (e2) => {
            let t2 = true;
            const r2 = this.getStyle(e2), { display: i2, visibility: n2, opacity: o2, filter: s2 } = r2;
            if ((i2 === "none" || ["hidden", "collapse"].includes(n2) || Number(o2) < 0.1) && (t2 = false), !t2)
              return false;
            if (s2) {
              s2.split(" ").filter((e3) => {
                const t3 = e3.split("(")[0];
                return ["brightness", "blur", "opacity"].includes(t3);
              }).map((e3) => {
                const [t3, r3] = e3.split(/\(|\)/);
                return [t3, Number(r3.match(/^[0-9\.]+/))];
              }).forEach((e3) => {
                const [r3, i3] = e3;
                switch (r3) {
                  case "brightness":
                    (i3 < 0.1 || i3 > 3) && (t2 = false);
                    break;
                  case "blur":
                    i3 > 3 && (t2 = false);
                    break;
                  case "opacity":
                    i3 < 0.1 && (t2 = false);
                }
              });
            }
            return t2;
          }), kO(this, "checkPropertyUpToAllParentNodes", (e2, t2) => {
            let r2 = true, i2 = true;
            const n2 = (e3) => t2(e3);
            let o2 = e2;
            for (; o2 && i2; ) {
              n2(o2) || (r2 = false, i2 = false), o2 = o2.parentElement, o2 || (i2 = false);
            }
            return r2;
          }), kO(this, "checkActualCssVisibleIncludeInherit", (e2) => this.checkPropertyUpToAllParentNodes(e2, this.checkCssVisibleProperty)), kO(this, "getSizeAboutClient", (e2) => {
            const { width: t2, height: r2, left: i2, right: n2, top: o2, bottom: s2 } = e2.getBoundingClientRect(), a2 = this.getClientWidth(), c2 = this.getClientHeight();
            return { width: t2, height: r2, left: i2, right: n2, top: o2, bottom: s2, clientWidth: a2, clientHeight: c2, clientMin: Math.min(a2, c2) };
          }), kO(this, "checkActualSize", () => {
            const { width: e2, height: t2, clientMin: r2 } = this._clientSize;
            return this.checkSizeIsVisible(e2, t2, r2);
          }), kO(this, "elementFromPoint", (e2, t2) => document.elementFromPoint ? document.elementFromPoint(e2, t2) : null), kO(this, "checkCoverForAPoint", (e2, t2, r2) => {
            const i2 = this.elementFromPoint(e2, t2);
            return i2 !== null && i2 !== r2;
          }), kO(this, "getPointPositionList", () => {
            const { width: e2, height: t2, left: r2, top: i2 } = this._clientSize, n2 = e2 / 6, o2 = t2 / 6, s2 = [], a2 = 10 ** 6;
            for (let e3 = 0; e3 < 5; e3++)
              for (let t3 = 0; t3 < 5; t3++) {
                const c2 = (r2 * a2 + (e3 === 0 ? 0.1 : e3 === 4 ? (n2 * e3 * a2 - 1e5) / a2 : n2 * e3) * a2) / a2, d2 = (i2 * a2 + (t3 === 0 ? 0.1 : t3 === 4 ? (o2 * t3 * a2 - 1e5) / a2 : o2 * t3) * a2) / a2;
                s2.push({ x: c2, y: d2 });
              }
            return [...s2];
          }), kO(this, "checkElementCover", (e2) => this.getPointPositionList().map((t2) => this.checkCoverForAPoint(t2.x, t2.y, e2)).filter((e3) => !!e3).length > 6), kO(this, "checkSizeIsVisible", (e2, t2, r2) => (e2 > 50 || r2 / e2 <= 10) && (t2 > 50 || r2 / t2 <= 10)), kO(this, "checkSizeOfPartInClient", () => {
            const { left: e2, right: t2, top: r2, bottom: i2, clientHeight: n2, clientWidth: o2, clientMin: s2 } = this._clientSize;
            let a2, c2, d2, u2;
            if (e2 < 0)
              a2 = 0;
            else {
              if (!(e2 < o2))
                return false;
              a2 = e2;
            }
            if (t2 < 0)
              return false;
            if (c2 = t2 < o2 ? t2 : o2, r2 < 0)
              d2 = 0;
            else {
              if (!(r2 < n2))
                return false;
              d2 = r2;
            }
            if (i2 < 0)
              return false;
            u2 = i2 < n2 ? i2 : n2;
            const A2 = c2 - a2, h2 = u2 - d2;
            return this.checkSizeIsVisible(A2, h2, s2);
          }), kO(this, "returnHiddenResult", (e2) => (this._clientSize = null, { visible: false, reason: e2 })), kO(this, "checkOneElementVisible", (e2) => {
            if (e2 instanceof HTMLElement) {
              if (this.checkElementIsMountedOnDom(e2)) {
                if (this.checkActualCssVisibleIncludeInherit(e2)) {
                  if (this._clientSize = this.getSizeAboutClient(e2), this.checkElementCover(e2))
                    return this.returnHiddenResult(yq.COVERED);
                  {
                    const e3 = this.checkActualSize(), t2 = this.checkSizeOfPartInClient();
                    return e3 && !t2 ? this.returnHiddenResult(yq.POSITION) : e3 ? (this._clientSize = null, { visible: true }) : this.returnHiddenResult(yq.SIZE);
                  }
                }
                return this.returnHiddenResult(yq.STYLE);
              }
              return this.returnHiddenResult(Tq.UNMOUNTED);
            }
            return this.returnHiddenResult(Tq.INVALID_HTML_ELEMENT);
          }), kO(this, "checkElementIsMountedOnDom", (e2) => this.checkPropertyUpToAllParentNodes(e2, (e3) => e3.nodeName.toUpperCase() !== "HTML" ? e3.parentElement !== null : !!document.documentElement));
        }
      }();
      function Xq(e2, t2) {
        var r2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          t2 && (i2 = i2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), r2.push.apply(r2, i2);
        }
        return r2;
      }
      function Zq(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r2 = arguments[t2] != null ? arguments[t2] : {};
          t2 % 2 ? Xq(Object(r2), true).forEach(function(t3) {
            kO(e2, t3, r2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : Xq(Object(r2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
          });
        }
        return e2;
      }
      let $q = (wq = PD("LocalVideoTrack", "getTrackId"), bq = pj(), Oq = BV("LocalVideoTrack", "_enabledMutex"), Nq = pj(), Dq = BV("LocalVideoTrack", "_enabledMutex"), Lq = pj(), Pq = wV({ report: bV }), kq = pj(), Bq = pj(), Mq = pj(), Uq = pj(), Qq = pj(), xq = pj(), Fq = pj(), wq((zF((jq = class e2 extends MV {
        get isPlaying() {
          return !(!this._player || this._player.videoElementStatus !== dP.PLAYING);
        }
        constructor(e3, t2, r2, i2, n2, o2) {
          super(e3, n2), kO(this, "trackMediaType", "video"), kO(this, "_player", void 0), kO(this, "_videoBeautyProcessor", void 0), kO(this, "_videoVisibleTimer", null), kO(this, "_previousVideoVisibleStatus", void 0), kO(this, "_clearPreviousVideoVisibleStatus", () => this._previousVideoVisibleStatus = void 0), kO(this, "_encoderConfig", void 0), kO(this, "_scalabiltyMode", { numSpatialLayers: 1, numTemporalLayers: 1 }), kO(this, "_optimizationMode", void 0), kO(this, "_videoHeight", void 0), kO(this, "_videoWidth", void 0), kO(this, "_forceBitrateLimit", void 0), kO(this, "_enabled", true), kO(this, "processorDestination", void 0), kO(this, "processorContext", void 0), this.updateMediaStreamTrackResolution(), this._encoderConfig = t2, this._scalabiltyMode = r2, this._optimizationMode = i2, this._hints = o2 || [], this._hints.indexOf(hk.SCREEN_TRACK) === -1 && this.updateBitrateFromProfile(), this.processorContext = new rz(this.getTrackId()), this.processorDestination = new tz(this.processorContext), this.bindProcessorDestinationEvents();
        }
        play(e3) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          const r2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.LOCAL_VIDEO_TRACK_PLAY, options: [this.getTrackId(), typeof e3 == "string" ? e3 : "HTMLElement", t2] });
          if (typeof e3 == "string") {
            const t3 = document.getElementById(e3);
            t3 ? e3 = t3 : (dD.warning("[".concat(this.getTrackId(), '] can not find "#').concat(e3, '" element, use document.body')), TD("warning", this, 'can not find "#'.concat(e3, '" element, use document.body')), e3 = document.body);
          }
          dD.debug("[".concat(this.getTrackId(), "] start video playback"), JSON.stringify(t2)), ND("debug", this, "play", t2);
          const i2 = Zq(Zq(Zq({}, this._getDefaultPlayerConfig()), t2), {}, { trackId: this.getTrackId(), element: e3 });
          this._player ? this._player.updateConfig(i2) : (this._player = new XJ(i2), this._player.updateVideoTrack(this._mediaStreamTrack)), this._player.play(), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {
            try {
              const e4 = this.getVideoElementVisibleStatus();
              this.emit(gk.VIDEO_ELEMENT_VISIBLE_STATUS, e4);
            } catch (e4) {
            }
          }, JD("CHECK_VIDEO_VISIBLE_INTERVAL")), r2.onSuccess();
        }
        stop() {
          const e3 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.LOCAL_VIDEO_TRACK_STOP, options: [this.getTrackId()] });
          if (!this._player)
            return e3.onSuccess();
          this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, dD.debug("[".concat(this.getTrackId(), "] stop video playback")), ND("debug", this, "stop"), e3.onSuccess();
        }
        async setEnabled(e3, t2) {
          if (!t2) {
            if (e3 === this._enabled)
              return;
            this.stateCheck("enabled", e3);
          }
          if (dD.info("[".concat(this.getTrackId(), "] start setEnabled"), e3), ND("info", this, "setEnabled", e3), !e3) {
            this._originMediaStreamTrack.enabled = false;
            try {
              await OG(this, Ak.NEED_DISABLE_TRACK, this);
            } catch (t3) {
              throw dD.error("[".concat(this.getTrackId(), "] setEnabled to false error"), t3.toString()), ND("error", this, "setEnabled", e3, t3.toString()), t3;
            }
            return t2 || (this._enabled = false), dD.info("[".concat(this.getTrackId(), "] setEnabled to false success")), void ND("info", this, "setEnabled", e3, "success");
          }
          this._originMediaStreamTrack.enabled = true;
          try {
            await OG(this, Ak.NEED_ENABLE_TRACK, this);
          } catch (t3) {
            throw dD.error("[".concat(this.getTrackId(), "] setEnabled to true error"), t3.toString()), ND("error", this, "setEnabled", e3, t3.toString()), t3;
          }
          dD.info("[".concat(this.getTrackId(), "] setEnabled to true success")), ND("info", this, "setEnabled", e3, "success"), t2 || (this._enabled = true);
        }
        async setMuted(e3) {
          e3 !== this._muted && (this.stateCheck("muted", e3), this._muted = e3, this._mediaStreamTrack.enabled = !e3, dD.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(e3)), ND("debug", this, "setMuted", e3), e3 ? await OG(this, Ak.NEED_MUTE_TRACK, this) : await OG(this, Ak.NEED_UNMUTE_TRACK, this));
        }
        getStats() {
          UG(() => {
            dD.warning("[deprecated] LocalVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalVideoStats instead"), TD("warning", this, "[deprecated] LocalVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalVideoStats instead");
          }, "localVideoTrackGetStatsWarning");
          const e3 = NG(this, Ak.GET_STATS);
          return e3 || Zq({}, jP);
        }
        async setBeautyEffect(e3) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          const r2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.LOCAL_VIDEO_TRACK_BEAUTY, options: [this.getTrackId(), e3, t2] });
          if (e3 || this._videoBeautyProcessor) {
            if (dO() === eO.IOS || dO() === eO.ANDROID) {
              const e4 = new tD(eD.INVALID_OPERATION, "can not enable beauty effect on mobile device");
              throw r2.onError(e4), e4;
            }
            if (!this._enabled && e3) {
              const e4 = new tD(eD.TRACK_IS_DISABLED, "can not enable beauty effect when track is disabled");
              throw r2.onError(e4), e4;
            }
            if (dD.info("[".concat(this.getTrackId(), "] start setBeautyEffect"), e3, JSON.stringify(t2)), ND("info", this, "setBeautyEffect", [e3, t2]), this._videoBeautyProcessor || e3) {
              try {
                if (!this._videoBeautyProcessor)
                  if (this._videoBeautyProcessor = new Cq(), this.processor) {
                    const e4 = this.processor;
                    this.pipe(this._videoBeautyProcessor).pipe(e4);
                  } else
                    this.pipe(this._videoBeautyProcessor).pipe(this.processorDestination);
                await this._videoBeautyProcessor.setBeautyEffectOptions(t2), e3 ? await this._videoBeautyProcessor.enable() : await this._videoBeautyProcessor.disable();
              } catch (i2) {
                throw dD.error("[".concat(this.getTrackId(), "] setBeautyEffect error"), i2.toString()), ND("info", this, "setBeautyEffect", [e3, t2]), r2.onError(i2), i2;
              }
              dD.info("[".concat(this.getTrackId(), "] setBeautyEffect success")), ND("info", this, "setBeautyEffect", [e3, t2], "success"), r2.onSuccess();
            } else
              r2.onSuccess();
          }
        }
        getCurrentFrameData() {
          return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);
        }
        clone(t2, r2, i2, n2) {
          const o2 = this._mediaStreamTrack.clone();
          return new e2(o2, t2, r2, i2, n2);
        }
        async setBitrateLimit(e3) {
          if (dD.debug("[".concat(this.getTrackId(), "] set bitrate limit, ").concat(JSON.stringify(e3))), ND("debug", this, "setBitrateLimit", e3), e3) {
            this._forceBitrateLimit = e3, this._encoderConfig && (this._encoderConfig.bitrateMax ? this._encoderConfig.bitrateMax = this._encoderConfig.bitrateMax < e3.max_bitrate ? this._encoderConfig.bitrateMax : e3.max_bitrate : this._encoderConfig.bitrateMax = e3.max_bitrate, this._encoderConfig.bitrateMin, this._encoderConfig.bitrateMin = e3.min_bitrate);
            try {
              await OG(this, Ak.NEED_UPDATE_VIDEO_ENCODER, this);
            } catch (e4) {
              return e4.throw();
            }
          }
        }
        async setOptimizationMode(e3) {
          if (e3 !== "motion" && e3 !== "detail" && e3 !== "balanced")
            return dD.error(eD.INVALID_PARAMS, "optimization mode must be motion, detail or balanced"), void ND("error", this, "setOptimizationMode", e3, eD.INVALID_PARAMS);
          const t2 = this._optimizationMode;
          try {
            this._optimizationMode = e3, await OG(this, Ak.SET_OPTIMIZATION_MODE, this);
          } catch (r2) {
            throw this._optimizationMode = t2, dD.error("[".concat(this.getTrackId(), "] set optimization mode failed"), r2.toString()), ND("error", this, "setOptimizationMode", e3, r2.toString()), r2;
          }
          dD.info("[".concat(this.getTrackId(), "] set optimization mode success (").concat(e3, ")")), ND("info", this, "setOptimizationMode", e3, "success");
        }
        setScalabiltyMode(e3) {
          if (e3.numSpatialLayers === 1 && e3.numTemporalLayers !== 1)
            return dD.error(eD.INVALID_PARAMS, "scalability mode currently not supported, no SVC."), ND("error", this, "setScalabiltyMode", e3, eD.INVALID_PARAMS), void (this._scalabiltyMode = { numSpatialLayers: 1, numTemporalLayers: 1 });
          this._scalabiltyMode = e3, dD.info("[".concat(this.getTrackId(), "] set scalability mode success (").concat(e3, ")")), ND("info", this, "setScalabiltyMode", e3, "success");
        }
        updateMediaStreamTrackResolution() {
          TG(this._originMediaStreamTrack).then((e3) => {
            let [t2, r2] = e3;
            this._videoHeight = r2, this._videoWidth = t2;
          }).catch(yG);
        }
        _updatePlayerSource() {
          this._player && this._player.updateVideoTrack(this._mediaStreamTrack);
        }
        _getDefaultPlayerConfig() {
          return { fit: "contain" };
        }
        updateBitrateFromProfile() {
          if (!this._encoderConfig)
            return;
          const { width: e3, height: t2, frameRate: r2 } = this.getMediaStreamTrackSettings();
          if (!e3 || !t2 || !r2)
            return;
          const [i2, n2] = function(e4, t3, r3) {
            const i3 = JD("BITRATE_ADAPTER_TYPE");
            let n3;
            const o2 = 200 * Math.pow(r3 / 15, 0.6) * Math.pow(e4 * t3 / 640 / 360, 0.75), s2 = o2;
            if (i3 === "STANDARD_BITRATE")
              n3 = 4 * o2;
            else {
              if (i3 !== "COMPATIABLE_BITRATE")
                return;
              n3 = 2 * o2;
            }
            return [Math.floor(n3), Math.floor(s2)];
          }(e3, t2, r2) || [void 0, void 0];
          this._encoderConfig.bitrateMin || this._encoderConfig.bitrateMax || (this._encoderConfig.bitrateMin = n2, this._encoderConfig.bitrateMax = i2, dD.debug("[".concat(this.getTrackId(), "] update bitrate from profile, [w: ").concat(e3, ", h: ").concat(t2, ", fps: ").concat(r2, "] => [brMax: ").concat(i2, ", brMin: ").concat(n2, "]")), ND("debug", this, "updateBitrateFromProfile", void 0, "[w: ".concat(e3, ", h: ").concat(t2, ", fps: ").concat(r2, "] => [brMax: ").concat(i2, ", brMin: ").concat(n2, "]")));
        }
        getVideoElementVisibleStatus() {
          try {
            var e3, t2;
            const r2 = this == null || (e3 = this._player) === null || e3 === void 0 ? void 0 : e3.getContainerElement(), i2 = { track: this, element: this == null || (t2 = this._player) === null || t2 === void 0 ? void 0 : t2.getVideoElement(), slot: r2 == null ? void 0 : r2.parentElement }, { element: n2, slot: o2 } = i2;
            if (this.isPlaying && n2 instanceof HTMLVideoElement && o2 instanceof HTMLElement) {
              const e4 = zq.checkOneElementVisible(n2), t3 = Object.assign({}, e4);
              if (t3.visible !== this._previousVideoVisibleStatus) {
                this._previousVideoVisibleStatus = t3.visible;
                const e5 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE, options: [this.getTrackId()] });
                t3.visible ? e5.onSuccess("Video is visible") : e5.onSuccess("Invisible because of ".concat(t3.reason));
              }
              return t3;
            }
            return;
          } catch (e4) {
            throw new tD(eD.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e4.message);
          }
        }
        async renewMediaStreamTrack(e3) {
        }
        pipe(e3) {
          if (this._videoBeautyProcessor && e3 !== this._videoBeautyProcessor)
            return this._videoBeautyProcessor.pipe(e3);
          if (this.processor === e3)
            return e3;
          if (e3._source)
            throw new tD(eD.INVALID_OPERATION, "Processor ".concat(e3.name, " already piped, please call unpipe beforehand."));
          return this.unpipe(), this.processor = e3, this.processor._source = this, e3.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }), e3;
        }
        unpipe() {
          if (!this.processor)
            return;
          const e3 = this.processor;
          this.processor._source = void 0, this.processor = void 0, e3.reset();
        }
        close() {
          super.close(), this.unbindProcessorDestinationEvents(), this.unbindProcessorContextEvents(), this.unpipe(), this.processorDestination._source && this.processorDestination._source.unpipe();
        }
        bindProcessorDestinationEvents() {
          this.processorDestination.on(Pk.ON_TRACK, async (e3) => {
            e3 ? e3 !== this._mediaStreamTrack && (this._mediaStreamTrack = e3, this._updatePlayerSource(), await OG(this, Ak.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await OG(this, Ak.NEED_REPLACE_TRACK, this));
          });
        }
        unbindProcessorDestinationEvents() {
          this.processorDestination.removeAllListeners(Pk.ON_TRACK);
        }
        unbindProcessorContextEvents() {
          this.processorContext.removeAllListeners(kk.REQUEST_UPDATE_CONSTRAINTS), this.processorContext.removeAllListeners(kk.REQUEST_CONSTRAINTS);
        }
      }).prototype, "play", [bq], Object.getOwnPropertyDescriptor(jq.prototype, "play"), jq.prototype), zF(jq.prototype, "setEnabled", [Oq, Nq], Object.getOwnPropertyDescriptor(jq.prototype, "setEnabled"), jq.prototype), zF(jq.prototype, "setMuted", [Dq, Lq, Pq], Object.getOwnPropertyDescriptor(jq.prototype, "setMuted"), jq.prototype), zF(jq.prototype, "getStats", [kq], Object.getOwnPropertyDescriptor(jq.prototype, "getStats"), jq.prototype), zF(jq.prototype, "setBeautyEffect", [Bq], Object.getOwnPropertyDescriptor(jq.prototype, "setBeautyEffect"), jq.prototype), zF(jq.prototype, "getCurrentFrameData", [Mq], Object.getOwnPropertyDescriptor(jq.prototype, "getCurrentFrameData"), jq.prototype), zF(jq.prototype, "setBitrateLimit", [Uq], Object.getOwnPropertyDescriptor(jq.prototype, "setBitrateLimit"), jq.prototype), zF(jq.prototype, "setOptimizationMode", [Qq], Object.getOwnPropertyDescriptor(jq.prototype, "setOptimizationMode"), jq.prototype), zF(jq.prototype, "setScalabiltyMode", [xq], Object.getOwnPropertyDescriptor(jq.prototype, "setScalabiltyMode"), jq.prototype), zF(jq.prototype, "updateMediaStreamTrackResolution", [Fq], Object.getOwnPropertyDescriptor(jq.prototype, "updateMediaStreamTrackResolution"), jq.prototype), Vq = jq)) || Vq), ez = (Gq = PD("CameraVideoTrack", "getTrackId"), Kq = pj(), Hq = BV("CameraVideoTrack", "_enabledMutex"), Yq = pj(), Wq = pj(), Gq((zF((qq = class extends $q {
        constructor(e2, t2, r2, i2, n2, o2) {
          super(e2, t2.encoderConfig ? jD(t2.encoderConfig) : {}, i2, n2, o2), kO(this, "_config", void 0), kO(this, "_originalConstraints", void 0), kO(this, "_constraints", void 0), kO(this, "_enabled", true), kO(this, "_deviceName", "default"), kO(this, "tryResumeVideoForIOS15WeChat", async () => {
            IO() && !CO() && SO() && this._enabled && !this._isClosed && (dD.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS 15 device on WeChat.")), await this.renewMediaStreamTrack());
          }), LD("info", this, "constructor", { trackId: o2, deviceId: e2.label, constraints: r2, config: t2 }), this._config = t2, this._originalConstraints = r2, this._constraints = r2, this._deviceName = e2.label, this._config.encoderConfig && (this._encoderConfig = jD(this._config.encoderConfig)), VV.on(NV.IOS_15_INTERRUPTION_END, this.tryResumeVideoForIOS15WeChat), VV.on(NV.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15WeChat), this.bindProcessorContextEvents();
        }
        async setDevice(e2) {
          const t2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.CAM_VIDEO_TRACK_SET_DEVICE, options: [this.getTrackId(), e2] });
          if (dD.info("[".concat(this.getTrackId(), "] set device to ").concat(e2)), ND("info", this, "setDevice", e2), this._enabled)
            try {
              const t3 = await dj.getDeviceById(e2), r2 = {};
              r2.video = Zq({}, this._constraints), r2.video.deviceId = { exact: e2 }, r2.video.facingMode = void 0, this._originMediaStreamTrack.stop();
              let i2 = null;
              try {
                i2 = await oj(r2, this.getTrackId());
              } catch (t4) {
                throw dD.error("[".concat(this.getTrackId(), "] setDevice failed"), t4.toString()), ND("error", this, "setDevice", e2, t4.toString()), i2 = await oj({ video: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(i2.getVideoTracks()[0], false), t4;
              }
              await this._updateOriginMediaStreamTrack(i2.getVideoTracks()[0], false), this.updateMediaStreamTrackResolution(), this._deviceName = t3.label, this._config.cameraId = e2, this._constraints.deviceId = { exact: e2 };
            } catch (r2) {
              throw t2.onError(r2), dD.error("[".concat(this.getTrackId(), "] setDevice error"), r2.toString()), ND("error", this, "setDevice", e2, r2.toString()), r2;
            }
          else
            try {
              const t3 = await dj.getDeviceById(e2);
              this._deviceName = t3.label, this._config.cameraId = e2, this._constraints.deviceId = { exact: e2 };
            } catch (r2) {
              throw t2.onError(r2), dD.error("[".concat(this.getTrackId(), "] setDevice error"), r2.toString()), ND("error", this, "setDevice", e2, r2.toString()), r2;
            }
          dD.info("[".concat(this.getTrackId(), "] setDevice success")), ND("info", this, "setDevice", e2, "success"), t2.onSuccess();
        }
        async setEnabled(e2, t2) {
          if (!t2) {
            if (e2 === this._enabled)
              return;
            this.stateCheck("enabled", e2);
          }
          if (dD.info("[".concat(this.getTrackId(), "] start setEnabled"), e2), ND("info", this, "setEnabled", e2), !e2) {
            this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop(), t2 || (this._enabled = false);
            try {
              await OG(this, Ak.NEED_DISABLE_TRACK, this);
            } catch (t3) {
              throw dD.error("[".concat(this.getTrackId(), "] setEnabled to false error"), t3.toString()), ND("error", this, "setEnabled", e2, t3.toString()), t3;
            }
            return dD.info("[".concat(this.getTrackId(), "] setEnabled to false success")), void ND("info", this, "setEnabled", e2, "success");
          }
          const r2 = Zq({}, this._constraints), i2 = dj.searchDeviceIdByName(this._deviceName);
          i2 && !r2.deviceId && (r2.deviceId = { exact: i2 });
          try {
            const e3 = await oj({ video: this._constraints }, this.getTrackId());
            await this._updateOriginMediaStreamTrack(e3.getVideoTracks()[0], false), await OG(this, Ak.NEED_ENABLE_TRACK, this);
          } catch (t3) {
            throw dD.error("[".concat(this.getTrackId(), "] setEnabled true error"), t3.toString()), ND("error", this, "setEnabled", e2, t3.toString()), t3;
          }
          this.updateMediaStreamTrackResolution(), dD.info("[".concat(this.getTrackId(), "] setEnabled to true success")), ND("info", this, "setEnabled", e2, "success"), t2 || (this._enabled = true);
        }
        async setEncoderConfiguration(e2, t2) {
          const r2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.CAM_VIDEO_TRACK_SET_ENCODER_CONFIG, options: [this.getTrackId(), e2] });
          if (!this._enabled) {
            const e3 = new tD(eD.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
            throw r2.onError(e3), e3;
          }
          e2 = jD(e2), this._forceBitrateLimit && (e2.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e2.bitrateMax, e2.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e2.bitrateMin);
          const i2 = BG(this._config);
          i2.encoderConfig = e2;
          const n2 = vq(i2);
          (pO() || fO() || vO()) && (n2.deviceId = void 0), dD.debug("[".concat(this.getTrackId(), "] setEncoderConfiguration applyConstraints"), JSON.stringify(e2), JSON.stringify(n2)), ND("debug", this, "setEncoderConfiguration", e2);
          try {
            await this._originMediaStreamTrack.applyConstraints(n2), this.updateMediaStreamTrackResolution();
          } catch (e3) {
            const t3 = new tD(eD.UNEXPECTED_ERROR, e3.toString());
            throw dD.error("[".concat(this.getTrackId(), "] applyConstraints error"), t3.toString()), ND("error", this, "setEncoderConfiguration", e3.toString()), r2.onError(t3), t3;
          }
          this._config = i2, this._constraints = n2, this._originalConstraints = n2, this._encoderConfig = e2, this._hints.indexOf(hk.SCREEN_TRACK) === -1 && this.updateBitrateFromProfile();
          try {
            await OG(this, Ak.NEED_UPDATE_VIDEO_ENCODER, this);
          } catch (e3) {
            return r2.onError(e3), e3.throw();
          }
          r2.onSuccess();
        }
        _getDefaultPlayerConfig() {
          return { mirror: true, fit: "cover" };
        }
        onTrackEnded() {
          if ((fO() || vO()) && this._enabled && !this._isClosed && VV.duringInterruption) {
            const e2 = async () => {
              VV.off(NV.IOS_INTERRUPTION_END, e2), this._enabled && !this._isClosed && (dD.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS device.")), TD("debug", this, "try capture camera media device for interrupted iOS device."), await this.setEnabled(false), await this.setEnabled(true));
            };
            VV.on(NV.IOS_INTERRUPTION_END, e2);
          } else
            dD.debug("[".concat(this.getTrackId(), "] track ended")), OD("debug", ["MediaStreamTrack", this.getTrackId()], "ended"), this.emit(gk.TRACK_ENDED);
        }
        async renewMediaStreamTrack(e2) {
          const t2 = e2 || this._constraints, r2 = dj.searchDeviceIdByName(this._deviceName);
          r2 && !t2.deviceId && (t2.deviceId = { exact: r2 });
          const i2 = await oj({ video: t2 }, this.getTrackId());
          this._constraints = t2, await this._updateOriginMediaStreamTrack(i2.getVideoTracks()[0], true), this.updateMediaStreamTrackResolution();
        }
        close() {
          super.close(), VV.off(NV.IOS_15_INTERRUPTION_END, this.tryResumeVideoForIOS15WeChat), VV.off(NV.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15WeChat);
        }
        bindProcessorContextEvents() {
          this.processorContext.on(kk.REQUEST_UPDATE_CONSTRAINTS, async (e2, t2, r2) => {
            try {
              const r3 = Object.assign({}, this._originalConstraints, ...e2);
              await this.renewMediaStreamTrack(r3), t2();
            } catch (e3) {
              r2(e3);
            }
          }), this.processorContext.on(kk.REQUEST_CONSTRAINTS, async (e2) => {
            e2(this._originMediaStreamTrack.getSettings());
          });
        }
      }).prototype, "setDevice", [Kq], Object.getOwnPropertyDescriptor(qq.prototype, "setDevice"), qq.prototype), zF(qq.prototype, "setEnabled", [Hq, Yq], Object.getOwnPropertyDescriptor(qq.prototype, "setEnabled"), qq.prototype), zF(qq.prototype, "setEncoderConfiguration", [Wq], Object.getOwnPropertyDescriptor(qq.prototype, "setEncoderConfiguration"), qq.prototype), Jq = qq)) || Jq);
      class tz extends ZN {
        constructor(e2) {
          super(), kO(this, "name", "VideoProcessorDestination"), kO(this, "ID", "0"), kO(this, "_source", void 0), kO(this, "videoContext", void 0), kO(this, "inputTrack", void 0), this.videoContext = e2;
        }
        get kind() {
          return "video";
        }
        get enabled() {
          return true;
        }
        pipe() {
          throw new tD(eD.NOT_SUPPORTED, "VideoProcessor cannot pipe to any other Processor");
        }
        unpipe() {
          throw new tD(eD.NOT_SUPPORTED, "VideoProcessor cannot unpipe to any other Processor");
        }
        enable() {
        }
        disable() {
        }
        updateInput(e2) {
          if (e2.context !== this.videoContext)
            throw new Error("ProcessorContext passed to VideoTrack.processorDestination doesn't match it's belonging VideoTrack's context.\nProbably you are making pipeline like this:\nvideoTrack1.pipe(processor).pipe(videoTrack2.processorDestination).");
          e2.track && e2.track !== this.inputTrack && (this.inputTrack = e2.track, this.emit(Pk.ON_TRACK, e2.track));
        }
        reset() {
          this.inputTrack = void 0, this.emit(Pk.ON_TRACK, void 0);
        }
      }
      class rz extends ZN {
        constructor(e2) {
          super(), kO(this, "constraintsMap", /* @__PURE__ */ new Map()), kO(this, "statsRegistry", []), kO(this, "trackId", void 0), this.trackId = e2;
        }
        async getConstraints() {
          return await bG(this, kk.REQUEST_CONSTRAINTS);
        }
        async requestApplyConstraints(e2, t2) {
          var r2;
          return dD.info("processor ".concat(t2.name, " requestApplyConstraints for ").concat(this.trackId)), e2 && this.constraintsMap.set(t2, e2), OG(this, kk.REQUEST_UPDATE_CONSTRAINTS, Array.from(nV(r2 = this.constraintsMap).call(r2)));
        }
        async requestRevertConstraints(e2) {
          var t2;
          if (this.constraintsMap.has(e2))
            return dD.info("processor ".concat(e2.name, " requestRevertConstraints for ").concat(this.trackId)), this.constraintsMap.delete(e2), OG(this, kk.REQUEST_UPDATE_CONSTRAINTS, Array.from(nV(t2 = this.constraintsMap).call(t2)));
        }
        registerStats(e2, t2, r2) {
          this.statsRegistry.find((r3) => r3.processorID === e2.ID && r3.processorName === e2.name && r3.type === t2) || this.statsRegistry.push({ processorName: e2.name, processorID: e2.ID, type: t2, cb: r2 });
        }
        unregisterStats(e2, t2) {
        }
        gatherStats() {
          return this.statsRegistry.map((e2) => {
            let { processorID: t2, processorName: r2, type: i2, cb: n2 } = e2;
            return { processorID: t2, processorName: r2, type: i2, stats: n2() };
          });
        }
      }
      class iz {
        get hasVideo() {
          return this._video_enabled_ && !this._video_muted_ && this._video_added_;
        }
        get hasAudio() {
          return this._audio_enabled_ && !this._audio_muted_ && this._audio_added_;
        }
        get audioTrack() {
          if (this.hasAudio)
            return this._audioTrack;
        }
        get videoTrack() {
          if (this.hasVideo)
            return this._videoTrack;
        }
        constructor(e2, t2) {
          kO(this, "uid", void 0), kO(this, "_uintid", void 0), kO(this, "_trust_in_room_", true), kO(this, "_trust_audio_enabled_state_", true), kO(this, "_trust_video_enabled_state_", true), kO(this, "_trust_audio_mute_state_", true), kO(this, "_trust_video_mute_state_", true), kO(this, "_trust_stream_added_state_", true), kO(this, "_audio_muted_", false), kO(this, "_video_muted_", false), kO(this, "_audio_enabled_", true), kO(this, "_video_enabled_", true), kO(this, "_audio_added_", false), kO(this, "_video_added_", false), kO(this, "_audioTrack", void 0), kO(this, "_videoTrack", void 0), kO(this, "_audioSSRC", void 0), kO(this, "_videoSSRC", void 0), kO(this, "_audioOrtc", void 0), kO(this, "_videoOrtc", void 0), kO(this, "_cname", void 0), kO(this, "_rtxSsrcId", void 0), this.uid = e2, this._uintid = t2;
        }
      }
      var nz = iR, oz = ZC, sz = sv;
      JA({ target: "Promise", stat: true }, { try: function(e2) {
        var t2 = oz.f(this), r2 = sz(e2);
        return (r2.error ? t2.reject : t2.resolve)(r2.value), t2.promise;
      } });
      var az = nz, cz = JA, dz = Qc, uz = bc, Az = Fx, hz = md, lz = Au, pz = th, gz = aL, fz = Jx, Ez = OF, Iz = Pd, mz = Nu("isConcatSpreadable"), _z = 9007199254740991, Cz = "Maximum allowed index exceeded", vz = dz.TypeError, Sz = Iz >= 51 || !uz(function() {
        var e2 = [];
        return e2[mz] = false, e2.concat()[0] !== e2;
      }), Rz = Ez("concat"), yz = function(e2) {
        if (!hz(e2))
          return false;
        var t2 = e2[mz];
        return t2 !== void 0 ? !!t2 : Az(e2);
      };
      cz({ target: "Array", proto: true, forced: !Sz || !Rz }, { concat: function(e2) {
        var t2, r2, i2, n2, o2, s2 = lz(this), a2 = fz(s2, 0), c2 = 0;
        for (t2 = -1, i2 = arguments.length; t2 < i2; t2++)
          if (yz(o2 = t2 === -1 ? s2 : arguments[t2])) {
            if (c2 + (n2 = pz(o2)) > _z)
              throw vz(Cz);
            for (r2 = 0; r2 < n2; r2++, c2++)
              r2 in o2 && gz(a2, c2, o2[r2]);
          } else {
            if (c2 >= _z)
              throw vz(Cz);
            gz(a2, c2++, o2);
          }
        return a2.length = c2, a2;
      } });
      var Tz = {}, wz = sd, bz = Ed, Oz = hf.f, Nz = lL, Dz = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
      Tz.f = function(e2) {
        return Dz && wz(e2) == "Window" ? function(e3) {
          try {
            return Oz(e3);
          } catch (e4) {
            return Nz(Dz);
          }
        }(e2) : Oz(bz(e2));
      };
      var Lz = {}, Pz = Nu;
      Lz.f = Pz;
      var kz = _d, Bz = pu, Mz = Lz, Uz = fA.f, Qz = function(e2) {
        var t2 = kz.Symbol || (kz.Symbol = {});
        Bz(t2, e2) || Uz(t2, e2, { value: Mz.f(e2) });
      }, xz = JA, Fz = Qc, Vz = yd, jz = Gc, Gz = qc, Kz = Bc, Hz = Yc, Yz = Md, Wz = bc, Jz = pu, qz = Fx, zz = Kc, Xz = md, Zz = Mc, $z = Gd, eX = vA, tX = Au, rX = Ed, iX = Vu, nX = hI, oX = rd, sX = hE, aX = Yf, cX = hf, dX = Tz, uX = Lf, AX = Hc, hX = fA, lX = Gf, pX = zc, gX = Z_, fX = mm, EX = ru.exports, IX = vf, mX = mu, _X = Nu, CX = Lz, vX = Qz, SX = Um, RX = Am, yX = rF.forEach, TX = Yg("hidden"), wX = "Symbol", bX = _X("toPrimitive"), OX = RX.set, NX = RX.getterFor(wX), DX = Object.prototype, LX = Fz.Symbol, PX = LX && LX.prototype, kX = Fz.TypeError, BX = Fz.QObject, MX = Vz("JSON", "stringify"), UX = AX.f, QX = hX.f, xX = dX.f, FX = pX.f, VX = Kz([].push), jX = EX("symbols"), GX = EX("op-symbols"), KX = EX("string-to-symbol-registry"), HX = EX("symbol-to-string-registry"), YX = EX("wks"), WX = !BX || !BX.prototype || !BX.prototype.findChild, JX = Hz && Wz(function() {
        return sX(QX({}, "a", { get: function() {
          return QX(this, "a", { value: 7 }).a;
        } })).a != 7;
      }) ? function(e2, t2, r2) {
        var i2 = UX(DX, t2);
        i2 && delete DX[t2], QX(e2, t2, r2), i2 && e2 !== DX && QX(DX, t2, i2);
      } : QX, qX = function(e2, t2) {
        var r2 = jX[e2] = sX(PX);
        return OX(r2, { type: wX, tag: e2, description: t2 }), Hz || (r2.description = t2), r2;
      }, zX = function(e2, t2, r2) {
        e2 === DX && zX(GX, t2, r2), eX(e2);
        var i2 = iX(t2);
        return eX(r2), Jz(jX, i2) ? (r2.enumerable ? (Jz(e2, TX) && e2[TX][i2] && (e2[TX][i2] = false), r2 = sX(r2, { enumerable: oX(0, false) })) : (Jz(e2, TX) || QX(e2, TX, oX(1, {})), e2[TX][i2] = true), JX(e2, i2, r2)) : QX(e2, i2, r2);
      }, XX = function(e2, t2) {
        eX(e2);
        var r2 = rX(t2), i2 = aX(r2).concat(tZ(r2));
        return yX(i2, function(t3) {
          Hz && !Gz(ZX, r2, t3) || zX(e2, t3, r2[t3]);
        }), e2;
      }, ZX = function(e2) {
        var t2 = iX(e2), r2 = Gz(FX, this, t2);
        return !(this === DX && Jz(jX, t2) && !Jz(GX, t2)) && (!(r2 || !Jz(this, t2) || !Jz(jX, t2) || Jz(this, TX) && this[TX][t2]) || r2);
      }, $X = function(e2, t2) {
        var r2 = rX(e2), i2 = iX(t2);
        if (r2 !== DX || !Jz(jX, i2) || Jz(GX, i2)) {
          var n2 = UX(r2, i2);
          return !n2 || !Jz(jX, i2) || Jz(r2, TX) && r2[TX][i2] || (n2.enumerable = true), n2;
        }
      }, eZ = function(e2) {
        var t2 = xX(rX(e2)), r2 = [];
        return yX(t2, function(e3) {
          Jz(jX, e3) || Jz(IX, e3) || VX(r2, e3);
        }), r2;
      }, tZ = function(e2) {
        var t2 = e2 === DX, r2 = xX(t2 ? GX : rX(e2)), i2 = [];
        return yX(r2, function(e3) {
          !Jz(jX, e3) || t2 && !Jz(DX, e3) || VX(i2, jX[e3]);
        }), i2;
      };
      (Yz || (fX(PX = (LX = function() {
        if (Zz(PX, this))
          throw kX("Symbol is not a constructor");
        var e2 = arguments.length && arguments[0] !== void 0 ? nX(arguments[0]) : void 0, t2 = mX(e2), r2 = function(e3) {
          this === DX && Gz(r2, GX, e3), Jz(this, TX) && Jz(this[TX], t2) && (this[TX][t2] = false), JX(this, t2, oX(1, e3));
        };
        return Hz && WX && JX(DX, t2, { configurable: true, set: r2 }), qX(t2, e2);
      }).prototype, "toString", function() {
        return NX(this).tag;
      }), fX(LX, "withoutSetter", function(e2) {
        return qX(mX(e2), e2);
      }), pX.f = ZX, hX.f = zX, lX.f = XX, AX.f = $X, cX.f = dX.f = eZ, uX.f = tZ, CX.f = function(e2) {
        return qX(_X(e2), e2);
      }, Hz && QX(PX, "description", { configurable: true, get: function() {
        return NX(this).description;
      } })), xz({ global: true, wrap: true, forced: !Yz, sham: !Yz }, { Symbol: LX }), yX(aX(YX), function(e2) {
        vX(e2);
      }), xz({ target: wX, stat: true, forced: !Yz }, { for: function(e2) {
        var t2 = nX(e2);
        if (Jz(KX, t2))
          return KX[t2];
        var r2 = LX(t2);
        return KX[t2] = r2, HX[r2] = t2, r2;
      }, keyFor: function(e2) {
        if (!$z(e2))
          throw kX(e2 + " is not a symbol");
        if (Jz(HX, e2))
          return HX[e2];
      }, useSetter: function() {
        WX = true;
      }, useSimple: function() {
        WX = false;
      } }), xz({ target: "Object", stat: true, forced: !Yz, sham: !Hz }, { create: function(e2, t2) {
        return t2 === void 0 ? sX(e2) : XX(sX(e2), t2);
      }, defineProperty: zX, defineProperties: XX, getOwnPropertyDescriptor: $X }), xz({ target: "Object", stat: true, forced: !Yz }, { getOwnPropertyNames: eZ, getOwnPropertySymbols: tZ }), xz({ target: "Object", stat: true, forced: Wz(function() {
        uX.f(1);
      }) }, { getOwnPropertySymbols: function(e2) {
        return uX.f(tX(e2));
      } }), MX) && xz({ target: "JSON", stat: true, forced: !Yz || Wz(function() {
        var e2 = LX();
        return MX([e2]) != "[null]" || MX({ a: e2 }) != "{}" || MX(Object(e2)) != "{}";
      }) }, { stringify: function(e2, t2, r2) {
        var i2 = gX(arguments), n2 = t2;
        if ((Xz(t2) || e2 !== void 0) && !$z(e2))
          return qz(t2) || (t2 = function(e3, t3) {
            if (zz(n2) && (t3 = Gz(n2, this, e3, t3)), !$z(t3))
              return t3;
          }), i2[1] = t2, jz(MX, null, i2);
      } });
      if (!PX[bX]) {
        var rZ = PX.valueOf;
        fX(PX, bX, function(e2) {
          return Gz(rZ, this);
        });
      }
      SX(LX, wX), IX[TX] = true, Qz("asyncIterator"), Qz("hasInstance"), Qz("isConcatSpreadable"), Qz("iterator"), Qz("match"), Qz("matchAll"), Qz("replace"), Qz("search"), Qz("species"), Qz("split"), Qz("toPrimitive"), Qz("toStringTag"), Qz("unscopables"), Um(Qc.JSON, "JSON", true);
      var iZ = _d.Symbol;
      Qz("asyncDispose"), Qz("dispose"), Qz("matcher"), Qz("metadata"), Qz("observable"), Qz("patternMatch"), Qz("replaceAll");
      var nZ = iZ, oZ = Lz.f("asyncIterator"), sZ = oZ;
      function aZ(e2) {
        this.wrapped = e2;
      }
      function cZ(e2) {
        var t2, r2;
        function i2(t3, r3) {
          try {
            var o2 = e2[t3](r3), s2 = o2.value, a2 = s2 instanceof aZ;
            az.resolve(a2 ? s2.wrapped : s2).then(function(e3) {
              a2 ? i2(t3 === "return" ? "return" : "next", e3) : n2(o2.done ? "return" : "normal", e3);
            }, function(e3) {
              i2("throw", e3);
            });
          } catch (e3) {
            n2("throw", e3);
          }
        }
        function n2(e3, n3) {
          switch (e3) {
            case "return":
              t2.resolve({ value: n3, done: true });
              break;
            case "throw":
              t2.reject(n3);
              break;
            default:
              t2.resolve({ value: n3, done: false });
          }
          (t2 = t2.next) ? i2(t2.key, t2.arg) : r2 = null;
        }
        this._invoke = function(e3, n3) {
          return new az(function(o2, s2) {
            var a2 = { key: e3, arg: n3, resolve: o2, reject: s2, next: null };
            r2 ? r2 = r2.next = a2 : (t2 = r2 = a2, i2(e3, n3));
          });
        }, typeof e2.return != "function" && (this.return = void 0);
      }
      function dZ(e2) {
        return function() {
          return new cZ(e2.apply(this, arguments));
        };
      }
      function uZ(e2) {
        return new aZ(e2);
      }
      cZ.prototype[typeof nZ == "function" && sZ || "@@asyncIterator"] = function() {
        return this;
      }, cZ.prototype.next = function(e2) {
        return this._invoke("next", e2);
      }, cZ.prototype.throw = function(e2) {
        return this._invoke("throw", e2);
      }, cZ.prototype.return = function(e2) {
        return this._invoke("return", e2);
      };
      var AZ = Lz.f("iterator");
      function hZ(e2, t2) {
        var r2 = {}, i2 = false;
        function n2(r3, n3) {
          return i2 = true, n3 = new az(function(t3) {
            t3(e2[r3](n3));
          }), { done: false, value: t2(n3) };
        }
        return r2[nZ !== void 0 && AZ || "@@iterator"] = function() {
          return this;
        }, r2.next = function(e3) {
          return i2 ? (i2 = false, e3) : n2("next", e3);
        }, typeof e2.throw == "function" && (r2.throw = function(e3) {
          if (i2)
            throw i2 = false, e3;
          return n2("throw", e3);
        }), typeof e2.return == "function" && (r2.return = function(e3) {
          return i2 ? (i2 = false, e3) : n2("return", e3);
        }), r2;
      }
      var lZ = oZ, pZ = Gi, gZ = o, fZ = r, EZ = v, IZ = Be, mZ = Q, _Z = H, CZ = yh, vZ = Rt.f, SZ = Ti, RZ = fZ.Symbol, yZ = RZ && RZ.prototype;
      if (gZ && mZ(RZ) && (!("description" in yZ) || RZ().description !== void 0)) {
        var TZ = {}, wZ = function() {
          var e2 = arguments.length < 1 || arguments[0] === void 0 ? void 0 : CZ(arguments[0]), t2 = _Z(yZ, this) ? new RZ(e2) : e2 === void 0 ? RZ() : RZ(e2);
          return e2 === "" && (TZ[t2] = true), t2;
        };
        SZ(wZ, RZ), wZ.prototype = yZ, yZ.constructor = wZ;
        var bZ = String(RZ("test")) == "Symbol(test)", OZ = EZ(yZ.toString), NZ = EZ(yZ.valueOf), DZ = /^Symbol\((.*)\)[^)]+$/, LZ = EZ("".replace), PZ = EZ("".slice);
        vZ(yZ, "description", { configurable: true, get: function() {
          var e2 = NZ(this), t2 = OZ(e2);
          if (IZ(TZ, e2))
            return "";
          var r2 = bZ ? PZ(t2, 7, -1) : LZ(t2, DZ, "$1");
          return r2 === "" ? void 0 : r2;
        } }), pZ({ global: true, forced: true }, { Symbol: wZ });
      }
      var kZ = { exports: {} };
      function BZ(e2, t2) {
        var r2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          t2 && (i2 = i2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), r2.push.apply(r2, i2);
        }
        return r2;
      }
      function MZ(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r2 = arguments[t2] != null ? arguments[t2] : {};
          t2 % 2 ? BZ(Object(r2), true).forEach(function(t3) {
            kO(e2, t3, r2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : BZ(Object(r2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
          });
        }
        return e2;
      }
      function UZ(e2, t2, r2, i2, n2, o2) {
        let s2 = [], a2 = [], c2 = [], d2 = [], u2 = false, A2 = false;
        if (kZ.exports.parse(e2).mediaDescriptions.forEach((e3) => {
          o2 && o2 !== e3.attributes.direction || (e3.media.mediaType !== "video" || u2 || (a2 = e3.attributes.payloads, d2 = e3.attributes.extmaps, u2 = true), e3.media.mediaType !== "audio" || A2 || (s2 = e3.attributes.payloads, c2 = e3.attributes.extmaps, A2 = true));
        }), !d2 || a2.length === 0)
          throw new Error("Cannot get video capabilities from SDP.");
        if (!c2 || s2.length === 0)
          throw new Error("Cannot get audio capabilities from SDP.");
        return a2.forEach((e3) => {
          var t3;
          (t3 = e3.rtpMap) !== null && t3 !== void 0 && t3.clockRate && (e3.rtpMap.clockRate = parseInt(e3.rtpMap.clockRate));
        }), s2.forEach((e3) => {
          var t3;
          (t3 = e3.rtpMap) !== null && t3 !== void 0 && t3.clockRate && (e3.rtpMap.clockRate = parseInt(e3.rtpMap.clockRate));
        }), t2 && (s2 = s2.filter((e3) => {
          var t3;
          return ((t3 = e3.rtpMap) === null || t3 === void 0 ? void 0 : t3.encodingName.toLowerCase()) !== "rtx";
        }), a2 = a2.filter((e3) => {
          var t3;
          return ((t3 = e3.rtpMap) === null || t3 === void 0 ? void 0 : t3.encodingName.toLowerCase()) !== "rtx";
        })), r2 && (a2 = a2.filter((e3) => {
          var t3;
          return !/(red)|(ulpfec)|(flexfec)/i.test(((t3 = e3.rtpMap) === null || t3 === void 0 ? void 0 : t3.encodingName) || "");
        })), i2 && (i2 == null ? void 0 : i2.length) > 0 && (s2 = s2.filter((e3) => {
          var t3;
          return i2.includes(((t3 = e3.rtpMap) === null || t3 === void 0 ? void 0 : t3.encodingName.toLowerCase()) || "");
        })), n2 && (n2 == null ? void 0 : n2.length) > 0 && (a2 = a2.filter((e3) => {
          var t3;
          return n2.includes(((t3 = e3.rtpMap) === null || t3 === void 0 ? void 0 : t3.encodingName.toLowerCase()) || "");
        })), { audioCodecs: s2, videoCodecs: a2, audioExtensions: c2, videoExtensions: d2 };
      }
      function QZ(e2) {
        const t2 = kZ.exports.parse(e2);
        let r2, i2;
        for (const e3 of t2.mediaDescriptions) {
          if (!r2) {
            const t3 = e3.attributes.iceUfrag, i3 = e3.attributes.icePwd;
            if (!t3 || !i3)
              throw new Error("Cannot get iceUfrag or icePwd from SDP.");
            r2 = { iceUfrag: t3, icePwd: i3 };
          }
          if (!i2) {
            const t3 = e3.attributes.fingerprints;
            t3.length > 0 && (i2 = { fingerprints: t3 });
          }
        }
        if (!i2 && t2.attributes.fingerprints.length > 0 && (i2 = { fingerprints: t2.attributes.fingerprints }), !i2 || !r2)
          throw new Error("Cannot get iceParameters or dtlsParameters from SDP.");
        return { iceParameters: r2, dtlsParameters: i2 };
      }
      function xZ(e2, t2, r2) {
        const { cname: i2 } = e2;
        let n2;
        t2 !== void 0 && r2 !== void 0 ? (n2 = [{ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t2, port: r2.toString(), type: "host", extension: {} }], dD.debug("Using remote candidate from AP ".concat(t2, ":").concat(r2)), TD("debug", [], "Using remote candidate from AP ".concat(t2, ":").concat(r2))) : n2 = e2.iceParameters.candidates.map((e3) => ({ foundation: e3.foundation, componentId: "1", transport: e3.protocol, priority: e3.priority.toString(), connectionAddress: e3.ip, port: e3.port.toString(), type: e3.type, extension: {} }));
        const o2 = { fingerprints: e2.dtlsParameters.fingerprints.map((e3) => ({ hashFunction: e3.algorithm, fingerprint: e3.fingerprint })) }, s2 = { iceUfrag: e2.iceParameters.iceUfrag, icePwd: e2.iceParameters.icePwd };
        let a2;
        switch (e2.dtlsParameters.role) {
          case "server":
            a2 = "passive";
            break;
          case "client":
            a2 = "active";
            break;
          case "auto":
            a2 = "actpass";
        }
        return { dtlsParameters: o2, iceParameters: s2, candidates: n2, rtpCapabilities: YZ(e2.rtpCapabilities), setup: a2, cname: i2 };
      }
      function FZ(e2, t2, r2) {
        const i2 = [], n2 = [];
        return e2.forEach((e3) => {
          let { ssrcId: o2, rtx: s2 } = e3;
          const a2 = SG(8, "track-"), c2 = { ssrcId: o2, attributes: MZ({ label: a2, mslabel: r2 = r2 || SG(10, ""), msid: "".concat(r2, " ").concat(a2) }, t2 && { cname: t2 }) };
          if (i2.push(c2), s2 !== void 0) {
            const e4 = { ssrcId: s2, attributes: MZ({ label: a2, mslabel: r2, msid: "".concat(r2, " ").concat(a2) }, t2 && { cname: t2 }) };
            i2.push(e4), n2.push({ semantic: "FID", ssrcIds: [o2, s2] });
          }
        }), e2.length > 1 && n2.push({ semantic: "SIM", ssrcIds: e2.map((e3) => {
          let { ssrcId: t3 } = e3;
          return t3;
        }) }), { ssrcs: i2, ssrcGroups: n2 };
      }
      function VZ(e2, t2) {
        t2 instanceof Hj && e2.attributes.payloads.forEach((e3) => {
          var r2;
          const i2 = (r2 = e3.rtpMap) === null || r2 === void 0 ? void 0 : r2.encodingName.toLowerCase();
          if (!i2 || ["opus", "pcmu", "pcma", "g722"].indexOf(i2) === -1)
            return;
          e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters.minptime = "10", e3.fmtp.parameters.useinbandfec = "1";
          const n2 = t2._encoderConfig;
          n2 && (i2 !== "pcmu" && i2 !== "pcma" && i2 !== "g722" && (n2.bitrate && !gO() && (e3.fmtp.parameters.maxaveragebitrate = "".concat(Math.floor(1e3 * n2.bitrate))), n2.sampleRate && (e3.fmtp.parameters.maxplaybackrate = "".concat(n2.sampleRate), e3.fmtp.parameters["sprop-maxcapturerate"] = "".concat(n2.sampleRate))), n2.stereo && (e3.fmtp.parameters.stereo = "1", e3.fmtp.parameters["sprop-stereo"] = "1"));
        });
      }
      function jZ(e2) {
        const t2 = e2.attributes.unrecognized.findIndex((e3) => e3.attField === "x-google-flag" && e3.attValue === "conference");
        t2 !== -1 && e2.attributes.unrecognized.splice(t2, 1);
      }
      function GZ(e2, t2) {
        if (!(t2 instanceof $q && t2._encoderConfig && t2._hints.indexOf(hk.SCREEN_TRACK) === -1))
          return;
        const r2 = t2._encoderConfig;
        Mk().supportMinBitrate && r2.bitrateMin && e2.attributes.payloads.forEach((e3) => {
          var t3;
          ["h264", "vp8", "vp9", "av1"].includes(((t3 = e3.rtpMap) === null || t3 === void 0 ? void 0 : t3.encodingName.toLowerCase()) || "") && (e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters["x-google-min-bitrate"] = "".concat(r2.bitrateMin));
        }), Mk().supportMinBitrate && !t2._hints.includes(hk.LOW_STREAM) && r2.bitrateMax && e2.attributes.payloads.forEach((e3) => {
          var t3;
          ["h264", "vp8", "vp9", "av1"].includes(((t3 = e3.rtpMap) === null || t3 === void 0 ? void 0 : t3.encodingName.toLowerCase()) || "") && (e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters["x-google-start-bitrate"] = "".concat(Math.floor(r2.bitrateMax)));
        });
      }
      function KZ(e2, t2, r2) {
        if (!t2)
          return;
        let i2, n2;
        if (e2.media.mediaType === "video" ? (i2 = r2.videoExtensions, n2 = r2.videoCodecs) : (i2 = r2.audioExtensions, n2 = r2.audioCodecs), t2.tcc === true) {
          const t3 = i2.find((e3) => e3.extensionName === "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01");
          if (t3) {
            e2.attributes.extmaps.find((e3) => e3.extensionName === "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01") || e2.attributes.extmaps.push({ entry: t3.entry, extensionName: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" });
            (function(e3, t4) {
              return t4.filter((t5) => !!e3.find((e4) => e4.payloadType === t5.payloadType && !!e4.rtcpFeedbacks.find((e5) => e5.type === "transport-cc")));
            })(n2, e2.attributes.payloads).forEach((e3) => {
              e3.rtcpFeedbacks.find((e4) => e4.type === "transport-cc") || e3.rtcpFeedbacks.push({ type: "transport-cc" });
            });
          }
        } else if (t2.tcc === false) {
          const t3 = e2.attributes.extmaps.findIndex((e3) => e3.extensionName === "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01");
          t3 !== -1 && e2.attributes.extmaps.splice(t3, 1), e2.attributes.payloads.forEach((e3) => {
            const t4 = e3.rtcpFeedbacks.findIndex((e4) => e4.type === "transport-cc");
            t4 !== -1 && e3.rtcpFeedbacks.splice(t4, 1);
          });
        }
        if (t2.remb === true) {
          const t3 = i2.find((e3) => e3.extensionName === "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time");
          if (t3) {
            e2.attributes.extmaps.find((e3) => e3.extensionName === "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time") || e2.attributes.extmaps.push({ entry: t3.entry, extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" });
            (function(e3, t4) {
              return t4.filter((t5) => !!e3.find((e4) => e4.payloadType === t5.payloadType && !!e4.rtcpFeedbacks.find((e5) => e5.type === "goog-remb")));
            })(n2, e2.attributes.payloads).forEach((e3) => {
              e3.rtcpFeedbacks.find((e4) => e4.type === "goog-remb") || e3.rtcpFeedbacks.push({ type: "goog-remb" });
            });
          }
        } else if (t2.remb === false) {
          const t3 = e2.attributes.extmaps.findIndex((e3) => e3.extensionName === "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time");
          t3 !== -1 && e2.attributes.extmaps.splice(t3, 1), e2.attributes.payloads.forEach((e3) => {
            const t4 = e3.rtcpFeedbacks.findIndex((e4) => e4.type === "goog-remb");
            t4 !== -1 && e3.rtcpFeedbacks.splice(t4, 1);
          });
        }
      }
      function HZ(e2, t2, r2, i2, n2, o2) {
        if (r2 === "videoExtensions" || r2 === "audioExtensions") {
          const s2 = [];
          return e2[r2].forEach((e3) => {
            t2[r2].some((t3, r3) => {
              if (e3.entry === t3.entry && e3.extensionName === t3.extensionName)
                return s2.push(r3), true;
            }) ? o2[r2].push(e3) : i2[r2].push(e3);
          }), void t2[r2].forEach((e3, t3) => {
            s2.indexOf(t3) === -1 && n2[r2].push(e3);
          });
        }
        if (r2 === "videoCodecs" || r2 === "audioCodecs") {
          const s2 = [];
          return e2[r2].forEach((e3) => {
            t2[r2].some((t3, r3) => {
              if (e3.payloadType === t3.payloadType && JSON.stringify(e3) === JSON.stringify(t3))
                return s2.push(r3), true;
            }) ? o2[r2].push(e3) : i2[r2].push(e3);
          }), void t2[r2].forEach((e3, t3) => {
            s2.indexOf(t3) === -1 && n2[r2].push(e3);
          });
        }
      }
      function YZ(e2) {
        const { send: t2, recv: r2, sendrecv: i2 } = e2;
        if (!i2) {
          if (!t2 || !r2)
            throw new Error("cannot merge rtp capabilities because one of send or recv is empty!");
          return { send: t2, recv: r2 };
        }
        let n2, o2;
        return t2 ? (n2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, n2.audioCodecs = [...t2.audioCodecs, ...i2.audioCodecs], n2.videoCodecs = [...t2.videoCodecs, ...i2.videoCodecs], n2.audioExtensions = [...t2.audioExtensions, ...i2.audioExtensions], n2.videoExtensions = [...t2.videoExtensions, ...i2.videoExtensions]) : n2 = i2, r2 ? (o2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, o2.audioCodecs = [...r2.audioCodecs, ...i2.audioCodecs], o2.videoCodecs = [...r2.videoCodecs, ...i2.videoCodecs], o2.audioExtensions = [...r2.audioExtensions, ...i2.audioExtensions], o2.videoExtensions = [...r2.videoExtensions, ...i2.videoExtensions]) : o2 = i2, { send: n2, recv: o2 };
      }
      !function(e2, t2) {
        e2.exports = (() => {
          var e3 = { 8: (e4, t4, r3) => {
            r3.r(t4), r3.d(t4, { Parser: () => v2, Printer: () => w2, parse: () => D2, print: () => L2 });
            const i2 = "\n", n2 = "".concat("\r").concat(i2), o2 = " ";
            let s2;
            function a2(e5) {
              return e5 >= "0" && e5 <= "9";
            }
            function c2(e5) {
              return e5 >= "!" && e5 <= "~";
            }
            function d2(e5) {
              return c2(e5) || e5 >= "\x80" && e5 <= "\xFF";
            }
            function u2(e5) {
              return e5 === "!" || e5 >= "#" && e5 <= "'" || e5 >= "*" && e5 <= "+" || e5 >= "-" && e5 <= "." || e5 >= "0" && e5 <= "9" || e5 >= "A" && e5 <= "Z" || e5 >= "^" && e5 <= "~";
            }
            function A2(e5) {
              return e5 >= "1" && e5 <= "9";
            }
            function h2(e5) {
              return e5 >= "A" && e5 <= "Z" || e5 >= "a" && e5 <= "z";
            }
            function l2(e5) {
              return e5 === "d" || e5 === "h" || e5 === "m" || e5 === "s";
            }
            function p2(e5) {
              return e5 > "" && e5 < "	" || e5 > "\v" && e5 < "\f" || e5 > "" && e5 < "\xFF";
            }
            function g2(e5) {
              return h2(e5) || a2(e5) || e5 === "+" || e5 === "/";
            }
            function f2(e5) {
              return a2(e5) || h2(e5) || e5 === "+" || e5 === "/" || e5 === "-" || e5 === "_";
            }
            function E2(e5) {
              return h2(e5) || a2(e5) || e5 === "+" || e5 === "/";
            }
            function I2(e5, t5) {
              var r4 = Object.keys(e5);
              if (Object.getOwnPropertySymbols) {
                var i3 = Object.getOwnPropertySymbols(e5);
                t5 && (i3 = i3.filter(function(t6) {
                  return Object.getOwnPropertyDescriptor(e5, t6).enumerable;
                })), r4.push.apply(r4, i3);
              }
              return r4;
            }
            function m2(e5) {
              for (var t5 = 1; t5 < arguments.length; t5++) {
                var r4 = arguments[t5] != null ? arguments[t5] : {};
                t5 % 2 ? I2(Object(r4), true).forEach(function(t6) {
                  _2(e5, t6, r4[t6]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(r4)) : I2(Object(r4)).forEach(function(t6) {
                  Object.defineProperty(e5, t6, Object.getOwnPropertyDescriptor(r4, t6));
                });
              }
              return e5;
            }
            function _2(e5, t5, r4) {
              return t5 in e5 ? Object.defineProperty(e5, t5, { value: r4, enumerable: true, configurable: true, writable: true }) : e5[t5] = r4, e5;
            }
            !function(e5) {
              e5.VERSION = "v", e5.ORIGIN = "o", e5.SESSION_NAME = "s", e5.INFORMATION = "i", e5.URI = "u", e5.EMAIL = "e", e5.PHONE = "p", e5.CONNECTION = "c", e5.BANDWIDTH = "b", e5.TIME = "t", e5.REPEAT = "r", e5.ZONE_ADJUSTMENTS = "z", e5.KEY = "k", e5.ATTRIBUTE = "a", e5.MEDIA = "m";
            }(s2 || (s2 = {}));
            class C2 {
              consumeText(e5, t5) {
                let r4 = t5;
                for (; r4 < e5.length; ) {
                  const t6 = e5[r4];
                  if (t6 === "\0" || t6 === "\r" || t6 === i2)
                    break;
                  r4 += 1;
                }
                if (r4 - t5 == 0)
                  throw new Error("Invalid text, at ".concat(e5));
                return r4;
              }
              consumeUnicastAddress(e5, t5, r4) {
                return this.consumeTill(e5, t5, o2);
              }
              consumeOneOrMore(e5, t5, r4) {
                let i3 = t5;
                for (; r4(e5[i3]); )
                  i3++;
                if (i3 - t5 == 0)
                  throw new Error("Invalid rule at ".concat(t5, "."));
                return i3;
              }
              consumeSpace(e5, t5) {
                if (e5[t5] === o2)
                  return t5 + 1;
                throw new Error("Invalid space at ".concat(t5, "."));
              }
              consumeIP4Address(e5, t5) {
                let r4 = t5;
                for (let t6 = 0; t6 < 4; t6++)
                  if (r4 = this.consumeDecimalUChar(e5, r4), t6 !== 3) {
                    if (e5[r4] !== ".")
                      throw new Error("Invalid IP4 address.");
                    r4++;
                  }
                return r4;
              }
              consumeDecimalUChar(e5, t5) {
                let r4 = t5;
                for (let t6 = 0; t6 < 3 && a2(e5[r4]); t6++, r4++)
                  ;
                if (r4 - t5 == 0)
                  throw new Error("Invalid decimal uchar.");
                const i3 = parseInt(e5.slice(t5, r4));
                if (i3 >= 0 && i3 <= 255)
                  return r4;
                throw new Error("Invalid decimal uchar");
              }
              consumeIP6Address(e5, t5) {
                let r4 = this.consumeHexpart(e5, t5);
                return e5[r4] === ":" ? (r4 += 1, r4 = this.consumeIP4Address(e5, r4), r4) : r4;
              }
              consumeHexpart(e5, t5) {
                let r4 = t5;
                if (e5[r4] === ":" && e5[r4 + 1] === ":") {
                  r4 += 2;
                  try {
                    r4 = this.consumeHexseq(e5, r4);
                  } catch (e6) {
                  }
                  return r4;
                }
                if (r4 = this.consumeHexseq(e5, r4), e5[r4] === ":" && e5[r4 + 1] === ":") {
                  r4 += 2;
                  try {
                    r4 = this.consumeHexseq(e5, r4);
                  } catch (e6) {
                  }
                  return r4;
                }
                return r4;
              }
              consumeHexseq(e5, t5) {
                let r4 = t5;
                for (; r4 = this.consumeHex4(e5, r4), e5[r4] === ":" && e5[r4 + 1] !== ":"; )
                  r4 += 1;
                return r4;
              }
              consumeHex4(e5, t5) {
                let r4 = 0;
                for (; r4 < 4; r4++)
                  if (!((i3 = e5[t5 + r4]) >= "0" && i3 <= "9" || i3 >= "a" && i3 <= "f" || i3 >= "A" && i3 <= "F")) {
                    if (r4 === 0)
                      throw new Error("Invalid hex 4");
                    break;
                  }
                var i3;
                return t5 + r4;
              }
              consumeFQDN(e5, t5) {
                let r4 = t5;
                for (; a2(e5[r4]) || h2(e5[r4]) || e5[r4] === "-" || e5[r4] === "."; )
                  r4 += 1;
                if (r4 - t5 < 4)
                  throw new Error("Invalid FQDN");
                return r4;
              }
              consumeExtnAddr(e5, t5) {
                return this.consumeOneOrMore(e5, t5, d2);
              }
              consumeMulticastAddress(e5, t5, r4) {
                switch (r4) {
                  case "IP4":
                  case "ip4":
                    return this.consumeIP4MulticastAddress(e5, t5);
                  case "IP6":
                  case "ip6":
                    return this.consumeIP6MulticastAddress(e5, t5);
                  default:
                    try {
                      return this.consumeFQDN(e5, t5);
                    } catch (r5) {
                      return this.consumeExtnAddr(e5, t5);
                    }
                }
              }
              consumeIP6MulticastAddress(e5, t5) {
                const r4 = this.consumeHexpart(e5, t5);
                return e5[r4] === "/" ? this.consumeInteger(e5, r4 + 1) : r4;
              }
              consumeIP4MulticastAddress(e5, t5) {
                let r4 = t5 + 3;
                const i3 = e5.slice(t5, r4), n3 = parseInt(i3);
                if (n3 < 224 || n3 > 239)
                  throw new Error("Invalid IP4 multicast address, IPv4 multicast addresses may be in the range 224.0.0.0 to 239.255.255.255.");
                for (let t6 = 0; t6 < 3; t6++) {
                  if (e5[r4] !== ".")
                    throw new Error("Invalid IP4 multicast address.");
                  r4 += 1, r4 = this.consumeDecimalUChar(e5, r4);
                }
                return e5[r4] === "/" && (r4 += 1), r4 = this.consumeTTL(e5, r4), e5[r4] === "/" && (r4 = this.consumeInteger(e5, r4)), r4;
              }
              consumeInteger(e5, t5) {
                if (!A2(e5[t5]))
                  throw new Error("Invalid integer.");
                for (t5 += 1; a2(e5[t5]); )
                  t5 += 1;
                return t5;
              }
              consumeTTL(e5, t5) {
                if (e5[t5] === "0")
                  return t5 + 1;
                if (!A2(e5[t5]))
                  throw new Error("Invalid TTL.");
                t5 += 1;
                for (let r4 = 0; r4 < 2 && a2(e5[t5]); r4++)
                  t5 += 1;
                return t5;
              }
              consumeToken(e5, t5) {
                return this.consumeOneOrMore(e5, t5, u2);
              }
              consumeTime(e5, t5) {
                let r4 = t5;
                if (e5[r4] === "0")
                  return r4 + 1;
                for (A2(e5[r4]) && (r4 += 1); a2(e5[r4]); )
                  r4++;
                if (r4 - t5 < 10)
                  throw new Error("Invalid time");
                return r4;
              }
              consumeAddress(e5, t5) {
                return this.consumeTill(e5, t5, o2);
              }
              consumeTypedTime(e5, t5) {
                let r4 = t5;
                return r4 = this.consumeOneOrMore(e5, r4, a2), l2(e5[r4]) ? r4 + 1 : r4;
              }
              consumeRepeatInterval(e5, t5) {
                if (!A2(e5[t5]))
                  throw new Error("Invalid repeat interval");
                for (t5 += 1; a2(e5[t5]); )
                  t5 += 1;
                return l2(e5[t5]) && (t5 += 1), t5;
              }
              consumePort(e5, t5) {
                return this.consumeOneOrMore(e5, t5, a2);
              }
              consume(e5, t5, r4) {
                for (let i3 = 0; i3 < r4.length; i3++) {
                  if (t5 + i3 >= e5.length)
                    throw new Error("consume exceeding value length");
                  if (e5[t5 + i3] !== r4[i3])
                    throw new Error("consume ".concat(r4, " failed at ").concat(i3));
                }
                return t5 + r4.length;
              }
              consumeTill(e5, t5, r4) {
                let i3 = t5;
                for (; i3 < e5.length && (typeof r4 != "string" || e5[i3] !== r4) && (typeof r4 != "function" || !r4(e5[i3])); )
                  i3++;
                return i3;
              }
            }
            class v2 extends C2 {
              constructor() {
                super(), _2(this, "records", []), _2(this, "currentLine", 0);
              }
              parse(e5) {
                const t5 = this.probeEOL(e5);
                this.records = e5.split(t5).filter((e6) => !!e6.trim()).map(this.parseLine), this.currentLine = 0;
                const r4 = this.parseVersion(), i3 = this.parseOrigin(), n3 = this.parseSessionName(), o3 = this.parseInformation(), s3 = this.parseUri(), a3 = this.parseEmail(), c3 = this.parsePhone(), d3 = this.parseConnection(), u3 = this.parseBandWidth(), A3 = this.parseTimeFields(), h3 = this.parseKey(), l3 = this.parseSessionAttribute(), p3 = this.parseMediaDescription();
                if (this.currentLine !== this.records.length)
                  throw new Error("parsing failed, non exhaustive sdp lines.");
                return { version: r4, origin: i3, sessionName: n3, information: o3, uri: s3, emails: a3, phones: c3, connection: d3, bandwidths: u3, timeFields: A3, key: h3, attributes: l3, mediaDescriptions: p3 };
              }
              getCurrentRecord() {
                const e5 = this.records[this.currentLine];
                if (!e5)
                  throw new Error("Record doesn't exit.");
                return e5;
              }
              probeEOL(e5) {
                for (let t5 = 0; t5 < e5.length; t5++)
                  if (e5[t5] === i2)
                    return e5[t5 - 1] === "\r" ? n2 : i2;
                throw new Error("Invalid newline character.");
              }
              parseLine(e5, t5) {
                if (e5.length < 2)
                  throw new Error("Invalid sdp line, sdp line should be of form <type>=<value>.");
                const r4 = e5[0];
                if (e5[1] !== "=")
                  throw new Error('Invalid sdp line, <type> should be a single character followed by an "=" sign.');
                return { type: r4, value: e5.slice(2), line: t5, cur: 0 };
              }
              parseSessionAttribute() {
                const e5 = new R2();
                for (; this.currentLine < this.records.length; ) {
                  const t5 = this.getCurrentRecord();
                  if (t5.type !== s2.ATTRIBUTE)
                    break;
                  const r4 = { attField: this.extractOneOrMore(t5, (e6) => u2(e6) && e6 !== ":"), _cur: 0 };
                  t5.value[t5.cur] === ":" && (t5.cur += 1, r4.attValue = this.extractOneOrMore(t5, p2)), e5.parse(r4), this.currentLine++;
                }
                return e5.digest();
              }
              parseMediaAttributes(e5) {
                const t5 = new y2(e5);
                for (; this.currentLine < this.records.length; ) {
                  const e6 = this.getCurrentRecord();
                  if (e6.type !== s2.ATTRIBUTE)
                    break;
                  const r4 = { attField: this.extractOneOrMore(e6, (e7) => u2(e7) && e7 !== ":"), _cur: 0 };
                  e6.value[e6.cur] === ":" && (e6.cur += 1, r4.attValue = this.extractOneOrMore(e6, p2)), t5.parse(r4), this.currentLine++;
                }
                return t5.digest();
              }
              parseKey() {
                const e5 = this.getCurrentRecord();
                if (e5.type === s2.KEY) {
                  if (e5.value === "prompt" || e5.value === "clear:" || e5.value === "base64:" || e5.value === "uri:")
                    return e5.value;
                  throw this.currentLine++, new Error("Invalid key.");
                }
              }
              parseZone() {
                const e5 = this.getCurrentRecord();
                if (e5.type === s2.ZONE_ADJUSTMENTS) {
                  const t5 = [];
                  for (; ; )
                    try {
                      const r4 = this.extract(e5, this.consumeTime);
                      this.consumeSpaceForRecord(e5);
                      let i3 = false;
                      e5.value[e5.cur] === "-" && (i3 = true, e5.cur += 1);
                      const n3 = this.extract(e5, this.consumeTypedTime);
                      t5.push({ time: r4, typedTime: n3, back: i3 });
                    } catch (e6) {
                      break;
                    }
                  if (t5.length === 0)
                    throw new Error("Invalid zone adjustments");
                  return this.currentLine++, t5;
                }
                return [];
              }
              parseRepeat() {
                const e5 = [];
                for (; ; ) {
                  const t5 = this.getCurrentRecord();
                  if (t5.type !== s2.REPEAT)
                    break;
                  {
                    const r4 = this.extract(t5, this.consumeRepeatInterval), i3 = this.parseTypedTime(t5);
                    e5.push({ repeatInterval: r4, typedTimes: i3 }), this.currentLine++;
                  }
                }
                return e5;
              }
              parseTypedTime(e5) {
                const t5 = [];
                for (; ; )
                  try {
                    this.consumeSpaceForRecord(e5), t5.push(this.extract(e5, this.consumeTypedTime));
                  } catch (e6) {
                    break;
                  }
                if (t5.length === 0)
                  throw new Error("Invalid typed time.");
                return t5;
              }
              parseTime() {
                const e5 = this.getCurrentRecord(), t5 = this.extract(e5, this.consumeTime);
                this.consumeSpaceForRecord(e5);
                const r4 = this.extract(e5, this.consumeTime);
                return this.currentLine++, { startTime: t5, stopTime: r4 };
              }
              parseBandWidth() {
                const e5 = [];
                for (; this.currentLine < this.records.length; ) {
                  const t5 = this.getCurrentRecord();
                  if (t5.type !== s2.BANDWIDTH)
                    break;
                  {
                    const r4 = this.extractOneOrMore(t5, u2);
                    if (t5.value[t5.cur] !== ":")
                      throw new Error("Invalid bandwidth field.");
                    t5.cur++;
                    const i3 = this.extractOneOrMore(t5, a2);
                    e5.push({ bwtype: r4, bandwidth: i3 }), this.currentLine++;
                  }
                }
                return e5;
              }
              parseVersion() {
                const e5 = this.getCurrentRecord();
                if (e5.type !== s2.VERSION)
                  throw new Error("first sdp record must be version");
                const t5 = e5.value.slice(0, this.consumeOneOrMore(e5.value, 0, a2));
                if (t5.length !== e5.value.length)
                  throw new Error('invalid proto version, "v='.concat(e5.value, '"'));
                return this.currentLine++, t5;
              }
              parseOrigin() {
                const e5 = this.getCurrentRecord();
                if (e5.type !== s2.ORIGIN)
                  throw new Error("second line of sdp must be origin");
                const t5 = this.extractOneOrMore(e5, d2);
                this.consumeSpaceForRecord(e5);
                const r4 = this.extractOneOrMore(e5, a2);
                this.consumeSpaceForRecord(e5);
                const i3 = this.extractOneOrMore(e5, a2);
                this.consumeSpaceForRecord(e5);
                const n3 = this.extractOneOrMore(e5, u2);
                this.consumeSpaceForRecord(e5);
                const o3 = this.extractOneOrMore(e5, u2);
                this.consumeSpaceForRecord(e5);
                const c3 = this.extract(e5, this.consumeUnicastAddress);
                return this.currentLine++, { username: t5, sessId: r4, sessVersion: i3, nettype: n3, addrtype: o3, unicastAddress: c3 };
              }
              parseSessionName() {
                const e5 = this.getCurrentRecord();
                if (e5.type === s2.SESSION_NAME) {
                  const t5 = this.extract(e5, this.consumeText);
                  return this.currentLine++, t5;
                }
              }
              parseInformation() {
                const e5 = this.getCurrentRecord();
                if (e5.type !== s2.INFORMATION)
                  return;
                const t5 = this.extract(e5, this.consumeText);
                return this.currentLine++, t5;
              }
              parseUri() {
                const e5 = this.getCurrentRecord();
                if (e5.type === s2.URI)
                  return this.currentLine++, e5.value;
              }
              parseEmail() {
                const e5 = [];
                for (; ; ) {
                  const t5 = this.getCurrentRecord();
                  if (t5.type !== s2.EMAIL)
                    break;
                  e5.push(t5.value), this.currentLine++;
                }
                return e5;
              }
              parsePhone() {
                const e5 = [];
                for (; ; ) {
                  const t5 = this.getCurrentRecord();
                  if (t5.type !== s2.PHONE)
                    break;
                  e5.push(t5.value), this.currentLine++;
                }
                return e5;
              }
              parseConnection() {
                const e5 = this.getCurrentRecord();
                if (e5.type === s2.CONNECTION) {
                  const t5 = this.extractOneOrMore(e5, u2);
                  this.consumeSpaceForRecord(e5);
                  const r4 = this.extractOneOrMore(e5, u2);
                  this.consumeSpaceForRecord(e5);
                  const i3 = this.extract(e5, this.consumeAddress);
                  return this.currentLine++, { nettype: t5, addrtype: r4, address: i3 };
                }
              }
              parseMedia() {
                const e5 = this.getCurrentRecord(), t5 = this.extract(e5, this.consumeToken);
                this.consumeSpaceForRecord(e5);
                let r4 = this.extract(e5, this.consumePort);
                e5.value[e5.cur] === "/" && (e5.cur += 1, r4 += this.extract(e5, this.consumeInteger)), this.consumeSpaceForRecord(e5);
                const i3 = [];
                for (i3.push(this.extract(e5, this.consumeToken)); e5.value[e5.cur] === "/"; )
                  e5.cur += 1, i3.push(this.extract(e5, this.consumeToken));
                if (i3.length === 0)
                  throw new Error("Invalid proto");
                const n3 = this.parseFmt(e5);
                return this.currentLine++, { mediaType: t5, port: r4, protos: i3, fmts: n3 };
              }
              parseTimeFields() {
                const e5 = [];
                for (; this.getCurrentRecord().type === s2.TIME; ) {
                  const t5 = this.parseTime(), r4 = this.parseRepeat(), i3 = this.parseZone();
                  e5.push({ time: t5, repeats: r4, zones: i3 });
                }
                return e5;
              }
              parseMediaDescription() {
                const e5 = [];
                for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s2.MEDIA; ) {
                  const t5 = this.parseMedia(), r4 = this.parseInformation(), i3 = this.parseConnections(), n3 = this.parseBandWidth(), o3 = this.parseKey(), s3 = this.parseMediaAttributes(t5);
                  e5.push({ media: t5, information: r4, connections: i3, bandwidths: n3, key: o3, attributes: s3 });
                }
                return e5;
              }
              parseConnections() {
                const e5 = [];
                for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s2.CONNECTION; )
                  e5.push(this.parseConnection());
                return e5;
              }
              parseFmt(e5) {
                const t5 = [];
                for (; ; )
                  try {
                    this.consumeSpaceForRecord(e5), t5.push(this.extract(e5, this.consumeToken));
                  } catch (e6) {
                    break;
                  }
                if (t5.length === 0)
                  throw new Error("Invalid fmts");
                return t5;
              }
              extract(e5, t5, ...r4) {
                const i3 = t5.call(this, e5.value, e5.cur, ...r4), n3 = e5.value.slice(e5.cur, i3);
                return e5.cur = i3, n3;
              }
              extractOneOrMore(e5, t5) {
                const r4 = this.consumeOneOrMore(e5.value, e5.cur, t5), i3 = e5.value.slice(e5.cur, r4);
                return e5.cur = r4, i3;
              }
              consumeSpaceForRecord(e5) {
                if (e5.value[e5.cur] !== o2)
                  throw new Error("Invalid space at ".concat(e5.cur, "."));
                e5.cur += 1;
              }
            }
            class S2 extends C2 {
              constructor(...e5) {
                super(...e5), _2(this, "attributes", void 0), _2(this, "digested", false);
              }
              extractOneOrMore(e5, t5, r4) {
                const i3 = this.consumeOneOrMore(e5.attValue, e5._cur, t5), n3 = e5.attValue.slice(e5._cur, i3), [o3, s3] = r4 || [];
                if (typeof o3 == "number" && n3.length < o3)
                  throw new Error("error in length, should be more or equal than ".concat(o3, " characters."));
                if (typeof s3 == "number" && n3.length > s3)
                  throw new Error("error in length, should be less or equal than ".concat(s3, " characters."));
                return e5._cur = i3, n3;
              }
              consumeAttributeSpace(e5) {
                if (e5.attValue[e5._cur] !== o2)
                  throw new Error("Invalid space at ".concat(e5._cur, "."));
                e5._cur += 1;
              }
              extract(e5, t5, ...r4) {
                if (!e5.attValue)
                  throw new Error("Nothing to extract from attValue.");
                const i3 = t5.call(this, e5.attValue, e5._cur, ...r4), n3 = e5.attValue.slice(e5._cur, i3);
                return e5._cur = i3, n3;
              }
              atEnd(e5) {
                if (!e5.attValue)
                  throw new Error();
                return e5._cur >= e5.attValue.length;
              }
              peekChar(e5) {
                if (!e5.attValue)
                  throw new Error();
                return e5.attValue[e5._cur];
              }
              peek(e5, t5) {
                if (!e5.attValue)
                  throw new Error();
                for (let r4 = 0; r4 < t5.length; r4++)
                  if (t5[r4] !== e5.attValue[e5._cur + r4])
                    return false;
                return true;
              }
              parseIceUfrag(e5) {
                if (this.attributes.iceUfrag)
                  throw new Error("Invalid ice-ufrag, should be only a single line if 'a=ice-ufrag'");
                this.attributes.iceUfrag = this.extractOneOrMore(e5, g2, [4, 256]);
              }
              parseIcePwd(e5) {
                if (this.attributes.icePwd)
                  throw new Error("Invalid ice-pwd, should be only a single line if 'a=ice-pwd'");
                this.attributes.icePwd = this.extractOneOrMore(e5, g2, [22, 256]);
              }
              parseIceOptions(e5) {
                if (this.attributes.iceOptions)
                  throw new Error("Invalid ice-options, should be only one 'ice-options' line");
                const t5 = [];
                for (; !this.atEnd(e5); ) {
                  t5.push(this.extractOneOrMore(e5, g2));
                  try {
                    this.consumeAttributeSpace(e5);
                  } catch (t6) {
                    if (this.atEnd(e5))
                      break;
                    throw t6;
                  }
                }
                this.attributes.iceOptions = t5;
              }
              parseFingerprint(e5) {
                const t5 = this.extract(e5, this.consumeToken);
                this.consumeAttributeSpace(e5);
                const r4 = this.extract(e5, this.consumeTill);
                this.attributes.fingerprints.push({ hashFunction: t5, fingerprint: r4 });
              }
              parseExtmap(e5) {
                const t5 = this.extractOneOrMore(e5, a2);
                let r4;
                this.peekChar(e5) === "/" && (this.extract(e5, this.consume, "/"), r4 = this.extract(e5, this.consumeToken)), this.consumeAttributeSpace(e5);
                const i3 = this.extract(e5, this.consumeTill, o2), n3 = m2(m2({ entry: parseInt(t5, 10) }, r4 && { direction: r4 }), {}, { extensionName: i3 });
                this.peekChar(e5) === o2 && (this.consumeAttributeSpace(e5), n3.extensionAttributes = this.extract(e5, this.consumeTill)), this.attributes.extmaps.push(n3);
              }
              parseSetup(e5) {
                if (this.attributes.setup)
                  throw new Error("must only be one single 'a=setup' line.");
                const t5 = this.extract(e5, this.consumeTill);
                if (t5 !== "active" && t5 !== "passive" && t5 !== "actpass" && t5 !== "holdconn")
                  throw new Error("role must be one of 'active', 'passive', 'actpass', 'holdconn'.");
                this.attributes.setup = t5;
              }
            }
            class R2 extends S2 {
              constructor(...e5) {
                super(...e5), _2(this, "attributes", { unrecognized: [], groups: [], extmaps: [], fingerprints: [], identities: [] });
              }
              parse(e5) {
                if (this.digested)
                  throw new Error("already digested");
                try {
                  switch (e5.attField) {
                    case "group":
                      this.parseGroup(e5);
                      break;
                    case "ice-lite":
                      this.parseIceLite();
                      break;
                    case "ice-ufrag":
                      this.parseIceUfrag(e5);
                      break;
                    case "ice-pwd":
                      this.parseIcePwd(e5);
                      break;
                    case "ice-options":
                      this.parseIceOptions(e5);
                      break;
                    case "fingerprint":
                      this.parseFingerprint(e5);
                      break;
                    case "setup":
                      this.parseSetup(e5);
                      break;
                    case "tls-id":
                      this.parseTlsId(e5);
                      break;
                    case "identity":
                      this.parseIdentity(e5);
                      break;
                    case "extmap":
                      this.parseExtmap(e5);
                      break;
                    case "msid-semantic":
                      this.parseMsidSemantic(e5);
                      break;
                    default:
                      e5.ignored = true, this.attributes.unrecognized.push(e5);
                  }
                } catch (t5) {
                  throw console.error("parsing session attribute ".concat(e5.attField, ' error, "a=').concat(e5.attField, ":").concat(e5.attValue, '"')), t5;
                }
                if (!e5.ignored && e5.attValue && !this.atEnd(e5))
                  throw new Error("attribute parsing error");
              }
              digest() {
                return this.digested = true, this.attributes;
              }
              parseGroup(e5) {
                const t5 = this.extract(e5, this.consumeToken), r4 = [];
                for (; !this.atEnd(e5) && this.peekChar(e5) === o2; )
                  this.consumeAttributeSpace(e5), r4.push(this.extract(e5, this.consumeToken));
                this.attributes.groups.push({ semantic: t5, identificationTag: r4 });
              }
              parseIceLite() {
                if (this.attributes.iceLite)
                  throw new Error("Invalid ice-lite, should be only a single line of 'a=ice-lite'");
                this.attributes.iceLite = true;
              }
              parseTlsId(e5) {
                if (this.attributes.tlsId)
                  throw new Error("must be only one tld-id line");
                this.attributes.tlsId = this.extractOneOrMore(e5, f2);
              }
              parseIdentity(e5) {
                const t5 = this.extractOneOrMore(e5, E2), r4 = [];
                for (; !this.atEnd(e5) && this.peekChar(e5) === o2; ) {
                  this.consumeAttributeSpace(e5);
                  const t6 = this.extract(e5, this.consumeToken);
                  this.extract(e5, this.consume, "=");
                  const i3 = this.extractOneOrMore(e5, (e6) => e6 !== o2 && p2(e6));
                  r4.push({ name: t6, value: i3 });
                }
                this.attributes.identities.push({ assertionValue: t5, extensions: r4 });
              }
              parseMsidSemantic(e5) {
                this.peekChar(e5) === o2 && this.consumeAttributeSpace(e5);
                const t5 = { semantic: this.extract(e5, this.consumeToken), identifierList: [] };
                for (; ; ) {
                  try {
                    this.consumeAttributeSpace(e5);
                  } catch (e6) {
                    break;
                  }
                  if (this.peekChar(e5) === "*") {
                    this.extract(e5, this.consume, "*"), t5.applyForAll = true;
                    break;
                  }
                  {
                    const r4 = this.extract(e5, this.consumeTill, o2);
                    t5.identifierList.push(r4);
                  }
                }
                this.attributes.msidSemantic = t5;
              }
            }
            class y2 extends S2 {
              constructor(e5) {
                super(), _2(this, "attributes", void 0), e5.protos.indexOf("RTP") !== -1 || e5.protos.indexOf("rtp"), this.attributes = { unrecognized: [], candidates: [], extmaps: [], fingerprints: [], imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: [], ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: [] };
              }
              parse(e5) {
                if (this.digested)
                  throw new Error("already digested");
                try {
                  switch (e5.attField) {
                    case "extmap":
                      this.parseExtmap(e5);
                      break;
                    case "setup":
                      this.parseSetup(e5);
                      break;
                    case "ice-ufrag":
                      this.parseIceUfrag(e5);
                      break;
                    case "ice-pwd":
                      this.parseIcePwd(e5);
                      break;
                    case "ice-options":
                      this.parseIceOptions(e5);
                      break;
                    case "candidate":
                      this.parseCandidate(e5);
                      break;
                    case "remote-candidate":
                      this.parseRemoteCandidate(e5);
                      break;
                    case "end-of-candidates":
                      this.parseEndOfCandidates();
                      break;
                    case "fingerprint":
                      this.parseFingerprint(e5);
                      break;
                    case "rtpmap":
                      this.parseRtpmap(e5);
                      break;
                    case "ptime":
                      this.parsePtime(e5);
                      break;
                    case "maxptime":
                      this.parseMaxPtime(e5);
                      break;
                    case "sendrecv":
                    case "recvonly":
                    case "sendonly":
                    case "inactive":
                      this.parseDirection(e5);
                      break;
                    case "ssrc":
                      this.parseSSRC(e5);
                      break;
                    case "fmtp":
                      this.parseFmtp(e5);
                      break;
                    case "rtcp-fb":
                      this.parseRtcpFb(e5);
                      break;
                    case "rtcp-mux":
                      this.parseRTCPMux();
                      break;
                    case "rtcp-mux-only":
                      this.parseRTCPMuxOnly();
                      break;
                    case "rtcp-rsize":
                      this.parseRTCPRsize();
                      break;
                    case "rtcp":
                      this.parseRTCP(e5);
                      break;
                    case "mid":
                      this.parseMid(e5);
                      break;
                    case "msid":
                      this.parseMsid(e5);
                      break;
                    case "imageattr":
                      this.parseImageAttr(e5);
                      break;
                    case "rid":
                      this.parseRid(e5);
                      break;
                    case "simulcast":
                      this.parseSimulcast(e5);
                      break;
                    case "sctp-port":
                      this.parseSctpPort(e5);
                      break;
                    case "max-message-size":
                      this.parseMaxMessageSize(e5);
                      break;
                    case "ssrc-group":
                      this.parseSSRCGroup(e5);
                      break;
                    default:
                      e5.ignored = true, this.attributes.unrecognized.push(e5);
                  }
                } catch (t5) {
                  throw console.error("parsing media attribute ".concat(e5.attField, ' error, "a=').concat(e5.attField, ":").concat(e5.attValue, '"')), t5;
                }
                if (!e5.ignored && e5.attValue && !this.atEnd(e5))
                  throw new Error("attribute parsing error");
              }
              parseCandidate(e5) {
                const t5 = this.extractOneOrMore(e5, g2, [1, 32]);
                this.consumeAttributeSpace(e5);
                const r4 = this.extractOneOrMore(e5, a2, [1, 5]);
                this.consumeAttributeSpace(e5);
                const i3 = this.extract(e5, this.consumeToken);
                this.consumeAttributeSpace(e5);
                const n3 = this.extractOneOrMore(e5, a2, [1, 10]);
                this.consumeAttributeSpace(e5);
                const s3 = this.extract(e5, this.consumeAddress);
                this.consumeAttributeSpace(e5);
                const d3 = this.extract(e5, this.consumePort);
                this.consumeAttributeSpace(e5), this.extract(e5, this.consume, "typ"), this.consumeAttributeSpace(e5);
                const u3 = { foundation: t5, componentId: r4, transport: i3, priority: n3, connectionAddress: s3, port: d3, type: this.extract(e5, this.consumeToken), extension: {} };
                for (this.peek(e5, " raddr") && (this.extract(e5, this.consume, " raddr"), this.consumeAttributeSpace(e5), u3.relAddr = this.extract(e5, this.consumeAddress)), this.peek(e5, " rport") && (this.extract(e5, this.consume, " rport"), this.consumeAttributeSpace(e5), u3.relPort = this.extract(e5, this.consumePort)); this.peekChar(e5) === o2; ) {
                  this.consumeAttributeSpace(e5);
                  const t6 = this.extract(e5, this.consumeToken);
                  this.consumeAttributeSpace(e5), u3.extension[t6] = this.extractOneOrMore(e5, c2);
                }
                this.attributes.candidates.push(u3);
              }
              parseRemoteCandidate(e5) {
                const t5 = [];
                for (; ; ) {
                  const r4 = this.extractOneOrMore(e5, a2, [1, 5]);
                  this.consumeAttributeSpace(e5);
                  const i3 = this.extract(e5, this.consumeAddress);
                  this.consumeAttributeSpace(e5);
                  const n3 = this.extract(e5, this.consumePort);
                  t5.push({ componentId: r4, connectionAddress: i3, port: n3 });
                  try {
                    this.consumeAttributeSpace(e5);
                  } catch (e6) {
                    break;
                  }
                }
                this.attributes.remoteCandidatesList.push(t5);
              }
              parseEndOfCandidates() {
                if (this.attributes.endOfCandidates)
                  throw new Error("must be only one line of end-of-candidates");
                this.attributes.endOfCandidates = true;
              }
              parseRtpmap(e5) {
                const t5 = this.extract(e5, this.consumeToken);
                this.consumeAttributeSpace(e5);
                const r4 = this.extract(e5, this.consumeTill, "/");
                this.extract(e5, this.consume, "/");
                const i3 = { encodingName: r4, clockRate: this.extractOneOrMore(e5, a2) };
                this.atEnd(e5) || this.peekChar(e5) !== "/" || (this.extract(e5, this.consume, "/"), i3.encodingParameters = parseInt(this.extract(e5, this.consumeTill), 10));
                const n3 = this.attributes.payloads.find((e6) => e6.payloadType === parseInt(t5, 10));
                n3 ? n3.rtpMap = i3 : this.attributes.payloads.push({ payloadType: parseInt(t5, 10), rtpMap: i3, rtcpFeedbacks: [] });
              }
              parsePtime(e5) {
                if (this.attributes.ptime)
                  throw new Error("must be only one line of ptime");
                this.attributes.ptime = this.extract(e5, this.consumeTill);
              }
              parseMaxPtime(e5) {
                if (this.attributes.maxPtime)
                  throw new Error("must be only one line of ptime");
                this.attributes.maxPtime = this.extract(e5, this.consumeTill);
              }
              parseDirection(e5) {
                if (this.attributes.direction)
                  throw new Error("must be only one line of direction info");
                this.attributes.direction = e5.attField;
              }
              parseSSRC(e5) {
                const t5 = this.extractOneOrMore(e5, a2);
                this.consumeAttributeSpace(e5);
                const r4 = this.extract(e5, this.consumeTill, ":");
                let i3;
                this.peekChar(e5) === ":" && (this.extract(e5, this.consume, ":"), i3 = this.extract(e5, this.consumeTill));
                const n3 = this.attributes.ssrcs.find((e6) => e6.ssrcId === parseInt(t5, 10));
                n3 ? n3.attributes[r4] = i3 : this.attributes.ssrcs.push({ ssrcId: parseInt(t5, 10), attributes: { [r4]: i3 } });
              }
              parseFmtp(e5) {
                const t5 = this.extract(e5, this.consumeTill, o2);
                this.consumeAttributeSpace(e5);
                const r4 = this.extract(e5, this.consumeTill), i3 = {};
                r4.split(";").forEach((e6) => {
                  let [t6, r5] = e6.split("=");
                  t6 = t6.trim(), r5 = typeof r5 == "string" ? r5.trim() : r5, typeof t6 == "string" && t6.length > 0 && (i3[t6] = r5);
                });
                const n3 = this.attributes.payloads.find((e6) => e6.payloadType === parseInt(t5, 10));
                n3 ? n3.fmtp = { parameters: i3 } : this.attributes.payloads.push({ payloadType: parseInt(t5, 10), rtcpFeedbacks: [], fmtp: { parameters: i3 } });
              }
              parseFmtParameters(e5) {
                const t5 = {}, r4 = this.extract(e5, this.consumeTill, "=");
                e5._cur++;
                const i3 = this.extract(e5, this.consumeTill, ";");
                for (t5[r4] = i3; e5.attValue[e5._cur] === ";"; ) {
                  const r5 = this.extract(e5, this.consumeTill, "=");
                  e5._cur++;
                  const i4 = this.extract(e5, this.consumeTill, ";");
                  t5[r5] = i4;
                }
                return t5;
              }
              parseRtcpFb(e5) {
                let t5 = "";
                t5 = this.peekChar(e5) === "*" ? this.extract(e5, this.consume, "*") : this.extract(e5, this.consumeTill, o2), this.consumeAttributeSpace(e5);
                const r4 = this.extract(e5, this.consumeTill, o2);
                let i3;
                switch (r4) {
                  case "trr-int":
                    i3 = { type: r4, interval: this.extract(e5, this.consumeTill) };
                    break;
                  case "ack":
                  case "nack":
                  default: {
                    const t6 = { type: r4 };
                    this.peekChar(e5) === o2 && (this.consumeAttributeSpace(e5), t6.parameter = this.extract(e5, this.consumeToken), this.peekChar(e5) === o2 && (t6.additional = this.extract(e5, this.consumeTill))), i3 = t6;
                  }
                }
                if (t5 === "*")
                  this.attributes.rtcpFeedbackWildcards.push(i3);
                else {
                  const e6 = this.attributes.payloads.find((e7) => e7.payloadType === parseInt(t5, 10));
                  e6 ? e6.rtcpFeedbacks.push(i3) : this.attributes.payloads.push({ payloadType: parseInt(t5, 10), rtcpFeedbacks: [i3] });
                }
              }
              parseRTCPMux() {
                if (this.attributes.rtcpMux)
                  throw new Error("must be single line of rtcp-mux");
                this.attributes.rtcpMux = true;
              }
              parseRTCPMuxOnly() {
                if (this.attributes.rtcpMuxOnly)
                  throw new Error("must be single line of rtcp-only");
                this.attributes.rtcpMuxOnly = true;
              }
              parseRTCPRsize() {
                if (this.attributes.rtcpRsize)
                  throw new Error("must be single line of rtcp-rsize");
                this.attributes.rtcpRsize = true;
              }
              parseRTCP(e5) {
                if (this.attributes.rtcp)
                  throw new Error("must be single line of rtcp");
                const t5 = { port: this.extract(e5, this.consumePort) };
                this.peekChar(e5) === o2 && (this.consumeAttributeSpace(e5), t5.netType = this.extractOneOrMore(e5, u2), this.consumeAttributeSpace(e5), t5.addressType = this.extractOneOrMore(e5, u2), this.consumeAttributeSpace(e5), t5.address = this.extract(e5, this.consumeAddress)), this.attributes.rtcp = t5;
              }
              parseMsid(e5) {
                const t5 = { id: this.extractOneOrMore(e5, u2, [1, 64]) };
                this.peekChar(e5) === o2 && (this.consumeAttributeSpace(e5), t5.appdata = this.extractOneOrMore(e5, u2, [1, 64])), this.attributes.msids.push(t5);
              }
              parseImageAttr(e5) {
                this.attributes.imageattr.push(e5.attValue);
              }
              parseRid(e5) {
                const t5 = this.extractOneOrMore(e5, (e6) => h2(e6) || a2(e6) || e6 === "_" || e6 === "-");
                this.consumeAttributeSpace(e5);
                const r4 = { id: t5, direction: this.extract(e5, this.consumeToken), params: [] };
                if (this.peekChar(e5) === o2) {
                  if (this.consumeAttributeSpace(e5), this.peek(e5, "pt=")) {
                    this.extract(e5, this.consume, "pt=");
                    const t6 = [];
                    for (; ; ) {
                      const r5 = this.extract(e5, this.consumeToken);
                      t6.push(r5);
                      try {
                        this.extract(e5, this.consume, ",");
                      } catch (e6) {
                        break;
                      }
                    }
                    r4.payloads = t6, this.peekChar(e5) === o2 && this.extract(e5, this.consume, o2);
                  }
                  for (; ; ) {
                    const t6 = this.extract(e5, this.consumeToken);
                    switch (t6) {
                      case "depend": {
                        const i3 = { type: t6, rids: this.extract(e5, this.consume, "=").split(",") };
                        r4.params.push(i3);
                        break;
                      }
                      case "max-width":
                      case "height-width":
                      case "max-fps":
                      case "max-fs":
                      case "max-br":
                      case "max-pps":
                      case "max-bpp":
                      default: {
                        const i3 = { type: t6 };
                        this.peekChar(e5) === "=" && (this.extract(e5, this.consume, "="), i3.val = this.extract(e5, this.consumeTill, ";")), r4.params.push(i3);
                      }
                    }
                    try {
                      this.extract(e5, this.consume, ";");
                    } catch (e6) {
                      break;
                    }
                  }
                }
                this.attributes.rids.push(r4);
              }
              parseSimulcast(e5) {
                if (this.attributes.simulcast)
                  throw new Error("must be single line of simulcast");
                this.attributes.simulcast = e5.attValue, this.extract(e5, this.consumeTill);
              }
              parseSctpPort(e5) {
                this.attributes.sctpPort = this.extractOneOrMore(e5, a2, [1, 5]);
              }
              parseMaxMessageSize(e5) {
                this.attributes.maxMessageSize = this.extractOneOrMore(e5, a2, [1, void 0]);
              }
              digest() {
                return this.digested = true, this.attributes;
              }
              parseMid(e5) {
                this.attributes.mid = this.extract(e5, this.consumeToken);
              }
              parseSSRCGroup(e5) {
                const t5 = this.extract(e5, this.consumeToken), r4 = [];
                for (; ; )
                  try {
                    this.consumeAttributeSpace(e5);
                    const t6 = this.extract(e5, this.consumeInteger);
                    r4.push(parseInt(t6, 10));
                  } catch (e6) {
                    break;
                  }
                this.attributes.ssrcGroups.push({ semantic: t5, ssrcIds: r4 });
              }
            }
            function T2(e5, t5, r4) {
              return t5 in e5 ? Object.defineProperty(e5, t5, { value: r4, enumerable: true, configurable: true, writable: true }) : e5[t5] = r4, e5;
            }
            class w2 {
              constructor() {
                T2(this, "eol", n2);
              }
              print(e5, t5) {
                let r4 = "";
                return t5 && (this.eol = t5), r4 += this.printVersion(e5.version), r4 += this.printOrigin(e5.origin), r4 += this.printSessionName(e5.sessionName), r4 += this.printInformation(e5.information), r4 += this.printUri(e5.uri), r4 += this.printEmail(e5.emails), r4 += this.printPhone(e5.phones), r4 += this.printConnection(e5.connection), r4 += this.printBandwidth(e5.bandwidths), r4 += this.printTimeFields(e5.timeFields), r4 += this.printKey(e5.key), r4 += this.printSessionAttributes(e5.attributes), r4 += this.printMediaDescription(e5.mediaDescriptions), r4;
              }
              printVersion(e5) {
                return "v=".concat(e5).concat(this.eol);
              }
              printOrigin(e5) {
                return "o=".concat(e5.username, " ").concat(e5.sessId, " ").concat(e5.sessVersion, " ").concat(e5.nettype, " ").concat(e5.addrtype, " ").concat(e5.unicastAddress).concat(this.eol);
              }
              printSessionName(e5) {
                return e5 ? "s=".concat(e5).concat(this.eol) : "";
              }
              printInformation(e5) {
                return e5 ? "i=".concat(e5).concat(this.eol) : "";
              }
              printUri(e5) {
                return e5 ? "u=".concat(e5).concat(this.eol) : "";
              }
              printEmail(e5) {
                let t5 = "";
                for (const r4 of e5)
                  t5 += "e=".concat(r4).concat(this.eol);
                return t5;
              }
              printPhone(e5) {
                let t5 = "";
                for (const r4 of e5)
                  t5 += "e=".concat(r4).concat(this.eol);
                return t5;
              }
              printConnection(e5) {
                return e5 ? "c=".concat(e5.nettype, " ").concat(e5.addrtype, " ").concat(e5.address).concat(this.eol) : "";
              }
              printBandwidth(e5) {
                let t5 = "";
                for (const r4 of e5)
                  t5 += "b=".concat(r4.bwtype, ":").concat(r4.bandwidth).concat(this.eol);
                return t5;
              }
              printTimeFields(e5) {
                let t5 = "";
                for (const r4 of e5) {
                  t5 += "t=".concat(r4.time.startTime, " ").concat(r4.time.startTime).concat(this.eol);
                  for (const e6 of r4.repeats)
                    t5 += "r=".concat(e6.repeatInterval, " ").concat(e6.typedTimes.join(" ")).concat(this.eol);
                  r4.zoneAdjustments && (t5 += "z=", t5 += "z=".concat(r4.zoneAdjustments.map((e6) => "".concat(e6.time, " ").concat(e6.back ? "-" : "", " ").concat(e6.typedTime)).join(" ")).concat(this.eol), t5 += this.eol);
                }
                return t5;
              }
              printKey(e5) {
                return e5 ? "k=".concat(e5).concat(this.eol) : "";
              }
              printAttributes(e5) {
                let t5 = "";
                for (const r4 of e5)
                  t5 += "a=".concat(r4.attField).concat(r4.attValue ? ":".concat(r4.attValue) : "").concat(this.eol);
                return t5;
              }
              printMediaDescription(e5) {
                let t5 = "";
                for (const r4 of e5)
                  t5 += this.printMedia(r4.media), t5 += this.printInformation(r4.information), t5 += this.printConnections(r4.connections), t5 += this.printBandwidth(r4.bandwidths), t5 += this.printKey(r4.key), t5 += this.printMediaAttributes(r4);
                return t5;
              }
              printConnections(e5) {
                let t5 = "";
                for (const r4 of e5)
                  t5 += this.printConnection(r4);
                return t5;
              }
              printMedia(e5) {
                return "m=".concat(e5.mediaType, " ").concat(e5.port, " ").concat(e5.protos.join("/"), " ").concat(e5.fmts.join(" ")).concat(this.eol);
              }
              printSessionAttributes(e5) {
                return new O2(this.eol).print(e5);
              }
              printMediaAttributes(e5) {
                return new N2(this.eol).print(e5);
              }
            }
            class b2 {
              constructor(e5) {
                T2(this, "eol", void 0), this.eol = e5;
              }
              printIceUfrag(e5) {
                return e5 === void 0 ? "" : "a=ice-ufrag:".concat(e5).concat(this.eol);
              }
              printIcePwd(e5) {
                return e5 === void 0 ? "" : "a=ice-pwd:".concat(e5).concat(this.eol);
              }
              printIceOptions(e5) {
                return e5 === void 0 ? "" : "a=ice-options:".concat(e5.join(o2)).concat(this.eol);
              }
              printFingerprints(e5) {
                return e5.length > 0 ? e5.map((e6) => "a=fingerprint:".concat(e6.hashFunction).concat(o2).concat(e6.fingerprint)).join(this.eol) + this.eol : "";
              }
              printExtmap(e5) {
                return e5.map((e6) => "a=extmap:".concat(e6.entry).concat(e6.direction ? "/".concat(e6.direction) : "").concat(o2).concat(e6.extensionName).concat(e6.extensionAttributes ? "".concat(o2).concat(e6.extensionAttributes) : "").concat(this.eol)).join("");
              }
              printSetup(e5) {
                return e5 === void 0 ? "" : "a=setup:".concat(e5).concat(this.eol);
              }
              printUnrecognized(e5) {
                return e5.map((e6) => "a=".concat(e6.attField).concat(e6.attValue ? ":".concat(e6.attValue) : "").concat(this.eol)).join("");
              }
            }
            class O2 extends b2 {
              print(e5) {
                let t5 = "";
                return t5 += this.printGroups(e5.groups), t5 += this.printMsidSemantic(e5.msidSemantic), t5 += this.printIceLite(e5.iceLite), t5 += this.printIceUfrag(e5.iceUfrag), t5 += this.printIcePwd(e5.icePwd), t5 += this.printIceOptions(e5.iceOptions), t5 += this.printFingerprints(e5.fingerprints), t5 += this.printSetup(e5.setup), t5 += this.printTlsId(e5.tlsId), t5 += this.printIdentity(e5.identities), t5 += this.printExtmap(e5.extmaps), t5 += this.printUnrecognized(e5.unrecognized), t5;
              }
              printGroups(e5) {
                let t5 = "";
                return e5.length > 0 && (t5 += e5.map((e6) => "a=group:".concat(e6.semantic).concat(e6.identificationTag.map((e7) => "".concat(o2).concat(e7)).join("")).concat(this.eol)).join("")), t5;
              }
              printIceLite(e5) {
                return e5 === void 0 ? "" : "a=ice-lite" + this.eol;
              }
              printTlsId(e5) {
                return e5 ? "a=tls-id:".concat(e5).concat(this.eol) : "";
              }
              printIdentity(e5) {
                return e5.length === 0 ? "" : e5.map((e6) => "a=identity:".concat(e6.assertionValue).concat(e6.extensions.map((e7) => "".concat(o2).concat(e7.name).concat(e7.value ? "=".concat(e7.value) : "")))).join(this.eol) + this.eol;
              }
              printMsidSemantic(e5) {
                if (!e5)
                  return "";
                let t5 = "a=msid-semantic:".concat(e5.semantic);
                return e5.applyForAll ? t5 += "".concat(o2, "*") : e5.identifierList.length > 0 && (t5 += e5.identifierList.map((e6) => "".concat(o2).concat(e6))), t5 + this.eol;
              }
            }
            class N2 extends b2 {
              print(e5) {
                const t5 = e5.attributes;
                let r4 = "";
                return r4 += this.printRTCP(t5.rtcp), r4 += this.printIceUfrag(t5.iceUfrag), r4 += this.printIcePwd(t5.icePwd), r4 += this.printIceOptions(t5.iceOptions), r4 += this.printCandidates(t5.candidates), r4 += this.printRemoteCandidatesList(t5.remoteCandidatesList), r4 += this.printEndOfCandidates(t5.endOfCandidates), r4 += this.printFingerprints(t5.fingerprints), r4 += this.printSetup(t5.setup), r4 += this.printMid(t5.mid), r4 += this.printExtmap(t5.extmaps), r4 += this.printRTPRelated(t5), r4 += this.printPtime(t5.ptime), r4 += this.printMaxPtime(t5.maxPtime), r4 += this.printDirection(t5.direction), r4 += this.printSSRCGroups(t5.ssrcGroups), r4 += this.printSSRC(t5.ssrcs), r4 += this.printRTCPMux(t5.rtcpMux), r4 += this.printRTCPMuxOnly(t5.rtcpMuxOnly), r4 += this.printRTCPRsize(t5.rtcpRsize), r4 += this.printMSId(t5.msids), r4 += this.printImageattr(t5.imageattr), r4 += this.printRid(t5.rids), r4 += this.printSimulcast(t5.simulcast), r4 += this.printSCRPPort(t5.sctpPort), r4 += this.printMaxMessageSize(t5.maxMessageSize), r4 += this.printUnrecognized(t5.unrecognized), r4;
              }
              printCandidates(e5) {
                return e5.map((e6) => "a=candidate:".concat(e6.foundation).concat(o2).concat(e6.componentId).concat(o2).concat(e6.transport).concat(o2).concat(e6.priority).concat(o2).concat(e6.connectionAddress).concat(o2).concat(e6.port).concat(o2, "typ").concat(o2).concat(e6.type).concat(e6.relAddr ? "".concat(o2, "raddr").concat(o2).concat(e6.relAddr) : "").concat(e6.relPort ? "".concat(o2, "rport").concat(o2).concat(e6.relPort) : "").concat(Object.keys(e6.extension).map((t5) => "".concat(o2).concat(t5).concat(o2).concat(e6.extension[t5])).join("")).concat(this.eol)).join("");
              }
              printRemoteCandidatesList(e5) {
                return e5.map((e6) => "a=remote-candidates:".concat(e6.join(o2)).concat(this.eol)).join("");
              }
              printEndOfCandidates(e5) {
                return e5 === void 0 ? "" : "a=end-of-candidates" + this.eol;
              }
              printRTPRelated(e5) {
                if (!e5.payloads)
                  return "";
                const t5 = e5.payloads;
                let r4 = "";
                r4 += e5.rtcpFeedbackWildcards.map((e6) => this.printRTCPFeedback("*", e6)).join("");
                for (const e6 of t5)
                  r4 += this.printRtpMap(e6.payloadType, e6.rtpMap), r4 += this.printFmtp(e6.payloadType, e6.fmtp), r4 += e6.rtcpFeedbacks.map((t6) => this.printRTCPFeedback(e6.payloadType, t6)).join("");
                return r4;
              }
              printFmtp(e5, t5) {
                if (!t5)
                  return "";
                const r4 = Object.keys(t5.parameters);
                return r4.length === 1 && t5.parameters[r4[0]] === void 0 ? "a=fmtp:".concat(e5).concat(o2).concat(r4[0]).concat(this.eol) : "a=fmtp:".concat(e5).concat(o2).concat(Object.keys(t5.parameters).map((e6) => "".concat(e6, "=").concat(t5.parameters[e6])).join(";")).concat(this.eol);
              }
              printRtpMap(e5, t5) {
                return t5 ? "a=rtpmap:".concat(e5).concat(o2).concat(t5.encodingName, "/").concat(t5.clockRate).concat(t5.encodingParameters ? "/".concat(t5.encodingParameters) : "").concat(this.eol) : "";
              }
              printRTCPFeedback(e5, t5) {
                let r4 = "a=rtcp-fb:".concat(e5).concat(o2), i3 = t5;
                switch (i3.type) {
                  case "trr-int":
                    r4 += "ttr-int".concat(o2).concat(i3.interval);
                    break;
                  case "ack":
                  case "nack":
                  default:
                    i3 = i3, r4 += "".concat(i3.type), i3.parameter && (r4 += "".concat(o2).concat(i3.parameter), i3.additional && (r4 += "".concat(o2).concat(i3.additional)));
                }
                return r4 + this.eol;
              }
              printPtime(e5) {
                return e5 === void 0 ? "" : "a=ptime:".concat(e5).concat(this.eol);
              }
              printMaxPtime(e5) {
                return e5 === void 0 ? "" : "a=maxptime:".concat(e5).concat(this.eol);
              }
              printDirection(e5) {
                return e5 === void 0 ? "" : "a=".concat(e5).concat(this.eol);
              }
              printSSRC(e5) {
                return e5.map((e6) => Object.keys(e6.attributes).map((t5) => "a=ssrc:".concat(e6.ssrcId.toString(10)).concat(o2).concat(t5).concat(e6.attributes[t5] ? ":".concat(e6.attributes[t5]) : "").concat(this.eol)).join("")).join("");
              }
              printRTCPMux(e5) {
                return e5 === void 0 ? "" : "a=rtcp-mux".concat(this.eol);
              }
              printRTCPMuxOnly(e5) {
                return e5 === void 0 ? "" : "a=rtcp-mux-only".concat(this.eol);
              }
              printRTCPRsize(e5) {
                return e5 === void 0 ? "" : "a=rtcp-rsize".concat(this.eol);
              }
              printRTCP(e5) {
                if (e5 === void 0)
                  return "";
                let t5 = "a=rtcp:".concat(e5.port);
                return e5.netType && (t5 += "".concat(o2).concat(e5.netType)), e5.addressType && (t5 += "".concat(o2).concat(e5.addressType)), e5.address && (t5 += "".concat(o2).concat(e5.address)), t5 + this.eol;
              }
              printMSId(e5) {
                return e5.map((e6) => "a=msid:".concat(e6.id).concat(e6.appdata ? "".concat(o2).concat(e6.appdata) : "").concat(this.eol)).join("");
              }
              printImageattr(e5) {
                return e5.map((e6) => "a=imageattr:".concat(e6).concat(this.eol)).join("");
              }
              printRid(e5) {
                return e5.map((e6) => {
                  let t5 = "a=rid:".concat(e6.id).concat(o2).concat(e6.direction);
                  return e6.payloads && (t5 += "".concat(o2, "pt=").concat(e6.payloads.join(","))), e6.params.length > 0 && (t5 += "".concat(o2).concat(e6.params.map((e7) => e7.type === "depend" ? "depend=".concat(e7.rids.join(",")) : "".concat(e7.type, "=").concat(e7.val)).join(";"))), t5 + this.eol;
                }).join("");
              }
              printSimulcast(e5) {
                return e5 === void 0 ? "" : "a=simulcast:".concat(e5).concat(this.eol);
              }
              printSCRPPort(e5) {
                return e5 === void 0 ? "" : "a=sctp-port:".concat(e5).concat(this.eol);
              }
              printMaxMessageSize(e5) {
                return e5 === void 0 ? "" : "a=max-message-size:".concat(e5);
              }
              printMid(e5) {
                return e5 === void 0 ? "" : "a=mid:".concat(e5).concat(this.eol);
              }
              printSSRCGroups(e5) {
                return e5.map((e6) => "a=ssrc-group:".concat(e6.semantic).concat(e6.ssrcIds.map((e7) => "".concat(o2).concat(e7.toString(10))).join("")).concat(this.eol)).join("");
              }
            }
            function D2(e5) {
              return new v2().parse(e5);
            }
            function L2(e5, t5) {
              return new w2().print(e5, t5);
            }
          } }, t3 = {};
          function r2(i2) {
            if (t3[i2])
              return t3[i2].exports;
            var n2 = t3[i2] = { exports: {} };
            return e3[i2](n2, n2.exports, r2), n2.exports;
          }
          return r2.d = (e4, t4) => {
            for (var i2 in t4)
              r2.o(t4, i2) && !r2.o(e4, i2) && Object.defineProperty(e4, i2, { enumerable: true, get: t4[i2] });
          }, r2.o = (e4, t4) => Object.prototype.hasOwnProperty.call(e4, t4), r2.r = (e4) => {
            typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e4, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e4, "__esModule", { value: true });
          }, r2(8);
        })();
      }(kZ);
      class WZ {
        constructor(e2) {
          kO(this, "sessionDesc", void 0), kO(this, "localCapabilities", void 0), kO(this, "rtpCapabilities", void 0), kO(this, "candidates", void 0), kO(this, "iceParameters", void 0), kO(this, "dtlsParameters", void 0), kO(this, "setup", void 0), kO(this, "currentMidIndex", void 0), kO(this, "cname", void 0), e2 = BG(e2);
          const { remoteIceParameters: t2, remoteDtlsParameters: r2, candidates: i2, remoteRTPCapabilities: n2, remoteSetup: o2, localCapabilities: s2, sdkCodec: a2, cname: c2 } = e2, d2 = kZ.exports.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE audio video\na=msid-semantic: WMS\na=ice-lite\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:audio\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:video\n");
          this.rtpCapabilities = n2, this.candidates = i2, this.iceParameters = t2, this.dtlsParameters = r2, this.setup = o2, this.localCapabilities = s2, this.cname = c2;
          for (let e3 = 0; e3 < d2.mediaDescriptions.length; e3++) {
            const s3 = d2.mediaDescriptions[e3];
            if (s3.attributes.iceUfrag = t2.iceUfrag, s3.attributes.icePwd = t2.icePwd, s3.attributes.fingerprints = r2.fingerprints, s3.attributes.candidates = i2, s3.attributes.setup = o2, s3.media.mediaType === "video") {
              s3.media.fmts = n2.videoCodecs.map((e5) => e5.payloadType.toString(10));
              const e4 = n2.videoCodecs.filter((e5) => {
                var t3;
                return (t3 = e5.rtpMap) === null || t3 === void 0 ? void 0 : t3.encodingName.toLowerCase().includes(a2);
              });
              if (e4.length === 0)
                throw new Error("Codec ".concat(a2, " not supported by remote SDP."));
              s3.attributes.payloads = e4, s3.attributes.extmaps = n2.videoExtensions;
            }
            s3.media.mediaType === "audio" && (s3.media.fmts = n2.audioCodecs.map((e4) => e4.payloadType.toString(10)), s3.attributes.payloads = n2.audioCodecs, s3.attributes.extmaps = n2.audioExtensions), d2.mediaDescriptions[e3] = this.mungMediaDesc(s3);
          }
          this.sessionDesc = d2, this.currentMidIndex = d2.mediaDescriptions.length - 1;
        }
        toString() {
          return kZ.exports.print(this.sessionDesc);
        }
        send(e2, t2, r2) {
          const { ssrcs: i2, ssrcGroups: n2 } = FZ(t2, this.cname), o2 = this.sessionDesc.mediaDescriptions.find((t3) => e2 === yk.VIDEO ? t3.media.mediaType === "video" : t3.media.mediaType === "audio"), s2 = i2[0].attributes.label, a2 = i2[0].attributes.mslabel;
          return o2.attributes.ssrcs = o2.attributes.ssrcs.concat(i2), o2.attributes.ssrcGroups = o2.attributes.ssrcGroups.concat(n2), { id: s2, mslabel: a2 };
        }
        batchSend(e2) {
          return e2.map((e3) => {
            let { kind: t2, ssrcMsg: r2 } = e3;
            return this.send(t2, r2, void 0);
          });
        }
        stopSending(e2) {
          this.sessionDesc.mediaDescriptions.forEach((t2) => {
            const r2 = [], i2 = [], n2 = [];
            t2.attributes.ssrcs.forEach((t3) => {
              e2.includes(t3.attributes.label || "") ? n2.push(t3) : r2.push(t3);
            }), t2.attributes.ssrcGroups.forEach((e3) => {
              n2.map((e4) => e4.ssrcId).includes(e3.ssrcIds[0]) || i2.push(e3);
            }), t2.attributes.ssrcs = r2, t2.attributes.ssrcGroups = i2;
          });
        }
        mute(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2);
          if (!t2)
            throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.mute."));
          t2.attributes.direction = "inactive";
        }
        unmute(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2);
          if (!t2)
            throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.unmute."));
          t2.attributes.direction = "sendonly";
        }
        receive(e2, t2, r2) {
          e2.forEach((e3, t3) => {
            const r3 = e3._mediaStreamTrack, i2 = this.sessionDesc.mediaDescriptions.findIndex((e4) => e4.attributes.mid === r3.kind), n2 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i2], e3);
            this.sessionDesc.mediaDescriptions[i2] = n2;
          });
        }
        stopReceiving(e2) {
        }
        restartICE(e2, t2) {
          e2 = BG(e2), t2 = BG(t2), this.iceParameters = e2, this.candidates = t2, this.sessionDesc.mediaDescriptions.forEach((t3) => {
            t3.attributes.iceUfrag = e2.iceUfrag, t3.attributes.icePwd = e2.icePwd, t3.attributes.candidates = this.candidates;
          });
        }
        predictReceivingMids(e2) {
          const t2 = [];
          for (let r2 = 0; r2 < e2; r2++)
            t2.push((this.currentMidIndex + r2 + 1).toString(10));
          return t2;
        }
        mungRecvMediaDsec(e2, t2) {
          const r2 = BG(e2);
          return VZ(r2, t2), GZ(r2, t2), r2;
        }
        updateRecvMedia(e2, t2) {
          const r2 = this.sessionDesc.mediaDescriptions.findIndex((t3) => t3.attributes.mid === e2);
          if (r2 !== -1) {
            const e3 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[r2], t2);
            this.sessionDesc.mediaDescriptions[r2] = e3;
          }
        }
        bumpMid(e2) {
          this.currentMidIndex += e2;
        }
        updateTrackLabel(e2, t2, r2) {
          const i2 = this.sessionDesc.mediaDescriptions.find((t3) => e2 === yk.VIDEO ? t3.attributes.mid === "video" : t3.attributes.mid === "audio");
          if (i2) {
            const e3 = i2.attributes.ssrcs.find((e4) => e4.attributes.label === t2);
            var n2;
            if (e3)
              e3.attributes.label = r2, (n2 = e3.attributes.msid) === null || n2 === void 0 || n2.replace(t2, r2);
          }
        }
        mungMediaDesc(e2) {
          const t2 = BG(e2);
          return jZ(t2), function(e3) {
            const t3 = e3.attributes.extmaps.find((e4) => e4.extensionName === "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01");
            t3 && e3.attributes.extmaps.splice(e3.attributes.extmaps.indexOf(t3), 1), e3.attributes.payloads.forEach((e4) => {
              const t4 = e4.rtcpFeedbacks.findIndex((e5) => e5.type === "transport-cc");
              t4 !== -1 && e4.rtcpFeedbacks.splice(t4, 1);
            });
          }(t2), t2;
        }
      }
      function JZ(e2) {
        if (Array.isArray(e2))
          return e2.map(function(e3) {
            return e3;
          });
        if (!qZ(e2))
          return e2;
        var t2 = {};
        for (var r2 in e2)
          qZ(e2[r2]) || Array.isArray(e2[r2]) ? t2[r2] = JZ(e2[r2]) : t2[r2] = e2[r2];
        return t2;
      }
      function qZ(e2) {
        return !(typeof e2 != "object" || Array.isArray(e2) || !e2);
      }
      var zZ = function() {
        function e2(e3) {
          this.input = [], this.size = e3;
        }
        return e2.prototype.add = function(e3) {
          this.input.push(e3), this.input.length > this.size && this.input.splice(0, 1);
        }, e2.prototype.diffMean = function() {
          return this.input.length === 0 ? 0 : (this.input[this.input.length - 1] - this.input[0]) / this.input.length;
        }, e2;
      }(), XZ = function(e2, t2) {
        return (XZ = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
          e3.__proto__ = t3;
        } || function(e3, t3) {
          for (var r2 in t3)
            t3.hasOwnProperty(r2) && (e3[r2] = t3[r2]);
        })(e2, t2);
      };
      function ZZ(e2, t2) {
        function r2() {
          this.constructor = e2;
        }
        XZ(e2, t2), e2.prototype = t2 === null ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
      }
      var $Z = function() {
        return ($Z = Object.assign || function(e2) {
          for (var t2, r2 = 1, i2 = arguments.length; r2 < i2; r2++)
            for (var n2 in t2 = arguments[r2])
              Object.prototype.hasOwnProperty.call(t2, n2) && (e2[n2] = t2[n2]);
          return e2;
        }).apply(this, arguments);
      };
      function e$(e2, t2, r2, i2) {
        return new (r2 || (r2 = Promise))(function(n2, o2) {
          function s2(e3) {
            try {
              c2(i2.next(e3));
            } catch (e4) {
              o2(e4);
            }
          }
          function a2(e3) {
            try {
              c2(i2.throw(e3));
            } catch (e4) {
              o2(e4);
            }
          }
          function c2(e3) {
            e3.done ? n2(e3.value) : new r2(function(t3) {
              t3(e3.value);
            }).then(s2, a2);
          }
          c2((i2 = i2.apply(e2, t2 || [])).next());
        });
      }
      function t$(e2, t2) {
        var r2, i2, n2, o2, s2 = { label: 0, sent: function() {
          if (1 & n2[0])
            throw n2[1];
          return n2[1];
        }, trys: [], ops: [] };
        return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, typeof Symbol == "function" && (o2[Symbol.iterator] = function() {
          return this;
        }), o2;
        function a2(o3) {
          return function(a3) {
            return function(o4) {
              if (r2)
                throw new TypeError("Generator is already executing.");
              for (; s2; )
                try {
                  if (r2 = 1, i2 && (n2 = 2 & o4[0] ? i2.return : o4[0] ? i2.throw || ((n2 = i2.return) && n2.call(i2), 0) : i2.next) && !(n2 = n2.call(i2, o4[1])).done)
                    return n2;
                  switch (i2 = 0, n2 && (o4 = [2 & o4[0], n2.value]), o4[0]) {
                    case 0:
                    case 1:
                      n2 = o4;
                      break;
                    case 4:
                      return s2.label++, { value: o4[1], done: false };
                    case 5:
                      s2.label++, i2 = o4[1], o4 = [0];
                      continue;
                    case 7:
                      o4 = s2.ops.pop(), s2.trys.pop();
                      continue;
                    default:
                      if (!(n2 = s2.trys, (n2 = n2.length > 0 && n2[n2.length - 1]) || o4[0] !== 6 && o4[0] !== 2)) {
                        s2 = 0;
                        continue;
                      }
                      if (o4[0] === 3 && (!n2 || o4[1] > n2[0] && o4[1] < n2[3])) {
                        s2.label = o4[1];
                        break;
                      }
                      if (o4[0] === 6 && s2.label < n2[1]) {
                        s2.label = n2[1], n2 = o4;
                        break;
                      }
                      if (n2 && s2.label < n2[2]) {
                        s2.label = n2[2], s2.ops.push(o4);
                        break;
                      }
                      n2[2] && s2.ops.pop(), s2.trys.pop();
                      continue;
                  }
                  o4 = t2.call(e2, s2);
                } catch (e3) {
                  o4 = [6, e3], i2 = 0;
                } finally {
                  r2 = n2 = 0;
                }
              if (5 & o4[0])
                throw o4[1];
              return { value: o4[0] ? o4[1] : void 0, done: true };
            }([o3, a3]);
          };
        }
      }
      var r$, i$ = { address: "unknown", candidateType: "unknown", id: "unknown", port: 0, priority: 0, protocol: "unknown", type: "unknown" }, n$ = { timestamp: 0, bitrate: { actualEncoded: 0, transmit: 0 }, sendPacketLossRate: 0, recvPacketLossRate: 0, videoRecv: [], videoSend: [], audioRecv: [], audioSend: [], selectedCandidatePair: { id: "unknown", localCandidate: i$, remoteCandidate: i$ } }, o$ = { firsCount: 0, nacksCount: 0, plisCount: 0, framesDecodeCount: 0, framesDecodeInterval: 0, framesDecodeFreezeTime: 0, decodeFrameRate: 0, bytes: 0, packetsLost: 0, packetLostRate: 0, packets: 0, ssrc: 0, qpSumPerFrame: 0 }, s$ = { firsCount: 0, nacksCount: 0, plisCount: 0, frameCount: 0, bytes: 0, packets: 0, packetsLost: 0, packetLostRate: 0, ssrc: 0, rttMs: 0, qpSumPerFrame: 0 }, a$ = { bytes: 0, packets: 0, packetsLost: 0, packetLostRate: 0, ssrc: 0, rttMs: 0 }, c$ = { jitterBufferMs: 0, jitterMs: 0, bytes: 0, packetsLost: 0, packetLostRate: 0, packets: 0, ssrc: 0, receivedFrames: 0, droppedFrames: 0 }, d$ = function() {
        function e2(e3, t2) {
          var r2 = this;
          this.videoIsReady = false, this.videoIsReady2 = {}, this.stats = JZ(n$), this.isFirstVideoReceived = {}, this.isFirstVideoDecoded = {}, this.isFirstAudioReceived = {}, this.isFirstAudioDecoded = {}, this.lossRateWindowStats = [], this.pc = e3, this.options = t2, this.intervalTimer = window.setInterval(function() {
            return e$(r2, void 0, void 0, function() {
              return t$(this, function(e4) {
                return this.updateStats(), [2];
              });
            });
          }, this.options.updateInterval);
        }
        return e2.prototype.getStats = function() {
          return this.stats;
        }, e2.prototype.setVideoIsReady = function(e3) {
          this.videoIsReady = e3;
        }, e2.prototype.setVideoIsReady2 = function(e3, t2) {
          this.videoIsReady2[e3] = t2;
        }, e2.prototype.getVideoIsReady = function(e3) {
          return this.videoIsReady2[e3] || false;
        }, e2.prototype.setIsFirstAudioDecoded = function(e3) {
        }, e2.prototype.destroy = function() {
          window.clearInterval(this.intervalTimer), this.pc = void 0;
        }, e2.prototype.calcLossRate = function(e3) {
          var t2 = this;
          this.lossRateWindowStats.push(e3), this.lossRateWindowStats.length > this.options.lossRateInterval && this.lossRateWindowStats.splice(0, 1);
          for (var r2 = this.lossRateWindowStats.length, i2 = 0, n2 = 0, o2 = 0, s2 = 0, a2 = function(a3) {
            e3[a3].forEach(function(e4, c3) {
              if (t2.lossRateWindowStats[r2 - 1][a3][c3] && t2.lossRateWindowStats[0][a3][c3]) {
                var d3 = t2.lossRateWindowStats[r2 - 1][a3][c3].packets - t2.lossRateWindowStats[0][a3][c3].packets, u2 = t2.lossRateWindowStats[r2 - 1][a3][c3].packetsLost - t2.lossRateWindowStats[0][a3][c3].packetsLost;
                a3 === "videoSend" || a3 === "audioSend" ? (i2 += d3, o2 += u2) : (n2 += d3, s2 += u2), Number.isNaN(d3) || Number.isNaN(d3) ? e4.packetLostRate = 0 : e4.packetLostRate = d3 <= 0 || u2 <= 0 ? 0 : u2 / (d3 + u2);
              }
            });
          }, c2 = 0, d2 = ["videoSend", "audioSend", "videoRecv", "audioRecv"]; c2 < d2.length; c2++) {
            a2(d2[c2]);
          }
          e3.sendPacketLossRate = i2 <= 0 || o2 <= 0 ? 0 : o2 / (i2 + o2), e3.recvPacketLossRate = n2 <= 0 || s2 <= 0 ? 0 : s2 / (n2 + s2);
        }, e2;
      }(), u$ = function(e2) {
        function t2() {
          var t3 = e2 !== null && e2.apply(this, arguments) || this;
          return t3._stats = n$, t3.lastDecodeVideoReceiverStats = /* @__PURE__ */ new Map(), t3;
        }
        return ZZ(t2, e2), t2.prototype.updateStats = function() {
          return e$(this, void 0, void 0, function() {
            var e3, t3, r2, i2;
            return t$(this, function(n2) {
              switch (n2.label) {
                case 0:
                  return [4, this._getStats()];
                case 1:
                  return e3 = n2.sent(), t3 = this.statsResponsesToObjects(e3), this._stats = JZ(n$), r2 = t3.filter(function(e4) {
                    return e4.type === "ssrc";
                  }), this.processSSRCStats(r2), (i2 = t3.find(function(e4) {
                    return e4.type === "VideoBwe";
                  })) && this.processBandwidthStats(i2), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats, [2];
              }
            });
          });
        }, t2.prototype.processBandwidthStats = function(e3) {
          this._stats.bitrate = { actualEncoded: Number(e3.googActualEncBitrate), targetEncoded: Number(e3.googTargetEncBitrate), retransmit: Number(e3.googRetransmitBitrate), transmit: Number(e3.googTransmitBitrate) }, this._stats.sendBandwidth = Number(e3.googAvailableSendBandwidth);
        }, t2.prototype.processSSRCStats = function(e3) {
          var t3 = this;
          e3.forEach(function(e4) {
            var r2 = e4.id.includes("send");
            switch (e4.mediaType + "_" + (r2 ? "send" : "recv")) {
              case "video_send":
                var i2 = JZ(s$);
                i2.codec = e4.googCodecName, i2.adaptionChangeReason = "none", e4.googCpuLimitedResolution && (i2.adaptionChangeReason = "cpu"), e4.googBandwidthLimitedResolution && (i2.adaptionChangeReason = "bandwidth"), i2.avgEncodeMs = Number(e4.googAvgEncodeMs), i2.inputFrame = { width: Number(e4.googFrameWidthInput) || Number(e4.googFrameWidthSent), height: Number(e4.googFrameHeightInput) || Number(e4.googFrameHeightSent), frameRate: Number(e4.googFrameRateInput) }, i2.sentFrame = { width: Number(e4.googFrameWidthSent), height: Number(e4.googFrameHeightSent), frameRate: Number(e4.googFrameRateInput) }, i2.firsCount = Number(e4.googFirReceived), i2.nacksCount = Number(e4.googNacksReceived), i2.plisCount = Number(e4.googPlisReceived), i2.frameCount = Number(e4.framesEncoded), i2.bytes = Number(e4.bytesSent), i2.packets = Number(e4.packetsSent), i2.packetsLost = Number(e4.packetsLost), i2.ssrc = Number(e4.ssrc), i2.rttMs = Number(e4.googRtt || 0), t3._stats.videoSend.push(i2), t3._stats.rtt = i2.rttMs;
                break;
              case "video_recv":
                var n2 = JZ(o$), o2 = t3.lastDecodeVideoReceiverStats.get(Number(e4.ssrc));
                if (n2.codec = e4.googCodecName, n2.targetDelayMs = Number(e4.googTargetDelayMs), n2.renderDelayMs = Number(e4.googRenderDelayMs), n2.currentDelayMs = Number(e4.googCurrentDelayMs), n2.minPlayoutDelayMs = Number(e4.googMinPlayoutDelayMs), n2.decodeMs = Number(e4.googDecodeMs), n2.maxDecodeMs = Number(e4.googMaxDecodeMs), n2.receivedFrame = { width: Number(e4.googFrameWidthReceived), height: Number(e4.googFrameHeightReceived), frameRate: Number(e4.googFrameRateReceived) }, n2.decodedFrame = { width: Number(e4.googFrameWidthReceived), height: Number(e4.googFrameHeightReceived), frameRate: Number(e4.googFrameRateDecoded) }, n2.outputFrame = { width: Number(e4.googFrameWidthReceived), height: Number(e4.googFrameHeightReceived), frameRate: Number(e4.googFrameRateOutput) }, n2.jitterBufferMs = Number(e4.googJitterBufferMs), n2.firsCount = Number(e4.googFirsSent), n2.nacksCount = Number(e4.googNacksSent), n2.plisCount = Number(e4.googPlisSent), n2.framesDecodeCount = Number(e4.framesDecoded), n2.bytes = Number(e4.bytesReceived), n2.packets = Number(e4.packetsReceived), n2.packetsLost = Number(e4.packetsLost), n2.ssrc = Number(e4.ssrc), n2.packets > 0 && !t3.isFirstVideoReceived[n2.ssrc] && (t3.onFirstVideoReceived && t3.onFirstVideoReceived(n2.ssrc), t3.isFirstVideoReceived[n2.ssrc] = true), n2.framesDecodeCount > 0 && !t3.isFirstVideoDecoded[n2.ssrc] && (t3.onFirstVideoDecoded && t3.onFirstVideoDecoded(n2.ssrc, n2.decodedFrame.width, n2.decodedFrame.height), t3.isFirstVideoDecoded[n2.ssrc] = true), o2) {
                  var s2 = o2.stats, a2 = Date.now() - o2.lts;
                  n2.framesDecodeFreezeTime = s2.framesDecodeFreezeTime, n2.framesDecodeInterval = s2.framesDecodeInterval, n2.framesDecodeCount > s2.framesDecodeCount && t3.isFirstVideoDecoded ? (o2.lts = Date.now(), n2.framesDecodeInterval = a2, n2.framesDecodeInterval >= t3.options.freezeRateLimit && (t3.getVideoIsReady(parseInt(e4.ssrc, 10)) ? n2.framesDecodeFreezeTime += n2.framesDecodeInterval : t3.setVideoIsReady2(parseInt(e4.ssrc, 10), true))) : n2.framesDecodeCount < o2.stats.framesDecodeCount && (n2.framesDecodeInterval = 0);
                }
                t3.lastDecodeVideoReceiverStats.set(n2.ssrc, { stats: $Z({}, n2), lts: Date.now() }), t3._stats.videoRecv.push(n2);
                break;
              case "audio_recv":
                var c2 = JZ(c$);
                c2.codec = e4.googCodecName, c2.outputLevel = Math.abs(Number(e4.audioOutputLevel)) / 32767, c2.decodingCNG = Number(e4.googDecodingCNG), c2.decodingCTN = Number(e4.googDecodingCTN), c2.decodingCTSG = Number(e4.googDecodingCTSG), c2.decodingNormal = Number(e4.googDecodingNormal), c2.decodingPLC = Number(e4.googDecodingPLC), c2.decodingPLCCNG = Number(e4.googDecodingPLCCNG), c2.expandRate = Number(e4.googExpandRate), c2.accelerateRate = Number(e4.googAccelerateRate), c2.preemptiveExpandRate = Number(e4.googPreemptiveExpandRate), c2.secondaryDecodedRate = Number(e4.googSecondaryDecodedRate), c2.speechExpandRate = Number(e4.googSpeechExpandRate), c2.preferredJitterBufferMs = Number(e4.googPreferredJitterBufferMs), c2.jitterBufferMs = Number(e4.googJitterBufferMs), c2.jitterMs = Number(e4.googJitterReceived), c2.bytes = Number(e4.bytesReceived), c2.packets = Number(e4.packetsReceived), c2.packetsLost = Number(e4.packetsLost), c2.ssrc = Number(e4.ssrc), c2.receivedFrames = Number(e4.googDecodingCTN) || Number(e4.packetsReceived), c2.droppedFrames = Number(e4.googDecodingPLC) + Number(e4.googDecodingPLCCNG) || Number(e4.packetsLost), c2.receivedFrames > 0 && !t3.isFirstAudioReceived[c2.ssrc] && (t3.onFirstAudioReceived && t3.onFirstAudioReceived(c2.ssrc), t3.isFirstAudioReceived[c2.ssrc] = true), c2.decodingNormal > 0 && !t3.isFirstAudioDecoded[c2.ssrc] && (t3.onFirstAudioDecoded && t3.onFirstAudioDecoded(c2.ssrc), t3.isFirstAudioDecoded[c2.ssrc] = true), t3._stats.audioRecv.push(c2);
                break;
              case "audio_send":
                var d2 = JZ(a$);
                d2.codec = e4.googCodecName, d2.inputLevel = Math.abs(Number(e4.audioInputLevel)) / 32767, d2.aecReturnLoss = Number(e4.googEchoCancellationReturnLoss || 0), d2.aecReturnLossEnhancement = Number(e4.googEchoCancellationReturnLossEnhancement || 0), d2.residualEchoLikelihood = Number(e4.googResidualEchoLikelihood || 0), d2.residualEchoLikelihoodRecentMax = Number(e4.googResidualEchoLikelihoodRecentMax || 0), d2.bytes = Number(e4.bytesSent), d2.packets = Number(e4.packetsSent), d2.packetsLost = Number(e4.packetsLost), d2.ssrc = Number(e4.ssrc), d2.rttMs = Number(e4.googRtt || 0), t3._stats.rtt = d2.rttMs, t3._stats.audioSend.push(d2);
            }
          });
        }, t2.prototype._getStats = function() {
          var e3 = this;
          return new Promise(function(t3, r2) {
            e3.pc.getStats(t3, r2);
          });
        }, t2.prototype.statsResponsesToObjects = function(e3) {
          var t3 = [];
          return e3.result().forEach(function(e4) {
            var r2 = { id: e4.id, timestamp: e4.timestamp.valueOf().toString(), type: e4.type };
            e4.names().forEach(function(t4) {
              r2[t4] = e4.stat(t4);
            }), t3.push(r2);
          }), t3;
        }, t2;
      }(d$);
      !function(e2) {
        e2.CERTIFICATE = "certificate", e2.CODEC = "codec", e2.CANDIDATE_PAIR = "candidate-pair", e2.LOCAL_CANDIDATE = "local-candidate", e2.REMOTE_CANDIDATE = "remote-candidate", e2.INBOUND = "inbound-rtp", e2.TRACK = "track", e2.OUTBOUND = "outbound-rtp", e2.PC = "peer-connection", e2.REMOTE_INBOUND = "remote-inbound-rtp", e2.REMOTE_OUTBOUND = "remote-outbound-rtp", e2.TRANSPORT = "transport", e2.CSRC = "csrc", e2.DATA_CHANNEL = "data-channel", e2.STREAM = "stream", e2.SENDER = "sender", e2.RECEIVER = "receiver";
      }(r$ || (r$ = {}));
      var A$, h$ = function(e2) {
        function t2() {
          var t3 = e2 !== null && e2.apply(this, arguments) || this;
          return t3._stats = n$, t3.lastDecodeVideoReceiverStats = /* @__PURE__ */ new Map(), t3.lastVideoFramesRecv = /* @__PURE__ */ new Map(), t3.lastVideoFramesSent = /* @__PURE__ */ new Map(), t3.lastVideoFramesDecode = /* @__PURE__ */ new Map(), t3.lastVideoJBDelay = /* @__PURE__ */ new Map(), t3.lastAudioJBDelay = /* @__PURE__ */ new Map(), t3.mediaBytesSent = /* @__PURE__ */ new Map(), t3.mediaBytesRetransmit = /* @__PURE__ */ new Map(), t3.mediaBytesTargetEncode = /* @__PURE__ */ new Map(), t3.lastEncoderMs = /* @__PURE__ */ new Map(), t3;
        }
        return ZZ(t2, e2), t2.prototype.updateStats = function() {
          return e$(this, void 0, void 0, function() {
            var e3, t3 = this;
            return t$(this, function(r2) {
              switch (r2.label) {
                case 0:
                  return e3 = this, [4, this.pc.getStats()];
                case 1:
                  return e3.report = r2.sent(), this._stats = JZ(n$), this.report.forEach(function(e4) {
                    switch (e4.type) {
                      case r$.OUTBOUND:
                        e4.mediaType === "audio" ? t3.processAudioOutboundStats(e4) : e4.mediaType === "video" && t3.processVideoOutboundStats(e4);
                        break;
                      case r$.INBOUND:
                        e4.mediaType === "audio" ? t3.processAudioInboundStats(e4) : e4.mediaType === "video" && t3.processVideoInboundStats(e4);
                        break;
                      case r$.TRANSPORT:
                        var r3 = t3.report.get(e4.selectedCandidatePairId);
                        r3 && t3.processCandidatePairStats(r3);
                        break;
                      case r$.CANDIDATE_PAIR:
                        e4.selected && t3.processCandidatePairStats(e4);
                    }
                  }), this.updateSendBitrate(), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats, [2];
              }
            });
          });
        }, t2.prototype.processCandidatePairStats = function(e3) {
          if (this._stats.sendBandwidth = e3.availableOutgoingBitrate || 0, e3.currentRoundTripTime && (this._stats.rtt = 1e3 * e3.currentRoundTripTime), this._stats.videoSend.forEach(function(t4) {
            !t4.rttMs && e3.currentRoundTripTime && (t4.rttMs = 1e3 * e3.currentRoundTripTime);
          }), this._stats.audioSend.forEach(function(t4) {
            !t4.rttMs && e3.currentRoundTripTime && (t4.rttMs = 1e3 * e3.currentRoundTripTime);
          }), this._stats.selectedCandidatePair.id = e3.id, e3.localCandidateId) {
            var t3 = this.report.get(e3.localCandidateId);
            t3 && this.processCandidateStats(t3);
          }
          if (e3.remoteCandidateId) {
            var r2 = this.report.get(e3.remoteCandidateId);
            r2 && this.processCandidateStats(r2);
          }
        }, t2.prototype.processCandidateStats = function(e3) {
          var t3;
          e3.type === r$.LOCAL_CANDIDATE && (t3 = this._stats.selectedCandidatePair.localCandidate), e3.type === r$.REMOTE_CANDIDATE && (t3 = this._stats.selectedCandidatePair.remoteCandidate), t3 && (t3.type = e3.type, t3.id = e3.id, e3.address && (t3.address = e3.address), e3.candidateType && (t3.candidateType = e3.candidateType), e3.port && (t3.port = e3.port), e3.priority && (t3.priority = e3.priority), e3.protocol && (t3.protocol = e3.protocol), e3.relayProtocol && (t3.relayProtocol = e3.relayProtocol), e3.type === r$.LOCAL_CANDIDATE && this.stats.selectedCandidatePair.localCandidate.id !== t3.id && this.onSelectedLocalCandidateChanged && this.onSelectedLocalCandidateChanged($Z({}, t3), $Z({}, this.stats.selectedCandidatePair.localCandidate)), e3.type === r$.REMOTE_CANDIDATE && this.stats.selectedCandidatePair.remoteCandidate.id !== t3.id && this.onSelectedRemoteCandidateChanged && this.onSelectedRemoteCandidateChanged($Z({}, t3), $Z({}, this.stats.selectedCandidatePair.remoteCandidate)));
        }, t2.prototype.processAudioInboundStats = function(e3) {
          var t3 = this._stats.audioRecv.find(function(t4) {
            return t4.ssrc === e3.ssrc;
          });
          t3 || (t3 = JZ(c$), this._stats.audioRecv.push(t3)), t3.ssrc = e3.ssrc, t3.packets = e3.packetsReceived, t3.packetsLost = e3.packetsLost, t3.bytes = e3.bytesReceived, t3.jitterMs = 1e3 * e3.jitter, e3.trackId && this.processAudioTrackReceiverStats(e3.trackId, t3), e3.codecId && (t3.codec = this.getCodecFromCodecStats(e3.codecId)), t3.receivedFrames || (t3.receivedFrames = e3.packetsReceived), t3.droppedFrames || (t3.droppedFrames = e3.packetsLost), t3.receivedFrames > 0 && !this.isFirstAudioReceived[t3.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t3.ssrc), this.isFirstAudioReceived[t3.ssrc] = true), t3.outputLevel && t3.outputLevel > 0 && !this.isFirstAudioDecoded[t3.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t3.ssrc), this.isFirstAudioDecoded[t3.ssrc] = true);
        }, t2.prototype.processVideoInboundStats = function(e3) {
          var t3 = this._stats.videoRecv.find(function(t4) {
            return t4.ssrc === e3.ssrc;
          });
          t3 || (t3 = JZ(o$), this._stats.videoRecv.push(t3)), t3.ssrc = e3.ssrc, t3.packets = e3.packetsReceived, t3.packetsLost = e3.packetsLost, t3.bytes = e3.bytesReceived, t3.firsCount = e3.firCount, t3.nacksCount = e3.nackCount, t3.plisCount = e3.pliCount, t3.framesDecodeCount = e3.framesDecoded;
          var r2 = this.lastDecodeVideoReceiverStats.get(t3.ssrc), i2 = this.lastVideoFramesDecode.get(t3.ssrc), n2 = Date.now();
          if (t3.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t3.ssrc]) {
            var o2 = t3.decodedFrame ? t3.decodedFrame.width : 0, s2 = t3.decodedFrame ? t3.decodedFrame.height : 0;
            this.onFirstVideoDecoded && this.onFirstVideoDecoded(t3.ssrc, o2, s2), this.isFirstVideoDecoded[t3.ssrc] = true;
          }
          if (r2) {
            var a2 = r2.stats, c2 = n2 - r2.lts;
            t3.framesDecodeFreezeTime = a2.framesDecodeFreezeTime, t3.framesDecodeInterval = a2.framesDecodeInterval, t3.framesDecodeCount > a2.framesDecodeCount && this.isFirstVideoDecoded ? (r2.lts = Date.now(), t3.framesDecodeInterval = c2, t3.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e3.ssrc)) ? t3.framesDecodeFreezeTime += t3.framesDecodeInterval : this.setVideoIsReady2(parseInt(e3.ssrc, 10), true))) : t3.framesDecodeCount < a2.framesDecodeCount && (t3.framesDecodeInterval = 0), e3.framesDecoded && e3.qpSum && (r2.stats.framesDecodeCount > e3.framesDecoded ? t3.qpSumPerFrame = e3.qpSum / e3.framesDecoded : t3.qpSumPerFrame = (e3.qpSum - r2.qpSum) / (e3.framesDecoded - r2.stats.framesDecodeCount));
          }
          i2 && n2 - i2.lts >= 800 ? (t3.decodeFrameRate = Math.round((t3.framesDecodeCount - i2.count) / ((n2 - i2.lts) / 1e3)), this.lastVideoFramesDecode.set(t3.ssrc, { count: t3.framesDecodeCount, lts: n2, rate: t3.decodeFrameRate })) : i2 ? t3.decodeFrameRate = i2.rate : this.lastVideoFramesDecode.set(t3.ssrc, { count: t3.framesDecodeCount, lts: n2, rate: 0 }), e3.totalDecodeTime && (t3.decodeMs = 1e3 * e3.totalDecodeTime), e3.trackId && this.processVideoTrackReceiverStats(e3.trackId, t3), e3.codecId && (t3.codec = this.getCodecFromCodecStats(e3.codecId)), e3.framerateMean && (t3.framesRateFirefox = e3.framerateMean), t3.packets > 0 && !this.isFirstVideoReceived[t3.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t3.ssrc), this.isFirstVideoReceived[t3.ssrc] = true), this.lastDecodeVideoReceiverStats.set(t3.ssrc, { stats: $Z({}, t3), lts: r2 ? r2.lts : Date.now(), qpSum: e3.qpSum });
        }, t2.prototype.processVideoOutboundStats = function(e3) {
          var t3 = this._stats.videoSend.find(function(t4) {
            return t4.ssrc === e3.ssrc;
          });
          t3 || (t3 = JZ(s$), this._stats.videoSend.push(t3));
          var r2, i2 = this.mediaBytesSent.get(e3.ssrc);
          i2 ? i2.add(e3.bytesSent) : ((o2 = new zZ(10)).add(e3.bytesSent), this.mediaBytesSent.set(e3.ssrc, o2));
          if (e3.retransmittedBytesSent !== void 0) {
            var n2 = this.mediaBytesRetransmit.get(e3.ssrc);
            if (n2)
              n2.add(e3.retransmittedBytesSent);
            else
              (o2 = new zZ(10)).add(e3.retransmittedBytesSent), this.mediaBytesRetransmit.set(e3.ssrc, o2);
          }
          if (e3.totalEncodedBytesTarget) {
            var o2, s2 = this.mediaBytesTargetEncode.get(e3.ssrc);
            if (s2)
              s2.add(e3.totalEncodedBytesTarget);
            else
              (o2 = new zZ(10)).add(e3.totalEncodedBytesTarget), this.mediaBytesTargetEncode.set(e3.ssrc, o2);
          }
          if (t3.ssrc = e3.ssrc, t3.bytes = e3.bytesSent, t3.packets = e3.packetsSent, t3.firsCount = e3.firCount, t3.nacksCount = e3.nackCount, t3.plisCount = e3.pliCount, t3.frameCount = e3.framesEncoded, t3.adaptionChangeReason = e3.qualityLimitationReason, e3.totalEncodeTime && e3.framesEncoded)
            if (!(r2 = this.lastEncoderMs.get(e3.ssrc)) || r2.lastFrameCount > e3.framesEncoded)
              t3.avgEncodeMs = 1e3 * e3.totalEncodeTime / e3.framesEncoded;
            else {
              var a2 = e3.framesEncoded - r2.lastFrameCount, c2 = e3.totalEncodeTime - r2.lastEncoderTime;
              t3.avgEncodeMs = 1e3 * c2 / a2;
            }
          e3.framesEncoded && e3.qpSum && (!(r2 = this.lastEncoderMs.get(e3.ssrc)) || r2.lastFrameCount > e3.framesEncoded ? t3.qpSumPerFrame = e3.qpSum / e3.framesEncoded : t3.qpSumPerFrame = (e3.qpSum - r2.lastQpSum) / (e3.framesEncoded - r2.lastFrameCount));
          if (this.lastEncoderMs.set(e3.ssrc, { lastFrameCount: e3.framesEncoded, lastEncoderTime: e3.totalEncodeTime, lastQpSum: e3.qpSum, lts: Date.now() }), e3.codecId && (t3.codec = this.getCodecFromCodecStats(e3.codecId)), e3.mediaSourceId && this.processVideoMediaSource(e3.mediaSourceId, t3), e3.trackId && this.processVideoTrackSenderStats(e3.trackId, t3), e3.remoteId)
            this.processRemoteInboundStats(e3.remoteId, t3);
          else {
            var d2 = this.findRemoteStatsId(e3.ssrc, r$.REMOTE_INBOUND);
            d2 && this.processRemoteInboundStats(d2, t3);
          }
        }, t2.prototype.processAudioOutboundStats = function(e3) {
          var t3 = this._stats.audioSend.find(function(t4) {
            return t4.ssrc === e3.ssrc;
          });
          if (t3 || (t3 = JZ(a$), this._stats.audioSend.push(t3)), t3.ssrc = e3.ssrc, t3.packets = e3.packetsSent, t3.bytes = e3.bytesSent, e3.mediaSourceId && this.processAudioMediaSource(e3.mediaSourceId, t3), e3.codecId && (t3.codec = this.getCodecFromCodecStats(e3.codecId)), e3.trackId && this.processAudioTrackSenderStats(e3.trackId, t3), e3.remoteId)
            this.processRemoteInboundStats(e3.remoteId, t3);
          else {
            var r2 = this.findRemoteStatsId(e3.ssrc, r$.REMOTE_INBOUND);
            r2 && this.processRemoteInboundStats(r2, t3);
          }
        }, t2.prototype.findRemoteStatsId = function(e3, t3) {
          var r2 = Array.from(this.report.values()).find(function(r3) {
            return r3.type === t3 && r3.ssrc === e3;
          });
          return r2 ? r2.id : null;
        }, t2.prototype.processVideoMediaSource = function(e3, t3) {
          var r2 = this.report.get(e3);
          r2 && r2.width && r2.height && r2.framesPerSecond && (t3.inputFrame = { width: r2.width, height: r2.height, frameRate: r2.framesPerSecond });
        }, t2.prototype.processAudioMediaSource = function(e3, t3) {
          var r2 = this.report.get(e3);
          r2 && (t3.inputLevel = r2.audioLevel);
        }, t2.prototype.processVideoTrackSenderStats = function(e3, t3) {
          var r2 = this.report.get(e3);
          if (r2) {
            var i2 = 0, n2 = Date.now(), o2 = this.lastVideoFramesSent.get(t3.ssrc);
            o2 && n2 - o2.lts >= 800 ? (i2 = Math.round((r2.framesSent - o2.count) / ((n2 - o2.lts) / 1e3)), this.lastVideoFramesSent.set(t3.ssrc, { count: r2.framesSent, lts: n2, rate: i2 })) : o2 ? i2 = o2.rate : this.lastVideoFramesSent.set(t3.ssrc, { count: r2.framesSent, lts: n2, rate: 0 }), t3.sentFrame = { width: r2.frameWidth, height: r2.frameHeight, frameRate: i2 };
          }
        }, t2.prototype.processVideoTrackReceiverStats = function(e3, t3) {
          var r2 = this.report.get(e3);
          if (r2) {
            var i2 = this.lastVideoFramesRecv.get(t3.ssrc), n2 = Date.now();
            t3.framesReceivedCount = r2.framesReceived;
            var o2 = 0;
            if (i2 && n2 - i2.lts >= 800 ? (o2 = Math.round((r2.framesReceived - i2.count) / ((n2 - i2.lts) / 1e3)), this.lastVideoFramesRecv.set(t3.ssrc, { count: r2.framesReceived, lts: n2, rate: o2 })) : i2 ? o2 = i2.rate : this.lastVideoFramesRecv.set(t3.ssrc, { count: r2.framesReceived, lts: n2, rate: 0 }), t3.receivedFrame = { width: r2.frameWidth || 0, height: r2.frameHeight || 0, frameRate: o2 || 0 }, t3.decodedFrame = { width: r2.frameWidth || 0, height: r2.frameHeight || 0, frameRate: t3.decodeFrameRate || 0 }, t3.outputFrame = { width: r2.frameWidth || 0, height: r2.frameHeight || 0, frameRate: t3.decodeFrameRate || 0 }, r2.jitterBufferDelay && r2.jitterBufferEmittedCount) {
              var s2 = this.lastVideoJBDelay.get(t3.ssrc);
              this.lastVideoJBDelay.set(t3.ssrc, { jitterBufferDelay: r2.jitterBufferDelay, jitterBufferEmittedCount: r2.jitterBufferEmittedCount }), s2 || (s2 = { jitterBufferDelay: 0, jitterBufferEmittedCount: 0 });
              var a2 = 1e3 * (r2.jitterBufferDelay - s2.jitterBufferDelay) / (r2.jitterBufferEmittedCount - s2.jitterBufferEmittedCount);
              t3.jitterBufferMs = a2, t3.currentDelayMs = Math.round(a2);
            }
          }
        }, t2.prototype.processAudioTrackSenderStats = function(e3, t3) {
          var r2 = this.report.get(e3);
          r2 && (t3.aecReturnLoss = r2.echoReturnLoss || 0, t3.aecReturnLossEnhancement = r2.echoReturnLossEnhancement || 0);
        }, t2.prototype.processAudioTrackReceiverStats = function(e3, t3) {
          var r2 = this.report.get(e3);
          if (r2) {
            if (r2.removedSamplesForAcceleration && r2.totalSamplesReceived && (t3.accelerateRate = r2.removedSamplesForAcceleration / r2.totalSamplesReceived), r2.jitterBufferDelay && r2.jitterBufferEmittedCount) {
              var i2 = this.lastAudioJBDelay.get(t3.ssrc);
              this.lastAudioJBDelay.set(t3.ssrc, { jitterBufferDelay: r2.jitterBufferDelay, jitterBufferEmittedCount: r2.jitterBufferEmittedCount }), i2 || (i2 = { jitterBufferDelay: 0, jitterBufferEmittedCount: 0 });
              var n2 = 1e3 * (r2.jitterBufferDelay - i2.jitterBufferDelay) / (r2.jitterBufferEmittedCount - i2.jitterBufferEmittedCount);
              t3.jitterBufferMs = Math.round(n2);
            }
            t3.outputLevel = r2.audioLevel;
            var o2 = 1920;
            r2.totalSamplesDuration && r2.totalSamplesReceived && (o2 = r2.totalSamplesReceived / r2.totalSamplesDuration / 50, t3.receivedFrames = Math.round(r2.totalSamplesReceived / o2)), r2.concealedSamples && (t3.droppedFrames = Math.round(r2.concealedSamples / o2));
          }
        }, t2.prototype.processRemoteInboundStats = function(e3, t3) {
          var r2 = this.report.get(e3);
          r2 && (t3.packetsLost = r2.packetsLost, r2.roundTripTime && (t3.rttMs = 1e3 * r2.roundTripTime));
        }, t2.prototype.getCodecFromCodecStats = function(e3) {
          var t3 = this.report.get(e3);
          if (!t3)
            return "";
          var r2 = t3.mimeType.match(/\/(.*)$/);
          return r2 && r2[1] ? r2[1] : "";
        }, t2.prototype.updateSendBitrate = function() {
          var e3 = 0, t3 = null, r2 = null;
          this.mediaBytesSent.forEach(function(t4) {
            e3 += t4.diffMean();
          }), this.mediaBytesRetransmit.forEach(function(e4) {
            t3 = t3 === null ? e4.diffMean() : t3 + e4.diffMean();
          }), this.mediaBytesTargetEncode.forEach(function(e4) {
            r2 = r2 === null ? e4.diffMean() : r2 + e4.diffMean();
          });
          var i2 = t3 !== null ? e3 - t3 : e3;
          this._stats.bitrate = { actualEncoded: 8 * i2 / (this.options.updateInterval / 1e3), transmit: 8 * e3 / (this.options.updateInterval / 1e3) }, t3 !== null && (this._stats.bitrate.retransmit = 8 * t3 / (this.options.updateInterval / 1e3)), r2 !== null && (this._stats.bitrate.targetEncoded = 8 * r2 / (this.options.updateInterval / 1e3));
        }, t2;
      }(d$), l$ = function(e2) {
        function t2() {
          return e2 !== null && e2.apply(this, arguments) || this;
        }
        return ZZ(t2, e2), t2.prototype.updateStats = function() {
          return Promise.resolve();
        }, t2;
      }(d$);
      function p$(e2, t2, r2, i2) {
        t2 === void 0 && (t2 = 250), r2 === void 0 && (r2 = 8), i2 === void 0 && (i2 = 500);
        var n2, o2 = (n2 = navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]*/i)) && n2[0] ? Number(n2[0].split("/")[1]) : null;
        return o2 ? o2 < 76 ? new u$(e2, { updateInterval: t2, lossRateInterval: r2, freezeRateLimit: i2 }) : new h$(e2, { updateInterval: t2, lossRateInterval: r2, freezeRateLimit: i2 }) : function(e3) {
          return !!window.RTCStatsReport && e3.getStats() instanceof Promise;
        }(e2) ? new h$(e2, { updateInterval: t2, lossRateInterval: r2, freezeRateLimit: i2 }) : new l$(e2, { updateInterval: t2, lossRateInterval: r2, freezeRateLimit: i2 });
      }
      function g$(e2, t2) {
        var r2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          t2 && (i2 = i2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), r2.push.apply(r2, i2);
        }
        return r2;
      }
      function f$(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r2 = arguments[t2] != null ? arguments[t2] : {};
          t2 % 2 ? g$(Object(r2), true).forEach(function(t3) {
            kO(e2, t3, r2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : g$(Object(r2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
          });
        }
        return e2;
      }
      let E$ = (zF((A$ = class e2 extends Dk {
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        constructor(t2, r2) {
          super(t2, r2), kO(this, "store", void 0), kO(this, "peerConnection", void 0), kO(this, "remoteSDP", void 0), kO(this, "initialOffer", void 0), kO(this, "statsFilter", void 0), kO(this, "useRTX", false), kO(this, "localCapabilities", void 0), kO(this, "localCandidateCount", 0), kO(this, "allCandidatesReceived", false), kO(this, "mutex", new kV("P2PConnection-mutex")), this.store = r2, this.peerConnection = new RTCPeerConnection(e2.resolvePCConfiguration(t2), { optional: [{ googDscp: true }] }), this.statsFilter = p$(this.peerConnection, void 0, void 0, gO() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1;
        }
        async establish() {
          try {
            const e3 = await this.peerConnection.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
            if (!e3.sdp)
              throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
            const t2 = QZ(e3.sdp), r2 = UZ(e3.sdp, !this.useRTX, false, ["opus"]);
            return this.localCapabilities = r2, this.initialOffer = e3, f$(f$({}, t2), {}, { rtpCapabilities: { send: { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, recv: { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, sendrecv: r2 }, offerSDP: e3.sdp });
          } catch (e3) {
            throw new tD(eD.GET_LOCAL_CONNECTION_PARAMS_FAILED, e3.toString());
          }
        }
        async connect(e3, t2, r2, i2, n2, o2) {
          try {
            if (!this.initialOffer)
              throw new Error("Cannot establish P2PConnection without initial offer.");
            this.remoteSDP = new WZ({ remoteIceParameters: e3, remoteDtlsParameters: t2, candidates: r2, remoteRTPCapabilities: i2.send, remoteSetup: n2, localCapabilities: this.localCapabilities, sdkCodec: this.store.codec, cname: o2 });
            const s2 = this.remoteSDP.toString();
            await this.peerConnection.setLocalDescription(this.initialOffer), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: s2 });
          } catch (e4) {
            throw new tD(eD.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e4.toString()));
          }
        }
        send(e3, t2) {
          var r2 = this;
          return dZ(function* () {
            const i2 = yield uZ(r2.mutex.lock());
            try {
              if (!r2.remoteSDP)
                throw new Error("Cannot call P2PConnection.send before remote SDP created");
              const n2 = e3.map((e4) => r2.peerConnection.addTrack(e4._mediaStreamTrack)), o2 = yield uZ(r2.peerConnection.createOffer()), s2 = kZ.exports.parse(o2.sdp), a2 = e3.map((e4) => {
                const t3 = e4._mediaStreamTrack, i3 = s2.mediaDescriptions.find((e5) => e5.attributes.mid === t3.kind);
                if (!i3)
                  throw new Error("Cannot extract ssrc from mediaDescription.");
                return function(e5, t4, r3) {
                  const i4 = e5.attributes.ssrcs.filter((e6) => e6.attributes.label === t4), n3 = e5.attributes.ssrcGroups;
                  if (i4.length === 0)
                    throw new Error("Cannot extract ssrc from plan-b SDP.");
                  if (n3 && i4.length > 1) {
                    const e6 = n3.find((e7) => e7.ssrcIds.indexOf(i4[0].ssrcId) !== -1);
                    return e6 ? [{ ssrcId: e6.ssrcIds[0], rtx: r3 ? e6.ssrcIds[1] : void 0 }] : [{ ssrcId: i4[0].ssrcId }];
                  }
                  return [{ ssrcId: i4[0].ssrcId }];
                }(i3, t3.id, r2.useRTX);
              });
              let c2;
              try {
                c2 = yield a2;
              } catch (e4) {
                throw n2.forEach((e5) => {
                  pO() && e5.replaceTrack(null), r2.peerConnection.removeTrack(e5);
                }), e4;
              }
              const d2 = r2.mungSendOfferSDP(o2.sdp, e3);
              r2.remoteSDP.receive(e3, t2, c2);
              const u2 = r2.remoteSDP.toString();
              return yield uZ(r2.peerConnection.setLocalDescription({ type: "offer", sdp: d2 })), yield uZ(r2.applySendEncodings(n2, e3)), yield uZ(r2.peerConnection.setRemoteDescription({ type: "answer", sdp: u2 })), e3.map((e4, t3) => {
                const r3 = e4._mediaStreamTrack.id;
                return { localSSRC: a2[t3], id: r3 };
              });
            } catch (e4) {
              throw new tD(eD.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e4.toString()));
            } finally {
              i2();
            }
          })();
        }
        async stopSending(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
            const t2 = this.peerConnection.getSenders().filter((t3) => {
              var r3;
              return e3.indexOf(((r3 = t3.track) === null || r3 === void 0 ? void 0 : r3.id) || "") !== -1;
            });
            if (t2.length !== e3.length)
              throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");
            t2.map((e4) => {
              pO() && e4.replaceTrack(null), this.peerConnection.removeTrack(e4);
            });
            const r2 = await this.peerConnection.createOffer();
            await this.peerConnection.setLocalDescription(r2), this.remoteSDP.stopReceiving(e3);
            const i2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "answer", sdp: i2 });
          } catch (e4) {
            throw new tD(eD.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e4.toString()));
          }
        }
        async receive(e3, t2, r2, i2) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.receive ".concat(e3, " before remoteSDP created."));
            const { id: r3, mslabel: n2 } = this.remoteSDP.send(e3, t2, i2), o2 = new nR((t3, i3) => {
              const o3 = setTimeout(() => {
                i3(new Error("Cannot receive track, id: ".concat(r3)));
              }, 1e4), s3 = (i4) => {
                const a3 = oO();
                if ((a3.name === "Safari" && Number(a3.version) === 11 || fO()) && i4.track.id !== r3 && i4.streams[0].id === n2) {
                  var c2;
                  const n3 = i4.streams[0].getTracks()[0];
                  return (c2 = this.remoteSDP) === null || c2 === void 0 || c2.updateTrackLabel(e3, r3, i4.track.id), this.peerConnection.removeEventListener("track", s3), clearTimeout(o3), void t3(n3);
                }
                if (i4.track.id === r3)
                  return this.peerConnection.removeEventListener("track", s3), clearTimeout(o3), void t3(i4.track);
              };
              this.peerConnection.addEventListener("track", s3);
            }), s2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: s2 });
            const a2 = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(a2);
            return { track: await o2, id: r3 };
          } catch (e4) {
            throw new tD(eD.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async stopReceiving(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
            this.remoteSDP.stopSending(e3);
            const t2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const r2 = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(r2);
          } catch (e4) {
            throw new tD(eD.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e4.toString()));
          }
        }
        async muteRemote(e3) {
        }
        async unmuteRemote(e3) {
        }
        async muteLocal(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
            const t2 = this.peerConnection.getSenders().filter((t3) => {
              var r2;
              return e3.indexOf(((r2 = t3.track) === null || r2 === void 0 ? void 0 : r2.id) || "") !== -1;
            });
            if (t2.length !== e3.length)
              throw new Error("sender' length doesn't match mids' length.");
            t2.map((e4) => {
              if (pO() && e4.track)
                e4.track.enabled = false;
              else {
                const t3 = e4.getParameters();
                t3.encodings.forEach((e5) => e5.active = false), e4.setParameters(t3);
              }
            });
          } catch (e4) {
            throw new tD(eD.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e4.toString()));
          }
        }
        async unmuteLocal(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
            const t2 = this.peerConnection.getSenders().filter((t3) => {
              var r3;
              return e3.indexOf(((r3 = t3.track) === null || r3 === void 0 ? void 0 : r3.id) || "") !== -1;
            });
            if (t2.length !== e3.length)
              throw new Error("Senders' length doesn't match mids' length.");
            t2.map(async (e4) => {
              if (pO() && e4.track)
                e4.track.enabled = true;
              else {
                const t3 = e4.getParameters();
                t3.encodings.forEach((e5) => e5.active = true), await e4.setParameters(t3);
              }
            });
            const r2 = await this.peerConnection.createOffer();
            await this.peerConnection.setLocalDescription(r2);
            const i2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "answer", sdp: i2 });
          } catch (e4) {
            throw new tD(eD.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e4.toString()));
          }
        }
        async reEstablish() {
          const e3 = await this.peerConnection.createOffer({ iceRestart: true });
          if (!e3.sdp)
            throw new Error("Cannot get SDP from restart offer.");
          return { iceParameters: QZ(e3.sdp).iceParameters, restartICE: async (t2, r2) => this.restartICE(e3, t2, r2), restartOfferSDP: e3.sdp };
        }
        close() {
          var e3;
          this.peerConnection.close(), (e3 = this.onConnectionStateChange) === null || e3 === void 0 || e3.call(this, "closed"), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.statsFilter.destroy();
        }
        getStats() {
          return this.statsFilter.getStats();
        }
        getRemoteVideoIsReady(e3) {
          return this.statsFilter.getVideoIsReady(e3);
        }
        async updateEncoderConfig(e3, t2) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
            const e4 = await this.peerConnection.createOffer(), r2 = this.mungSendOfferSDP(e4.sdp, [t2]);
            this.remoteSDP.updateRecvMedia(t2._mediaStreamTrack.kind, t2);
            const i2 = this.remoteSDP.toString();
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: r2 }), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: i2 });
          } catch (e4) {
            throw new tD(eD.EXCHANGE_SDP_FAILED, e4.toString());
          }
        }
        async updateSendParameters(e3, t2) {
          const r2 = this.peerConnection.getSenders().filter((t3) => {
            var r3;
            return ((r3 = t3.track) === null || r3 === void 0 ? void 0 : r3.id) === e3;
          });
          r2.length === 1 && await this.applySendEncodings(r2, [t2]);
        }
        setStatsRemoteVideoIsReady(e3, t2) {
          this.statsFilter.setVideoIsReady2(e3, t2);
        }
        async replaceTrack(e3, t2) {
          const r2 = this.peerConnection.getSenders().find((e4) => {
            var r3;
            return ((r3 = e4.track) === null || r3 === void 0 ? void 0 : r3.id) === t2;
          });
          r2 && await r2.replaceTrack(e3._mediaStreamTrack);
        }
        async restartICE(e3, t2, r2) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot restartICE before remoteSDP created.");
            this.remoteSDP.restartICE(t2, r2);
            const i2 = this.remoteSDP.toString();
            await this.peerConnection.setLocalDescription(e3), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: i2 });
          } catch (e4) {
            throw new tD(eD.EXCHANGE_SDP_FAILED, "P2PConnection.restartICE failed; ".concat(e4.toString()));
          }
        }
        bindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = () => {
            var e3;
            (e3 = this.onICEConnectionStateChange) === null || e3 === void 0 || e3.call(this, this.peerConnection.iceConnectionState);
          }, this.peerConnection.onconnectionstatechange = () => {
            var e3;
            (e3 = this.onConnectionStateChange) === null || e3 === void 0 || e3.call(this, this.peerConnection.connectionState);
          }, this.peerConnection.onicecandidate = (e3) => {
            e3.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, dD.debug("[pc-".concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
          }, setTimeout(() => {
            this.allCandidatesReceived || (this.allCandidatesReceived = true, dD.debug("[pc-".concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
          }, JD("CANDIDATE_TIMEOUT"));
        }
        unbindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
        }
        static resolvePCConfiguration(t2) {
          const r2 = { iceServers: [], sdpSemantics: "plan-b" };
          return t2.iceServers ? r2.iceServers = t2.iceServers : t2.turnServer && t2.turnServer.mode !== "off" && (QP(t2.turnServer.servers) ? r2.iceServers = t2.turnServer.servers : (r2.iceServers && r2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.servers)), JD("USE_TURN_SERVER_OF_GATEWAY") && r2.iceServers && t2.turnServer.serversFromGateway && r2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.serversFromGateway)), t2.turnServer.servers.concat(t2.turnServer.serversFromGateway || []).forEach((e3) => {
            e3.forceturn && (r2.iceTransportPolicy = "relay");
          }))), r2;
        }
        static turnServerConfigToIceServers(e3) {
          const t2 = [];
          return e3.forEach((e4) => {
            e4.security ? e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turns:".concat(e4.turnServerURL, ":").concat(e4.tcpport, "?transport=tcp") }) : (e4.udpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.udpport, "?transport=udp") }), e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.tcpport, "?transport=tcp") }));
          }), t2;
        }
        async applySendEncodings(e3, t2) {
          try {
            if (!Mk().supportSetRtpSenderParameters)
              return;
            if (e3.length !== t2.length)
              return;
            for (let i2 = 0; i2 < e3.length; i2++) {
              var r2;
              const n2 = e3[i2], o2 = t2[i2];
              if (!o2)
                continue;
              const s2 = {}, a2 = {};
              if (o2 instanceof $q)
                switch (o2._optimizationMode) {
                  case "motion":
                    s2.degradationPreference = "maintain-framerate";
                    break;
                  case "detail":
                    s2.degradationPreference = "maintain-resolution";
                    break;
                  default:
                    s2.degradationPreference = "balanced";
                }
              if (JD("DSCP_TYPE") && yO()) {
                const e4 = JD("DSCP_TYPE");
                ["very-low", "low", "medium", "high"].includes(e4) && (a2.networkPriority = e4);
              }
              const c2 = n2.getParameters(), d2 = (r2 = c2.encodings) === null || r2 === void 0 ? void 0 : r2[0];
              d2 && Object.assign(d2, a2), Object.assign(c2, s2), await n2.setParameters(c2);
            }
          } catch (e4) {
            dD.debug("Apply RTPSendEncodings failed.");
          }
        }
        mungSendOfferSDP(e3, t2) {
          const r2 = kZ.exports.parse(e3);
          return t2.forEach((e4, t3) => {
            const i2 = e4._mediaStreamTrack, n2 = r2.mediaDescriptions.find((e5) => e5.attributes.mid === i2.kind);
            n2 && VZ(n2, e4);
          }), kZ.exports.print(r2);
        }
        bindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = (e3) => {
            var t2;
            (t2 = this.onFirstAudioReceived) === null || t2 === void 0 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoReceived = (e3) => {
            var t2;
            (t2 = this.onFirstVideoReceived) === null || t2 === void 0 || t2.call(this, e3);
          }, this.statsFilter.onFirstAudioDecoded = (e3) => {
            var t2;
            (t2 = this.onFirstAudioDecoded) === null || t2 === void 0 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoDecoded = (e3, t2, r2) => {
            var i2;
            (i2 = this.onFirstVideoDecoded) === null || i2 === void 0 || i2.call(this, e3, t2, r2);
          }, this.statsFilter.onSelectedLocalCandidateChanged = (e3, t2) => {
            var r2;
            (r2 = this.onSelectedLocalCandidateChanged) === null || r2 === void 0 || r2.call(this, e3, t2);
          }, this.statsFilter.onSelectedRemoteCandidateChanged = (e3, t2) => {
            var r2;
            (r2 = this.onSelectedRemoteCandidateChanged) === null || r2 === void 0 || r2.call(this, e3, t2);
          };
        }
        unbindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0;
        }
        async batchReceive(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");
            const t2 = this.remoteSDP.batchSend(e3).map((t3, r3) => {
              let { id: i3, mslabel: n2 } = t3;
              const { kind: o2 } = e3[r3];
              return new nR((e4, t4) => {
                const r4 = setTimeout(() => {
                  t4(new Error("Cannot receive track, id: ".concat(i3)));
                }, 1e4), s2 = (t5) => {
                  const a2 = oO();
                  if (a2.name === "Safari" && Number(a2.version) === 11 && t5.track.id !== i3 && t5.streams[0].id === n2) {
                    var c2;
                    const n3 = t5.streams[0].getTracks()[0];
                    return (c2 = this.remoteSDP) === null || c2 === void 0 || c2.updateTrackLabel(o2, i3, t5.track.id), this.peerConnection.removeEventListener("track", s2), clearTimeout(r4), void e4({ track: n3, id: i3 });
                  }
                  if (t5.track.id === i3)
                    return this.peerConnection.removeEventListener("track", s2), clearTimeout(r4), void e4({ track: t5.track, id: i3 });
                };
                this.peerConnection.addEventListener("track", s2);
              });
            }), r2 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: r2 });
            const i2 = await this.peerConnection.createAnswer();
            return await this.peerConnection.setLocalDescription(i2), await nR.all(t2);
          } catch (e4) {
            throw new tD(eD.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
      }).prototype, "connect", [I$], Object.getOwnPropertyDescriptor(A$.prototype, "connect"), A$.prototype), zF(A$.prototype, "stopSending", [I$], Object.getOwnPropertyDescriptor(A$.prototype, "stopSending"), A$.prototype), zF(A$.prototype, "receive", [I$], Object.getOwnPropertyDescriptor(A$.prototype, "receive"), A$.prototype), zF(A$.prototype, "stopReceiving", [I$], Object.getOwnPropertyDescriptor(A$.prototype, "stopReceiving"), A$.prototype), zF(A$.prototype, "muteRemote", [I$], Object.getOwnPropertyDescriptor(A$.prototype, "muteRemote"), A$.prototype), zF(A$.prototype, "unmuteRemote", [I$], Object.getOwnPropertyDescriptor(A$.prototype, "unmuteRemote"), A$.prototype), zF(A$.prototype, "muteLocal", [I$], Object.getOwnPropertyDescriptor(A$.prototype, "muteLocal"), A$.prototype), zF(A$.prototype, "unmuteLocal", [I$], Object.getOwnPropertyDescriptor(A$.prototype, "unmuteLocal"), A$.prototype), zF(A$.prototype, "reEstablish", [I$], Object.getOwnPropertyDescriptor(A$.prototype, "reEstablish"), A$.prototype), zF(A$.prototype, "close", [I$], Object.getOwnPropertyDescriptor(A$.prototype, "close"), A$.prototype), zF(A$.prototype, "updateEncoderConfig", [I$], Object.getOwnPropertyDescriptor(A$.prototype, "updateEncoderConfig"), A$.prototype), zF(A$.prototype, "updateSendParameters", [I$], Object.getOwnPropertyDescriptor(A$.prototype, "updateSendParameters"), A$.prototype), zF(A$.prototype, "replaceTrack", [I$], Object.getOwnPropertyDescriptor(A$.prototype, "replaceTrack"), A$.prototype), zF(A$.prototype, "restartICE", [I$], Object.getOwnPropertyDescriptor(A$.prototype, "restartICE"), A$.prototype), A$);
      function I$(e2, t2, r2) {
        const i2 = e2[t2];
        if (typeof i2 != "function")
          throw new Error("Cannot use mutex on object property.");
        return r2.value = async function() {
          const e3 = this.mutex, r3 = await e3.lock("Locking from P2PConnection.".concat(t2));
          try {
            for (var n2 = arguments.length, o2 = new Array(n2), s2 = 0; s2 < n2; s2++)
              o2[s2] = arguments[s2];
            return await i2.apply(this, o2);
          } finally {
            r3();
          }
        }, r2;
      }
      var m$;
      const _$ = "9", C$ = 4e4;
      let v$ = PD("RemoteSDP")(m$ = class {
        get localCapabilities() {
          return BG(this._localCapabilities);
        }
        get rtpCapabilities() {
          return BG(this._rtpCapabilities);
        }
        get candidates() {
          return BG(this._candidates);
        }
        get iceParameters() {
          return BG(this._iceParameters);
        }
        get dtlsParameters() {
          return BG(this._dtlsParameters);
        }
        constructor(e2) {
          kO(this, "sessionDesc", void 0), kO(this, "_localCapabilities", void 0), kO(this, "_rtpCapabilities", void 0), kO(this, "_candidates", void 0), kO(this, "_iceParameters", void 0), kO(this, "_dtlsParameters", void 0), kO(this, "setup", void 0), kO(this, "currentMidIndex", void 0), kO(this, "cname", void 0), e2 = BG(e2);
          const { remoteIceParameters: t2, remoteDtlsParameters: r2, candidates: i2, remoteRTPCapabilities: n2, remoteSetup: o2, localCapabilities: s2, cname: a2 } = e2, c2 = kZ.exports.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1\na=msid-semantic: WMS\na=ice-lite\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\n");
          this._rtpCapabilities = n2, this._candidates = i2, this._iceParameters = t2, this._dtlsParameters = r2, this._localCapabilities = s2, this.setup = o2, this.cname = a2;
          const d2 = this.rtpCapabilities.send;
          for (const e3 of c2.mediaDescriptions) {
            if (e3.attributes.iceUfrag = t2.iceUfrag, e3.attributes.icePwd = t2.icePwd, e3.attributes.fingerprints = r2.fingerprints, e3.attributes.candidates = i2, e3.attributes.setup = o2, e3.media.mediaType === "video" && (e3.media.fmts = d2.videoCodecs.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = d2.videoCodecs, e3.attributes.extmaps = d2.videoExtensions, JD("PRELOAD_MEDIA_COUNT") > 0)) {
              const { ssrcs: t3, ssrcGroups: r3 } = FZ([{ ssrcId: C$, rtx: JD("USE_RTX") ? 40001 : void 0 }], this.cname);
              e3.attributes.ssrcs = t3, e3.attributes.ssrcGroups = r3;
            }
            if (e3.media.mediaType === "audio" && (e3.media.fmts = d2.audioCodecs.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = d2.audioCodecs, e3.attributes.extmaps = d2.audioExtensions, JD("PRELOAD_MEDIA_COUNT") > 0)) {
              const { ssrcs: t3, ssrcGroups: r3 } = FZ([{ ssrcId: 2e4 }], this.cname);
              e3.attributes.ssrcs = t3, e3.attributes.ssrcGroups = r3;
            }
          }
          this.sessionDesc = c2, this.currentMidIndex = c2.mediaDescriptions.length - 1;
        }
        preloadRemoteMedia() {
          const e2 = JD("PRELOAD_MEDIA_COUNT");
          ND("debug", this, "preloadRemoteMedia", e2), this.rtpCapabilities;
          const t2 = this.candidates, r2 = this.dtlsParameters, i2 = this.iceParameters, n2 = this.rtpCapabilities.send;
          for (let o2 = 1; o2 < e2; o2++) {
            const e3 = 2 * o2 + 2e4, s2 = 2 * o2 + C$, { ssrcs: a2, ssrcGroups: c2 } = FZ([{ ssrcId: e3 }], this.cname), { ssrcs: d2, ssrcGroups: u2 } = FZ([{ ssrcId: s2, rtx: JD("USE_RTX") ? s2 + 1 : void 0 }], this.cname);
            this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "video", port: _$, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: n2.videoCodecs.map((e4) => e4.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: i2.iceUfrag, icePwd: i2.icePwd, unrecognized: [], candidates: t2, extmaps: n2.videoExtensions, fingerprints: r2.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: d2, ssrcGroups: u2, rtcpFeedbackWildcards: [], payloads: n2.videoCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(2 * o2) } }), this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "audio", port: _$, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: n2.audioCodecs.map((e4) => e4.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: i2.iceUfrag, icePwd: i2.icePwd, unrecognized: [], candidates: t2, extmaps: n2.audioExtensions, fingerprints: r2.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: a2, ssrcGroups: c2, rtcpFeedbackWildcards: [], payloads: n2.audioCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(2 * o2 + 1) } }), this.currentMidIndex += 2;
          }
          this.updateBundleMids();
        }
        toString() {
          return kZ.exports.print(this.sessionDesc);
        }
        send(e2, t2, r2, i2) {
          const { ssrcs: n2, ssrcGroups: o2 } = FZ(t2, this.cname, r2), s2 = this.findPreloadMediaDesc(n2);
          if (s2) {
            if (i2 && (i2.tcc || i2.remb)) {
              const e3 = this.sessionDesc.mediaDescriptions.indexOf(s2);
              return this.sessionDesc.mediaDescriptions[e3] = this.mungSendMediaDesc(s2, i2), { mid: s2.attributes.mid, needExchangeSDP: true };
            }
            return { mid: s2.attributes.mid, needExchangeSDP: false };
          }
          {
            const t3 = this.findAvailableMediaIndex(e2);
            if (pO() || EO()) {
              if (t3 !== -1 && t3 !== 1) {
                const e3 = BG(this.sessionDesc.mediaDescriptions[t3]);
                return e3.attributes.direction = "sendonly", e3.attributes.ssrcs = n2, e3.attributes.ssrcGroups = o2, this.sessionDesc.mediaDescriptions[t3] = this.mungSendMediaDesc(e3, i2), { mid: e3.attributes.mid, needExchangeSDP: true };
              }
              {
                const t4 = this.createOrRecycleSendMedia(e2, n2, o2, "sendonly", i2);
                return this.updateBundleMids(), { mid: t4.attributes.mid, needExchangeSDP: true };
              }
            }
            if (t3 !== -1) {
              const e3 = BG(this.sessionDesc.mediaDescriptions[t3]);
              return e3.attributes.direction = "sendonly", e3.attributes.ssrcs = n2, e3.attributes.ssrcGroups = o2, this.sessionDesc.mediaDescriptions[t3] = this.mungSendMediaDesc(e3, i2), { mid: e3.attributes.mid, needExchangeSDP: true };
            }
            {
              const t4 = this.createOrRecycleSendMedia(e2, n2, o2, "sendonly", i2);
              return this.updateBundleMids(), { mid: t4.attributes.mid, needExchangeSDP: true };
            }
          }
        }
        batchSend(e2) {
          const t2 = e2.map((e3) => {
            let { kind: t3, ssrcMsg: r3, mslabel: i3 } = e3;
            return this.send(t3, r3, i3);
          }), r2 = [];
          let i2 = false;
          return t2.forEach((e3) => {
            let { mid: t3, needExchangeSDP: n2 } = e3;
            n2 && (i2 = true), r2.push(t3);
          }), { mids: r2, needExchangeSDP: i2 };
        }
        stopSending(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => t3.attributes.mid && e2.indexOf(t3.attributes.mid) !== -1);
          if (t2.length !== e2.length)
            throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");
          t2.forEach((e3) => {
            e3.attributes.mid === "0" || gO() || pO() || EO() ? e3.attributes.ssrcs = [] : (e3.attributes.ssrcs = [], e3.attributes.direction = "inactive", e3.media.port = "0");
          }), this.updateBundleMids();
        }
        mute(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2);
          if (!t2)
            throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.mute."));
          t2.attributes.direction = "inactive";
        }
        unmute(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2);
          if (!t2)
            throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.unmute."));
          t2.attributes.direction = "sendonly";
        }
        muteRemote(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => e2.includes(t3.attributes.mid || ""));
          if (t2.length !== e2.length)
            throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
          t2.forEach((e3) => {
            e3.attributes.direction = "inactive";
          });
        }
        unmuteRemote(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => e2.includes(t3.attributes.mid || ""));
          if (t2.length !== e2.length)
            throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
          t2.forEach((e3) => {
            e3.attributes.direction = "recvonly";
          });
        }
        receive(e2, t2, r2, i2) {
          e2.forEach((e3, n2) => {
            this.createOrRecycleRecvMedia(e3, [], "recvonly", t2, r2, i2[n2]);
          }), this.updateBundleMids();
        }
        stopReceiving(e2) {
          const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => e2.indexOf(t3.attributes.mid) !== -1);
          if (t2.length !== e2.length)
            throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");
          t2.forEach((e3) => {
            e3.media.port = "0", e3.attributes.direction = "inactive";
          }), this.updateBundleMids();
        }
        restartICE(e2, t2) {
          e2 = BG(e2), t2 = BG(t2), this._iceParameters = e2, this._candidates = t2, this.sessionDesc.mediaDescriptions.forEach((t3) => {
            t3.attributes.iceUfrag = e2.iceUfrag, t3.attributes.icePwd = e2.icePwd, t3.attributes.candidates = this.candidates;
          });
        }
        predictReceivingMids(e2) {
          const t2 = [];
          for (let r2 = 0; r2 < e2; r2++)
            t2.push((this.currentMidIndex + r2 + 1).toString(10));
          return t2;
        }
        findAvailableMediaIndex(e2) {
          return this.sessionDesc.mediaDescriptions.findIndex((t2) => t2.media.mediaType === e2 && t2.media.port !== "0" && (t2.attributes.direction === "sendonly" || t2.attributes.direction === "sendrecv") && t2.attributes.ssrcs.length === 0);
        }
        createOrRecycleRecvMedia(e2, t2, r2, i2, n2, o2) {
          const s2 = e2._mediaStreamTrack.kind, a2 = this.rtpCapabilities.recv, c2 = this.localCapabilities.send;
          let d2 = [];
          if (s2 === yk.VIDEO) {
            var u2, A2;
            if (JD("H264_PROFILE_LEVEL_ID") && i2 === "h264" && (d2 = a2.videoCodecs.filter((e3) => {
              var t3, r3;
              return (((t3 = e3.rtpMap) === null || t3 === void 0 ? void 0 : t3.encodingName.toLowerCase()) || "").includes(i2) && (e3 == null || (r3 = e3.fmtp) === null || r3 === void 0 ? void 0 : r3.parameters["profile-level-id"]) === JD("H264_PROFILE_LEVEL_ID");
            })), !d2 || ((u2 = d2) === null || u2 === void 0 ? void 0 : u2.length) === 0) {
              const e3 = c2.videoCodecs.filter((e4) => {
                var t3;
                return (((t3 = e4.rtpMap) === null || t3 === void 0 ? void 0 : t3.encodingName.toLowerCase()) || "").includes(i2);
              });
              e3.length !== 0 && (d2 = a2.videoCodecs.filter((t3) => e3.some((e4) => e4.payloadType === t3.payloadType)));
            }
            if (JD("USE_RTX")) {
              const e3 = d2.map((e4) => e4.payloadType.toString()), t3 = a2.videoCodecs.filter((t4) => {
                var r3, i3;
                return ((r3 = t4.rtpMap) === null || r3 === void 0 ? void 0 : r3.encodingName) === "rtx" && e3.includes(((i3 = t4.fmtp) === null || i3 === void 0 ? void 0 : i3.parameters.apt) || "");
              });
              d2 = [...d2, ...t3];
            }
            if (d2.length === 0)
              dD.warning("codec ".concat(i2, " not included in rtpCapabilities, fallback to default payloads: ").concat((A2 = a2.videoCodecs[0].rtpMap) === null || A2 === void 0 ? void 0 : A2.encodingName)), d2 = a2.videoCodecs;
          } else
            d2 = a2.audioCodecs.filter((e3) => {
              var t3;
              return (((t3 = e3.rtpMap) === null || t3 === void 0 ? void 0 : t3.encodingName.toLowerCase()) || "").includes(n2);
            }), d2.length === 0 && (dD.warning("codec ".concat(n2, " not included in rtpCapabilities, fallback to opus")), d2 = a2.audioCodecs.filter((e3) => {
              var t3;
              return (((t3 = e3.rtpMap) === null || t3 === void 0 ? void 0 : t3.encodingName.toLowerCase()) || "").includes("opus");
            }));
          const h2 = s2 === yk.VIDEO ? a2.videoExtensions : a2.audioExtensions;
          this.currentMidIndex += 1;
          const l2 = "".concat(this.currentMidIndex);
          let p2 = { media: { mediaType: s2, port: _$, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: d2.map((e3) => e3.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: h2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: d2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: r2, rtcpMux: true, rtcpRsize: true, mid: "".concat(l2) } };
          p2 = this.mungRecvMediaDsec(p2, e2, o2);
          const g2 = this.findFirstClosedMedia(s2);
          if (g2) {
            const e3 = this.sessionDesc.mediaDescriptions.indexOf(g2);
            this.sessionDesc.mediaDescriptions[e3] = p2;
          } else
            this.sessionDesc.mediaDescriptions.push(p2);
          return p2;
        }
        createOrRecycleSendMedia(e2, t2, r2, i2, n2) {
          const o2 = this.rtpCapabilities.send, s2 = e2 === yk.VIDEO ? o2.videoCodecs : o2.audioCodecs, a2 = e2 === yk.VIDEO ? o2.videoExtensions : o2.audioExtensions;
          this.currentMidIndex += 1;
          const c2 = "".concat(this.currentMidIndex);
          let d2 = { media: { mediaType: e2, port: _$, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: s2.map((e3) => e3.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: a2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: r2, rtcpFeedbackWildcards: [], payloads: s2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: i2, rtcpMux: true, rtcpRsize: true, mid: "".concat(c2) } };
          d2 = this.mungSendMediaDesc(d2, n2);
          const u2 = this.findFirstClosedMedia(e2);
          if (u2) {
            const e3 = this.sessionDesc.mediaDescriptions.indexOf(u2);
            this.sessionDesc.mediaDescriptions[e3] = d2;
          } else
            this.sessionDesc.mediaDescriptions.push(d2);
          return d2;
        }
        updateBundleMids() {
          this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter((e2) => e2.media.port !== "0").map((e2) => e2.attributes.mid);
        }
        mungRecvMediaDsec(e2, t2, r2) {
          const i2 = BG(e2);
          return jZ(i2), VZ(i2, t2), GZ(i2, t2), function(e3) {
            if (e3.media.mediaType !== "video")
              return;
            const t3 = oO();
            if (t3.name !== tO.SAFARI && t3.os !== eO.IOS)
              return;
            const r3 = e3.attributes.extmaps.findIndex((e4) => /video-orientation/g.test(e4.extensionName));
            r3 !== -1 && e3.attributes.extmaps.splice(r3, 1);
          }(i2), KZ(i2, r2, this.localCapabilities.send), i2;
        }
        mungSendMediaDesc(e2, t2) {
          const r2 = BG(e2);
          return KZ(r2, t2, this.localCapabilities.recv), r2;
        }
        updateRecvMedia(e2, t2) {
          const r2 = this.sessionDesc.mediaDescriptions.findIndex((t3) => t3.attributes.mid === e2);
          if (r2 !== -1) {
            const e3 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[r2], t2);
            this.sessionDesc.mediaDescriptions[r2] = e3;
          }
        }
        bumpMid(e2) {
          this.currentMidIndex += e2;
        }
        findFirstClosedMedia(e2) {
          return this.sessionDesc.mediaDescriptions.find((t2) => gO() ? t2.media.port === "0" && t2.media.mediaType === e2 : t2.media.port === "0");
        }
        findPreloadMediaDesc(e2) {
          return this.sessionDesc.mediaDescriptions.find((t2) => {
            var r2, i2;
            return ((r2 = t2.attributes) === null || r2 === void 0 || (i2 = r2.ssrcs[0]) === null || i2 === void 0 ? void 0 : i2.ssrcId) === e2[0].ssrcId;
          });
        }
      }) || m$;
      var S$, R$;
      function y$(e2, t2) {
        var r2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          t2 && (i2 = i2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), r2.push.apply(r2, i2);
        }
        return r2;
      }
      function T$(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r2 = arguments[t2] != null ? arguments[t2] : {};
          t2 % 2 ? y$(Object(r2), true).forEach(function(t3) {
            kO(e2, t3, r2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : y$(Object(r2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
          });
        }
        return e2;
      }
      let w$ = PD("P2PConnection", "store.p2pId")((zF((R$ = class e2 extends Dk {
        get currentLocalDescription() {
          return this.peerConnection.currentLocalDescription;
        }
        get currentRemoteDescription() {
          return this.peerConnection.currentRemoteDescription;
        }
        get peerConnectionState() {
          return this.peerConnection.connectionState;
        }
        get iceConnectionState() {
          return this.peerConnection.iceConnectionState;
        }
        constructor(t2, r2) {
          super(t2, r2), kO(this, "store", void 0), kO(this, "peerConnection", void 0), kO(this, "remoteSDP", void 0), kO(this, "initialOffer", void 0), kO(this, "transportEventReceiver", void 0), kO(this, "statsFilter", void 0), kO(this, "useRTX", JD("USE_RTX")), kO(this, "localCapabilities", void 0), kO(this, "localCandidateCount", 0), kO(this, "allCandidatesReceived", false), kO(this, "mutex", new kV("P2PConnection-mutex")), this.store = r2, this.peerConnection = new RTCPeerConnection(e2.resolvePCConfiguration(t2), { optional: [{ googDscp: true }] }), this.statsFilter = p$(this.peerConnection, void 0, void 0, gO() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1;
        }
        async establish() {
          try {
            this.peerConnection.addTransceiver("video", { direction: "recvonly" }), this.peerConnection.addTransceiver("audio", { direction: "recvonly" });
            const e3 = await this.peerConnection.createOffer();
            if (!e3.sdp)
              throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
            const t2 = QZ(e3.sdp), r2 = await async function(e4, t3, r3, i2) {
              const n2 = new RTCPeerConnection();
              n2.addTransceiver("video", { direction: "sendonly" }), n2.addTransceiver("audio", { direction: "sendonly" }), n2.addTransceiver("video", { direction: "recvonly" }), n2.addTransceiver("audio", { direction: "recvonly" });
              const o2 = (await n2.createOffer()).sdp, s2 = UZ(o2, e4, t3, r3, i2, "sendonly"), a2 = UZ(o2, e4, t3, r3, i2, "recvonly"), c2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, d2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, u2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] };
              if (HZ(s2, a2, "videoExtensions", c2, d2, u2), HZ(s2, a2, "videoCodecs", c2, d2, u2), HZ(s2, a2, "audioExtensions", c2, d2, u2), HZ(s2, a2, "audioCodecs", c2, d2, u2), JD("RAISE_H264_BASELINE_PRIORITY")) {
                const e5 = u2.videoCodecs.findIndex((e6) => {
                  var t4, r4;
                  return ((t4 = e6.rtpMap) === null || t4 === void 0 ? void 0 : t4.encodingName.toLocaleLowerCase()) === "h264" && ((r4 = e6.fmtp) === null || r4 === void 0 ? void 0 : r4.parameters["profile-level-id"]) === "42001f";
                });
                if (e5 !== -1) {
                  const t4 = u2.videoCodecs.findIndex((e6) => {
                    var t5;
                    return ((t5 = e6.rtpMap) === null || t5 === void 0 ? void 0 : t5.encodingName.toLocaleLowerCase()) === "h264";
                  });
                  if (t4 < e5) {
                    dD.debug("raising H264 baseline profile priority");
                    const r4 = u2.videoCodecs[e5];
                    u2.videoCodecs.splice(e5, 1), u2.videoCodecs.splice(t4, 0, r4);
                  }
                  t4 !== -1 && (d2.videoCodecs = d2.videoCodecs.filter((e6) => {
                    var t5, r4;
                    return !(((t5 = e6.rtpMap) === null || t5 === void 0 ? void 0 : t5.encodingName.toLocaleLowerCase()) === "h264" && ((r4 = e6.fmtp) === null || r4 === void 0 ? void 0 : r4.parameters["profile-level-id"]) !== "42001f");
                  })), t4 !== -1 && JD("FILTER_SEND_H264_BASELINE") && (c2.videoCodecs = c2.videoCodecs.filter((e6) => {
                    var t5, r4;
                    return !(((t5 = e6.rtpMap) === null || t5 === void 0 ? void 0 : t5.encodingName.toLocaleLowerCase()) === "h264" && ((r4 = e6.fmtp) === null || r4 === void 0 ? void 0 : r4.parameters["profile-level-id"]) !== "42001f");
                  }));
                }
              }
              try {
                n2.close();
              } catch (e5) {
              }
              return { send: c2, recv: d2, sendrecv: u2 };
            }(!this.useRTX, false);
            return this.localCapabilities = YZ(r2), this.initialOffer = e3, T$(T$({}, t2), {}, { rtpCapabilities: r2, offerSDP: e3.sdp });
          } catch (e3) {
            throw new tD(eD.GET_LOCAL_CONNECTION_PARAMS_FAILED, e3.toString());
          }
        }
        async connect(e3, t2, r2, i2, n2, o2) {
          try {
            if (!this.initialOffer)
              throw new Error("Cannot establish P2PConnection without initial offer.");
            this.remoteSDP = new v$({ remoteIceParameters: e3, remoteDtlsParameters: t2, candidates: r2, remoteRTPCapabilities: i2, remoteSetup: n2, localCapabilities: this.localCapabilities, cname: o2 });
            const s2 = this.remoteSDP.toString(), a2 = this.logSDPExchange(this.initialOffer.sdp || "", "offer", "local", "connect");
            await this.peerConnection.setLocalDescription(this.initialOffer), a2 == null || a2(s2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: s2 });
            const c2 = this.peerConnection.getTransceivers()[0];
            if (c2 != null && c2.receiver && this.tryBindTransportEvents(c2.receiver), JD("PRELOAD_MEDIA_COUNT") > 0) {
              this.remoteSDP.preloadRemoteMedia();
              const e4 = this.remoteSDP.toString();
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e4 });
              const t3 = await this.peerConnection.createAnswer();
              await this.peerConnection.setLocalDescription(t3);
            }
          } catch (e4) {
            throw new tD(eD.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e4.toString()));
          }
        }
        send(e3, t2, r2) {
          var i2 = this;
          return dZ(function* () {
            const n2 = yield uZ(i2.mutex.lock());
            try {
              if (!i2.remoteSDP)
                throw new Error("Cannot call P2PConnection.send before remote SDP created");
              const o2 = [];
              e3.forEach((e4) => {
                const t3 = i2.peerConnection.addTransceiver(e4._mediaStreamTrack, { direction: "sendonly" });
                o2.push(t3);
              }), gO() && JD("SIMULCAST") === true && (TD("debug", i2, "apply simulcast for firefox"), yield uZ(i2.applySimulcastForFirefox(o2, e3)));
              const s2 = yield uZ(i2.peerConnection.createOffer()), a2 = i2.remoteSDP.predictReceivingMids(e3.length), c2 = i2.mungSendOfferSDP(s2.sdp, e3, a2), d2 = kZ.exports.parse(c2), u2 = a2.map((e4) => {
                const t3 = d2.mediaDescriptions.find((t4) => t4.attributes.mid === e4);
                if (!t3)
                  throw new Error("Cannot extract ssrc from mediaDescription.");
                return function(e5, t4) {
                  const r3 = [], i3 = e5.attributes.ssrcGroups.filter((e6) => e6.semantic === "FID"), n3 = e5.attributes.ssrcGroups.find((e6) => e6.semantic === "SIM"), o3 = e5.attributes.ssrcs;
                  if (n3)
                    n3.ssrcIds.forEach((e6) => {
                      var n4;
                      const o4 = (n4 = i3.find((t5) => t5.ssrcIds[0] === e6)) === null || n4 === void 0 ? void 0 : n4.ssrcIds[1];
                      r3.push({ ssrcId: e6, rtx: t4 ? o4 : void 0 });
                    });
                  else if (i3.length > 0) {
                    const e6 = i3[0].ssrcIds[0], n4 = i3[0].ssrcIds[1];
                    r3.push({ ssrcId: e6, rtx: t4 ? n4 : void 0 });
                  } else {
                    if (o3.length === 0)
                      throw new Error("No ssrcs found on local media description.");
                    r3.push({ ssrcId: o3[0].ssrcId });
                  }
                  return r3;
                }(t3, i2.useRTX);
              });
              let A2;
              try {
                A2 = yield u2;
              } catch (n3) {
                A2 = [], i2.remoteSDP.receive(e3, t2, r2, A2);
                const o3 = i2.remoteSDP.toString();
                throw yield uZ(i2.peerConnection.setLocalDescription({ type: "offer", sdp: c2 })), yield uZ(i2.peerConnection.setRemoteDescription({ type: "answer", sdp: o3 })), yield uZ(i2.stopSending(a2, true)), n3;
              }
              i2.remoteSDP.receive(e3, t2, r2, A2);
              const h2 = i2.remoteSDP.toString(), l2 = i2.logSDPExchange(c2, "offer", "local", "send");
              return yield uZ(i2.peerConnection.setLocalDescription({ type: "offer", sdp: c2 })), yield uZ(i2.applySimulcastEncodings(o2, e3)), yield uZ(i2.applySendEncodings(o2, e3)), l2 == null || l2(h2), yield uZ(i2.peerConnection.setRemoteDescription({ type: "answer", sdp: h2 })), o2.map((e4, t3) => {
                const r3 = a2[t3];
                return { localSSRC: u2[t3], id: r3, transceiver: e4 };
              });
            } catch (e4) {
              throw e4 instanceof tD ? e4 : new tD(eD.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e4.toString()));
            } finally {
              n2();
            }
          })();
        }
        async stopSending(e3, t2) {
          const r2 = t2 ? void 0 : await this.mutex.lock("From P2PConnection.stopSending");
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
            const t3 = this.peerConnection.getTransceivers().filter((t4) => e3.indexOf(t4.mid) !== -1);
            if (t3.length !== e3.length)
              throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");
            t3.map((e4) => {
              var t4;
              e4.direction = "inactive", (t4 = e4.stop) === null || t4 === void 0 || t4.call(e4);
            });
            const i2 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i2.sdp || "", "offer", "local", "stopSending");
            await this.peerConnection.setLocalDescription(i2), this.remoteSDP.stopReceiving(e3);
            const o2 = this.remoteSDP.toString();
            n2 == null || n2(o2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: o2 });
          } catch (e4) {
            throw new tD(eD.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e4.toString()));
          } finally {
            r2 && r2();
          }
        }
        async receive(e3, t2, r2, i2) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.receive ".concat(e3, " before remoteSDP created."));
            const { mid: n2, needExchangeSDP: o2 } = this.remoteSDP.send(e3, t2, r2, i2);
            if (o2) {
              const t3 = this.remoteSDP.toString(), r3 = this.logSDPExchange(t3, "offer", "remote", "receive");
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t3 });
              const i3 = await this.peerConnection.createAnswer();
              r3 == null || r3(i3.sdp || ""), await this.peerConnection.setLocalDescription(i3), dD.debug("[P2PConnection] receive ".concat(e3, " by exchanging SDP."));
            } else
              dD.debug("[P2PConnection] receive ".concat(e3, " no need to exchange SDP."));
            const s2 = this.peerConnection.getTransceivers().find((e4) => e4.mid === n2);
            if (!s2)
              throw new Error("Cannot get transceiver after setLocalDescription.");
            return { track: s2.receiver.track, id: n2 };
          } catch (e4) {
            throw new tD(eD.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async batchReceive(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");
            const { mids: t2, needExchangeSDP: r2 } = this.remoteSDP.batchSend(e3);
            if (r2) {
              const e4 = this.remoteSDP.toString(), t3 = this.logSDPExchange(e4, "offer", "remote", "receive");
              await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e4 });
              const r3 = await this.peerConnection.createAnswer();
              t3 == null || t3(r3.sdp || ""), await this.peerConnection.setLocalDescription(r3), dD.debug("[P2PConnection] batchReceive by exchanging SDP.");
            } else
              dD.debug("[P2PConnection] batchReceive no need to exchange SDP.");
            return t2.map((e4) => {
              const t3 = this.peerConnection.getTransceivers().find((t4) => t4.mid === e4);
              if (!t3)
                throw new Error("Cannot get transceiver after setLocalDescription.");
              return { track: t3.receiver.track, id: e4 };
            });
          } catch (e4) {
            throw new tD(eD.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
          }
        }
        async stopReceiving(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
            this.remoteSDP.stopSending(e3);
            const t2 = this.remoteSDP.toString(), r2 = this.logSDPExchange(t2, "offer", "remote", "stopReceiving");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const i2 = await this.peerConnection.createAnswer();
            r2 == null || r2(i2.sdp || ""), await this.peerConnection.setLocalDescription(i2);
          } catch (e4) {
            throw new tD(eD.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e4.toString()));
          }
        }
        async muteRemote(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.muteRemote mid=".concat(e3, " before remote SDP created."));
            this.remoteSDP.mute(e3);
            const t2 = this.remoteSDP.toString(), r2 = this.logSDPExchange(t2, "offer", "remote", "muteRemote");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const i2 = await this.peerConnection.createAnswer();
            r2 == null || r2(i2.sdp || ""), await this.peerConnection.setLocalDescription(i2);
          } catch (e4) {
            throw new tD(eD.EXCHANGE_SDP_FAILED, "P2PConnection.muteRemote failed; ".concat(e4.toString()));
          }
        }
        async unmuteRemote(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.unmuteRemote mid=".concat(e3, " before remote SDP created."));
            this.remoteSDP.unmute(e3);
            const t2 = this.remoteSDP.toString(), r2 = this.logSDPExchange(t2, "offer", "remote", "unmuteRemote");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
            const i2 = await this.peerConnection.createAnswer();
            r2 == null || r2(i2.sdp || ""), await this.peerConnection.setLocalDescription(i2);
          } catch (e4) {
            throw new tD(eD.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteRemote failed; ".concat(e4.toString()));
          }
        }
        async muteLocal(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
            const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && e3.indexOf(t3.mid) !== -1);
            if (t2.length !== e3.length)
              throw new Error("Transceivers' length doesn't match mids' length.");
            t2.map((e4) => {
              e4.direction = "inactive";
            });
            const r2 = await this.peerConnection.createOffer(), i2 = this.logSDPExchange(r2.sdp || "", "offer", "local", "muteLocal");
            await this.peerConnection.setLocalDescription(r2), this.remoteSDP.muteRemote(e3);
            const n2 = this.remoteSDP.toString();
            i2 == null || i2(n2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n2 });
          } catch (e4) {
            throw new tD(eD.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e4.toString()));
          }
        }
        async unmuteLocal(e3) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
            const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && e3.indexOf(t3.mid) !== -1);
            if (t2.length !== e3.length)
              throw new Error("Transceivers' length doesn't match mids' length.");
            t2.map(async (e4, t3) => {
              e4.direction = "sendonly";
            });
            const r2 = await this.peerConnection.createOffer(), i2 = this.logSDPExchange(r2.sdp || "", "offer", "local", "unmuteLocal");
            await this.peerConnection.setLocalDescription(r2), this.remoteSDP.unmuteRemote(e3);
            const n2 = this.remoteSDP.toString();
            i2 == null || i2(n2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n2 });
          } catch (e4) {
            throw new tD(eD.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e4.toString()));
          }
        }
        async reEstablish() {
          const e3 = await this.peerConnection.createOffer({ iceRestart: true });
          if (!e3.sdp)
            throw new Error("Cannot get SDP from restart offer.");
          return { iceParameters: QZ(e3.sdp).iceParameters, restartICE: async (t2, r2) => this.restartICE(e3, t2, r2), restartOfferSDP: e3.sdp };
        }
        close() {
          var e3;
          this.peerConnection.close(), (e3 = this.onConnectionStateChange) === null || e3 === void 0 || e3.call(this, "closed"), this.tryUnbindTransportEvents(), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.transportEventReceiver = void 0, this.statsFilter.destroy();
        }
        getStats() {
          return this.statsFilter.getStats();
        }
        getRemoteVideoIsReady(e3) {
          return this.statsFilter.getVideoIsReady(e3);
        }
        async updateEncoderConfig(e3, t2) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
            const r2 = await this.peerConnection.createOffer(), i2 = this.mungSendOfferSDP(r2.sdp, [t2], [e3]);
            this.remoteSDP.updateRecvMedia(e3, t2);
            const n2 = this.remoteSDP.toString(), o2 = this.logSDPExchange(i2, "offer", "local", "updateEncoderConfig");
            await this.peerConnection.setLocalDescription({ type: "offer", sdp: i2 }), o2 == null || o2(n2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n2 });
          } catch (e4) {
            throw new tD(eD.EXCHANGE_SDP_FAILED, e4.toString());
          }
        }
        async updateSendParameters(e3, t2) {
          const r2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid === e3);
          r2.length === 1 && (this.isVP8Simulcast(t2) ? gO() || await this.applySimulcastEncodings(r2, [t2]) : await this.applySendEncodings(r2, [t2]));
        }
        setStatsRemoteVideoIsReady(e3, t2) {
          this.statsFilter.setVideoIsReady2(e3, t2);
        }
        async replaceTrack(e3, t2) {
          const r2 = this.peerConnection.getTransceivers().find((e4) => e4.mid === t2);
          r2 && await r2.sender.replaceTrack(e3._mediaStreamTrack);
        }
        async restartICE(e3, t2, r2) {
          try {
            if (!this.remoteSDP)
              throw new Error("Cannot restartICE before remoteSDP created.");
            this.remoteSDP.restartICE(t2, r2);
            const i2 = this.remoteSDP.toString(), n2 = this.logSDPExchange(e3.sdp || "", "offer", "local", "restartICE");
            await this.peerConnection.setLocalDescription(e3), n2 == null || n2(i2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: i2 });
          } catch (e4) {
            throw new tD(eD.EXCHANGE_SDP_FAILED, "P2PConnection.restartICE failed; ".concat(e4.toString()));
          }
        }
        bindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = () => {
            var e3;
            (e3 = this.onICEConnectionStateChange) === null || e3 === void 0 || e3.call(this, this.peerConnection.iceConnectionState);
          }, this.peerConnection.onconnectionstatechange = () => {
            var e3;
            (e3 = this.onConnectionStateChange) === null || e3 === void 0 || e3.call(this, this.peerConnection.connectionState);
          }, this.peerConnection.onicecandidate = (e3) => {
            e3.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, dD.debug("[pc-".concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
          }, setTimeout(() => {
            this.allCandidatesReceived || (this.allCandidatesReceived = true, dD.debug("[pc-".concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
          }, JD("CANDIDATE_TIMEOUT"));
        }
        unbindPCEvents() {
          this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
        }
        static resolvePCConfiguration(t2) {
          const r2 = { iceServers: [] };
          return t2.iceServers ? r2.iceServers = t2.iceServers : t2.turnServer && t2.turnServer.mode !== "off" && (QP(t2.turnServer.servers) ? r2.iceServers = t2.turnServer.servers : (r2.iceServers && r2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.servers)), JD("USE_TURN_SERVER_OF_GATEWAY") && r2.iceServers && t2.turnServer.serversFromGateway && r2.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.serversFromGateway)), t2.turnServer.servers.concat(t2.turnServer.serversFromGateway || []).forEach((e3) => {
            e3.forceturn && (r2.iceTransportPolicy = "relay");
          }))), r2;
        }
        static turnServerConfigToIceServers(e3) {
          const t2 = [];
          return e3.forEach((e4) => {
            e4.security ? e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turns:".concat(cG(e4.turnServerURL), ":").concat(e4.tcpport, "?transport=tcp") }) : (e4.udpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.udpport, "?transport=udp") }), e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.tcpport, "?transport=tcp") }));
          }), t2;
        }
        tryBindTransportEvents(e3) {
          e3.transport && (this.transportEventReceiver = e3, e3.transport.onstatechange = () => {
            var t2, r2;
            (t2 = e3.transport) !== null && t2 !== void 0 && t2.state && ((r2 = this.onDTLSTransportStateChange) === null || r2 === void 0 || r2.call(this, e3.transport.state));
          }, e3.transport.onerror = (e4) => {
            var t2;
            (t2 = this.onDTLSTransportError) === null || t2 === void 0 || t2.call(this, e4.error);
          }, e3.transport.iceTransport && (e3.transport.iceTransport.onstatechange = () => {
            var t2, r2, i2;
            (t2 = e3.transport) !== null && t2 !== void 0 && t2.iceTransport.state && ((r2 = this.onICETransportStateChange) === null || r2 === void 0 || r2.call(this, (i2 = e3.transport) === null || i2 === void 0 ? void 0 : i2.iceTransport.state));
          }));
        }
        tryUnbindTransportEvents() {
          this.transportEventReceiver && this.transportEventReceiver.transport && (this.transportEventReceiver.transport.onstatechange = null, this.transportEventReceiver.transport.onerror = null, this.transportEventReceiver.transport.iceTransport && (this.transportEventReceiver.transport.iceTransport.onstatechange = null));
        }
        async applySendEncodings(e3, t2) {
          try {
            if (!Mk().supportSetRtpSenderParameters)
              return;
            if (e3.length !== t2.length)
              return;
            for (let c2 = 0; c2 < e3.length; c2++) {
              const d2 = e3[c2], u2 = t2[c2];
              if (u2 && u2 instanceof $q) {
                var r2, i2;
                if (this.isVP8Simulcast(u2))
                  continue;
                const e4 = {}, t3 = {};
                switch (u2._optimizationMode) {
                  case "motion":
                    e4.degradationPreference = "maintain-framerate";
                    break;
                  case "detail":
                    e4.degradationPreference = "maintain-resolution";
                    break;
                  default:
                    e4.degradationPreference = "balanced";
                }
                var n2, o2, s2, a2;
                if ((r2 = u2._encoderConfig) !== null && r2 !== void 0 && r2.bitrateMax)
                  t3.maxBitrate = 1e3 * ((n2 = u2._encoderConfig) === null || n2 === void 0 ? void 0 : n2.bitrateMax);
                if (u2._hints.includes(hk.LOW_STREAM))
                  (o2 = u2._encoderConfig) !== null && o2 !== void 0 && o2.frameRate && (t3.maxFramerate = uG(u2._encoderConfig.frameRate)), (s2 = u2._encoderConfig) !== null && s2 !== void 0 && s2.scaleResolutionDownBy && ((a2 = u2._encoderConfig) === null || a2 === void 0 ? void 0 : a2.scaleResolutionDownBy) > 1 && (t3.scaleResolutionDownBy = u2._encoderConfig.scaleResolutionDownBy);
                if (JD("DSCP_TYPE") && yO()) {
                  const e5 = JD("DSCP_TYPE");
                  ["very-low", "low", "medium", "high"].includes(e5) && (t3.networkPriority = e5);
                }
                const c3 = d2.sender.getParameters(), A2 = (i2 = c3.encodings) === null || i2 === void 0 ? void 0 : i2[0];
                gO() && !A2 && (e4.encodings = [t3]), A2 && Object.assign(A2, t3), Object.assign(c3, e4), await d2.sender.setParameters(c3);
              }
            }
          } catch (e4) {
            dD.debug("Apply RTPSendEncodings failed.");
          }
        }
        mungSendOfferSDP(e3, t2, r2) {
          const i2 = kZ.exports.parse(e3);
          return t2.forEach((e4, t3) => {
            const n2 = r2[t3], o2 = i2.mediaDescriptions.find((e5) => e5.attributes.mid === n2);
            o2 && (VZ(o2, e4), function(e5, t4, r3) {
              if (gO())
                return;
              if (e5.media.mediaType !== "video")
                return;
              if (!(t4 instanceof $q))
                return;
              if (r3 !== "vp9" && r3 !== "vp8")
                return;
              if (r3 === "vp8" && !JD("SIMULCAST"))
                return;
              if (t4._scalabiltyMode === void 0 || t4._scalabiltyMode.numSpatialLayers <= 1)
                return;
              const i3 = r3 === "vp8" ? 2 : t4._scalabiltyMode.numSpatialLayers, n3 = e5.attributes.ssrcs[0], o3 = e5.attributes.ssrcGroups.find((e6) => e6.semantic === "FID" && e6.ssrcIds[0] === n3.ssrcId), s2 = { semantic: "SIM", ssrcIds: [n3.ssrcId] };
              for (let t5 = 1; t5 < i3; t5++)
                e5.attributes.ssrcs.push({ ssrcId: n3.ssrcId + t5, attributes: BG(n3.attributes) }), s2.ssrcIds.push(n3.ssrcId + t5), o3 && (e5.attributes.ssrcs.push({ ssrcId: o3.ssrcIds[1] + t5, attributes: BG(n3.attributes) }), e5.attributes.ssrcGroups.push({ semantic: "FID", ssrcIds: [n3.ssrcId + t5, o3.ssrcIds[1] + t5] }));
              e5.attributes.ssrcGroups.unshift(s2);
            }(o2, e4, this.store.codec));
          }), kZ.exports.print(i2);
        }
        bindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = (e3) => {
            var t2;
            (t2 = this.onFirstAudioReceived) === null || t2 === void 0 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoReceived = (e3) => {
            var t2;
            (t2 = this.onFirstVideoReceived) === null || t2 === void 0 || t2.call(this, e3);
          }, this.statsFilter.onFirstAudioDecoded = (e3) => {
            var t2;
            (t2 = this.onFirstAudioDecoded) === null || t2 === void 0 || t2.call(this, e3);
          }, this.statsFilter.onFirstVideoDecoded = (e3, t2, r2) => {
            var i2;
            (i2 = this.onFirstVideoDecoded) === null || i2 === void 0 || i2.call(this, e3, t2, r2);
          }, this.statsFilter.onSelectedLocalCandidateChanged = (e3, t2) => {
            var r2;
            (r2 = this.onSelectedLocalCandidateChanged) === null || r2 === void 0 || r2.call(this, e3, t2);
          }, this.statsFilter.onSelectedRemoteCandidateChanged = (e3, t2) => {
            var r2;
            (r2 = this.onSelectedRemoteCandidateChanged) === null || r2 === void 0 || r2.call(this, e3, t2);
          };
        }
        unbindStatsEvents() {
          this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0;
        }
        async applySimulcastForFirefox(e3, t2) {
          if (e3.length === t2.length)
            for (let s2 = 0; s2 < e3.length; s2++) {
              var r2, i2, n2, o2;
              const a2 = e3[s2], c2 = t2[s2];
              if (c2 instanceof $q && !c2._hints.includes(hk.LOW_STREAM) && (r2 = c2._encoderConfig) !== null && r2 !== void 0 && r2.bitrateMax && ((i2 = c2._encoderConfig) === null || i2 === void 0 ? void 0 : i2.bitrateMax) > 200 && (n2 = c2._scalabiltyMode) !== null && n2 !== void 0 && n2.numSpatialLayers && ((o2 = c2._scalabiltyMode) === null || o2 === void 0 ? void 0 : o2.numSpatialLayers) > 1 && this.store.codec === "vp8") {
                const e4 = {}, t3 = { high: 1e3 * (c2._encoderConfig.bitrateMax - 50), medium: 5e4 };
                e4.encodings = [{ rid: "m", active: true, maxBitrate: t3.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: true, maxBitrate: t3.high }];
                const r3 = a2.sender.getParameters();
                await a2.sender.setParameters(Object.assign(r3, e4));
              }
            }
        }
        async applySimulcastEncodings(e3, t2) {
          if (!gO() && e3.length === t2.length)
            for (let r2 = 0; r2 < e3.length; r2++) {
              const i2 = t2[r2];
              if (i2 instanceof $q && this.isVP8Simulcast(i2)) {
                const t3 = e3[r2], n2 = {}, o2 = { high: 1e3 * (i2._encoderConfig.bitrateMax - 50), medium: 5e4 };
                n2.encodings = [{ active: true, adaptivePtime: false, networkPriority: "high", priority: "high", maxBitrate: o2.high }, { active: true, adaptivePtime: false, networkPriority: "low", priority: "low", maxBitrate: o2.medium, scaleResolutionDownBy: 4 }];
                const s2 = t3.sender.getParameters();
                await t3.sender.setParameters(Object.assign(s2, n2));
              }
            }
        }
        isVP8Simulcast(e3) {
          var t2, r2, i2, n2;
          return !!(e3 instanceof $q && JD("SIMULCAST") && this.store.codec === "vp8" && !e3._hints.includes(hk.LOW_STREAM) && (t2 = e3._encoderConfig) !== null && t2 !== void 0 && t2.bitrateMax && ((r2 = e3._encoderConfig) === null || r2 === void 0 ? void 0 : r2.bitrateMax) > 200 && (i2 = e3._scalabiltyMode) !== null && i2 !== void 0 && i2.numSpatialLayers && ((n2 = e3._scalabiltyMode) === null || n2 === void 0 ? void 0 : n2.numSpatialLayers) > 1);
        }
        logSDPExchange(e3, t2, r2, i2) {
          if (JD("SDP_LOGGING"))
            return dD.upload("exchanging ".concat(r2, " ").concat(t2, " SDP during P2PConnection.").concat(i2, "\n"), e3), t2 === "offer" ? (e4) => {
              this.logSDPExchange(e4, "answer", r2 === "local" ? "remote" : "local", i2);
            } : void 0;
        }
      }).prototype, "connect", [b$], Object.getOwnPropertyDescriptor(R$.prototype, "connect"), R$.prototype), zF(R$.prototype, "receive", [b$], Object.getOwnPropertyDescriptor(R$.prototype, "receive"), R$.prototype), zF(R$.prototype, "batchReceive", [b$], Object.getOwnPropertyDescriptor(R$.prototype, "batchReceive"), R$.prototype), zF(R$.prototype, "stopReceiving", [b$], Object.getOwnPropertyDescriptor(R$.prototype, "stopReceiving"), R$.prototype), zF(R$.prototype, "muteRemote", [b$], Object.getOwnPropertyDescriptor(R$.prototype, "muteRemote"), R$.prototype), zF(R$.prototype, "unmuteRemote", [b$], Object.getOwnPropertyDescriptor(R$.prototype, "unmuteRemote"), R$.prototype), zF(R$.prototype, "muteLocal", [b$], Object.getOwnPropertyDescriptor(R$.prototype, "muteLocal"), R$.prototype), zF(R$.prototype, "unmuteLocal", [b$], Object.getOwnPropertyDescriptor(R$.prototype, "unmuteLocal"), R$.prototype), zF(R$.prototype, "reEstablish", [b$], Object.getOwnPropertyDescriptor(R$.prototype, "reEstablish"), R$.prototype), zF(R$.prototype, "close", [b$], Object.getOwnPropertyDescriptor(R$.prototype, "close"), R$.prototype), zF(R$.prototype, "updateEncoderConfig", [b$], Object.getOwnPropertyDescriptor(R$.prototype, "updateEncoderConfig"), R$.prototype), zF(R$.prototype, "updateSendParameters", [b$], Object.getOwnPropertyDescriptor(R$.prototype, "updateSendParameters"), R$.prototype), zF(R$.prototype, "replaceTrack", [b$], Object.getOwnPropertyDescriptor(R$.prototype, "replaceTrack"), R$.prototype), zF(R$.prototype, "restartICE", [b$], Object.getOwnPropertyDescriptor(R$.prototype, "restartICE"), R$.prototype), S$ = R$)) || S$;
      function b$(e2, t2, r2) {
        const i2 = e2[t2];
        if (typeof i2 != "function")
          throw new Error("Cannot use mutex on object property.");
        return r2.value = async function() {
          const e3 = this.mutex, r3 = await e3.lock("From P2PConnection.".concat(t2));
          try {
            for (var n2 = arguments.length, o2 = new Array(n2), s2 = 0; s2 < n2; s2++)
              o2[s2] = arguments[s2];
            return await i2.apply(this, o2);
          } finally {
            r3();
          }
        }, r2;
      }
      function O$(e2, t2) {
        let r2 = document.createElement("video"), i2 = document.createElement("canvas");
        r2.setAttribute("style", "display:none"), i2.setAttribute("style", "display:none"), r2.setAttribute("muted", ""), r2.muted = true, r2.setAttribute("autoplay", ""), r2.autoplay = true, r2.setAttribute("playsinline", ""), i2.width = uG(t2.width), i2.height = uG(t2.height);
        const n2 = uG(t2.framerate || 15);
        document.body.append(r2), document.body.append(i2);
        let o2 = e2._mediaStreamTrack;
        r2.srcObject = new MediaStream([o2]), r2.play();
        const s2 = i2.getContext("2d");
        if (!s2)
          throw new tD(eD.UNEXPECTED_ERROR, "can not get canvas context");
        const a2 = Mk(), c2 = i2.captureStream(a2.supportRequestFrame ? 0 : n2).getVideoTracks()[0], d2 = YV(() => (() => {
          if (r2.paused && r2.play(), r2.videoHeight > 2 && r2.videoWidth > 2) {
            const e3 = r2.videoWidth, t3 = r2.videoHeight / e3, n3 = i2.width * t3;
            Math.abs(n3 - i2.height) >= 2 && (dD.debug("adjust low stream resolution", "".concat(i2.width, "x").concat(i2.height, " -> ").concat(i2.width, "x").concat(n3)), i2.height = n3);
          }
          s2.drawImage(r2, 0, 0, i2.width, i2.height), c2.requestFrame && c2.requestFrame(), o2 !== e2._mediaStreamTrack && (o2 = e2._mediaStreamTrack, r2.srcObject = new MediaStream([o2]));
        })(), n2), u2 = c2.stop;
        return c2.stop = () => {
          u2.call(c2), d2(), r2.remove(), i2.width = 0, i2.remove(), i2 = null, r2 = null, dD.debug("clean low stream renderer");
        }, c2;
      }
      var N$, D$;
      function L$(e2, t2) {
        var r2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          t2 && (i2 = i2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), r2.push.apply(r2, i2);
        }
        return r2;
      }
      function P$(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r2 = arguments[t2] != null ? arguments[t2] : {};
          t2 % 2 ? L$(Object(r2), true).forEach(function(t3) {
            kO(e2, t3, r2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : L$(Object(r2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
          });
        }
        return e2;
      }
      class k$ extends OV {
        getUserId() {
          return this._userId;
        }
        constructor(e2, t2, r2, i2) {
          super(e2, "track-".concat(e2.kind, "-").concat(t2, "-").concat(i2.clientId, "_").concat(SG(5, ""))), kO(this, "_userId", void 0), kO(this, "_uintId", void 0), kO(this, "_isDestroyed", false), kO(this, "store", void 0), this._userId = t2, this._uintId = r2, this.store = i2;
        }
        _updateOriginMediaStreamTrack(e2) {
          this._originMediaStreamTrack = e2, this._mediaStreamTrack = e2, this._updatePlayerSource();
        }
        _destroy() {
          this._isDestroyed = true, dD.info("[".concat(this.getTrackId(), "] is destroyed")), ND("info", this, "_destroy"), this.stop(), super.close();
        }
      }
      let B$ = PD("RemoteVideoTrack", "getTrackId")(N$ = class extends k$ {
        get isPlaying() {
          return !(!this._player || this._player.videoElementStatus !== dP.PLAYING);
        }
        constructor(e2, t2, r2, i2) {
          super(e2, t2, r2, i2), kO(this, "_videoVisibleTimer", null), kO(this, "_previousVideoVisibleStatus", void 0), kO(this, "_clearPreviousVideoVisibleStatus", () => this._previousVideoVisibleStatus = void 0), kO(this, "trackMediaType", "video"), kO(this, "_videoWidth", void 0), kO(this, "_videoHeight", void 0), kO(this, "_player", void 0), ND("info", this, "constructor", { userId: t2 }), this.updateMediaStreamTrackResolution();
        }
        getStats() {
          UG(() => {
            dD.warning("[deprecated] RemoteVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteVideoStats instead"), TD("warning", this, "[deprecated] RemoteVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteVideoStats instead");
          }, "remoteVideoTrackGetStatsWarning");
          return NG(this, Ak.GET_STATS) || P$({}, HP);
        }
        play(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          const r2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.REMOTE_VIDEO_TRACK_PLAY, options: [this.getTrackId(), typeof e2 == "string" ? e2 : "HTMLElement", t2] });
          if (typeof e2 == "string") {
            const t3 = document.getElementById(e2);
            t3 ? e2 = t3 : (dD.warning("[".concat(this.getTrackId(), '] can not find "#').concat(e2, '" element, use document.body')), TD("warning", this, 'can not find "#'.concat(e2, '" element, use document.body')), e2 = document.body);
          }
          dD.debug("[".concat(this.getTrackId(), "] start video playback"), JSON.stringify(t2)), ND("debug", this, "play", t2);
          const i2 = P$(P$({ fit: "cover" }, t2), {}, { trackId: this.getTrackId(), element: e2 });
          this._player ? this._player.updateConfig(i2) : (this._player = new XJ(i2), this._player.updateVideoTrack(this._mediaStreamTrack), this._player.onFirstVideoFrameDecoded = () => {
            this.store.subscribe(this.getUserId(), "video", void 0, void 0, performance.now()), this.emit(fk.FIRST_FRAME_DECODED);
          }), this._player.play(this.store.sessionId || void 0), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {
            try {
              const e3 = this.getVideoElementVisibleStatus();
              this.emit(fk.VIDEO_ELEMENT_VISIBLE_STATUS, e3);
            } catch (e3) {
            }
          }, JD("CHECK_VIDEO_VISIBLE_INTERVAL")), r2.onSuccess();
        }
        stop() {
          const e2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.REMOTE_VIDEO_TRACK_STOP, options: [this.getTrackId()] });
          if (!this._player)
            return e2.onSuccess();
          this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, dD.debug("[".concat(this.getTrackId(), "] stop video playback")), ND("debug", this, "stop"), e2.onSuccess();
        }
        getCurrentFrameData() {
          return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);
        }
        updateMediaStreamTrackResolution() {
          TG(this._originMediaStreamTrack).then((e2) => {
            let [t2, r2] = e2;
            this._videoHeight = r2, this._videoWidth = t2;
          }).catch(yG);
        }
        _updatePlayerSource() {
          dD.debug("[".concat(this.getTrackId(), "] update player source track")), ND("debug", this, "_updatePlayerSource"), this._player && this._player.updateVideoTrack(this._mediaStreamTrack);
        }
        getVideoElementVisibleStatus() {
          try {
            var e2, t2;
            const r2 = this == null || (e2 = this._player) === null || e2 === void 0 ? void 0 : e2.getContainerElement(), i2 = { track: this, element: this == null || (t2 = this._player) === null || t2 === void 0 ? void 0 : t2.getVideoElement(), slot: r2 == null ? void 0 : r2.parentElement }, { element: n2, slot: o2 } = i2;
            if (this.isPlaying && n2 instanceof HTMLVideoElement && o2 instanceof HTMLElement) {
              const e3 = zq.checkOneElementVisible(n2), t3 = Object.assign({}, e3);
              if (t3.visible !== this._previousVideoVisibleStatus) {
                this._previousVideoVisibleStatus = t3.visible;
                const e4 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE, options: [this.getTrackId()] });
                t3.visible ? e4.onSuccess("Video is visible") : e4.onSuccess("Invisible because of ".concat(t3.reason));
              }
              return t3;
            }
            return;
          } catch (e3) {
            throw new tD(eD.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e3.message);
          }
        }
      }) || N$, M$ = PD("RemoteAudioTrack", "getTrackId")(D$ = class extends k$ {
        get isPlaying() {
          return this._useAudioElement ? lj.isPlaying(this.getTrackId()) : this._source.isPlayed;
        }
        constructor(e2, t2, r2, i2) {
          super(e2, t2, r2, i2), kO(this, "trackMediaType", "audio"), kO(this, "_source", void 0), kO(this, "_useAudioElement", true), kO(this, "_volume", 100), ND("info", this, "constructor", { userId: t2 }), JD("REMOTE_AUDIO_TRACK_USES_WEB_AUDIO") && (this._useAudioElement = false), this._source = new zV(e2, true), this._source.once(BP.RECEIVE_TRACK_BUFFER, () => {
            this.emit(fk.FIRST_FRAME_DECODED);
          });
        }
        setAudioFrameCallback(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4096;
          if (!e2)
            return this._source.removeAllListeners(BP.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();
          this._source.startGetAudioBuffer(t2), this._source.removeAllListeners(BP.ON_AUDIO_BUFFER), this._source.on(BP.ON_AUDIO_BUFFER, (t3) => e2(t3));
        }
        setVolume(e2) {
          const t2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.REMOTE_AUDIO_SET_VOLUME, options: [this.getTrackId(), e2] }, 300);
          this._volume = e2, this._useAudioElement ? lj.setVolume(this.getTrackId(), e2) : this._source.setVolume(e2 / 100), t2.onSuccess();
        }
        async setPlaybackDevice(e2) {
          const t2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.REMOTE_AUDIO_SET_OUTPUT_DEVICE, options: [this.getTrackId(), e2] });
          if (!this._useAudioElement)
            throw new tD(eD.NOT_SUPPORTED, "your browser does not support setting the audio output device");
          try {
            await lj.setSinkID(this.getTrackId(), e2);
          } catch (e3) {
            throw t2.onError(e3), e3;
          }
          t2.onSuccess();
        }
        getVolumeLevel() {
          return this._source.getAccurateVolumeLevel();
        }
        getStats() {
          UG(() => {
            dD.warning("[deprecated] RemoteAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteAudioStats instead"), TD("warning", this, "[deprecated] RemoteAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteAudioStats instead");
          }, "remoteAudioTrackGetStatsWarning");
          return NG(this, Ak.GET_STATS) || P$({}, GP);
        }
        play() {
          const e2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.REMOTE_AUDIO_TRACK_PLAY, options: [this.getTrackId()] });
          dD.debug("[".concat(this.getTrackId(), "] start audio playback")), ND("debug", this, "play"), this._useAudioElement ? (dD.debug("[".concat(this.getTrackId(), "] use audio element to play")), TD("debug", this, "use audio element to play"), lj.play(this._mediaStreamTrack, this.getTrackId(), this._volume, this.store.sessionId || void 0)) : this._source.play(), e2.onSuccess();
        }
        stop() {
          const e2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.REMOTE_AUDIO_TRACK_STOP, options: [this.getTrackId()] });
          dD.debug("[".concat(this.getTrackId(), "] stop audio playback")), ND("debug", this, "stop"), this._useAudioElement ? lj.stop(this.getTrackId()) : this._source.stop(), e2.onSuccess();
        }
        _destroy() {
          super._destroy(), this._source.destroy();
        }
        _isFreeze() {
          return this._source.isFreeze;
        }
        _updatePlayerSource() {
          dD.debug("[".concat(this.getTrackId(), "] update player source track")), ND("debug", this, "_updatePlayerSource"), this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && lj.updateTrack(this.getTrackId(), this._mediaStreamTrack);
        }
      }) || D$;
      function U$(e2, t2) {
        var r2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          t2 && (i2 = i2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), r2.push.apply(r2, i2);
        }
        return r2;
      }
      function Q$(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r2 = arguments[t2] != null ? arguments[t2] : {};
          t2 % 2 ? U$(Object(r2), true).forEach(function(t3) {
            kO(e2, t3, r2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : U$(Object(r2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
          });
        }
        return e2;
      }
      class x$ extends ZN {
        constructor() {
          super(), kO(this, "uplinkStatsUploadInterval", void 0), kO(this, "uplinkStatsUploadSlowInterval", void 0), kO(this, "uplinkRelatedStatsUploadInterval", void 0), kO(this, "uplinkDenoiserStatsUploadInterval", void 0), kO(this, "transportStatsUploadInterval", void 0), kO(this, "extensionStatsUploadInterval", void 0), kO(this, "downlinkStatsUploadInterval", void 0), kO(this, "downlinkStatsUploadSlowInterval", void 0), kO(this, "downlinkRelatedStatsUploadInterval", void 0), kO(this, "lastStats", void 0), kO(this, "uploadUnplinkStarted", false), kO(this, "uploadDownlinkStarted", false), kO(this, "uploadTransportStarted", false), kO(this, "requestStats", void 0), kO(this, "requestLocalMedia", void 0), kO(this, "requestRemoteMedia", void 0), kO(this, "requestAllTracks", void 0), kO(this, "requestVideoIsReady", void 0), kO(this, "requestUpload", void 0);
        }
        startUploadTransportStats() {
          this.uploadTransportStarted || (this.uploadTransportStarted = true, this.transportStatsUploadInterval && window.clearInterval(this.transportStatsUploadInterval), this.transportStatsUploadInterval = window.setInterval(() => {
            var e2;
            const t2 = (e2 = this.requestStats) === null || e2 === void 0 ? void 0 : e2.call(this);
            t2 && this.uploadTransportStats(t2);
          }, 6e3));
        }
        startUploadUplinkStats() {
          this.uploadUnplinkStarted || (this.uploadUnplinkStarted = true, this.uplinkStatsUploadInterval && window.clearInterval(this.uplinkStatsUploadInterval), this.uplinkStatsUploadInterval = window.setInterval(() => {
            var e2;
            const t2 = (e2 = this.requestStats) === null || e2 === void 0 ? void 0 : e2.call(this);
            t2 && (this.uploadUplinkStats(t2, this.lastStats), this.lastStats = t2);
          }, 3e3), this.uplinkStatsUploadSlowInterval && window.clearInterval(this.uplinkStatsUploadSlowInterval), this.uplinkStatsUploadSlowInterval = window.setInterval(() => {
            var e2;
            const t2 = (e2 = this.requestStats) === null || e2 === void 0 ? void 0 : e2.call(this);
            t2 && this.uploadSlowUplinkStats(t2);
          }, 6e4), this.uplinkRelatedStatsUploadInterval && window.clearInterval(this.uplinkRelatedStatsUploadInterval), this.uplinkRelatedStatsUploadInterval = window.setInterval(() => {
            var e2;
            const t2 = (e2 = this.requestStats) === null || e2 === void 0 ? void 0 : e2.call(this);
            t2 && this.uploadRelatedUplinkStats(t2, this.lastStats), this.lastStats = t2;
          }, 1e3), this.uplinkDenoiserStatsUploadInterval && window.clearInterval(this.uplinkDenoiserStatsUploadInterval), this.uplinkDenoiserStatsUploadInterval = window.setInterval(() => {
            var e2;
            const t2 = (e2 = this.requestAllTracks) === null || e2 === void 0 ? void 0 : e2.call(this);
            t2 && this.uploadDenoiserStats(t2);
          }, 2e3), this.extensionStatsUploadInterval && window.clearInterval(this.extensionStatsUploadInterval), this.extensionStatsUploadInterval = window.setInterval(() => {
            var e2;
            const t2 = (e2 = this.requestAllTracks) === null || e2 === void 0 ? void 0 : e2.call(this);
            t2 && this.uploadExtensionStats(t2);
          }, 2e3));
        }
        uploadTransportStats(e2) {
          kG(() => {
            var t2;
            (t2 = this.requestUpload) === null || t2 === void 0 || t2.call(this, LP.TRANSPORT_STATS, function(e3) {
              const t3 = { connectionType: 100 };
              if (e3.selectedCandidatePair.localCandidate.candidateType === "relay") {
                const r2 = e3.selectedCandidatePair.localCandidate.relayProtocol;
                r2 === "udp" && (t3.connectionType = 101), r2 === "tcp" && (t3.connectionType = 103), r2 === "tls" && (t3.connectionType = 104);
              }
              return t3;
            }(e2));
          });
        }
        uploadUplinkStats(e2, t2) {
          var r2;
          (((r2 = this.requestLocalMedia) === null || r2 === void 0 ? void 0 : r2.call(this)) || []).forEach((r3) => {
            let [i2, { track: n2, ssrcs: o2 }] = r3;
            switch (i2) {
              case Tk.LocalVideoLowTrack:
              case Tk.LocalVideoTrack: {
                const r4 = function(e3, t3, r5) {
                  var i3;
                  const n3 = t3.videoSend.find((t4) => t4.ssrc === e3);
                  if (!n3)
                    return null;
                  const o3 = { id: SG(10, ""), timestamp: new Date(t3.timestamp).toISOString(), mediaType: "video", type: "ssrc", ssrc: n3.ssrc.toString() };
                  switch (o3.A_vstd = r5._originMediaStreamTrack && !r5._originMediaStreamTrack.enabled || !r5._mediaStreamTrack.enabled ? "1" : "0", n3.sentFrame && (o3.A_fhs = n3.sentFrame.height.toString(), o3.A_frs = n3.sentFrame.frameRate.toString(), o3.A_fws = n3.sentFrame.width.toString()), n3.adaptionChangeReason) {
                    case "none":
                      o3.A_ac = "0";
                      break;
                    case "cpu":
                      o3.A_ac = "1";
                      break;
                    case "bandwidth":
                      o3.A_ac = "2";
                      break;
                    case "other":
                      o3.A_ac = "3";
                  }
                  return o3.A_lvps = uP[r5._player ? r5._player.videoElementStatus : "uninit"].toString(), o3.A_nr = (i3 = n3.nacksCount) === null || i3 === void 0 ? void 0 : i3.toString(), n3.avgEncodeMs && (o3.A_aem = n3.avgEncodeMs.toFixed(0).toString()), o3;
                }(o2[0].ssrcId, e2, n2), s3 = hG(o2[0].ssrcId, e2, t2);
                r4 && kG(() => {
                  var e3;
                  return (e3 = this.requestUpload) === null || e3 === void 0 ? void 0 : e3.call(this, LP.PUBLISH_STATS, { stream_type: i2 === Tk.LocalVideoLowTrack ? "low" : "high", stats: Q$(Q$({}, r4), s3) });
                });
                break;
              }
              case Tk.LocalAudioTrack: {
                const t3 = function(e3, t4, r4) {
                  const i3 = t4.audioSend.find((t5) => t5.ssrc === e3);
                  if (!i3)
                    return null;
                  const n3 = { id: SG(10, ""), timestamp: new Date(t4.timestamp).toISOString(), mediaType: "audio", type: "ssrc", ssrc: i3.ssrc.toString() };
                  return n3.A_astd = r4._originMediaStreamTrack.enabled && r4._mediaStreamTrack.enabled ? "0" : "1", i3.inputLevel ? n3.A_ail = Math.round(100 * i3.inputLevel).toString() : n3.A_ail = Math.round(100 * r4._source.getAccurateVolumeLevel()).toString(), n3.A_apil = Math.round(100 * r4._source.getAccurateVolumeLevel()).toString(), i3.aecReturnLoss && (n3.A_ecrl = Math.round(i3.aecReturnLoss).toString()), i3.aecReturnLossEnhancement && (n3.A_ecrle = Math.round(i3.aecReturnLossEnhancement).toString()), n3;
                }(o2[0].ssrcId, e2, n2);
                t3 && kG(() => {
                  var e3;
                  return (e3 = this.requestUpload) === null || e3 === void 0 ? void 0 : e3.call(this, LP.PUBLISH_STATS, { stream_type: "high", stats: t3 });
                });
                break;
              }
            }
            const s2 = function(e3) {
              const t3 = { id: "bweforvideo", timestamp: new Date(e3.timestamp).toISOString(), type: "VideoBwe" };
              return e3.bitrate.retransmit && (t3.A_rb = e3.bitrate.retransmit.toString()), e3.bitrate.targetEncoded && (t3.A_teb = e3.bitrate.targetEncoded.toString()), t3.A_aeb = e3.bitrate.actualEncoded.toString(), t3.A_tb = e3.bitrate.transmit.toString(), e3.sendBandwidth !== void 0 && (t3.A_asb = e3.sendBandwidth.toString()), t3;
            }(e2);
            s2 && kG(() => {
              var e3;
              return (e3 = this.requestUpload) === null || e3 === void 0 ? void 0 : e3.call(this, LP.PUBLISH_STATS, { stream_type: i2 === Tk.LocalVideoLowTrack ? "low" : "high", stats: s2 });
            });
          });
        }
        uploadSlowUplinkStats(e2) {
          var t2;
          (((t2 = this.requestLocalMedia) === null || t2 === void 0 ? void 0 : t2.call(this)) || []).filter((e3) => {
            let [t3] = e3;
            return t3 === Tk.LocalVideoLowTrack || t3 === Tk.LocalVideoTrack;
          }).forEach((t3) => {
            let [r2, { ssrcs: i2 }] = t3;
            const n2 = hG(i2[0].ssrcId, e2);
            n2 && kG(() => {
              var e3;
              return (e3 = this.requestUpload) === null || e3 === void 0 ? void 0 : e3.call(this, LP.PUBLISH_STATS, { stream_type: r2 === Tk.LocalVideoLowTrack ? "low" : "high", stats: n2 });
            });
          });
        }
        uploadRelatedUplinkStats(e2, t2) {
          var r2;
          (((r2 = this.requestLocalMedia) === null || r2 === void 0 ? void 0 : r2.call(this)) || []).filter((e3) => {
            let [t3] = e3;
            return t3 === Tk.LocalVideoLowTrack || t3 === Tk.LocalVideoTrack;
          }).forEach((t3) => {
            let [r3, { ssrcs: i2 }] = t3;
            const n2 = function(e3, t4) {
              const r4 = t4.videoSend.find((t5) => t5.ssrc === e3);
              return r4 ? { mediaType: "video", isVideoMute: false, frameRateInput: r4.inputFrame && r4.inputFrame.frameRate.toString(), frameRateSent: r4.sentFrame && r4.sentFrame.frameRate.toString(), googRtt: r4.rttMs.toString(), qpSumPerFrame: Math.floor(r4.qpSumPerFrame).toString() } : null;
            }(i2[0].ssrcId, e2);
            n2 && kG(() => {
              var e3;
              (e3 = this.requestUpload) === null || e3 === void 0 || e3.call(this, LP.PUBLISH_RELATED_STATS, { stream_type: r3 === Tk.LocalVideoLowTrack ? "low" : "high", stats: n2 });
            });
          });
        }
        uploadDenoiserStats(e2) {
          for (let n2 = 0; n2 < e2.length; n2++) {
            const o2 = e2[n2];
            if (o2 instanceof Yj) {
              var t2, r2, i2;
              const e3 = (t2 = (r2 = o2._external).getDenoiserStats) === null || t2 === void 0 ? void 0 : t2.call(r2);
              return void (e3 && ((i2 = this.requestUpload) === null || i2 === void 0 || i2.call(this, LP.DENOISER_STATS, e3)));
            }
          }
        }
        uploadExtensionStats(e2) {
          for (let t2 = 0; t2 < e2.length; t2++) {
            const r2 = e2[t2];
            if (r2 instanceof Yj) {
              return void r2.getProcessorStats().forEach((e3) => {
                var t3;
                e3.type === LP.DENOISER_STATS && ((t3 = this.requestUpload) === null || t3 === void 0 || t3.call(this, LP.DENOISER_STATS, e3.stats));
              });
            }
          }
        }
        stopUploadUplinkStats() {
          this.uploadUnplinkStarted && (this.uploadUnplinkStarted = false, this.uplinkStatsUploadInterval && window.clearInterval(this.uplinkStatsUploadInterval), this.uplinkRelatedStatsUploadInterval && window.clearInterval(this.uplinkRelatedStatsUploadInterval), this.uplinkDenoiserStatsUploadInterval && window.clearInterval(this.uplinkDenoiserStatsUploadInterval), this.uplinkStatsUploadInterval = void 0, this.uplinkRelatedStatsUploadInterval = void 0, this.uplinkDenoiserStatsUploadInterval = void 0);
        }
        startUploadDownlinkStats() {
          this.uploadDownlinkStarted || (this.uploadDownlinkStarted = true, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval), this.downlinkStatsUploadInterval = window.setInterval(() => {
            var e2;
            const t2 = (e2 = this.requestStats) === null || e2 === void 0 ? void 0 : e2.call(this);
            t2 && (this.uploadDownlinkStats(t2, this.lastStats), this.lastStats = t2);
          }, 3e3), this.downlinkStatsUploadSlowInterval && window.clearInterval(this.downlinkStatsUploadSlowInterval), this.downlinkStatsUploadSlowInterval = window.setInterval(() => {
            var e2;
            const t2 = (e2 = this.requestStats) === null || e2 === void 0 ? void 0 : e2.call(this);
            t2 && this.uploadSlowDownlinkStats(t2);
          }, 6e4), this.downlinkRelatedStatsUploadInterval && window.clearInterval(this.downlinkRelatedStatsUploadInterval), this.downlinkRelatedStatsUploadInterval = window.setInterval(() => {
            var e2;
            const t2 = (e2 = this.requestStats) === null || e2 === void 0 ? void 0 : e2.call(this);
            t2 && (this.uploadRelatedDownlinkStats(t2, this.lastStats), this.lastStats = t2);
          }, 1e3));
        }
        uploadDownlinkStats(e2, t2) {
          var r2;
          (((r2 = this.requestRemoteMedia) === null || r2 === void 0 ? void 0 : r2.call(this)) || []).forEach((t3) => {
            let [r3, i2] = t3;
            if (i2.has(yk.VIDEO) && r3.videoTrack) {
              const t4 = r3.videoTrack ? function(e3, t5, r4) {
                const i3 = t5.videoRecv.find((t6) => t6.ssrc === e3);
                if (!i3)
                  return null;
                const n2 = { id: SG(10, ""), timestamp: new Date(t5.timestamp).toISOString(), mediaType: "video", type: "ssrc", ssrc: i3.ssrc.toString() };
                var o2, s2;
                return n2.bytesReceived = i3.bytes.toString(), n2.packetsLost = i3.packetsLost.toString(), n2.packetsReceived = i3.packets.toString(), i3.framesRateFirefox && (n2.A_frr = i3.framesRateFirefox.toString()), i3.receivedFrame ? (n2.A_frr = i3.receivedFrame.frameRate.toString(), n2.A_fhr = i3.receivedFrame.height.toString(), n2.A_fwr = i3.receivedFrame.width.toString()) : (n2.A_fhr = (o2 = r4._videoHeight) === null || o2 === void 0 ? void 0 : o2.toString(), n2.A_fwr = (s2 = r4._videoWidth) === null || s2 === void 0 ? void 0 : s2.toString()), n2.A_frd = i3.decodeFrameRate.toString(), i3.outputFrame && (n2.A_fro = i3.outputFrame.frameRate.toString()), i3.jitterBufferMs !== void 0 && (n2.A_jbm = Math.floor(i3.jitterBufferMs).toString()), i3.currentDelayMs !== void 0 && (n2.A_cdm = Math.floor(i3.currentDelayMs).toString()), n2.A_fs = i3.firsCount.toString(), n2.A_ns = i3.nacksCount.toString(), n2.A_ps = i3.plisCount.toString(), r4 && (n2.A_vrtd = r4._originMediaStreamTrack.enabled && r4._mediaStreamTrack.enabled ? "0" : "1"), r4._player && r4._player.freezeTimeCounterList.length > 0 && (n2.A_vrft = r4._player.freezeTimeCounterList.splice(0, 1)[0].toString()), n2.A_rvps = uP[r4._player ? r4._player.videoElementStatus : "uninit"].toString(), n2;
              }(r3._videoSSRC, e2, r3.videoTrack) : void 0;
              t4 && kG(() => {
                var e3;
                return (e3 = this.requestUpload) === null || e3 === void 0 ? void 0 : e3.call(this, LP.SUBSCRIBE_STATS, { stream_id: r3.uid, stats: t4 });
              });
            }
            if (i2.has(yk.AUDIO) && r3.audioTrack) {
              const t4 = r3.audioTrack ? function(e3, t5, r4) {
                const i3 = t5.audioRecv.find((t6) => t6.ssrc === e3);
                if (!i3)
                  return null;
                const n2 = { id: SG(10, ""), timestamp: new Date(t5.timestamp).toISOString(), mediaType: "audio", type: "ssrc", ssrc: i3.ssrc.toString() };
                return n2.bytesReceived = i3.bytes.toString(), n2.packetsLost = i3.packetsLost.toString(), n2.packetsReceived = i3.packets.toString(), i3.outputLevel ? n2.A_aol = Math.round(100 * i3.outputLevel).toString() : n2.A_aol = Math.round(100 * r4._source.getAccurateVolumeLevel()).toString(), n2.A_apol = Math.round(100 * r4._source.getAccurateVolumeLevel()).toString(), r4 && (n2.A_artd = r4._originMediaStreamTrack.enabled && r4._mediaStreamTrack.enabled ? "0" : "1"), n2.A_jr = i3.jitterMs.toString(), n2.A_jbm = Math.floor(i3.jitterBufferMs).toString(), n2.A_cdm = Math.floor(i3.jitterBufferMs).toString(), n2.A_raps = uP[lj.getPlayerState(r4.getTrackId())].toString(), n2;
              }(r3._audioSSRC, e2, r3.audioTrack) : void 0;
              t4 && kG(() => {
                var e3;
                return (e3 = this.requestUpload) === null || e3 === void 0 ? void 0 : e3.call(this, LP.SUBSCRIBE_STATS, { stream_id: r3.uid, stats: t4 });
              });
            }
          });
        }
        uploadSlowDownlinkStats(e2) {
        }
        uploadRelatedDownlinkStats(e2, t2) {
          var r2;
          (((r2 = this.requestRemoteMedia) === null || r2 === void 0 ? void 0 : r2.call(this)) || []).forEach((r3) => {
            let [i2, n2] = r3;
            if (n2.has(yk.VIDEO) && i2.videoTrack) {
              var o2;
              const r4 = (i2._videoSSRC && ((o2 = this.requestVideoIsReady) === null || o2 === void 0 ? void 0 : o2.call(this, i2._videoSSRC)) || false) === true, n3 = function(e3, t3, r5, i3, n4, o3) {
                const s2 = r5.videoRecv.find((t4) => t4.ssrc === e3), a2 = n4 ? n4.videoRecv.find((t4) => t4.ssrc === e3) : void 0;
                if (!s2)
                  return null;
                const c2 = rG.isRemoteVideoFreeze(o3, s2, a2) && t3, d2 = { mediaType: "video", isVideoMute: false, peerId: i3, frameRateReceived: s2.receivedFrame && s2.receivedFrame.frameRate.toString(), frameRateDecoded: s2.decodedFrame && s2.decodedFrame.frameRate.toString(), isFreeze: c2, bytesReceived: s2.bytes.toString(), packetsReceived: s2.packets.toString(), packetsLost: s2.packetsLost.toString(), qpSumPerFrame: Math.floor(s2.qpSumPerFrame).toString() };
                return s2.framesRateFirefox && (d2.frameRateDecoded = s2.framesRateFirefox.toString(), d2.frameRateReceived = s2.framesRateFirefox.toString()), d2;
              }(i2._videoSSRC, r4, e2, i2.uid, t2, i2.videoTrack);
              n3 && kG(() => {
                var e3;
                (e3 = this.requestUpload) === null || e3 === void 0 || e3.call(this, LP.SUBSCRIBE_RELATED_STATS, { stream_id: i2.uid, stats: n3 });
              });
            }
            if (n2.has(yk.AUDIO) && i2.audioTrack) {
              const t3 = function(e3, t4, r4, i3) {
                const n3 = t4.audioRecv.find((t5) => t5.ssrc === e3);
                if (!n3)
                  return null;
                const o3 = rG.isRemoteAudioFreeze(i3);
                return { mediaType: "audio", isAudioMute: false, peerId: r4, googJitterReceived: n3.jitterMs.toString(), isFreeze: o3, bytesReceived: n3.bytes.toString(), packetsReceived: n3.packets.toString(), packetsLost: n3.packetsLost.toString(), frameReceived: n3.receivedFrames.toString(), frameDropped: n3.droppedFrames.toString() };
              }(i2._audioSSRC, e2, i2.uid, i2.audioTrack);
              t3 && kG(() => {
                var e3;
                (e3 = this.requestUpload) === null || e3 === void 0 || e3.call(this, LP.SUBSCRIBE_RELATED_STATS, { stream_id: i2.uid, stats: t3 });
              });
            }
          });
        }
        stopUploadDownlinkStats() {
          this.uploadDownlinkStarted && (this.uploadDownlinkStarted = false, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval), this.downlinkRelatedStatsUploadInterval && window.clearInterval(this.downlinkRelatedStatsUploadInterval), this.downlinkStatsUploadInterval = void 0, this.downlinkRelatedStatsUploadInterval = void 0);
        }
        stopUploadTransportStats() {
          this.uploadTransportStarted && (this.uploadTransportStarted = false, this.transportStatsUploadInterval && window.clearInterval(this.transportStatsUploadInterval), this.transportStatsUploadInterval = void 0);
        }
      }
      var F$, V$;
      function j$(e2, t2) {
        var r2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          t2 && (i2 = i2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), r2.push.apply(r2, i2);
        }
        return r2;
      }
      function G$(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r2 = arguments[t2] != null ? arguments[t2] : {};
          t2 % 2 ? j$(Object(r2), true).forEach(function(t3) {
            kO(e2, t3, r2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : j$(Object(r2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
          });
        }
        return e2;
      }
      function K$(e2) {
        var t2, r2, i2, n2 = 2;
        for (typeof Symbol != "undefined" && (r2 = lZ, i2 = Symbol.iterator); n2--; ) {
          if (r2 && (t2 = e2[r2]) != null)
            return t2.call(e2);
          if (i2 && (t2 = e2[i2]) != null)
            return new H$(t2.call(e2));
          r2 = "@@asyncIterator", i2 = "@@iterator";
        }
        throw new TypeError("Object is not async iterable");
      }
      function H$(e2) {
        function t2(e3) {
          if (Object(e3) !== e3)
            return nR.reject(new TypeError(e3 + " is not an object."));
          var t3 = e3.done;
          return nR.resolve(e3.value).then(function(e4) {
            return { value: e4, done: t3 };
          });
        }
        return (H$ = function(e3) {
          this.s = e3, this.n = e3.next;
        }).prototype = { s: null, n: null, next: function() {
          return t2(this.n.apply(this.s, arguments));
        }, return: function(e3) {
          var r2 = this.s.return;
          return r2 === void 0 ? nR.resolve({ value: e3, done: true }) : t2(r2.apply(this.s, arguments));
        }, throw: function(e3) {
          var r2 = this.s.return;
          return r2 === void 0 ? nR.reject(e3) : t2(r2.apply(this.s, arguments));
        } }, new H$(e2);
      }
      let Y$ = PD("P2PChannel", "store.p2pId")((zF((V$ = class extends ZN {
        get state() {
          return this._state;
        }
        set state(e2) {
          const t2 = this._state;
          this._state = e2, this.emit(bk.StateChange, t2, this._state);
        }
        constructor(e2, t2) {
          super(), kO(this, "store", void 0), kO(this, "statsUploader", void 0), kO(this, "connection", void 0), kO(this, "localTrackMap", /* @__PURE__ */ new Map()), kO(this, "remoteUserMap", /* @__PURE__ */ new Map()), kO(this, "pendingLocalTracks", []), kO(this, "pendingRemoteTracks", []), kO(this, "statsCollector", void 0), kO(this, "isPlanB", false), kO(this, "iceFailedCount", 0), kO(this, "dtlsFailedCount", 0), kO(this, "mutex", new kV("P2PChannel-mutex")), kO(this, "_state", wk.Disconnected), kO(this, "handleMuteLocalTrack", async (e3, t3, r2) => {
            const i2 = await this.mutex.lock("Locking from P2PChannel.handleMuteLocalTrack");
            try {
              if (!this.connection)
                return void r2(new tD(eD.INVALID_OPERATION, "Cannot call P2PChannel.handleMuteLocalTrack before connection established."));
              ND("debug", this, "handleMuteLocalTrack", e3.getTrackId()), await this.waitTillConnected();
              const n2 = this.filterTobeMutedTracks(e3);
              if (n2.length === 0)
                return void t3();
              await this.connection.muteLocal(n2.map((e4) => {
                let [, { id: t4 }] = e4;
                return t4;
              }));
              const o2 = this.createMuteMessage(n2);
              await OG(this, bk.RequestMuteLocal, o2), t3();
            } catch (e4) {
              r2(e4);
            } finally {
              i2();
            }
          }), kO(this, "handleUnmuteLocalTrack", async (e3, t3, r2) => {
            const i2 = await this.mutex.lock("Locking from P2PChannel.handleUnmuteLocalTrack");
            try {
              if (!this.connection)
                return void r2(new tD(eD.INVALID_OPERATION, "Cannot call P2PChannel.handleUnmuteLocalTrack before connection established."));
              ND("debug", this, "handleUnmuteLocalTrack", e3.getTrackId()), await this.waitTillConnected();
              const n2 = this.filterTobeUnmutedTracks(e3);
              if (n2.length === 0)
                return void t3();
              await this.connection.unmuteLocal(n2.map((e4) => {
                let [, { id: t4 }] = e4;
                return t4;
              }));
              const o2 = this.createUnmuteMessage(n2);
              await OG(this, bk.RequestUnmuteLocal, o2), t3();
            } catch (e4) {
              r2(e4);
            } finally {
              i2();
            }
          }), kO(this, "handleUpdateVideoEncoder", async (e3, t3, r2) => {
            const i2 = await this.mutex.lock("Locking from P2PChannel.handleSetVideoEncoder");
            try {
              const r3 = this.localTrackMap.get(Tk.LocalVideoTrack);
              if (!this.connection || !r3 || r3.track !== e3)
                return void t3();
              await this.waitTillConnected();
              const { id: n2, track: o2 } = r3;
              await this.connection.updateSendParameters(n2, o2), await this.connection.updateEncoderConfig(n2, o2), this.emit(bk.UpdateVideoEncoder, o2), t3();
            } catch (e4) {
              r2(e4);
            } finally {
              i2();
            }
          }), kO(this, "handleSetOptimizationMode", async (e3, t3, r2) => {
            const i2 = await this.mutex.lock("Locking from P2PChannel.handleSetOptimizationMode");
            try {
              const r3 = this.localTrackMap.get(Tk.LocalVideoTrack);
              if (!this.connection || !r3 || r3.track !== e3)
                return;
              await this.waitTillConnected();
              const { id: n2, track: o2 } = r3;
              await this.connection.updateSendParameters(n2, o2), t3();
            } catch (e4) {
              r2(e4);
            } finally {
              i2();
            }
          }), kO(this, "handleReplaceTrack", async (e3, t3, r2, i2) => {
            let n2;
            dD.debug("P2PChannel handleReplaceTrack for [track-id-".concat(e3.getTrackId(), "]")), typeof i2 == "boolean" && i2 || (n2 = await this.mutex.lock("From P2PChannel.handleReplaceTrack"));
            try {
              const r3 = Array.from(this.localTrackMap.entries()).find((t4) => {
                let [, { track: r4 }] = t4;
                return e3 === r4;
              });
              if (!this.connection || !r3)
                return void t3();
              if (await this.waitTillConnected(), await this.connection.replaceTrack(e3, r3[1].id), this.isPlanB) {
                const t4 = r3[1];
                t4.id = e3._mediaStreamTrack.id, this.localTrackMap.set(r3[0], t4);
              }
              if (r3[0] === Tk.LocalVideoTrack && Mk().supportDualStreamEncoding) {
                const t4 = this.localTrackMap.get(Tk.LocalVideoLowTrack);
                if (t4) {
                  const r4 = e3._mediaStreamTrack.clone();
                  t4.track._originMediaStreamTrack.stop(), t4.track._mediaStreamTrack = r4, t4.track._originMediaStreamTrack = r4, await new nR((e4, r5) => {
                    this.handleReplaceTrack(t4.track, e4, r5, true);
                  });
                }
              }
              t3();
            } catch (e4) {
              r2(e4);
            } finally {
              var o2;
              (o2 = n2) === null || o2 === void 0 || o2();
            }
          }), kO(this, "handleGetLocalVideoStats", (e3) => {
            e3(this.statsCollector.getLocalVideoTrackStats());
          }), kO(this, "handleGetLocalAudioStats", (e3) => {
            e3(this.statsCollector.getLocalAudioTrackStats());
          }), kO(this, "handleGetRemoteVideoStats", (e3) => this.statsCollector.getRemoteVideoTrackStats(e3.uid)[e3.uid]), kO(this, "handleGetRemoteAudioStats", (e3) => this.statsCollector.getRemoteAudioTrackStats(e3.uid)[e3.uid]), this.store = e2, this.statsCollector = t2, this.statsCollector.addP2PChannel(this), this.statsUploader = new x$(), this.bindStatsUploaderEvents(), this.isPlanB = !Mk().supportUnifiedPlan || JD("CHROME_FORCE_PLAN_B") && yO();
        }
        async startP2PConnection(e2) {
          return this.state = wk.New, this.connection = this.isPlanB ? new E$(e2, this.store) : new w$(e2, this.store), this.bindConnectionEvents(this.connection), this.store.peerConnectionStart(), this.connection.establish();
        }
        async connect(e2, t2, r2, i2, n2, o2) {
          if (!this.connection)
            throw new tD(eD.UNEXPECTED_ERROR, "Cannot P2PChannel.connect before P2PChannel.startP2PConnection .");
          await this.connection.connect(e2, t2, r2, i2, n2, o2), this.statsUploader.startUploadTransportStats(), this.state = wk.Connected;
        }
        publish(e2, t2, r2) {
          var i2 = this;
          return dZ(function* () {
            const n2 = yield uZ(i2.mutex.lock("From P2PChannel.publish"));
            try {
              if (!i2.connection) {
                if (i2.state === wk.Disconnected)
                  throw new tD(eD.UNEXPECTED_ERROR, "PeerConnection already disconnected.");
                i2.throwIfTrackTypeNotMatch(e2);
                const t3 = e2.filter((e3) => i2.pendingLocalTracks.indexOf(e3) === -1);
                return void (i2.pendingLocalTracks = i2.pendingLocalTracks.concat(t3));
              }
              i2.store.pubId = i2.store.pubId + 1, $j.markPublishStart(i2.store.clientId, i2.store.pubId), yield uZ(i2.waitTillConnected());
              const o2 = i2.filterTobePublishedTracks(e2, t2, r2);
              if (o2.length === 0)
                return void (yield uZ(i2.tryToUnmuteAudio(e2)));
              yield* hZ(K$(i2.doPublish(i2.connection, o2)), uZ);
            } finally {
              n2();
            }
          })();
        }
        doPublish(e2, t2) {
          var r2 = this;
          return dZ(function* () {
            t2.forEach((e3) => {
              let { track: t3, type: i3 } = e3;
              const n3 = performance.now();
              r2.store.publish(t3.getTrackId(), i3 === Tk.LocalAudioTrack ? "audio" : "video", n3);
            }), r2.bindLocalTrackEvents(t2);
            const i2 = yield uZ(e2.send(t2.map((e3) => {
              let { track: t3 } = e3;
              return t3;
            }), r2.store.codec, r2.store.audioCodec)), n2 = (yield uZ(i2.next())).value, o2 = r2.createGatewayPublishMessage(t2, n2);
            let s2;
            try {
              s2 = yield o2;
            } catch (e3) {
              throw TD("error", r2, "doPublish yield error: ".concat(e3.toString())), i2.throw(e3), (e3 == null ? void 0 : e3.code) === eD.WS_ABORT && t2.forEach((e4) => {
                let { track: t3 } = e4;
                r2.pendingLocalTracks.indexOf(t3) === -1 && r2.pendingLocalTracks.push(t3);
              }), r2.unbindLocalTrackEvents(t2), e3;
            }
            const a2 = r2.mapPubResToRemoteConfig(o2, s2);
            ND("debug", r2, "doPublish", { remoteConfigs: a2, tracks: t2.map((e3) => {
              let { track: t3 } = e3;
              return t3.getTrackId();
            }), pubMsg: o2, pubAns: s2 });
            const c2 = (yield uZ(i2.next(a2))).value;
            t2.forEach((e3) => {
              let { type: t3 } = e3;
              r2.statsCollector.addLocalStats(t3);
            }), r2.assignLocalTracks(t2, c2), r2.statsUploader.startUploadUplinkStats(), t2.forEach((e3) => {
              let { track: t3, type: i3 } = e3;
              const n3 = performance.now();
              r2.store.publish(t3.getTrackId(), i3 === Tk.LocalAudioTrack ? "audio" : "video", void 0, n3);
            });
          })();
        }
        publishLowStream(e2) {
          var t2 = this;
          return dZ(function* () {
            if (!t2.connection)
              return;
            ND("debug", t2, "publishLowStream", e2);
            const r2 = yield uZ(t2.mutex.lock("Locking from P2PChannel.publishLowStream"));
            try {
              const n2 = t2.localTrackMap.get(Tk.LocalVideoTrack);
              if (!n2)
                throw new tD(eD.UNEXPECTED_ERROR, "Could not find high stream");
              if (t2.localTrackMap.has(Tk.LocalVideoLowTrack))
                throw new tD(eD.UNEXPECTED_ERROR, "[".concat(t2.store.clientId, "] Can't publish low stream when stream already publish"));
              yield uZ(t2.waitTillConnected());
              const o2 = [{ track: t2.getLowVideoTrack(n2.track, e2), type: Tk.LocalVideoLowTrack }];
              if (yield* hZ(K$(t2.doPublish(t2.connection, o2)), uZ), n2.track.muted || !n2.track.enabled) {
                var i2;
                const e3 = (i2 = t2.localTrackMap.get(Tk.LocalVideoLowTrack)) === null || i2 === void 0 ? void 0 : i2.id;
                e3 !== void 0 && (yield uZ(t2.connection.muteLocal([e3])));
              }
            } finally {
              r2();
            }
          })();
        }
        async republish() {
          this.pendingLocalTracks.length > 0 && (dD.debug("Emit P2PChannelEvents.RequestRePublish to republish tracks."), ND("debug", this, "republish", this.pendingLocalTracks.map((e2) => e2.getTrackId())), await bG(this, bk.RequestRePublish, this.pendingLocalTracks), this.emit(bk.MediaReconnectEnd, this.store.uid), this.pendingLocalTracks = []);
        }
        async reSubscribe(e2) {
          ND("debug", this, "reSubscribe", this.pendingRemoteTracks.map((e3) => {
            let { user: t2 } = e3;
            return t2.uid;
          }));
          for (let e3 = this.pendingRemoteTracks.length - 1; e3 >= 0; e3--) {
            const { user: t2, kind: r2 } = this.pendingRemoteTracks[e3];
            (r2 !== yk.AUDIO || t2._audio_added_ && t2._audioSSRC) && (r2 !== yk.VIDEO || t2._video_added_ && t2._videoSSRC) || this.pendingRemoteTracks.splice(e3, 1);
          }
          if (e2)
            await bG(this, bk.RequestReSubscribe, this.pendingRemoteTracks);
          else
            for (const { user: e3, kind: t2 } of this.pendingRemoteTracks)
              await this.subscribe(e3, t2, t2 === yk.VIDEO ? e3._videoSSRC : e3._audioSSRC);
          this.pendingRemoteTracks.forEach((e3) => {
            let { user: t2 } = e3;
            this.emit(bk.MediaReconnectEnd, t2.uid);
          }), this.pendingRemoteTracks = [];
        }
        async unpublish(e2) {
          if (!this.connection)
            return void e2.forEach((e3) => {
              const t3 = this.pendingLocalTracks.indexOf(e3);
              t3 !== -1 && this.pendingLocalTracks.splice(t3, 1);
            });
          await this.waitTillConnected();
          const t2 = this.filterTobeUnpublishedTracks(e2);
          return t2.length !== 0 ? (ND("debug", this, "unpublish"), this.doUnpublish(this.connection, t2)) : void 0;
        }
        async unpublishLowStream() {
          if (!this.connection)
            return;
          ND("debug", this, "unpublishLowStream");
          const e2 = this.localTrackMap.get(Tk.LocalVideoLowTrack);
          if (!e2)
            return;
          await this.waitTillConnected();
          const t2 = [[Tk.LocalVideoLowTrack, e2]];
          return this.doUnpublish(this.connection, t2);
        }
        async doUnpublish(e2, t2) {
          const r2 = this.createGatewayUnpublishMessage(t2);
          return await e2.stopSending(t2.map((e3) => {
            let [, { id: t3 }] = e3;
            return t3;
          })), this.withdrawLocalTracks(t2), this.unbindLocalTrackEvents(t2.map((e3) => {
            let [t3, { track: r3 }] = e3;
            return { type: t3, track: r3 };
          })), t2.forEach((e3) => {
            let [t3] = e3;
            this.statsCollector.removeLocalStats(t3);
          }), this.localTrackMap.size === 0 && this.statsUploader.stopUploadUplinkStats(), r2;
        }
        async subscribe(e2, t2, r2, i2, n2) {
          var o2;
          if (!this.connection)
            throw new tD(eD.INVALID_OPERATION, "Cannot subscribe remote user when peerConnection disconnected.");
          if (ND("debug", this, "subscribe", { uid: e2.uid, mediaType: t2, ssrcId: r2 }), (o2 = this.remoteUserMap.get(e2)) !== null && o2 !== void 0 && o2.has(t2))
            return;
          let s2, a2;
          if (await this.waitTillConnected(), n2) {
            const r3 = n2.find((e3) => {
              let { stream_type: r4 } = e3;
              return r4 === t2;
            });
            if (!r3)
              throw new tD(eD.UNEXPECTED_ERROR, "Cannot subscribe to remote ".concat(t2, " for user: ").concat(e2.uid, " because subscribe answer from gateway does not contain stream_type: ").concat(t2, "."));
            const i3 = await this.connection.receive(t2, r3.ssrcs, String(e2.uid), r3.attributes);
            s2 = i3.track, a2 = i3.id;
          } else {
            const n3 = await this.connection.receive(t2, [{ ssrcId: r2, rtx: i2 }], String(e2.uid), void 0);
            s2 = n3.track, a2 = n3.id;
          }
          t2 === yk.AUDIO ? (e2._audioTrack ? e2._audioTrack._updateOriginMediaStreamTrack(s2) : (e2._audioTrack = new M$(s2, e2.uid, e2._uintid, this.store), dD.info("[".concat(this.store.p2pId, "] create remote audio track: ").concat(e2._audioTrack.getTrackId()))), this.bindRemoteTrackEvents(e2, e2._audioTrack)) : (e2._videoTrack ? e2._videoTrack._updateOriginMediaStreamTrack(s2) : (e2._videoTrack = new B$(s2, e2.uid, e2._uintid, this.store), dD.info("[".concat(this.store.p2pId, "] create remote video track: ").concat(e2._videoTrack.getTrackId()))), this.bindRemoteTrackEvents(e2, e2._videoTrack));
          const c2 = this.remoteUserMap.get(e2);
          c2 ? c2.set(t2, a2) : this.remoteUserMap.set(e2, /* @__PURE__ */ new Map([[t2, a2]])), this.statsCollector.addRemoteStats(e2.uid), this.statsUploader.startUploadDownlinkStats();
          const d2 = this.pendingRemoteTracks.findIndex((r3) => {
            let { user: i3, kind: n3 } = r3;
            return i3.uid === e2.uid && t2 === n3;
          });
          d2 !== -1 && (this.pendingRemoteTracks.splice(d2, 1), this.emit(bk.MediaReconnectEnd, e2.uid));
        }
        async massSubscribe(e2) {
          return this.massSubscribeNoLock(e2);
        }
        async massSubscribeNoLock(e2) {
          if (!this.connection)
            throw new tD(eD.INVALID_OPERATION, "Cannot subscribeAll remote users when peerConnection disconnected.");
          ND("debug", this, "subscribeAll", e2.map((e3) => {
            let { user: t3, mediaType: r2, ssrcId: i2 } = e3;
            return { uid: t3.uid, mediaType: r2, ssrcId: i2 };
          })), e2 = e2.filter((e3) => {
            var t3;
            let { user: r2, mediaType: i2 } = e3;
            return !((t3 = this.remoteUserMap.get(r2)) !== null && t3 !== void 0 && t3.has(i2));
          }), await this.waitTillConnected();
          const t2 = await this.connection.batchReceive(e2.map((e3) => {
            let { user: t3, mediaType: r2, ssrcId: i2, rtxSsrcId: n2 } = e3;
            return { kind: r2, ssrcMsg: [{ ssrcId: i2, rtx: n2 }], mslabel: String(t3.uid) };
          }));
          e2.forEach((e3, r2) => {
            let { user: i2, mediaType: n2 } = e3;
            const { track: o2, id: s2 } = t2[r2];
            n2 === yk.AUDIO ? (i2._audioTrack ? i2._audioTrack._updateOriginMediaStreamTrack(o2) : (i2._audioTrack = new M$(o2, i2.uid, i2._uintid, this.store), dD.info("[".concat(this.store.p2pId, "] create remote audio track: ").concat(i2._audioTrack.getTrackId()))), this.bindRemoteTrackEvents(i2, i2._audioTrack)) : (i2._videoTrack ? i2._videoTrack._updateOriginMediaStreamTrack(o2) : (i2._videoTrack = new B$(o2, i2.uid, i2._uintid, this.store), dD.info("[".concat(this.store.p2pId, "] create remote video track: ").concat(i2._videoTrack.getTrackId()))), this.bindRemoteTrackEvents(i2, i2._videoTrack));
            const a2 = this.remoteUserMap.get(i2);
            a2 ? a2.set(n2, s2) : this.remoteUserMap.set(i2, /* @__PURE__ */ new Map([[n2, s2]])), this.statsCollector.addRemoteStats(i2.uid), this.statsUploader.startUploadDownlinkStats();
            const c2 = this.pendingRemoteTracks.findIndex((e4) => {
              let { user: t3, kind: r3 } = e4;
              return t3.uid === i2.uid && n2 === r3;
            });
            c2 !== -1 && (this.pendingRemoteTracks.splice(c2, 1), this.emit(bk.MediaReconnectEnd, i2.uid));
          });
        }
        async unsubscribe(e2, t2) {
          const r2 = this.pendingRemoteTracks.filter((r3) => {
            let { user: i3, kind: n3 } = r3;
            return t2 !== void 0 ? i3.uid === e2.uid && t2 === n3 : i3.uid === e2.uid;
          });
          if (r2.forEach((e3) => {
            const t3 = this.pendingRemoteTracks.indexOf(e3);
            this.pendingRemoteTracks.splice(t3, 1);
          }), !this.connection)
            return void r2.forEach((t3) => {
              let { kind: r3 } = t3;
              var i3;
              if (r3 === yk.AUDIO)
                (i3 = e2._audioTrack) === null || i3 === void 0 || i3._destroy(), e2._audioTrack = void 0;
              else if (r3 === yk.VIDEO) {
                var n3;
                (n3 = e2._videoTrack) === null || n3 === void 0 || n3._destroy(), e2._videoTrack = void 0;
              }
            });
          ND("debug", this, "unsubscribe", { uid: e2.uid, mediaType: t2 });
          const i2 = this.filterTobeUnSubscribedTracks(e2, t2);
          if (i2.length === 0)
            return;
          await this.connection.stopReceiving(i2.map((e3) => {
            let [, { id: t3 }] = e3;
            return t3;
          }));
          const n2 = this.createUnsubscribeMessage(i2);
          return this.withdrawRemoteTracks(i2), this.remoteUserMap.size === 0 && this.statsUploader.stopUploadDownlinkStats(), i2.forEach((e3) => {
            let [t3, { kind: r3 }] = e3;
            var i3, n3;
            r3 === yk.VIDEO && t3._videoSSRC && ((i3 = this.connection) === null || i3 === void 0 || i3.setStatsRemoteVideoIsReady(t3._videoSSRC, false));
            if (r3 === yk.VIDEO)
              this.unbindRemoteTrackEvents(t3._videoTrack), (n3 = t3._videoTrack) === null || n3 === void 0 || n3._destroy(), t3._videoTrack = void 0;
            else if (r3 === yk.AUDIO) {
              var o2;
              this.unbindRemoteTrackEvents(t3._audioTrack), (o2 = t3._audioTrack) === null || o2 === void 0 || o2._destroy(), t3._audioTrack = void 0;
            }
          }), n2;
        }
        async massUnsubscribe(e2) {
          return this.massUnsubscribeNoLock(e2);
        }
        async massUnsubscribeNoLock(e2) {
          let t2 = [];
          for (const { user: r3, mediaType: i3 } of e2) {
            const e3 = this.pendingRemoteTracks.filter((e4) => {
              let { user: t3, kind: n2 } = e4;
              return i3 !== void 0 ? t3.uid === r3.uid && i3 === n2 : t3.uid === r3.uid;
            });
            e3.forEach((e4) => {
              const t3 = this.pendingRemoteTracks.indexOf(e4);
              this.pendingRemoteTracks.splice(t3, 1);
            }), t2 = t2.concat(e3);
          }
          if (!this.connection)
            return void t2.forEach((e3) => {
              let { user: t3, kind: r3 } = e3;
              var i3;
              if (r3 === yk.AUDIO)
                (i3 = t3._audioTrack) === null || i3 === void 0 || i3._destroy(), t3._audioTrack = void 0;
              else if (r3 === yk.VIDEO) {
                var n2;
                (n2 = t3._videoTrack) === null || n2 === void 0 || n2._destroy(), t3._videoTrack = void 0;
              }
            });
          ND("debug", this, "batchUnsubscribe", e2.map((e3) => {
            let { user: t3, mediaType: r3 } = e3;
            return { uid: t3.uid, mediaType: r3 };
          }));
          const r2 = vh(e2).call(e2, (e3, t3) => {
            let { user: r3, mediaType: i3 } = t3;
            const n2 = this.filterTobeUnSubscribedTracks(r3, i3);
            return e3.concat(n2);
          }, []);
          if (r2.length === 0)
            return;
          await this.connection.stopReceiving(r2.map((e3) => {
            let [, { id: t3 }] = e3;
            return t3;
          }));
          const i2 = this.createUnsubscribeAllMessage(r2);
          return this.withdrawRemoteTracks(r2), this.remoteUserMap.size === 0 && this.statsUploader.stopUploadDownlinkStats(), r2.forEach((e3) => {
            let [t3, { kind: r3 }] = e3;
            var i3, n2;
            r3 === yk.VIDEO && t3._videoSSRC && ((i3 = this.connection) === null || i3 === void 0 || i3.setStatsRemoteVideoIsReady(t3._videoSSRC, false));
            if (r3 === yk.VIDEO)
              this.unbindRemoteTrackEvents(t3._videoTrack), (n2 = t3._videoTrack) === null || n2 === void 0 || n2._destroy(), t3._videoTrack = void 0;
            else if (r3 === yk.AUDIO) {
              var o2;
              this.unbindRemoteTrackEvents(t3._audioTrack), (o2 = t3._audioTrack) === null || o2 === void 0 || o2._destroy(), t3._audioTrack = void 0;
            }
          }), i2;
        }
        async muteRemote(e2, t2) {
          if (!this.connection)
            return;
          ND("debug", this, "muteRemote", { uid: e2.uid, kind: t2 });
          const r2 = this.remoteUserMap.get(e2);
          if (!r2)
            return dD.warning("P2PChannel.muteRemote has no remote user ".concat(e2.uid, ".")), void TD("warning", this, "P2PChannel.muteRemote has no remote user ".concat(e2.uid, "."));
          if (!r2.get(t2))
            return dD.warning("P2PChannel.muteRemote has no remote user ".concat(e2.uid, " media type ").concat(t2, ".")), void TD("warning", this, "P2PChannel.muteRemote has no remote user ".concat(e2.uid, " media type ").concat(t2, "."));
          const i2 = t2 === yk.VIDEO ? e2._videoSSRC : e2._audioSSRC;
          i2 !== void 0 && this.connection.setStatsRemoteVideoIsReady(i2, false);
        }
        async unmuteRemote(e2, t2) {
          return this.unmuteRemoteNoLock(e2, t2);
        }
        async unmuteRemoteNoLock(e2, t2) {
          if (!this.connection)
            return;
          ND("debug", this, "unmuteRemote", { uid: e2.uid, kind: t2 });
          const r2 = this.remoteUserMap.get(e2);
          if (!r2)
            return dD.warning("P2PChannel.unmuteRemote has no remote user ".concat(e2.uid, ".")), void TD("warning", this, "unmuteRemote has no remote user ".concat(e2.uid));
          return r2.get(t2) ? void 0 : (dD.warning("P2PChannel.unmuteRemote has no remote user ".concat(e2.uid, " media type ").concat(t2, ".")), void TD("warning", this, "unmuteRemote has no remote user ".concat(e2.uid, " media type ").concat(t2)));
        }
        getAllTracks(e2) {
          const t2 = this.localTrackMap.get(Tk.LocalAudioTrack);
          if ((t2 == null ? void 0 : t2.track) instanceof Jj) {
            const r2 = t2.track;
            return Array.from(this.localTrackMap.entries()).filter((e3) => {
              let [t3] = e3;
              return t3 !== Tk.LocalAudioTrack;
            }).filter((t3) => {
              let [r3] = t3;
              return !(e2 && r3 === Tk.LocalVideoLowTrack);
            }).map((e3) => {
              let [, { track: t3 }] = e3;
              return t3;
            }).concat(r2.trackList);
          }
          return Array.from(this.localTrackMap.entries()).filter((t3) => {
            let [r2] = t3;
            return !(e2 && r2 === Tk.LocalVideoLowTrack);
          }).map((e3) => {
            let [, { track: t3 }] = e3;
            return t3;
          });
        }
        reportPublishEvent(e2, t2, r2, i2, n2) {
          if (e2) {
            const r3 = this.localTrackMap.get(Tk.LocalAudioTrack), o3 = i2 ? this.localTrackMap.get(Tk.LocalVideoLowTrack) : this.localTrackMap.get(Tk.LocalVideoTrack);
            bV.publish(this.store.sessionId, { eventElapse: $j.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t2, audioName: r3 == null ? void 0 : r3.track.getTrackLabel(), videoName: o3 == null ? void 0 : o3.track.getTrackLabel(), screenshare: (o3 == null ? void 0 : o3.track._hints.indexOf(hk.SCREEN_TRACK)) !== -1, audio: !!r3, video: !!o3, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: n2 });
          } else {
            var o2;
            r2 || (r2 = []);
            const s2 = r2.find((e3) => e3 instanceof Hj), a2 = i2 ? (o2 = this.localTrackMap.get(Tk.LocalVideoTrack)) === null || o2 === void 0 ? void 0 : o2.track : r2.find((e3) => e3 instanceof $q);
            bV.publish(this.store.sessionId, { eventElapse: $j.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t2, audioName: s2 == null ? void 0 : s2.getTrackLabel(), videoName: a2 == null ? void 0 : a2.getTrackLabel(), screenshare: (a2 == null ? void 0 : a2._hints.indexOf(hk.SCREEN_TRACK)) !== -1, audio: !!s2, video: !!a2, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: n2 });
          }
        }
        reportSubscribeEvent(e2, t2, r2, i2) {
          const n2 = i2 === yk.VIDEO ? r2._videoSSRC : r2._audioSSRC;
          n2 && bV.subscribe(this.store.sessionId, { succ: e2, ec: t2, video: i2 === yk.VIDEO, audio: i2 === yk.AUDIO, peerid: r2.uid, subscribeRequestid: i2 === yk.VIDEO ? r2._videoSSRC : r2._audioSSRC, p2pid: this.store.p2pId, eventElapse: $j.measureFromSubscribeStart(this.store.clientId, n2) });
        }
        reset() {
          dD.debug("P2PChannel.reset"), this.mutex = new kV("P2PChannel-mutex"), this.connection && (this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0), this.statsUploader.stopUploadUplinkStats(), this.statsUploader.stopUploadDownlinkStats(), this.statsUploader.stopUploadTransportStats(), this.unbindLocalTrackEvents(), this.unbindAllRemoteTrackEvents(), this.localTrackMap.clear(), this.remoteUserMap.clear(), this.statsCollector.removeRemoteStats(), this.statsCollector.removeLocalStats(), this.iceFailedCount = 0, this.dtlsFailedCount = 0, this.pendingLocalTracks = [], this.pendingRemoteTracks = [], this.state = wk.Disconnected;
        }
        getStats() {
          var e2;
          return (e2 = this.connection) === null || e2 === void 0 ? void 0 : e2.getStats();
        }
        getRemoteVideoIsReady(e2) {
          var t2;
          return ((t2 = this.connection) === null || t2 === void 0 ? void 0 : t2.getRemoteVideoIsReady(e2)) || false;
        }
        getLocalAudioVolume() {
          const e2 = this.localTrackMap.get(Tk.LocalAudioTrack);
          if (e2)
            return e2.track.getVolumeLevel();
        }
        getLocalVideoSize() {
          const e2 = this.localTrackMap.get(Tk.LocalVideoTrack);
          if (e2)
            return { width: e2.track._videoWidth || 0, height: e2.track._videoHeight || 0 };
        }
        getEncoderConfig(e2) {
          const t2 = this.localTrackMap.get(e2);
          return t2 && t2.track instanceof $q || t2 && t2.track instanceof Hj ? t2.track._encoderConfig : void 0;
        }
        getLocalMedia(e2) {
          return this.localTrackMap.get(e2);
        }
        hasLocalMedia() {
          return this.localTrackMap.size > 0;
        }
        hasRemoteMedia(e2, t2) {
          if (!e2)
            return this.remoteUserMap.size > 0;
          const r2 = this.remoteUserMap.get(e2);
          return !!r2 && (!t2 || r2.has(t2));
        }
        async hasRemoteMediaWithLock(e2, t2) {
          if (!e2)
            return this.remoteUserMap.size > 0;
          const r2 = this.remoteUserMap.get(e2);
          return !!r2 && (!t2 || r2.has(t2));
        }
        getRemoteMedia(e2) {
          var t2;
          const r2 = Array.from(hV(t2 = this.remoteUserMap).call(t2)).find((t3) => t3.uid === e2);
          return r2 ? { audioTrack: r2.audioTrack, audioSSRC: r2._audioSSRC, videoTrack: r2.videoTrack, videoSSRC: r2._videoSSRC } : {};
        }
        getAudioLevels() {
          let e2 = Array.from(this.remoteUserMap.entries()).map((e3) => {
            let [t3] = e3;
            return { uid: t3.uid, level: t3.audioTrack ? 100 * t3.audioTrack._source.getAccurateVolumeLevel() : 0 };
          });
          const t2 = this.localTrackMap.get(Tk.LocalAudioTrack);
          return t2 && e2.push({ level: 100 * t2.track._source.getAccurateVolumeLevel(), uid: this.store.uid }), e2 = qL(e2).call(e2, (e3, t3) => e3.level - t3.level), e2;
        }
        async disconnectForReconnect() {
          this.connection && (ND("debug", this, "disconnectForReconnect"), dD.debug("P2PChannel.disconnectForReconnect closing P2PConnection"), this.state = wk.Reconnecting, this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0, this.localTrackMap.size !== 0 && (Array.from(this.localTrackMap.entries()).forEach((e2) => {
            let [t2, { track: r2 }] = e2;
            switch (t2) {
              case Tk.LocalVideoTrack:
                r2._hints.includes(hk.LOW_STREAM) ? r2.close() : this.pendingLocalTracks.push(r2);
                break;
              case Tk.LocalAudioTrack:
                r2 instanceof Jj ? this.pendingLocalTracks = this.pendingLocalTracks.concat(r2.trackList) : this.pendingLocalTracks.push(r2);
                break;
              case Tk.LocalVideoLowTrack:
            }
          }), this.emit(bk.MediaReconnectStart, this.store.uid)), this.unbindLocalTrackEvents(), this.localTrackMap.clear(), this.remoteUserMap.size !== 0 && Array.from(this.remoteUserMap.entries()).forEach((e2) => {
            let [t2, r2] = e2;
            Array.from(hV(r2).call(r2)).forEach((e3) => {
              this.setPendingRemoteMedia(t2, e3);
            }), this.emit(bk.MediaReconnectStart, t2.uid);
          }), this.unbindAllRemoteTrackEvents(), this.remoteUserMap.clear(), this.statsUploader.stopUploadUplinkStats(), this.statsUploader.stopUploadDownlinkStats(), this.statsUploader.stopUploadTransportStats(), dD.debug("P2PChannel disconnected, waiting to reconnect."));
        }
        hasPendingRemoteMedia(e2, t2) {
          for (const r2 of this.pendingRemoteTracks) {
            const { user: i2, kind: n2 } = r2;
            if ((e2 instanceof iz ? e2.uid : e2) === i2.uid && t2 === n2)
              return true;
          }
          return false;
        }
        setPendingRemoteMedia(e2, t2) {
          this.hasPendingRemoteMedia(e2, t2) || this.pendingRemoteTracks.push({ user: e2, kind: t2 });
        }
        async reEstablish() {
          if (this.connection)
            return this.connection.reEstablish();
        }
        getUplinkNetworkQuality() {
          if (!this.connection)
            return 0;
          const e2 = this.connection.getStats(), t2 = this.localTrackMap.get(Tk.LocalVideoTrack), r2 = this.localTrackMap.get(Tk.LocalAudioTrack), i2 = e2.videoSend.find((e3) => e3.ssrc === (t2 == null ? void 0 : t2.ssrcs[0].ssrcId)), n2 = e2.audioSend.find((e3) => e3.ssrc === (r2 == null ? void 0 : r2.ssrcs[0].ssrcId));
          if (!i2 || !n2)
            return 1;
          const o2 = NG(this, bk.NeedSignalRTT), s2 = i2 ? i2.rttMs : void 0, a2 = n2 ? n2.rttMs : void 0, c2 = s2 && a2 ? (s2 + a2) / 2 : s2 || a2, d2 = (c2 && o2 ? (c2 + o2) / 2 : c2 || o2) || 0, u2 = 100 * e2.sendPacketLossRate * 0.7 / 50 + 0.3 * d2 / 1500, A2 = u2 < 0.17 ? 1 : u2 < 0.36 ? 2 : u2 < 0.59 ? 3 : u2 < 0.1 ? 4 : 5, h2 = t2 == null ? void 0 : t2.track;
          if (h2 && h2._encoderConfig && h2._hints.indexOf(hk.SCREEN_TRACK) === -1) {
            const t3 = h2._encoderConfig.bitrateMax, r3 = e2.bitrate.actualEncoded;
            if (t3 && r3) {
              const e3 = (1e3 * t3 - r3) / (1e3 * t3);
              return tL[e3 < 0.15 ? 0 : e3 < 0.3 ? 1 : e3 < 0.45 ? 2 : e3 < 0.6 ? 3 : 4][A2];
            }
          }
          return A2;
        }
        getDownlinkNetworkQuality() {
          if (!this.connection)
            return 0;
          const e2 = this.connection.getStats();
          let t2 = 0;
          return Array.from(this.remoteUserMap.entries()).forEach((r2) => {
            let [i2] = r2;
            const n2 = i2._audioSSRC, o2 = i2._videoSSRC, s2 = e2.audioRecv.find((e3) => e3.ssrc === n2), a2 = e2.videoRecv.find((e3) => e3.ssrc === o2);
            if (!s2 && !a2)
              return void (t2 += 1);
            const c2 = NG(this, bk.NeedSignalRTT), d2 = e2.rtt, u2 = (d2 && c2 ? (d2 + c2) / 2 : d2 || c2) || 0, A2 = s2 ? s2.jitterMs : void 0, h2 = e2.recvPacketLossRate;
            let l2 = 0.7 * h2 * 100 / 50 + 0.3 * u2 / 1500;
            A2 && (l2 = 0.6 * h2 * 100 / 50 + 0.2 * u2 / 1500 + 0.2 * A2 / 400);
            t2 += l2 < 0.1 ? 1 : l2 < 0.17 ? 2 : l2 < 0.36 ? 3 : l2 < 0.59 ? 4 : 5;
          }), this.remoteUserMap.size > 0 ? Math.round(t2 / this.remoteUserMap.size) : t2;
        }
        async muteLocalTrack(e2) {
          return new nR((t2, r2) => {
            this.handleMuteLocalTrack(e2, t2, r2);
          });
        }
        filterTobePublishedTracks(e2, t2, r2) {
          const i2 = [], n2 = Mk(), o2 = this.getAllTracks();
          e2 = PG(e2 = e2.filter((e3) => o2.indexOf(e3) === -1));
          let s2 = false, a2 = false;
          for (const o3 of e2) {
            if (o3 instanceof $q && (this.localTrackMap.has(Tk.LocalVideoTrack) || s2 ? new tD(eD.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw() : (i2.push({ track: o3, type: Tk.LocalVideoTrack }), s2 = true), t2)) {
              const e3 = this.getLowVideoTrack(o3, r2);
              i2.push({ track: e3, type: Tk.LocalVideoLowTrack });
            }
            if (o3 instanceof Hj) {
              const e3 = this.localTrackMap.get(Tk.LocalAudioTrack);
              if (e3) {
                if (!(e3.track instanceof Jj))
                  throw new tD(eD.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
                if (o3._bypassWebAudio)
                  throw new tD(eD.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
                e3.track.addAudioTrack(o3), this.bindLocalAudioTrackEvents(o3, true);
              } else if (a2) {
                const e4 = i2.find((e5) => {
                  let { type: t3 } = e5;
                  return t3 === Tk.LocalAudioTrack;
                });
                if (!(e4.track instanceof Jj))
                  throw new tD(eD.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
                if (o3._bypassWebAudio)
                  throw new tD(eD.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
                e4.track.addAudioTrack(o3);
              } else {
                if (!n2.webAudioMediaStreamDest || o3 instanceof Jj || o3._bypassWebAudio)
                  i2.push({ track: o3, type: Tk.LocalAudioTrack });
                else {
                  const e4 = new Jj();
                  e4.addAudioTrack(o3), i2.push({ track: e4, type: Tk.LocalAudioTrack });
                }
                a2 = true;
              }
            }
          }
          return i2;
        }
        filterTobeUnpublishedTracks(e2) {
          const t2 = [], r2 = this.getAllTracks();
          e2 = PG(e2 = e2.filter((e3) => r2.indexOf(e3) !== -1));
          for (const r3 of e2) {
            if (r3 instanceof Hj) {
              const e3 = this.localTrackMap.get(Tk.LocalAudioTrack);
              if (!e3)
                continue;
              e3.track instanceof Jj ? (e3.track.removeAudioTrack(r3), this.unbindLocalAudioTrackEvents(r3), e3.track.trackList.length === 0 && (t2.push([Tk.LocalAudioTrack, e3]), e3.track.close())) : t2.push([Tk.LocalAudioTrack, e3]);
            }
            if (r3 instanceof $q) {
              const e3 = this.localTrackMap.get(Tk.LocalVideoTrack);
              if (!e3)
                continue;
              t2.push([Tk.LocalVideoTrack, e3]);
              const r4 = this.localTrackMap.get(Tk.LocalVideoLowTrack);
              r4 && t2.push([Tk.LocalVideoLowTrack, r4]);
            }
          }
          return t2;
        }
        bindLocalTrackEvents(e2) {
          e2.forEach((e3) => {
            let { track: t2, type: r2 } = e3;
            switch (r2) {
              case Tk.LocalVideoTrack:
                t2.addListener(Ak.GET_STATS, this.handleGetLocalVideoStats), t2.addListener(Ak.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.addListener(Ak.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.addListener(Ak.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.addListener(Ak.SET_OPTIMIZATION_MODE, this.handleSetOptimizationMode), t2.addListener(Ak.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.addListener(Ak.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.addListener(Ak.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                break;
              case Tk.LocalAudioTrack:
                this.bindLocalAudioTrackEvents(t2);
                break;
              case Tk.LocalVideoLowTrack:
            }
          });
        }
        bindLocalAudioTrackEvents(e2, t2) {
          e2 instanceof Jj ? e2.trackList.forEach((e3) => {
            e3.addListener(Ak.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.addListener(Ak.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.addListener(Ak.GET_STATS, this.handleGetLocalAudioStats), e3.addListener(Ak.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.addListener(Ak.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          }) : (e2.addListener(Ak.GET_STATS, this.handleGetLocalAudioStats), e2.addListener(Ak.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.addListener(Ak.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.addListener(Ak.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.addListener(Ak.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack), t2 || e2.addListener(Ak.NEED_REPLACE_TRACK, this.handleReplaceTrack));
        }
        unbindLocalTrackEvents(e2) {
          e2 || (e2 = Array.from(this.localTrackMap.entries()).map((e3) => {
            let [t2, { track: r2 }] = e3;
            return { track: r2, type: t2 };
          })), e2.forEach((e3) => {
            let { track: t2, type: r2 } = e3;
            switch (r2) {
              case Tk.LocalVideoTrack:
                t2.off(Ak.GET_STATS, this.handleGetLocalVideoStats), t2.off(Ak.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.off(Ak.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.off(Ak.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.off(Ak.SET_OPTIMIZATION_MODE, this.handleSetOptimizationMode), t2.off(Ak.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.off(Ak.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.off(Ak.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                break;
              case Tk.LocalAudioTrack:
                this.unbindLocalAudioTrackEvents(t2);
                break;
              case Tk.LocalVideoLowTrack:
            }
          });
        }
        unbindLocalAudioTrackEvents(e2) {
          e2 instanceof Jj ? e2.trackList.forEach((e3) => {
            e3.off(Ak.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.off(Ak.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.off(Ak.GET_STATS, this.handleGetLocalAudioStats), e3.off(Ak.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.off(Ak.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          }) : (e2.off(Ak.GET_STATS, this.handleGetLocalAudioStats), e2.off(Ak.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.off(Ak.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.off(Ak.NEED_REPLACE_TRACK, this.handleReplaceTrack), e2.off(Ak.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.off(Ak.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack));
        }
        bindRemoteTrackEvents(e2, t2) {
          t2 instanceof B$ && t2.addListener(Ak.GET_STATS, (t3) => {
            t3(this.handleGetRemoteVideoStats(e2));
          }), t2 instanceof M$ && t2.addListener(Ak.GET_STATS, (t3) => {
            t3(this.handleGetRemoteAudioStats(e2));
          });
        }
        unbindRemoteTrackEvents(e2) {
          e2 && e2.removeAllListeners(Ak.GET_STATS);
        }
        unbindAllRemoteTrackEvents() {
          Array.from(this.remoteUserMap.entries()).forEach((e2) => {
            let [t2, r2] = e2;
            r2.has(yk.AUDIO) && this.unbindRemoteTrackEvents(t2._audioTrack), r2.has(yk.VIDEO) && this.unbindRemoteTrackEvents(t2._videoTrack);
          });
        }
        createGatewayPublishMessage(e2, t2) {
          return e2.map((e3, r2) => {
            let i2, n2, { track: o2, type: s2 } = e3;
            switch (s2) {
              case Tk.LocalAudioTrack:
                i2 = ck.Audio, n2 = { dtx: o2 instanceof Yj && o2._config.DTX, hq: false, lq: false, stereo: false, speech: false };
                break;
              case Tk.LocalVideoTrack:
                i2 = o2._hints.includes(hk.SCREEN_TRACK) ? ck.Screen : ck.High, n2 = G$(G$({}, AG(o2)), {}, { codec: this.store.codec });
                break;
              case Tk.LocalVideoLowTrack:
                i2 = ck.Low, n2 = G$(G$({}, AG(o2)), {}, { codec: this.store.codec });
            }
            return { stream_type: i2, attributes: n2, ssrcs: t2[r2] };
          });
        }
        createGatewayUnpublishMessage(e2) {
          return e2.map((e3) => {
            let t2, [r2, { track: i2, ssrcs: n2, id: o2 }] = e3;
            switch (r2) {
              case Tk.LocalVideoTrack:
                t2 = i2._hints.includes(hk.SCREEN_TRACK) ? ck.Screen : ck.High;
                break;
              case Tk.LocalAudioTrack:
                t2 = ck.Audio;
                break;
              case Tk.LocalVideoLowTrack:
                t2 = ck.Low;
            }
            return { stream_type: t2, ssrcs: n2, mid: o2 };
          });
        }
        assignLocalTracks(e2, t2) {
          e2.forEach((e3, r2) => {
            let { track: i2, type: n2 } = e3;
            this.localTrackMap.set(n2, { track: i2, id: t2[r2].id, ssrcs: t2[r2].localSSRC });
          });
        }
        withdrawLocalTracks(e2) {
          e2.forEach((e3) => {
            let [t2] = e3;
            this.localTrackMap.delete(t2);
          });
        }
        async waitTillConnected() {
          return new nR((e2, t2) => {
            switch (this.state) {
              case wk.New:
              case wk.Reconnecting: {
                const r2 = (i2, n2) => n2 === wk.Disconnected ? (this.off(bk.StateChange, r2), void t2(new tD(eD.UNEXPECTED_ERROR, "PeerConnection already disconnected."))) : n2 === wk.Connected ? (this.off(bk.StateChange, r2), void e2(void 0)) : void 0;
                this.on(bk.StateChange, r2);
                break;
              }
              case wk.Connected:
                e2(void 0);
                break;
              case wk.Disconnected:
                t2(new tD(eD.UNEXPECTED_ERROR, "PeerConnection already disconnected."));
            }
          });
        }
        bindConnectionEvents(e2) {
          e2.onConnectionStateChange = async (t2) => {
            if (dD.info("[p2pId: ".concat(this.store.p2pId, "]: P2PConnection.onConnectionStateChange(").concat(t2, ")")), wD("info", this, "connectionStateChange", t2), this.emit(bk.PeerConnectionStateChange, t2), t2 !== "connected" || this.store.keyMetrics.peerConnectionEnd || this.store.peerConnectionEnd(), t2 === "failed") {
              e2.iceConnectionState === "failed" ? (setTimeout(() => this.emit(bk.P2PLost), 0), this.iceFailedCount += 1, await CG(iD(this.iceFailedCount, rD)), this.emit(bk.RequestRestartICE)) : await this.requestReconnect();
            }
          }, e2.onICEConnectionStateChange = (e3) => {
            dD.info("[p2pId: ".concat(this.store.p2pId, "]: P2PConnection.onICEConnectionStateChange(").concat(e3, ")")), wD("info", this, "iceConnectionStateChange", e3), bV.reportApiInvoke(this.store.sessionId, { name: "ICEConnectionStateChange", options: e3, tag: EP.TRACER }).onSuccess(), this.emit(bk.IceConnectionStateChange, e3);
          }, e2.onICETransportStateChange = (e3) => {
            dD.info("[p2pId: ".concat(this.store.p2pId, "]: P2PConnection.onICETransportStateChange(").concat(e3, ")")), wD("info", this, "ICETransportStateChange", e3);
          }, e2.onDTLSTransportStateChange = (e3) => {
            dD.info("[p2pId: ".concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportStateChange(").concat(e3, ")")), wD("info", this, "DTLSTransportStateChange", e3);
          }, e2.onDTLSTransportError = (e3) => {
            dD.info("[p2pId: ".concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportError(").concat(e3, ")")), wD("info", this, "DTLSTransportError", e3);
          }, e2.onFirstAudioDecoded = (e3) => {
            var t2;
            const r2 = Array.from(hV(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._audioSSRC === e3);
            var i2;
            r2 && ((i2 = r2.audioTrack) === null || i2 === void 0 || i2.emit(fk.FIRST_FRAME_DECODED), bV.firstRemoteFrame(this.store.sessionId, lP.FIRST_AUDIO_DECODE, pP.FIRST_AUDIO_DECODE, { peer: r2._uintid, subscribeElapse: $j.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId }));
          }, e2.onFirstAudioReceived = (e3) => {
            var t2;
            const r2 = Array.from(hV(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._audioSSRC === e3);
            r2 && bV.firstRemoteFrame(this.store.sessionId, lP.FIRST_AUDIO_RECEIVED, pP.FIRST_AUDIO_RECEIVED, { peer: r2._uintid, subscribeElapse: $j.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId });
          }, e2.onFirstVideoDecoded = (e3, t2, r2) => {
            var i2;
            const n2 = Array.from(hV(i2 = this.remoteUserMap).call(i2)).find((t3) => t3._videoSSRC === e3);
            n2 && bV.firstRemoteFrame(this.store.sessionId, lP.FIRST_VIDEO_DECODE, pP.FIRST_VIDEO_DECODE, { peer: n2._uintid, videowidth: t2, videoheight: r2, subscribeElapse: $j.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId });
          }, e2.onFirstVideoReceived = (e3) => {
            var t2;
            const r2 = Array.from(hV(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._videoSSRC === e3);
            r2 && bV.firstRemoteFrame(this.store.sessionId, lP.FIRST_VIDEO_RECEIVED, pP.FIRST_VIDEO_RECEIVED, { peer: r2._uintid, subscribeElapse: $j.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId });
          }, e2.onSelectedLocalCandidateChanged = (e3, t2) => {
            const r2 = e3.candidateType === "relay", i2 = t2.candidateType === "relay";
            t2.candidateType !== "unknown" && r2 === i2 || this.emit(bk.ConnectionTypeChange, r2), dD.info("[p2pId: ".concat(this.store.p2pId, "]: P2PConnection.SelectedLocalCandidateChanged(").concat(JSON.stringify(EG(t2)), " -> ").concat(JSON.stringify(EG(e3)), ")")), wD("info", this, "SelectedLocalCandidateChanged", "".concat(JSON.stringify(EG(t2)), " -> ").concat(JSON.stringify(EG(e3))));
          }, e2.onSelectedRemoteCandidateChanged = (e3, t2) => {
            dD.info("[p2pId: ".concat(this.store.p2pId, "]: P2PConnection.SelectedRemoteCandidateChanged(").concat(JSON.stringify(EG(t2)), " -> ").concat(JSON.stringify(EG(e3)), ")")), wD("info", this, "SelectedRemoteCandidateChanged", "".concat(JSON.stringify(EG(t2)), " -> ").concat(JSON.stringify(EG(e3))));
          };
        }
        unbindConnectionEvents(e2) {
          e2.onConnectionStateChange = void 0, e2.onICEConnectionStateChange = void 0, e2.onICETransportStateChange = void 0, e2.onDTLSTransportStateChange = void 0, e2.onDTLSTransportError = void 0, e2.onFirstAudioDecoded = void 0, e2.onFirstAudioReceived = void 0, e2.onFirstVideoDecoded = void 0, e2.onFirstVideoReceived = void 0, e2.onSelectedLocalCandidateChanged = void 0, e2.onSelectedRemoteCandidateChanged = void 0;
        }
        filterTobeMutedTracks(e2) {
          const t2 = [];
          if (this.getAllTracks().indexOf(e2) === -1)
            return t2;
          const r2 = this.localTrackMap.get(Tk.LocalAudioTrack);
          if (e2 instanceof Hj && (r2 == null ? void 0 : r2.track) instanceof Jj)
            return r2.track.isActive || t2.push([Tk.LocalAudioTrack, r2]), t2;
          const i2 = Array.from(this.localTrackMap.entries()).find((t3) => {
            let [, { track: r3 }] = t3;
            return e2 === r3;
          });
          if (i2 && (t2.push(i2), i2[0] === Tk.LocalVideoTrack)) {
            const e3 = this.localTrackMap.get(Tk.LocalVideoLowTrack);
            e3 && t2.push([Tk.LocalVideoLowTrack, e3]);
          }
          return t2;
        }
        filterTobeUnmutedTracks(e2) {
          const t2 = [], r2 = this.localTrackMap.get(Tk.LocalAudioTrack);
          if (e2 instanceof Hj && (r2 == null ? void 0 : r2.track) instanceof Jj)
            return r2.track.isActive && t2.push([Tk.LocalAudioTrack, r2]), t2;
          const i2 = Array.from(this.localTrackMap.entries()).find((t3) => {
            let [, { track: r3 }] = t3;
            return e2 === r3;
          });
          if (i2)
            if (i2[0] === Tk.LocalVideoTrack) {
              t2.push(i2);
              const e3 = this.localTrackMap.get(Tk.LocalVideoLowTrack);
              e3 && t2.push([Tk.LocalVideoLowTrack, e3]);
            } else
              t2.push(i2);
          return t2;
        }
        createMuteMessage(e2) {
          return e2.map((e3) => {
            let t2, [r2, { track: i2, ssrcs: n2, id: o2 }] = e3;
            switch (r2) {
              case Tk.LocalAudioTrack:
                t2 = ck.Audio;
                break;
              case Tk.LocalVideoTrack:
                t2 = i2._hints.includes(hk.SCREEN_TRACK) ? ck.Screen : ck.High;
                break;
              case Tk.LocalVideoLowTrack:
                t2 = ck.Low;
            }
            return { stream_type: t2, ssrcs: n2, mid: o2 };
          });
        }
        createUnmuteMessage(e2) {
          return e2.map((e3) => {
            let t2, [r2, { track: i2, ssrcs: n2, id: o2 }] = e3;
            switch (r2) {
              case Tk.LocalAudioTrack:
                t2 = ck.Audio;
                break;
              case Tk.LocalVideoTrack:
                t2 = i2._hints.includes(hk.SCREEN_TRACK) ? ck.Screen : ck.High;
                break;
              case Tk.LocalVideoLowTrack:
                t2 = ck.Low;
            }
            return { stream_type: t2, ssrcs: n2, mid: o2 };
          });
        }
        filterTobeUnSubscribedTracks(e2, t2) {
          const r2 = [], i2 = this.remoteUserMap.get(e2);
          if (!i2)
            return r2;
          if (t2) {
            const n2 = i2.get(t2);
            if (!n2)
              return r2;
            r2.push([e2, { kind: t2, id: n2 }]);
          } else
            Array.from(i2.entries()).forEach((t3) => {
              let [i3, n2] = t3;
              r2.push([e2, { kind: i3, id: n2 }]);
            });
          return r2;
        }
        createUnsubscribeMessage(e2) {
          const t2 = [];
          return e2.forEach((e3) => {
            let [r2, { kind: i2, id: n2 }] = e3;
            switch (i2) {
              case yk.VIDEO:
                return void (r2._videoSSRC && t2.push({ stream_type: yk.VIDEO, ssrcId: r2._videoSSRC }));
              case yk.AUDIO:
                return void (r2._audioSSRC && t2.push({ stream_type: yk.AUDIO, ssrcId: r2._audioSSRC }));
            }
          }), t2;
        }
        createUnsubscribeAllMessage(e2) {
          const t2 = /* @__PURE__ */ new Map();
          return e2.forEach((e3) => {
            let [r2, { kind: i2 }] = e3;
            if (t2.has(r2)) {
              let e4 = t2.get(r2);
              i2 === yk.VIDEO ? e4 |= uk.Video : e4 |= uk.Audio, t2.set(r2, e4);
            } else
              i2 === yk.VIDEO ? t2.set(r2, uk.Video) : t2.set(r2, uk.Audio);
          }), { users: Array.from(t2.entries()).map((e3) => {
            let [t3, r2] = e3;
            return { stream_id: t3.uid, stream_type: r2 };
          }) };
        }
        withdrawRemoteTracks(e2) {
          e2.forEach((e3) => {
            let [t2, { kind: r2 }] = e3;
            const i2 = this.remoteUserMap.get(t2);
            i2 && (i2.delete(r2), Array.from(i2.entries()).length === 0 && this.remoteUserMap.delete(t2));
          });
        }
        async updateBitrateLimit(e2) {
          const t2 = this.localTrackMap.get(Tk.LocalVideoTrack), r2 = this.localTrackMap.get(Tk.LocalVideoLowTrack);
          t2 && await t2.track.setBitrateLimit(e2.uplink), r2 && e2.low_stream_uplink && await r2.track.setBitrateLimit({ max_bitrate: e2.low_stream_uplink.bitrate, min_bitrate: e2.low_stream_uplink.bitrate || 0 });
        }
        isP2PDisconnected() {
          if (this.connection) {
            return this.connection.peerConnectionState !== "connected";
          }
          return true;
        }
        mapPubResToRemoteConfig(e2, t2) {
          return e2.map((e3, r2) => {
            var i2;
            let { stream_type: n2 } = e3;
            return (i2 = t2.find((e4) => {
              let { stream_type: t3 } = e4;
              return n2 === t3;
            })) === null || i2 === void 0 ? void 0 : i2.attributes;
          });
        }
        async tryToUnmuteAudio(e2) {
          for (let r2 = 0; r2 < e2.length; r2++)
            if (e2[r2] instanceof Hj) {
              var t2;
              const i2 = this.filterTobeUnmutedTracks(e2[r2]);
              if (i2.length === 0)
                continue;
              await ((t2 = this.connection) === null || t2 === void 0 ? void 0 : t2.unmuteLocal(i2.map((e3) => {
                let [, { id: t3 }] = e3;
                return t3;
              })));
              const n2 = this.createUnmuteMessage(i2);
              return void await OG(this, bk.RequestUnmuteLocal, n2);
            }
        }
        bindStatsUploaderEvents() {
          this.statsUploader.requestStats = () => this.getStats(), this.statsUploader.requestLocalMedia = () => Array.from(this.localTrackMap.entries()), this.statsUploader.requestRemoteMedia = () => Array.from(this.remoteUserMap.entries()), this.statsUploader.requestVideoIsReady = (e2) => {
            var t2;
            return !((t2 = this.connection) === null || t2 === void 0 || !t2.getRemoteVideoIsReady(e2));
          }, this.statsUploader.requestUpload = (e2, t2) => this.emit(bk.RequestUploadStats, e2, t2), this.statsUploader.requestAllTracks = () => this.getAllTracks();
        }
        unbindStatsUploaderEvents() {
          this.statsUploader.requestStats = void 0, this.statsUploader.requestLocalMedia = void 0, this.statsUploader.requestRemoteMedia = void 0, this.statsUploader.requestVideoIsReady = void 0;
        }
        async requestReconnect() {
          this.dtlsFailedCount += 1, await CG(iD(this.dtlsFailedCount, rD)), this.emit(bk.RequestReconnect);
        }
        async reconnectP2P() {
          const e2 = Array.from(this.localTrackMap.entries()), t2 = this.createGatewayUnpublishMessage(e2);
          Array.from(this.remoteUserMap.entries()), t2.length > 0 && await bG(this, bk.RequestUnpublishForReconnectPC, t2), this.disconnectForReconnect(), this.emit(bk.RequestReconnectPC);
        }
        canPublishLowStream() {
          return this.localTrackMap.has(Tk.LocalVideoTrack) || this.pendingLocalTracks.some((e2) => e2 instanceof $q);
        }
        throwIfTrackTypeNotMatch(e2) {
          if (e2.filter((e3) => e3 instanceof $q).length > 1)
            throw new tD(eD.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
          if (e2.filter((e3) => e3 instanceof Hj).length > 1 && (e2.some((e3) => e3 instanceof Hj && e3._bypassWebAudio) || !Mk().webAudioMediaStreamDest))
            throw new tD(eD.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
          for (const t2 of e2) {
            if (t2 instanceof $q && this.pendingLocalTracks.some((e3) => e3 instanceof $q))
              throw new tD(eD.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
            if (t2 instanceof Hj && this.pendingLocalTracks.some((e3) => e3 instanceof Hj) && (!Mk().webAudioMediaStreamDest || t2._bypassWebAudio || this.pendingLocalTracks.some((e3) => e3 instanceof Hj && e3._bypassWebAudio)))
              throw new tD(eD.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
          }
        }
        getLowVideoTrack(e2, t2) {
          const r2 = Mk().supportDualStreamEncoding, i2 = G$(G$({}, { width: 160, height: 120, framerate: 15, bitrate: 50 }), t2);
          let n2;
          n2 = r2 ? e2._mediaStreamTrack.clone() : O$(e2, i2);
          const o2 = new $q(n2, G$(G$({}, r2 && { scaleResolutionDownBy: fG(i2, e2) }), {}, { frameRate: i2.framerate, bitrateMax: i2.bitrate, bitrateMin: i2.bitrate }));
          return o2._hints.push(hk.LOW_STREAM), o2;
        }
        async globalLock() {
          return this.mutex.lock("From P2PChannel.globalLock");
        }
      }).prototype, "startP2PConnection", [W$], Object.getOwnPropertyDescriptor(V$.prototype, "startP2PConnection"), V$.prototype), zF(V$.prototype, "connect", [W$], Object.getOwnPropertyDescriptor(V$.prototype, "connect"), V$.prototype), zF(V$.prototype, "unpublish", [W$], Object.getOwnPropertyDescriptor(V$.prototype, "unpublish"), V$.prototype), zF(V$.prototype, "unpublishLowStream", [W$], Object.getOwnPropertyDescriptor(V$.prototype, "unpublishLowStream"), V$.prototype), zF(V$.prototype, "subscribe", [W$], Object.getOwnPropertyDescriptor(V$.prototype, "subscribe"), V$.prototype), zF(V$.prototype, "massSubscribe", [W$], Object.getOwnPropertyDescriptor(V$.prototype, "massSubscribe"), V$.prototype), zF(V$.prototype, "unsubscribe", [W$], Object.getOwnPropertyDescriptor(V$.prototype, "unsubscribe"), V$.prototype), zF(V$.prototype, "massUnsubscribe", [W$], Object.getOwnPropertyDescriptor(V$.prototype, "massUnsubscribe"), V$.prototype), zF(V$.prototype, "muteRemote", [W$], Object.getOwnPropertyDescriptor(V$.prototype, "muteRemote"), V$.prototype), zF(V$.prototype, "unmuteRemote", [W$], Object.getOwnPropertyDescriptor(V$.prototype, "unmuteRemote"), V$.prototype), zF(V$.prototype, "hasRemoteMediaWithLock", [W$], Object.getOwnPropertyDescriptor(V$.prototype, "hasRemoteMediaWithLock"), V$.prototype), zF(V$.prototype, "disconnectForReconnect", [W$], Object.getOwnPropertyDescriptor(V$.prototype, "disconnectForReconnect"), V$.prototype), zF(V$.prototype, "reEstablish", [W$], Object.getOwnPropertyDescriptor(V$.prototype, "reEstablish"), V$.prototype), zF(V$.prototype, "updateBitrateLimit", [W$], Object.getOwnPropertyDescriptor(V$.prototype, "updateBitrateLimit"), V$.prototype), F$ = V$)) || F$;
      function W$(e2, t2, r2) {
        const i2 = e2[t2];
        if (typeof i2 != "function")
          throw new Error("Cannot use mutex on object property.");
        return r2.value = async function() {
          const e3 = this.mutex, r3 = await e3.lock("From P2PChannel.".concat(t2));
          try {
            for (var n2 = arguments.length, o2 = new Array(n2), s2 = 0; s2 < n2; s2++)
              o2[s2] = arguments[s2];
            return await i2.apply(this, o2);
          } finally {
            r3();
          }
        }, r2;
      }
      function J$(e2) {
        return "Minified Redux error #" + e2 + "; visit https://redux.js.org/Errors?code=" + e2 + " for the full message or use the non-minified dev environment for full errors. ";
      }
      var q$, z$ = typeof Symbol == "function" && Symbol.observable || "@@observable", X$ = function() {
        return Math.random().toString(36).substring(7).split("").join(".");
      }, Z$ = { INIT: "@@redux/INIT" + X$(), REPLACE: "@@redux/REPLACE" + X$(), PROBE_UNKNOWN_ACTION: function() {
        return "@@redux/PROBE_UNKNOWN_ACTION" + X$();
      } };
      function $$(e2) {
        if (typeof e2 != "object" || e2 === null)
          return false;
        for (var t2 = e2; Object.getPrototypeOf(t2) !== null; )
          t2 = Object.getPrototypeOf(t2);
        return Object.getPrototypeOf(e2) === t2;
      }
      function e1(e2, t2, r2) {
        var i2;
        if (typeof t2 == "function" && typeof r2 == "function" || typeof r2 == "function" && typeof arguments[3] == "function")
          throw new Error(J$(0));
        if (typeof t2 == "function" && r2 === void 0 && (r2 = t2, t2 = void 0), r2 !== void 0) {
          if (typeof r2 != "function")
            throw new Error(J$(1));
          return r2(e1)(e2, t2);
        }
        if (typeof e2 != "function")
          throw new Error(J$(2));
        var n2 = e2, o2 = t2, s2 = [], a2 = s2, c2 = false;
        function d2() {
          a2 === s2 && (a2 = s2.slice());
        }
        function u2() {
          if (c2)
            throw new Error(J$(3));
          return o2;
        }
        function A2(e3) {
          if (typeof e3 != "function")
            throw new Error(J$(4));
          if (c2)
            throw new Error(J$(5));
          var t3 = true;
          return d2(), a2.push(e3), function() {
            if (t3) {
              if (c2)
                throw new Error(J$(6));
              t3 = false, d2();
              var r3 = a2.indexOf(e3);
              a2.splice(r3, 1), s2 = null;
            }
          };
        }
        function h2(e3) {
          if (!$$(e3))
            throw new Error(J$(7));
          if (e3.type === void 0)
            throw new Error(J$(8));
          if (c2)
            throw new Error(J$(9));
          try {
            c2 = true, o2 = n2(o2, e3);
          } finally {
            c2 = false;
          }
          for (var t3 = s2 = a2, r3 = 0; r3 < t3.length; r3++) {
            (0, t3[r3])();
          }
          return e3;
        }
        function l2(e3) {
          if (typeof e3 != "function")
            throw new Error(J$(10));
          n2 = e3, h2({ type: Z$.REPLACE });
        }
        function p2() {
          var e3, t3 = A2;
          return (e3 = { subscribe: function(e4) {
            if (typeof e4 != "object" || e4 === null)
              throw new Error(J$(11));
            function r3() {
              e4.next && e4.next(u2());
            }
            return r3(), { unsubscribe: t3(r3) };
          } })[z$] = function() {
            return this;
          }, e3;
        }
        return h2({ type: Z$.INIT }), (i2 = { dispatch: h2, subscribe: A2, getState: u2, replaceReducer: l2 })[z$] = p2, i2;
      }
      function t1(e2, t2) {
        var r2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          t2 && (i2 = i2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), r2.push.apply(r2, i2);
        }
        return r2;
      }
      function r1(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r2 = arguments[t2] != null ? arguments[t2] : {};
          t2 % 2 ? t1(Object(r2), true).forEach(function(t3) {
            kO(e2, t3, r2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : t1(Object(r2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
          });
        }
        return e2;
      }
      !function(e2) {
        e2.SET_SESSION_ID = "SET_SESSION_ID", e2.SET_P2P_ID = "SET_P2P_id", e2.SET_UID = "SET_UID", e2.SET_PUB_ID = "SET_PUB_ID", e2.SET_CLOUD_PROXY_SERVER_MODE = "SET_CLOUD_PROXY_SERVER_MODE", e2.KEY_METRIC_CLIENT_CREATED = "KEY_METRIC_CLIENT_CREATED", e2.KEY_METRIC_JOIN_START = "KEY_METRIC_JOIN_START", e2.AVOID_JOIN_START = "AVOID_JOIN_START", e2.KEY_METRIC_JOIN_END = "KEY_METRIC_JOIN_END", e2.KEY_METRIC_REQUEST_AP_START = "KEY_METRIC_REQUEST_AP_START", e2.KEY_METRIC_REQUEST_AP_END = "KEY_METRIC_REQUEST_AP_END", e2.KEY_METRIC_JOIN_GATEWAY_START = "KEY_METRIC_JOIN_GATEWAY_START", e2.KEY_METRIC_JOIN_GATEWAY_END = "KEY_METRIC_JOIN_GATEWAY_END", e2.KEY_METRIC_PEER_CONNECTION_START = "KEY_METRIC_PEER_CONNECTION_START", e2.KEY_METRIC_PEER_CONNECTION_END = "KEY_METRIC_PEER_CONNECTION_END", e2.KEY_METRIC_PUBLISH = "KEY_METRIC_PUBLISH", e2.KEY_METRIC_SUBSCRIBE = "KEY_METRIC_SUBSCRIBE", e2.RECORD_JOIN_CHANNEL_SERVICE = "RECORD_JOIN_CHANNEL_SERVICE", e2.RESET_JOIN_CHANNEL_SERVICE_RECORDS = "RESET_JOIN_CHANNEL_SERVICE_RECORDS", e2.RESET_KEY_METRICS = "RESET_KEY_METRICS";
      }(q$ || (q$ = {}));
      class i1 {
        constructor(e2, t2, r2, i2) {
          kO(this, "store", void 0), kO(this, "reducer", void 0);
          const n2 = { codec: e2, audioCodec: t2, mode: r2, clientId: i2, sessionId: null, p2pId: 0, pubId: 0, subId: 0, avoidJoinStart: 0, keyMetrics: { publish: [], subscribe: [] }, joinChannelServiceRecords: [], cloudProxyServerMode: "disabled" };
          this.reducer = function() {
            let e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : n2, t3 = arguments.length > 1 ? arguments[1] : void 0;
            switch (t3.type) {
              case q$.SET_SESSION_ID:
                return r1(r1({}, e3), {}, { sessionId: t3.sessionId });
              case q$.SET_P2P_ID:
                return r1(r1({}, e3), {}, { p2pId: t3.p2pId });
              case q$.SET_UID:
                return r1(r1({}, e3), {}, { uid: t3.uid });
              case q$.SET_PUB_ID:
                return r1(r1({}, e3), {}, { pubId: t3.pubId });
              case q$.KEY_METRIC_CLIENT_CREATED:
                return r1(r1({}, e3), {}, { keyMetrics: r1(r1({}, e3.keyMetrics), {}, { clientCreated: t3.metric }) });
              case q$.KEY_METRIC_JOIN_START:
                return r1(r1({}, e3), {}, { keyMetrics: r1(r1({}, e3.keyMetrics), {}, { joinStart: t3.metric }) });
              case q$.AVOID_JOIN_START:
                return r1(r1({}, e3), {}, { avoidJoinStart: t3.avoidJoinStart });
              case q$.KEY_METRIC_JOIN_END:
                return r1(r1({}, e3), {}, { keyMetrics: r1(r1({}, e3.keyMetrics), {}, { joinEnd: t3.metric }) });
              case q$.KEY_METRIC_REQUEST_AP_START:
                return r1(r1({}, e3), {}, { keyMetrics: r1(r1({}, e3.keyMetrics), {}, { requestAPStart: t3.metric }) });
              case q$.KEY_METRIC_REQUEST_AP_END:
                return r1(r1({}, e3), {}, { keyMetrics: r1(r1({}, e3.keyMetrics), {}, { requestAPEnd: t3.metric }) });
              case q$.KEY_METRIC_JOIN_GATEWAY_START:
                return r1(r1({}, e3), {}, { keyMetrics: r1(r1({}, e3.keyMetrics), {}, { joinGatewayStart: t3.metric }) });
              case q$.KEY_METRIC_JOIN_GATEWAY_END:
                return r1(r1({}, e3), {}, { keyMetrics: r1(r1({}, e3.keyMetrics), {}, { joinGatewayEnd: t3.metric }) });
              case q$.KEY_METRIC_PEER_CONNECTION_START:
                return r1(r1({}, e3), {}, { keyMetrics: r1(r1({}, e3.keyMetrics), {}, { peerConnectionStart: t3.metric }) });
              case q$.KEY_METRIC_PEER_CONNECTION_END:
                return r1(r1({}, e3), {}, { keyMetrics: r1(r1({}, e3.keyMetrics), {}, { peerConnectionEnd: t3.metric }) });
              case q$.KEY_METRIC_PUBLISH: {
                const r3 = e3.keyMetrics.publish, i3 = r3.findIndex((e4) => e4.trackId === t3.metric.trackId);
                return i3 !== -1 ? (r3[i3] = r1(r1({}, r3[i3]), t3.metric), r1(r1({}, e3), {}, { keyMetrics: r1(r1({}, e3.keyMetrics), {}, { publish: [...r3] }) })) : r1(r1({}, e3), {}, { keyMetrics: r1(r1({}, e3.keyMetrics), {}, { publish: [...e3.keyMetrics.publish, t3.metric] }) });
              }
              case q$.KEY_METRIC_SUBSCRIBE: {
                const r3 = e3.keyMetrics.subscribe, i3 = r3.findIndex((e4) => e4.userId === t3.metric.userId && e4.type === t3.metric.type);
                return i3 !== -1 ? (r3[i3] = r1(r1({}, r3[i3]), t3.metric), r1(r1({}, e3), {}, { keyMetrics: r1(r1({}, e3.keyMetrics), {}, { subscribe: [...r3] }) })) : r1(r1({}, e3), {}, { keyMetrics: r1(r1({}, e3.keyMetrics), {}, { subscribe: [...e3.keyMetrics.subscribe, t3.metric] }) });
              }
              case q$.SET_CLOUD_PROXY_SERVER_MODE:
                return e3.cloudProxyServerMode = t3.mode, e3;
              case q$.RECORD_JOIN_CHANNEL_SERVICE:
                return typeof t3.index != "number" ? e3.joinChannelServiceRecords = [...e3.joinChannelServiceRecords, t3.record] : (e3.joinChannelServiceRecords[t3.index] = r1(r1({}, e3.joinChannelServiceRecords[t3.index]), t3.record), e3.joinChannelServiceRecords = [...e3.joinChannelServiceRecords]), e3;
              case q$.RESET_JOIN_CHANNEL_SERVICE_RECORDS:
                return e3.joinChannelServiceRecords = [], e3;
              case q$.RESET_KEY_METRICS:
                return e3.keyMetrics = { publish: [], subscribe: [] }, e3;
              default:
                return e3;
            }
          }, this.store = e1(this.reducer);
        }
        set sessionId(e2) {
          this.store.dispatch({ type: q$.SET_SESSION_ID, sessionId: e2 });
        }
        get sessionId() {
          return this.store.getState().sessionId;
        }
        get codec() {
          return this.store.getState().codec;
        }
        get audioCodec() {
          return this.store.getState().audioCodec;
        }
        get clientId() {
          return this.store.getState().clientId;
        }
        set p2pId(e2) {
          this.store.dispatch({ type: q$.SET_P2P_ID, p2pId: e2 });
        }
        get p2pId() {
          return this.store.getState().p2pId;
        }
        set uid(e2) {
          this.store.dispatch({ type: q$.SET_UID, uid: e2 });
        }
        get uid() {
          return this.store.getState().uid;
        }
        set pubId(e2) {
          this.store.dispatch({ type: q$.SET_PUB_ID, pubId: e2 });
        }
        get pubId() {
          return this.store.getState().pubId;
        }
        set cloudProxyServerMode(e2) {
          this.store.dispatch({ type: q$.SET_CLOUD_PROXY_SERVER_MODE, mode: e2 });
        }
        get cloudProxyServerMode() {
          return this.store.getState().cloudProxyServerMode;
        }
        clientCreated() {
          this.store.dispatch({ type: q$.KEY_METRIC_CLIENT_CREATED, metric: performance.now() });
        }
        joinStart() {
          this.store.dispatch({ type: q$.KEY_METRIC_JOIN_START, metric: performance.now() });
        }
        get avoidJoinStart() {
          return this.store.getState().avoidJoinStart;
        }
        set avoidJoinStart(e2) {
          this.store.dispatch({ type: q$.AVOID_JOIN_START, avoidJoinStart: e2 });
        }
        joinEnd() {
          this.store.dispatch({ type: q$.KEY_METRIC_JOIN_END, metric: performance.now() });
        }
        requestAPStart() {
          this.store.dispatch({ type: q$.KEY_METRIC_REQUEST_AP_START, metric: performance.now() });
        }
        requestAPEnd() {
          this.store.dispatch({ type: q$.KEY_METRIC_REQUEST_AP_END, metric: performance.now() });
        }
        joinGatewayStart() {
          this.store.dispatch({ type: q$.KEY_METRIC_JOIN_GATEWAY_START, metric: performance.now() });
        }
        joinGatewayEnd() {
          this.store.dispatch({ type: q$.KEY_METRIC_JOIN_GATEWAY_END, metric: performance.now() });
        }
        peerConnectionStart() {
          this.store.dispatch({ type: q$.KEY_METRIC_PEER_CONNECTION_START, metric: performance.now() });
        }
        peerConnectionEnd() {
          this.store.dispatch({ type: q$.KEY_METRIC_PEER_CONNECTION_END, metric: performance.now() });
        }
        publish(e2, t2, r2, i2) {
          this.store.dispatch({ type: q$.KEY_METRIC_PUBLISH, metric: r1(r1({ trackId: e2, type: t2 }, r2 && { publishStart: r2 }), i2 && { publishEnd: i2 }) });
        }
        subscribe(e2, t2, r2, i2, n2) {
          this.store.dispatch({ type: q$.KEY_METRIC_SUBSCRIBE, metric: r1(r1(r1({ userId: e2, type: t2 }, r2 && { subscribeStart: r2 }), i2 && { subscribeEnd: i2 }), n2 && { firstFrame: n2 }) });
        }
        massSubscribe(e2, t2, r2, i2) {
          e2.forEach((e3) => {
            this.store.dispatch({ type: q$.KEY_METRIC_SUBSCRIBE, metric: r1(r1(r1({ userId: e3.userId, type: e3.type }, t2 && { subscribeStart: t2 }), r2 && { subscribeEnd: r2 }), i2 && { firstFrame: i2 }) });
          });
        }
        get keyMetrics() {
          return this.store.getState().keyMetrics;
        }
        recordJoinChannelService(e2, t2) {
          e2.service === "gateway" && Array.isArray(e2.urls) && (e2.urls = e2.urls.map((e3) => e3.replace(/(\d+)-\d+-\d+-(\d+)/, "$1-*-*-$2")));
          try {
            return typeof t2 != "number" ? (this.store.dispatch({ type: q$.RECORD_JOIN_CHANNEL_SERVICE, record: r1(r1({}, e2), {}, { sessionId: this.sessionId, cloudProxyMode: this.cloudProxyServerMode, uid: this.uid }) }), this.store.getState().joinChannelServiceRecords.length - 1) : (t2 < 0 || t2 >= this.store.getState().joinChannelServiceRecords.length || this.store.dispatch({ type: q$.RECORD_JOIN_CHANNEL_SERVICE, record: e2, index: t2 }), t2);
          } catch (e3) {
            return 0;
          }
        }
        resetJoinChannelServiceRecords() {
          this.store.dispatch({ type: q$.RESET_JOIN_CHANNEL_SERVICE_RECORDS });
        }
        resetKeyMetrics() {
          this.store.dispatch({ type: q$.RESET_KEY_METRICS });
        }
        get joinChannelServiceRecords() {
          try {
            return this.store.getState().joinChannelServiceRecords;
          } catch (e2) {
            return [];
          }
        }
      }
      let n1;
      const o1 = () => (n1 || n1 || (n1 = (window.location.protocol.split(":")[0] || "").toUpperCase(), n1)) === "HTTPS", s1 = () => window.isSecureContext !== void 0;
      class a1 {
        constructor(e2, t2) {
          kO(this, "time", void 0), kO(this, "sequence", void 0), kO(this, "name", void 0), kO(this, "elapse", void 0), this.name = e2, this.time = performance.now(), this.sequence = Lk[t2].indexOf(e2);
        }
        setElapse(e2) {
          this.elapse = e2;
        }
      }
      const c1 = /* @__PURE__ */ new Map();
      class d1 {
        constructor(e2, t2) {
          kO(this, "records", []), kO(this, "_id", void 0), kO(this, "_group", void 0), kO(this, "_localTimeStamp", void 0), kO(this, "_performanceTimeStamp", void 0), this._id = e2, this._group = t2, this._localTimeStamp = Date.now(), this._performanceTimeStamp = performance.now();
        }
        checkPoint(e2) {
          const t2 = new a1(e2, this._group);
          t2.sequence === -1 && dD.warning("[".concat(this._id, "] check point record failed, cannot get the sequence")), this.records.push(t2);
          const r2 = this.records.find((e3) => e3.sequence === t2.sequence - 1);
          r2 && t2.setElapse(t2.time - r2.time);
        }
        getRecord(e2) {
          return this.records.find((t2) => t2 && t2.name === e2);
        }
        resetRecords() {
          this.records.length = 0;
        }
      }
      var u1, A1, h1, l1, p1, g1, f1, E1, I1, m1;
      function _1(e2, t2) {
        var r2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          t2 && (i2 = i2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), r2.push.apply(r2, i2);
        }
        return r2;
      }
      function C1(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r2 = arguments[t2] != null ? arguments[t2] : {};
          t2 % 2 ? _1(Object(r2), true).forEach(function(t3) {
            kO(e2, t3, r2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : _1(Object(r2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
          });
        }
        return e2;
      }
      let v1 = (u1 = PD("AgoraRTCClient", "store.clientId"), A1 = TV({ report: bV }), h1 = TV(), l1 = TV({ report: bV }), p1 = wV(), g1 = TV({ report: bV }), f1 = wV({ report: bV }), E1 = TV({ reportResult: true, report: bV }), u1((zF((m1 = class extends ZN {
        get connectionState() {
          return this._gateway.state;
        }
        get remoteUsers() {
          return this._users;
        }
        get localTracks() {
          return this._p2pChannel.getAllTracks(true);
        }
        get uid() {
          return this._uid;
        }
        get channelName() {
          return this._channelName;
        }
        get isStringUID() {
          return !!this._joinInfo && !!this._joinInfo.stringUid;
        }
        constructor(e2) {
          let t2;
          if (super(), kO(this, "store", void 0), kO(this, "_uid", void 0), kO(this, "_channelName", void 0), kO(this, "_uintUid", void 0), kO(this, "_users", []), kO(this, "_codec", void 0), kO(this, "_mode", void 0), kO(this, "_config", void 0), kO(this, "_clientId", void 0), kO(this, "_appId", void 0), kO(this, "_sessionId", null), kO(this, "_key", void 0), kO(this, "_joinInfo", void 0), kO(this, "_gateway", void 0), kO(this, "_statsCollector", void 0), kO(this, "_configDistribute", void 0), kO(this, "_leaveMutex", new kV("client-leave")), kO(this, "_publishMutex", new kV("client-publish")), kO(this, "_renewTokenMutex", new kV("client-renewtoken")), kO(this, "_subscribeMutex", new kV("client-subscribe")), kO(this, "_encryptionMode", "none"), kO(this, "_encryptionSecret", null), kO(this, "_encryptionSalt", null), kO(this, "_proxyServer", void 0), kO(this, "_performanceRecorder", void 0), kO(this, "_turnServer", { servers: [], mode: "auto" }), kO(this, "_cloudProxyServerMode", "disabled"), kO(this, "_isDualStreamEnabled", false), kO(this, "_defaultStreamFallbackType", void 0), kO(this, "_lowStreamParameter", void 0), kO(this, "_streamFallbackTypeCacheMap", /* @__PURE__ */ new Map()), kO(this, "_remoteStreamTypeCacheMap", /* @__PURE__ */ new Map()), kO(this, "_axiosCancelSource", zN.CancelToken.source()), kO(this, "_audioVolumeIndicationInterval", void 0), kO(this, "_networkQualityInterval", void 0), kO(this, "_userOfflineTimeout", void 0), kO(this, "_streamRemovedTimeout", void 0), kO(this, "_injectStreamingClient", void 0), kO(this, "_liveTranscodeStreamingClient", void 0), kO(this, "_liveRawStreamingClient", void 0), kO(this, "_channelMediaRelayClient", void 0), kO(this, "_networkQualitySensitivity", "normal"), kO(this, "_p2pChannel", void 0), kO(this, "_useLocalAccessPoint", false), kO(this, "_joinAndNotLeaveYet", false), kO(this, "_numberOfJoinCount", 0), kO(this, "_remoteDefaultVideoStreamType", void 0), kO(this, "_handleLocalTrackEnable", (e3, t3, r2) => {
            this.publish(e3, false).then(t3).catch(r2);
          }), kO(this, "_handleLocalTrackDisable", (e3, t3, r2) => {
            this.unpublish(e3).then(t3).catch(r2);
          }), kO(this, "_handleUserOnline", (e3) => {
            this.isStringUID && typeof e3.uid != "string" && (dD.error("[".concat(this._clientId, "] StringUID is Mixed with UintUID")), TD("error", this, "StringUID is Mixed with UintUID"));
            const t3 = this._users.find((t4) => t4.uid === e3.uid);
            if (t3)
              t3._trust_in_room_ = true;
            else {
              const t4 = new iz(e3.uid, e3.uint_id || e3.uid);
              this._users.push(t4), dD.debug("[".concat(this._clientId, "] user online"), e3.uid), bD("info", this, "user-joined", { uid: e3.uid }), this.emit(wP.USER_JOINED, t4);
            }
          }), kO(this, "_handleUserOffline", (e3) => {
            const t3 = this._users.find((t4) => t4.uid === e3.uid);
            t3 && (this._handleRemoveStream(e3), LG(this._users, t3), this._remoteStreamTypeCacheMap.delete(t3.uid), this._streamFallbackTypeCacheMap.delete(t3.uid), dD.debug("[".concat(this._clientId, "] user offline"), e3.uid, "reason:", e3.reason), bD("info", this, "user-left", { reason: e3.reason, uid: e3.uid }), this.emit(wP.USER_LEAVED, t3, e3.reason));
          }), kO(this, "_handleAddAudioOrVideoStream", (e3, t3, r2, i2, n2, o2, s2) => {
            const a2 = this._users.find((e4) => e4.uid === t3);
            if (!a2)
              return dD.error("[".concat(this._clientId, "] can not find target user!(on_add_stream)")), void wD("error", ["AgoraRTCGateway", this._clientId], "add_".concat(e3, "_stream"), "can not find target user!");
            dD.debug("[".concat(this._clientId, "] stream added with uid ").concat(t3, ", type ").concat(e3)), wD("debug", ["AgoraRTCGateway", this._clientId], "add_".concat(e3, "_stream"), { uid: t3, mediaType: e3 });
            const c2 = e3 === "audio" ? a2.hasAudio : a2.hasVideo;
            a2._uintid || (a2._uintid = n2 || t3), a2._trust_stream_added_state_ = true, e3 === "audio" ? (a2._audio_added_ = true, r2 !== void 0 && (a2._audioSSRC = r2), i2 !== void 0 && (a2._cname = i2), o2 && (a2._audioOrtc = o2)) : (a2._video_added_ = true, r2 !== void 0 && (a2._videoSSRC = r2), i2 !== void 0 && (a2._cname = i2), s2 !== void 0 && (a2._rtxSsrcId = s2), o2 && (a2._videoOrtc = o2)), (e3 === "audio" ? a2.hasAudio : a2.hasVideo) && !c2 && (dD.info("[".concat(this._clientId, "] remote user ").concat(a2.uid, " published ").concat(e3)), TD("info", this, "remote user ".concat(a2.uid, " published ").concat(e3)), bD("info", this, "user-published", { uid: a2.uid, mediaType: e3 }), this.emit(wP.USER_PUBLISHED, a2, e3)), e3 === "video" ? bV.onGatewayStream(this._sessionId, lP.ON_ADD_VIDEO_STREAM, pP.ON_ADD_VIDEO_STREAM, { peer: n2 || t3 }) : bV.onGatewayStream(this._sessionId, lP.ON_ADD_AUDIO_STREAM, pP.ON_ADD_AUDIO_STREAM, { peer: n2 || t3 }), this._p2pChannel.hasPendingRemoteMedia(a2, e3) && this.subscribe(a2, e3).catch((e4) => {
              dD.error("[".concat(this._clientId, "] resubscribe error"), e4.toString()), TD("error", this, "resubscribe error: ".concat(e4.toString()));
            });
          }), kO(this, "_handleRemoveStream", (e3) => {
            const t3 = this._users.find((t4) => t4.uid === e3.uid);
            if (!t3)
              return dD.warning("[".concat(this._clientId, "] can not find target user!(on_remove_stream)")), void wD("warning", ["AgoraRTCGateway", this._clientId], "remove_stream", { uid: e3.uid, info: "can not find target user!" });
            dD.debug("[".concat(this._clientId, "] stream removed with uid ").concat(e3.uid)), wD("debug", ["AgoraRTCGateway", this._clientId], "remove_stream", { uid: e3.uid });
            let r2 = () => {
            };
            t3.hasAudio && t3.hasVideo ? r2 = () => {
              dD.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished audio track")), bD("info", this, "user-unpublished", { uid: t3.uid, mediaType: "audio" }), this.emit(wP.USER_UNPUBLISHED, t3, "audio"), dD.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished video track")), bD("info", this, "user-unpublished", { uid: t3.uid, mediaType: "video" }), this.emit(wP.USER_UNPUBLISHED, t3, "video");
            } : t3.hasVideo ? r2 = () => {
              dD.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished video track")), bD("info", this, "user-unpublished", { uid: t3.uid, mediaType: "video" }), this.emit(wP.USER_UNPUBLISHED, t3, "video");
            } : t3.hasAudio && (r2 = () => {
              dD.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished audio track")), bD("info", this, "user-unpublished", { uid: t3.uid, mediaType: "audio" }), this.emit(wP.USER_UNPUBLISHED, t3, "audio");
            }), t3._trust_stream_added_state_ = true, t3._audio_added_ = false, t3._video_added_ = false, this._p2pChannel.unsubscribe(t3).then((e4) => {
              if (e4)
                return this._gateway.unsubscribe(e4, t3.uid);
            }), t3._audioSSRC = void 0, t3._videoSSRC = void 0, t3._audioOrtc = void 0, t3._videoOrtc = void 0, t3._rtxSsrcId = void 0, bV.onGatewayStream(this._sessionId, lP.ON_REMOVE_STREAM, pP.ON_REMOVE_STREAM, { peer: e3.uint_id || e3.uid }), r2();
          }), kO(this, "_handleSetStreamLocalEnable", (e3, t3, r2) => {
            const i2 = this._users.find((e4) => e4.uid === t3);
            if (!i2)
              return dD.error("[".concat(this._clientId, "] can not find target user!(disable_local)")), void wD("error", this, "disable_local_video", "can not find target user!(disable_local)");
            dD.debug("[".concat(this._clientId, "] local ").concat(e3, " ").concat(r2 ? "enabled" : "disabled", " with uid ").concat(t3)), wD("debug", this, "disable_local_video", "local ".concat(e3, " ").concat(r2 ? "enabled" : "disabled", " with uid ").concat(t3));
            const n2 = e3 === "audio" ? i2.hasAudio : i2.hasVideo;
            if (e3 === "audio") {
              i2._trust_audio_enabled_state_ = true;
              const e4 = i2._audio_enabled_;
              if (i2._audio_enabled_ = r2, i2._audio_enabled_ === e4)
                return;
              {
                const e5 = i2._audio_enabled_ ? "enable-local-audio" : "disable-local-audio";
                dD.debug("[".concat(this._clientId, "] user-info-updated, uid: ").concat(t3, ", msg: ").concat(e5)), LD("debug", this, "user-info-updated", { uid: t3, msg: e5 }), this.emit(wP.USER_INFO_UPDATED, t3, e5);
              }
            } else {
              i2._trust_video_enabled_state_ = true;
              const e4 = i2._video_enabled_;
              if (i2._video_enabled_ = r2, i2._video_enabled_ === e4)
                return;
              {
                const e5 = i2._video_enabled_ ? "enable-local-video" : "disable-local-video";
                dD.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(t3, ", msg: ").concat(e5)), LD("debug", this, "user-info-updated", { uid: t3, msg: e5 }), this.emit(wP.USER_INFO_UPDATED, t3, e5);
              }
            }
            const o2 = e3 === "audio" ? i2.hasAudio : i2.hasVideo;
            return n2 !== o2 ? !n2 && o2 ? (dD.info("[".concat(this._clientId, "] remote user ").concat(t3, " published ").concat(e3)), bD("info", this, "user-published", { uid: t3, mediaType: e3 }), void this.emit(wP.USER_PUBLISHED, i2, e3)) : (e3 === "video" && i2._videoTrack && i2._videoTrack._destroy(), e3 === "audio" && i2._audioTrack, this._p2pChannel.muteRemote(i2, e3), dD.info("[".concat(this._clientId, "] remote user ").concat(t3, " unpublished ").concat(e3)), bD("info", this, "user-unpublished", { uid: t3, mediaType: e3 }), void this.emit(wP.USER_UNPUBLISHED, i2, e3)) : void 0;
          }), kO(this, "_handleMuteStream", (e3, t3, r2) => {
            dD.debug("[".concat(this._clientId, "] receive mute message"), e3, t3, r2), wD("debug", this, "mute_".concat(t3), r2);
            const i2 = this._users.find((t4) => t4.uid === e3);
            if (!i2)
              return dD.warning("[".concat(this._clientId, "] can not find remote user, ignore mute event, uid: ").concat(e3)), void wD("warning", this, "mute_".concat(t3), "can not find remote user, ignore mute event, uid: ".concat(e3));
            const n2 = t3 === "audio" ? i2.hasAudio : i2.hasVideo;
            if (t3 === "audio") {
              i2._trust_audio_mute_state_ = true;
              const t4 = i2._audio_muted_;
              if (i2._audio_muted_ = r2, i2._audio_muted_ === t4)
                return;
              {
                const t5 = i2._audio_muted_ ? "mute-audio" : "unmute-audio";
                dD.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(e3, ", msg: ").concat(t5)), LD("debug", this, "user-info-updated", { uid: e3, msg: t5 }), this.emit(wP.USER_INFO_UPDATED, e3, t5);
              }
            } else {
              i2._trust_video_mute_state_ = true;
              const t4 = i2._video_muted_;
              if (i2._video_muted_ = r2, i2._video_muted_ === t4)
                return;
              {
                const t5 = i2._video_muted_ ? "mute-video" : "unmute-video";
                dD.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(e3, ", msg: ").concat(t5)), LD("debug", this, "user-info-updated", { uid: e3, msg: t5 }), this.emit(wP.USER_INFO_UPDATED, e3, t5);
              }
            }
            const o2 = t3 === "audio" ? i2.hasAudio : i2.hasVideo;
            return n2 !== o2 ? !n2 && o2 ? (dD.info("[".concat(this._clientId, "] remote user ").concat(e3, " published ").concat(t3)), bD("info", this, "user-published", { uid: i2.uid, mediaType: t3 }), void this.emit(wP.USER_PUBLISHED, i2, t3)) : (t3 === "video" && i2._videoTrack && i2._videoTrack._destroy(), t3 === "audio" && i2._audioTrack, this._p2pChannel.muteRemote(i2, t3), dD.info("[".concat(this._clientId, "] remote user ").concat(e3, " unpublished ").concat(t3)), bD("info", this, "user-unpublished", { uid: e3, mediaType: t3 }), void this.emit(wP.USER_UNPUBLISHED, i2, t3)) : void 0;
          }), kO(this, "_handleP2PLost", async (e3) => {
            if (dD.debug("[".concat(this._clientId, "] receive p2p lost"), e3), wD("debug", this, "p2p_lost", e3), parseInt(e3.p2pid, 10) !== this.store.p2pId)
              return dD.warning("P2PLost stream not found", e3), void wD("warning", this, "p2p_lost", "P2PLost stream not found, ".concat(e3));
            await this._p2pChannel.requestReconnect();
          }), kO(this, "_handleTokenWillExpire", () => {
            dD.debug("[".concat(this._clientId, "] received message onTokenPrivilegeWillExpire")), wD("debug", this, "token_privilege_will_expire"), this.emit(wP.ON_TOKEN_PRIVILEGE_WILL_EXPIRE);
          }), kO(this, "_handleBeforeUnload", (e3) => {
            e3.type === "beforeunload" && e3.returnValue !== void 0 && e3.returnValue !== "" || (this.leave(), dD.info("[".concat(this._clientId, "] auto leave onbeforeunload or pagehide")), OD("info", ["window", this.store.clientId], pO() ? "beforeunload" : "pagehide"));
          }), kO(this, "_handleUpdateNetworkQuality", () => {
            if (this._networkQualitySensitivity === "normal")
              return;
            if (navigator && navigator.onLine !== void 0 && !navigator.onLine)
              return void this.emit(wP.NETWORK_QUALITY, { downlinkNetworkQuality: 6, uplinkNetworkQuality: 6 });
            const e3 = { downlinkNetworkQuality: 0, uplinkNetworkQuality: 0 };
            e3.uplinkNetworkQuality = this._p2pChannel.getUplinkNetworkQuality(), e3.downlinkNetworkQuality = this._p2pChannel.getDownlinkNetworkQuality(), this.emit(wP.NETWORK_QUALITY, e3);
          }), this._codec = e2.codec, this._mode = e2.mode, this._clientId = SG(5, "client-"), this.store = new i1(e2.codec, e2.audioCodec, e2.mode, this._clientId), this.store.clientCreated(), e2.proxyServer && this.setProxyServer(e2.proxyServer, true), e2.turnServer && this.setTurnServer(e2.turnServer, true), dD.info("[".concat(this._clientId, "] Initializing AgoraRTC client v").concat(MD, " build: ").concat(BD, ", mode: ").concat(this._mode, ", codec: ").concat(this._codec)), LD("info", this, "constructor", { version: MD, build: BD, mode: this._mode, codec: this._codec }), this._performanceRecorder = function(e3, t3) {
            const r2 = new d1(e3, t3);
            return c1.set(e3, r2), r2;
          }(this._clientId, "join"), e2.clientRoleOptions)
            try {
              FP(e2.clientRoleOptions), t2 = Object.assign({}, e2.clientRoleOptions);
            } catch (e3) {
              dD.warning("[".concat(this._clientId, "] ").concat(e3.toString())), TD("warning", this, e3.toString());
            }
          this._statsCollector = new rG(this.store), this._statsCollector.onStatsException = (e3, t3, r2) => {
            dD.debug("[".concat(this._clientId, "] receive exception msg, code: ").concat(e3, ", msg: ").concat(t3, ", uid: ").concat(r2)), bD("debug", this, wP.EXCEPTION, { code: e3, message: t3, uid: r2 }), this.emit(wP.EXCEPTION, { code: e3, msg: t3, uid: r2 });
          }, this._statsCollector.onUploadPublishDuration = (e3, t3, r2, i2) => {
            const n2 = this._users.find((t4) => t4.uid === e3);
            n2 && bV.peerPublishStatus(this._sessionId, { subscribeElapse: i2, audioPublishDuration: t3, videoPublishDuration: r2, peer: n2._uintid });
          }, this._gateway = new cJ(this.store, { clientId: this._clientId, mode: this._mode, codec: this._codec, websocketRetryConfig: e2.websocketRetryConfig || rD, httpRetryConfig: e2.httpRetryConfig || rD, forceWaitGatewayResponse: e2.forceWaitGatewayResponse === void 0 || e2.forceWaitGatewayResponse, statsCollector: this._statsCollector, role: e2.role, clientRoleOptions: t2 }), this._config = e2, this._configDistribute = new xJ(), this._p2pChannel = new Y$(this.store, this._statsCollector), this._handleP2PChannelEvents(), this._handleGatewayEvents();
        }
        async join(e2, t2, r2, i2, n2) {
          const o2 = ++this._numberOfJoinCount;
          this._performanceRecorder.checkPoint("startJoin"), this.store.joinStart(), i2 && (this.store.uid = i2);
          const s2 = o1(), a2 = s1() ? window.isSecureContext : "Browser Not Support";
          if (!s1() && !s2 || !window.isSecureContext) {
            const e3 = "The website must be running in a secure context (About secure context: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts ), otherwise the media collection will be restricted by the browser";
            dD.warning(e3), ND("warning", this, e3);
          }
          const c2 = RG();
          this.connectionState === "DISCONNECTED" && (this.store.avoidJoinStart = Math.round(Date.now()), dD.debug("[".concat(this._clientId, "] set avoidJoinStart to ").concat(this.store.avoidJoinStart)), ND("debug", this, "join", void 0, "[".concat(this._clientId, "] set avoidJoinStart to ").concat(this.store.avoidJoinStart)));
          const d2 = bV.reportApiInvoke(c2, { name: fP.JOIN, options: [e2, t2, r2, i2], states: { isHttps: s2, isSecureContext: a2 }, tag: EP.TRACER });
          try {
            if (!r2 && r2 !== null)
              throw new tD(eD.INVALID_PARAMS, "Invalid token: ".concat(r2, ". If you don not use token, set it to null"));
            r2 && $L(r2, "token", 1, 2047), $L(e2, "appid", 1, 2047), tP(t2), i2 && rP(i2), n2 && $L(n2, "optionalInfo", 1, 2047);
          } catch (e3) {
            throw d2.onError(e3), e3;
          }
          if (dD.info("[".concat(this._clientId, "] start join channel ").concat(t2, ", join number: ").concat(o2)), LD("info", this, "join", { channel: t2 }), this._leaveMutex.isLocked) {
            dD.debug("[".concat(this._clientId, "] join: waiting leave operation")), TD("debug", this, "join: waiting leave operation");
            (await this._leaveMutex.lock())(), dD.debug("[".concat(this._clientId, "] join: continue")), TD("debug", this, "join: continue");
          }
          if (this._joinAndNotLeaveYet = true, this.connectionState !== "DISCONNECTED") {
            const e3 = new tD(eD.INVALID_OPERATION, "[".concat(this._clientId, "] Client already in connecting/connected state"));
            throw d2.onError(e3), e3;
          }
          this._sessionId || (this._sessionId = c2, this.store.sessionId = this._sessionId), this._gateway.state = "CONNECTING";
          const u2 = C1({ clientId: this._clientId, appId: e2, sid: this._sessionId, cname: t2, uid: typeof i2 != "string" ? i2 : null, turnServer: this._turnServer, proxyServer: this._proxyServer, token: r2 || e2, cloudProxyServer: this._cloudProxyServerMode, optionalInfo: n2, useLocalAccessPoint: this._useLocalAccessPoint }, this._remoteDefaultVideoStreamType !== void 0 && { defaultVideoStream: this._remoteDefaultVideoStreamType });
          if (typeof i2 == "string" && (u2.stringUid = i2, this._uintUid ? (u2.uid = this._uintUid, this._uintUid = void 0) : u2.uid = 0), this._encryptionMode !== "none" && this._encryptionSecret) {
            if (u2.aesmode = this._encryptionMode, u2.aespassword = await (async (e3) => {
              const t3 = QG("MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCMnXAHkKIGAM+x4N22gCI+Wyu\nSTM9ztkT3uYslTT2PuKmZfPzhH6kVdO7PTjGCOZnAsyb3oTtWat0KcxQ4jxvqQV+\nHvYl3iI1Yd4vl2c3qRMJPLtRDfNxa2Mcxgq7e9aEUibzdd0st+OJAy3tOj/Y0aVy\nxQiYDz3vqa6bP29adwIDAQAB"), r3 = await window.crypto.subtle.importKey("spki", t3, { name: "RSA-OAEP", hash: "SHA-256" }, true, ["encrypt"]), i3 = iG(e3), n3 = await window.crypto.subtle.encrypt({ name: "RSA-OAEP" }, r3, i3);
              return xG(new Uint8Array(n3));
            })(this._encryptionSecret), !this._joinAndNotLeaveYet)
              throw new tD(eD.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
            this._encryptionSalt && (u2.aessalt = this._encryptionSalt);
          }
          this._startSession(this._sessionId, { channel: t2, appId: e2 });
          const A2 = this._sessionId;
          setTimeout(() => {
            this.connectionState === "CONNECTING" && A2 === this._sessionId && bV.joinChannelTimeout(this._sessionId, 5);
          }, 5e3);
          try {
            let i3;
            const n3 = u2.cloudProxyServer;
            if (n3 === "443only")
              u2.proxyServer = JD("PROXY_SERVER_TYPE2");
            else if (["proxy3", "proxy4", "proxy5"].includes(n3)) {
              const e3 = JD("PROXY_SERVER_TYPE3");
              Array.isArray(e3) ? u2.proxyServer = e3[0] : u2.proxyServer = e3;
            }
            if (bV.setProxyServer(u2.proxyServer), dD.setProxyServer(u2.proxyServer), yD(u2.proxyServer), this._performanceRecorder.checkPoint("startRequestAp"), this.store.requestAPStart(), u2.stringUid && !u2.uid && n3 === "normal") {
              await bJ(u2, this._axiosCancelSource.token, this._config.httpRetryConfig || rD, false, this.store);
              const e3 = await OJ(u2.stringUid, u2, this._axiosCancelSource.token, this._config.httpRetryConfig || rD, this.store);
              dD.debug("getUserAccount Success ".concat(u2.stringUid, " => ").concat(e3)), TD("debug", this, "getUserAccount Success ".concat(u2.stringUid, " => ").concat(e3)), u2.uid = e3, i3 = await wJ(u2, this._axiosCancelSource.token, this._config.httpRetryConfig || rD, this.store);
            } else if (u2.stringUid && !u2.uid) {
              const e3 = await OJ(u2.stringUid, u2, this._axiosCancelSource.token, this._config.httpRetryConfig || rD, this.store);
              dD.debug("getUserAccount Success ".concat(u2.stringUid, " => ").concat(e3)), TD("debug", this, "getUserAccount Success ".concat(u2.stringUid, " => ").concat(e3)), u2.uid = e3, i3 = await bJ(u2, this._axiosCancelSource.token, this._config.httpRetryConfig || rD, true, this.store);
            } else
              i3 = await bJ(u2, this._axiosCancelSource.token, this._config.httpRetryConfig || rD, true, this.store);
            if (!this._joinAndNotLeaveYet)
              throw new tD(eD.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
            this.store.requestAPEnd(), this._performanceRecorder.checkPoint("startJoinGateway"), setTimeout(() => {
              this._configDistribute.startGetConfigDistribute(u2, this._axiosCancelSource.token), this._configDistribute.on(Sk.UPDATE_BITRATE_LIMIT, (e3) => {
                this._p2pChannel.updateBitrateLimit(e3);
              });
            }, 0), this._key = r2 || e2;
            const o3 = i3.gatewayInfo;
            this._joinInfo = C1(C1({}, u2), {}, { cid: o3.cid, uid: u2.uid ? u2.uid : o3.uid, vid: o3.vid, apResponse: o3.res, uni_lbs_ip: o3.uni_lbs_ip, gatewayAddrs: o3.gatewayAddrs });
            const s3 = await this._joinGateway();
            if (!this._joinAndNotLeaveYet)
              throw new tD(eD.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
            return d2.onSuccess(s3), this._appId = e2, this._channelName = u2.cname, this._uid = s3, this.store.uid = s3, setTimeout(() => {
              this._networkQualityInterval && window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = window.setInterval(this._handleUpdateNetworkQuality, 2e3), window.addEventListener(pO() ? "beforeunload" : "pagehide", this._handleBeforeUnload);
            }, 0), dD.info("[".concat(this._clientId, "] Joining channel success: ").concat(t2)), LD("info", this, "join", t2, "success"), setTimeout(() => {
              JD("USE_NEW_LOG") ? kD() : dD.startUpload();
            }, 5e3), this._performanceRecorder.checkPoint("finishJoin"), this.store.joinEnd(), h2 = this, rL.includes(h2) || rL.push(h2), s3;
          } catch (e3) {
            const r3 = Array.isArray(e3) ? e3[0] : e3;
            throw dD.error("[".concat(this._clientId, "] join number: ").concat(o2, ", Joining channel failed, rollback"), r3), LD("error", this, "join", t2, r3.toString()), r3.code !== eD.OPERATION_ABORTED && this._numberOfJoinCount === o2 && (this._gateway.state = "DISCONNECTED", this._reset()), d2.onError(r3), r3;
          }
          var h2;
        }
        _joinGateway() {
          if (!this._joinInfo || !this._key)
            throw new tD(eD.INVALID_OPERATION);
          return this._gateway.join(this._joinInfo, this._key, !(this._joinInfo.cloudProxyServer !== "disabled" || !JD("JOIN_WITH_FALLBACK_SIGNAL_PROXY"))).then((e2) => e2).catch((e2) => {
            if (e2.code === eD.INIT_WEBSOCKET_TIMEOUT)
              return this._gateway.leave(true, TP.FALLBACK);
            throw e2;
          }).then((e2) => {
            if (e2)
              return e2;
            if (dD.info("[".concat(this._clientId, "] join timeout, fallback to proxy")), !this._joinInfo || !this._key)
              throw new tD(eD.INVALID_OPERATION);
            this._joinInfo.cloudProxyServer = "fallback", this._cloudProxyServerMode = "fallback", this.store.cloudProxyServerMode = "fallback";
            const t2 = JD("PROXY_SERVER_TYPE3");
            if (Array.isArray(t2))
              if (this._joinInfo.apUrl) {
                const e3 = new kW(this._joinInfo.apUrl).host.split("."), r2 = e3.slice(e3.length - 2).join(".");
                t2.forEach((e4) => {
                  this._joinInfo && e4.includes(r2) && (this._joinInfo.proxyServer = e4);
                }), this._joinInfo.proxyServer || (this._joinInfo.proxyServer = t2[0]);
              } else
                this._joinInfo.proxyServer = t2[0];
            else
              this._joinInfo.proxyServer = t2;
            dD.setProxyServer(this._joinInfo.proxyServer), bV.setProxyServer(this._joinInfo.proxyServer), yD(this._joinInfo.proxyServer);
            return bV.reportApiInvoke(this._sessionId, { name: fP.JOIN_FALLBACK_TO_PROXY, options: [this._joinInfo.proxyServer], tag: EP.TRACER }).onSuccess(), this.emit(wP.JOIN_FALLBACK_TO_PROXY, this._joinInfo.proxyServer), this._gateway.join(this._joinInfo, this._key);
          }).then((e2) => e2);
        }
        async leave() {
          const e2 = bV.reportApiInvoke(this._sessionId, { name: fP.LEAVE, options: [], tag: EP.TRACER });
          dD.info("[".concat(this._clientId, "] Leaving channel")), LD("info", this, "leave"), window.removeEventListener(pO() ? "beforeunload" : "pagehide", this._handleBeforeUnload), this._reset(), function(e3) {
            const t3 = rL.indexOf(e3);
            t3 !== -1 && rL.splice(t3, 1);
          }(this);
          const t2 = await this._leaveMutex.lock();
          if (this.connectionState === "DISCONNECTED")
            return dD.info("[".concat(this._clientId, "] Leaving channel repeated, success")), t2(), e2.onSuccess();
          await this._gateway.leave(this.connectionState !== "CONNECTED"), dD.info("[".concat(this._clientId, "] Leaving channel success")), LD("info", this, "leave", void 0, "success"), this._joinAndNotLeaveYet = false, this.store.resetJoinChannelServiceRecords(), t2(), e2.onSuccess();
        }
        async publish(e2) {
          let t2 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
          Array.isArray(e2) || (e2 = [e2]);
          const r2 = bV.reportApiInvoke(this._sessionId, { name: fP.PUBLISH, options: e2.map((e3) => e3 ? Object(e3).toString() : "null"), tag: EP.TRACER });
          if (e2.length === 0) {
            const e3 = new tD(eD.INVALID_PARAMS, "track list is empty");
            return r2.onError(e3), e3.throw();
          }
          if (this._gateway.role === "audience") {
            const e3 = new tD(eD.INVALID_OPERATION, "audience can not publish stream");
            return r2.onError(e3), e3.throw();
          }
          for (const i3 of e2) {
            if (!(i3 instanceof MV)) {
              const e3 = new tD(eD.INVALID_PARAMS, "parameter is not local track");
              return r2.onError(e3), e3.throw();
            }
            if (!i3._enabled && t2) {
              const e3 = new tD(eD.TRACK_IS_DISABLED, "can not publish a disabled track: ".concat(i3.getTrackId()));
              return r2.onError(e3), e3.throw();
            }
          }
          dD.info("[".concat(this._clientId, "] Publishing tracks, id ").concat(e2.map((e3) => "".concat(e3.getTrackId(), " ")))), LD("info", this, "publish", e2.map((e3) => "".concat(e3.getTrackId()))), await this._configDistribute.awaitConfigDistributeComplete(), t2 && e2.forEach((e3) => {
            const t3 = this._configDistribute.getBitrateLimit();
            e3 instanceof $q && t3 && e3.setBitrateLimit(t3.uplink);
          });
          const i2 = await this._publishMutex.lock();
          try {
            await this._publishHighStream(e2), r2.onSuccess(e2.map((e3) => e3.trackMediaType + ":" + e3.getTrackLabel()).toString()), dD.info("[".concat(this._clientId, "] Publish success, id ").concat(e2.map((e3) => "".concat(e3.getTrackId(), " ")))), LD("info", this, "publish", e2.map((e3) => "".concat(e3.getTrackId())), "success");
          } catch (e3) {
            throw r2.onError(e3), dD.error("[".concat(this._clientId, "] publish error"), e3.toString()), LD("error", this, "publish", void 0, e3.toString()), e3;
          } finally {
            i2();
          }
        }
        async unpublish(e2) {
          if (!this._joinInfo || this._uid === void 0)
            throw new tD(eD.INVALID_OPERATION, "Can't unpublish stream, haven't joined yet!");
          e2 ? Array.isArray(e2) || (e2 = [e2]) : e2 = this._p2pChannel.getAllTracks(true);
          const t2 = bV.reportApiInvoke(this._sessionId, { name: fP.UNPUBLISH, options: e2.map((e3) => e3.getTrackId()), tag: EP.TRACER });
          dD.info("[".concat(this._clientId, "] Unpublish tracks, tracks ").concat(e2.map((e3) => "".concat(e3.getTrackId(), " ")), " ")), LD("info", this, "unpublish", e2.map((e3) => "".concat(e3.getTrackId())));
          const r2 = await this._publishMutex.lock();
          try {
            const i2 = await this._p2pChannel.unpublish(e2);
            i2 && await this._gateway.unpublish(i2, this._uid), dD.info("[".concat(this._clientId, "] Unpublish success,tracks ").concat(e2.map((e3) => "".concat(e3.getTrackId())))), LD("info", this, "unpublish", e2.map((e3) => "".concat(e3.getTrackId())), "success"), t2.onSuccess();
          } catch (e3) {
            throw t2.onError(e3), dD.error("[".concat(this._clientId, "] unpublish error"), e3.toString()), LD("error", this, "unpublish", void 0, e3.toString()), e3;
          } finally {
            r2 && r2();
          }
        }
        async subscribe(e2, t2) {
          XL(t2, "mediaType", ["audio", "video"]);
          const r2 = bV.reportApiInvoke(this._sessionId, { name: fP.SUBSCRIBE, options: [e2.uid, t2], tag: EP.TRACER });
          if (!this._joinInfo) {
            const e3 = new tD(eD.INVALID_OPERATION, "Can't subscribe stream, not joined");
            throw r2.onError(e3), e3;
          }
          if (this.connectionState !== "CONNECTED" && this.connectionState !== "RECONNECTING") {
            const e3 = new tD(eD.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
            throw r2.onError(e3), e3;
          }
          if (!this._users.find((t3) => t3 === e2)) {
            const t3 = new tD(eD.INVALID_REMOTE_USER, "user is not in the channel");
            throw dD.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", this user is not in the channel")), LD("error", this, "subscribe", e2.uid, "this user is not in the channel"), r2.onError(t3), t3;
          }
          if (!e2.hasAudio && !e2.hasVideo) {
            const t3 = new tD(eD.INVALID_REMOTE_USER, "user is not published");
            throw dD.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", user is not published")), LD("error", this, "subscribe", e2.uid, "this user is not published"), r2.onError(t3), t3;
          }
          if (t2 === "audio" && (!e2.hasAudio || e2._audioSSRC === void 0) || t2 === "video" && (!e2.hasVideo || e2._videoSSRC === void 0)) {
            const i3 = new tD(eD.REMOTE_USER_IS_NOT_PUBLISHED);
            throw dD.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, " with mediaType ").concat(t2, ", remote track is not published")), LD("error", this, "subscribe", e2.uid, "mediaType ".concat(t2, ", remote track is not published")), r2.onError(i3), i3;
          }
          const i2 = t2 === "audio" ? e2._audioSSRC : e2._videoSSRC, n2 = t2 === "audio" ? e2._audioOrtc : e2._videoOrtc, o2 = t2 === "video" ? e2._rtxSsrcId : void 0, s2 = { stream_type: t2 === "audio" ? yk.AUDIO : yk.VIDEO, ssrcId: i2 }, a2 = await this._subscribeMutex.lock();
          dD.info("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, ", mediaType: ").concat(t2)), LD("info", this, "subscribe", { uid: e2.uid, mediaType: t2 });
          try {
            if (await this._p2pChannel.hasRemoteMediaWithLock(e2, t2))
              await this._p2pChannel.unmuteRemote(e2, t2);
            else
              try {
                $j.markSubscribeStart(this.store.clientId, i2), this.store.subscribe(e2.uid, t2, performance.now()), await this._p2pChannel.subscribe(e2, t2, i2, o2, n2);
                try {
                  await this._gateway.subscribe(e2.uid, s2, true);
                } catch (r3) {
                  throw await this._p2pChannel.unsubscribe(e2, t2), r3;
                }
                this.store.subscribe(e2.uid, t2, void 0, performance.now()), this._p2pChannel.reportSubscribeEvent(true, null, e2, t2);
              } catch (r3) {
                throw this._p2pChannel.reportSubscribeEvent(false, r3 == null ? void 0 : r3.code, e2, t2), r3;
              }
            dD.info("[".concat(this._clientId, "] subscribe success user ").concat(e2.uid, ", mediaType: ").concat(t2)), LD("info", this, "subscribe", { uid: e2.uid, mediaType: t2 }, "success"), this._defaultStreamFallbackType && this.setStreamFallbackOption(e2.uid, this._defaultStreamFallbackType).catch((e3) => {
              dD.warning("[".concat(this._clientId, "] auto set fallback failed"), e3), TD("warning", this, "auto set fallback failed, ".concat(e3.toString()));
            });
            const c2 = t2 === "audio" ? e2._audioTrack : e2._videoTrack;
            if (!c2) {
              const e3 = new tD(eD.UNEXPECTED_ERROR, "can not find remote track in user object");
              return r2.onError(e3), e3.throw();
            }
            return r2.onSuccess(c2.getTrackId()), c2;
          } catch (i3) {
            throw r2.onError(i3), dD.error("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, " error"), i3), LD("error", this, "subscribe", { uid: e2.uid, mediaType: t2 }, i3.toString()), i3;
          } finally {
            a2();
          }
        }
        async massSubscribe(e2) {
          eP(e2, "subscribeList");
          const t2 = bV.reportApiInvoke(this._sessionId, { name: fP.MASS_SUBSCRIBE, options: e2.map((e3) => {
            let { user: t3, mediaType: r3 } = e3;
            return [t3 == null ? void 0 : t3.uid, r3];
          }), tag: EP.TRACER });
          if (!this._joinInfo) {
            const e3 = new tD(eD.INVALID_OPERATION, "Can't subscribe stream, not joined");
            throw t2.onError(e3), e3;
          }
          if (this.connectionState !== "CONNECTED" && this.connectionState !== "RECONNECTING") {
            const e3 = new tD(eD.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
            throw t2.onError(e3), e3;
          }
          const r2 = performance.now(), i2 = /* @__PURE__ */ new Map(), n2 = await this._subscribeMutex.lock();
          dD.info("[".concat(this._clientId, "]start massSubscribe user ").concat(e2.map((e3) => {
            let { user: t3, mediaType: r3 } = e3;
            return "user: ".concat(t3 == null ? void 0 : t3.uid, ", mediaType: ").concat(r3);
          }).join("; "))), LD("info", this, "massSubscribe", e2);
          const o2 = (e2 = [...e2]).map((e3) => {
            let { user: t3, mediaType: r3 } = e3;
            return { user: t3, mediaType: r3 };
          }), s2 = await this._p2pChannel.globalLock();
          try {
            var a2;
            for (let r3 = e2.length - 1; r3 >= 0; r3--) {
              const n3 = e2[r3], { user: s3, mediaType: a3 } = n3;
              if (XL(a3, "mediaType", ["audio", "video"]), !s3) {
                const e3 = new tD(eD.INVALID_PARAMS, "user property does not exist in subscribeList item");
                throw dD.error("[".concat(this._clientId, "] user property does not exist in subscribeList item")), t2.onError(e3), e3;
              }
              if (!this._users.find((e3) => e3 === s3)) {
                const t3 = new tD(eD.INVALID_REMOTE_USER, "user is not in the channel");
                dD.error("[".concat(this._clientId, "] can not massSubscribe ").concat(s3.uid, ", this user is not in the channel")), LD("error", this, "massSubscribe", s3.uid, "this user is not in the channel"), o2[r3].error = t3, e2.splice(r3, 1);
                continue;
              }
              if (a3 === "audio" && (!s3.hasAudio || s3._audioSSRC === void 0) || a3 === "video" && (!s3.hasVideo || s3._videoSSRC === void 0)) {
                const t3 = new tD(eD.REMOTE_USER_IS_NOT_PUBLISHED);
                dD.error("[".concat(this._clientId, "] can not subscribe ").concat(s3.uid, " with mediaType ").concat(a3, ", remote user is not published")), LD("error", this, "subscribe", s3.uid, "mediaType ".concat(a3, ", remote user is not published")), o2[r3].error = t3, e2.splice(r3, 1);
                continue;
              }
              const c3 = uk.Video | uk.LwoVideo, d2 = i2.get(s3);
              if (d2) {
                if (a3 === "video" ? d2 & c3 : d2 & uk.Audio) {
                  e2.splice(r3, 1), dD.warning("repeat massSubscribe user:".concat(s3.uid, ", mediaType:").concat(a3, " twice"));
                  continue;
                }
                i2.set(s3, d2 | (a3 === "video" ? c3 : uk.Audio));
              } else
                i2.set(s3, a3 === "video" ? c3 : uk.Audio);
            }
            for (let t3 = e2.length - 1; t3 >= 0; t3--) {
              const r3 = e2[t3], { user: n3, mediaType: o3 } = r3, s3 = uk.Video | uk.LwoVideo;
              if (this._p2pChannel.hasRemoteMedia(n3, o3)) {
                await this._p2pChannel.unmuteRemoteNoLock(n3, o3);
                const r4 = i2.get(n3);
                i2.set(n3, o3 === "video" ? r4 ^ s3 : r4 ^ uk.Audio), e2.splice(t3, 1);
              }
            }
            this.store.massSubscribe(e2.map((e3) => ({ userId: e3.user.uid, type: e3.mediaType })), r2);
            const c2 = vh(a2 = Array.from(i2.entries())).call(a2, (e3, t3) => {
              let [r3, i3] = t3;
              if (i3 === 0)
                return e3;
              const n3 = { stream_id: r3.uid, stream_type: i3 };
              return i3 & uk.Audio && (n3.audio_ssrc = r3._audioSSRC), i3 & uk.Video && (n3.video_ssrc = r3._videoSSRC), e3.push(n3), e3;
            }, []);
            try {
              e2.length > 0 && await this._p2pChannel.massSubscribeNoLock(e2.map((e3) => {
                let { user: t3, mediaType: r3 } = e3;
                return { user: t3, mediaType: r3, ssrcId: r3 === yk.VIDEO ? t3._videoSSRC : t3._audioSSRC, rtxSsrcId: t3._rtxSsrcId };
              }));
              const i3 = /* @__PURE__ */ new Map();
              if (c2.length > 0) {
                const e3 = await this._gateway.subscribeAll(c2, true);
                ((e3 == null ? void 0 : e3.users) || []).forEach((e4) => {
                  let { stream_id: t3, video_error_code: r3, audio_error_code: n3, error_code: o3 } = e4;
                  (r3 || n3 || o3) && i3.set(t3, { video_error_code: r3, audio_error_code: n3, error_code: o3 });
                });
              }
              if (Array.from(i3.entries()).length > 0) {
                const e3 = Array.from(i3.entries()).map((e4) => {
                  let t3, [r3, i4] = e4;
                  i4.error_code || i4.video_error_code && i4.audio_error_code ? t3 = void 0 : i4.video_error_code ? t3 = yk.VIDEO : i4.audio_error_code && (t3 = yk.AUDIO);
                  return { user: this.remoteUsers.find((e5) => e5.uid === r3), mediaType: t3 };
                });
                await this._p2pChannel.massUnsubscribeNoLock(e3);
              }
              for (const e3 of o2) {
                const t3 = i3.get(e3.user.uid);
                if (t3) {
                  const r3 = t3.error_code || e3.mediaType === "audio" && t3.audio_error_code || e3.mediaType === "video" && t3.video_error_code;
                  if (r3) {
                    const t4 = QW(r3);
                    dD.error("user:".concat(e3.user.uid, " mediaType:").concat(e3.mediaType, " has massSubscribe error ").concat(t4.desc)), e3.error = new tD(eD.SUBSCRIBE_FAILED, "code ".concat(r3, ": ").concat(t4.desc));
                  }
                }
                e3.error || (e3.mediaType === "video" ? e3.track = e3.user.videoTrack : e3.track = e3.user.audioTrack);
              }
              return this.store.massSubscribe(o2.filter((e3) => !e3.error).map((e3) => ({ userId: e3.user.uid, type: e3.mediaType })), void 0, performance.now()), o2.forEach((e3) => {
                var t3;
                bV.subscribe(this.store.sessionId, { succ: !!e3.error, ec: ((t3 = e3.error) === null || t3 === void 0 ? void 0 : t3.code) || null, video: e3.mediaType === yk.VIDEO, audio: e3.mediaType === yk.AUDIO, peerid: e3.user.uid, subscribeRequestid: e3.mediaType === yk.VIDEO ? e3.user._videoSSRC : e3.user._audioSSRC, p2pid: this.store.p2pId, eventElapse: Math.floor(performance.now() - r2) }, true);
              }), t2.onSuccess(), dD.info("[".concat(this._clientId, "] massSubscribe success ").concat(e2.map((e3) => {
                let { user: t3, mediaType: r3 } = e3;
                return "user: ".concat(t3 == null ? void 0 : t3.uid, ", mediaType: ").concat(r3);
              }).join("; "))), LD("info", this, "massSubscribe", e2, "success"), o2;
            } catch (r3) {
              throw await this._p2pChannel.massUnsubscribeNoLock(e2), t2.onError(r3), r3;
            }
          } finally {
            s2(), n2();
          }
        }
        async unsubscribe(e2, t2) {
          if (t2 && XL(t2, "mediaType", ["audio", "video"]), !this._joinInfo)
            throw new tD(eD.INVALID_OPERATION, "Can't unsubscribe stream, haven't joined yet!");
          const r2 = bV.reportApiInvoke(this._sessionId, { name: fP.UNSUBSCRIBE, options: [e2.uid, t2], tag: EP.TRACER });
          if (!this._users.find((t3) => t3 === e2)) {
            const i2 = new tD(eD.INVALID_REMOTE_USER, "user is not in the channel");
            throw dD.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", user is not in the channel")), LD("error", this, "unsubscribe", { uid: e2.uid, mediaType: t2 }, "user is not in the channel"), r2.onError(i2), i2;
          }
          dD.info("[".concat(this._clientId, "] unsubscribe uid: ").concat(e2.uid, ", mediaType: ").concat(t2)), LD("info", this, "unsubscribe", { uid: e2.uid, mediaType: t2 });
          try {
            const i2 = await this._p2pChannel.unsubscribe(e2, t2);
            i2 && await this._gateway.unsubscribe(i2, e2.uid), dD.info("[".concat(this._clientId, "] unsubscribe success uid: ").concat(e2.uid, ", mediaType: ").concat(t2)), LD("info", this, "unsubscribe", { uid: e2.uid, mediaType: t2 }, "success"), r2.onSuccess();
          } catch (i2) {
            if (i2.code === eD.DISCONNECT_P2P)
              return dD.warning("disconnecting p2p, abort unsubscribe request."), void r2.onSuccess();
            throw dD.error("[".concat(this._clientId, "] unsubscribe user ").concat(e2.uid, " error"), i2.toString()), LD("error", this, "unsubscribe", { uid: e2.uid, mediaType: t2 }, i2.toString()), r2.onError(i2), i2;
          }
        }
        async massUnsubscribe(e2) {
          eP(e2, "unsubscribeList");
          const t2 = bV.reportApiInvoke(this._sessionId, { name: fP.UNSUBSCRIBE, options: e2.map((e3) => {
            let { user: t3, mediaType: r3 } = e3;
            return { uid: t3 == null ? void 0 : t3.uid, mediaType: r3 };
          }), tag: EP.TRACER });
          if (!this._joinInfo) {
            const e3 = new tD(eD.INVALID_OPERATION, "Can't unsubscribeAll stream, haven't joined yet!");
            throw t2.onError(e3), e3;
          }
          dD.info("[".concat(this._clientId, "] start massUnsubscribe ").concat(e2.map((e3) => {
            let { user: t3, mediaType: r3 } = e3;
            return "user: ".concat(t3 == null ? void 0 : t3.uid, ", mediaType: ").concat(r3, ";");
          }).join())), LD("info", this, "massUnsubscribe", e2), e2 = [...e2];
          const r2 = /* @__PURE__ */ new Map();
          for (let i2 = e2.length - 1; i2 >= 0; i2--) {
            const { user: n2, mediaType: o2 } = e2[i2];
            if (!n2) {
              const e3 = new tD(eD.INVALID_PARAMS, "user property does not exist in unsubscribeList item");
              throw dD.error("[".concat(this._clientId, "] user property does not exist in unsubscribeList item")), t2.onError(e3), e3;
            }
            XL(o2, "mediaType", ["video", "audio", void 0]);
            if (!this._users.find((e3) => e3 === n2)) {
              dD.warning("[".concat(this._clientId, "] can not subscribe ").concat(n2.uid, ", user is not in the channel")), LD("error", this, "unsubscribe", { uid: n2.uid, mediaType: o2 }, "user is not in the channel"), e2.splice(i2, 1);
              continue;
            }
            const s2 = uk.Video | uk.LwoVideo;
            if (r2.has(n2)) {
              const t3 = r2.get(n2);
              let a2;
              switch (o2) {
                case "video":
                  a2 = t3 & s2;
                  break;
                case "audio":
                  a2 = t3 & uk.Audio;
                  break;
                default:
                  a2 = t3 & (uk.Audio | s2);
              }
              if (a2) {
                dD.warning("repeat massUnsubscribe user:".concat(n2.uid, ",mediaType:").concat(o2, " twice.")), e2.splice(i2, 1);
                continue;
              }
              o2 ? o2 === "audio" ? r2.set(n2, t3 | uk.Audio) : o2 === "video" && r2.set(n2, t3 | s2) : r2.set(n2, t3 | uk.Audio | s2);
            } else
              o2 ? o2 === "audio" ? r2.set(n2, uk.Audio) : o2 === "video" && r2.set(n2, s2) : r2.set(n2, uk.Audio | s2);
          }
          try {
            const r3 = await this._p2pChannel.massUnsubscribe(e2);
            r3 && await this._gateway.massUnsubscribe(r3), dD.info("[".concat(this._clientId, "] massUnsubscribe success ").concat(e2.map((e3) => {
              let { user: t3, mediaType: r4 } = e3;
              return "user: ".concat(t3 == null ? void 0 : t3.uid, ", mediaType: ").concat(r4, ";");
            }).join())), LD("info", this, "massUnsubscribe", e2, "success"), t2.onSuccess();
          } catch (r3) {
            if (r3.code === eD.DISCONNECT_P2P)
              return dD.warning("disconnecting p2p, abort unsubscribe request."), void t2.onSuccess();
            throw dD.error("[".concat(this._clientId, "] massUnsubscribe error"), r3.toString()), LD("error", this, "massUnsubscribe", e2, r3.toString()), t2.onError(r3), r3;
          }
        }
        setLowStreamParameter(e2) {
          !function(e3) {
            if (!e3)
              throw new tD(eD.INVALID_PARAMS);
            iP(e3.width) || ZL(e3.width, "streamParameter.width"), iP(e3.height) || ZL(e3.height, "streamParameter.height"), iP(e3.framerate) || ZL(e3.framerate, "streamParameter.framerate"), iP(e3.bitrate) || ZL(e3.bitrate, "streamParameter.bitrate");
          }(e2);
          const t2 = bV.reportApiInvoke(this._sessionId, { name: fP.SET_LOW_STREAM_PARAMETER, options: [e2], tag: EP.TRACER });
          (!e2.width && e2.height || e2.width && !e2.height) && (dD.warning("[".concat(this._clientId, "] The width and height parameters take effect only when both are set")), TD("warning", this, "The width and height parameters take effect only when both are set")), dD.info("[".concat(this._clientId, "] set low stream parameter to"), JSON.stringify(e2)), LD("info", this, "setLowStreamParameter", e2);
          const r2 = this._configDistribute.getLowStreamConfigDistribute();
          r2 && r2.bitrate && e2.bitrate && r2.bitrate < e2.bitrate && (e2.bitrate = r2.bitrate), this._lowStreamParameter = e2, t2.onSuccess();
        }
        async enableDualStream() {
          const e2 = bV.reportApiInvoke(this._sessionId, { name: fP.ENABLE_DUAL_STREAM, options: [], tag: EP.TRACER });
          if (!Mk().supportDualStream) {
            bV.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: false });
            const t2 = new tD(eD.NOT_SUPPORTED, "Your browser is not support dual stream");
            throw e2.onError(t2), t2;
          }
          if (this._isDualStreamEnabled) {
            const t2 = new tD(eD.INVALID_OPERATION, "Dual stream is already enabled");
            throw e2.onError(t2), t2;
          }
          if (this._p2pChannel.canPublishLowStream())
            try {
              await this._publishLowStream();
            } catch (t2) {
              throw bV.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: false }), e2.onError(t2), t2;
            }
          this._isDualStreamEnabled = true, bV.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: true }), dD.info("[".concat(this._clientId, "] enable dual stream")), LD("info", this, "enableDualStream"), e2.onSuccess();
        }
        async disableDualStream() {
          if (!this._isDualStreamEnabled)
            return;
          if (!this._joinInfo)
            throw new tD(eD.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
          const e2 = bV.reportApiInvoke(this._sessionId, { name: fP.DISABLE_DUAL_STREAM, options: [], tag: EP.TRACER });
          if (this._p2pChannel.getLocalMedia(Tk.LocalVideoLowTrack))
            try {
              const e3 = await this._p2pChannel.unpublishLowStream();
              e3 && await this._gateway.unpublish(e3, this._joinInfo.stringUid || this._joinInfo.uid);
            } catch (t2) {
              throw bV.streamSwitch(this._sessionId, { lts: Date.now(), isdual: false, succ: false }), e2.onError(t2), t2;
            }
          this._isDualStreamEnabled = false, bV.streamSwitch(this._sessionId, { lts: Date.now(), isdual: false, succ: true }), dD.info("[".concat(this._clientId, "] disable dual stream")), LD("info", this, "disableDualStream"), e2.onSuccess();
        }
        async setClientRole(e2, t2) {
          !function(e3) {
            XL(e3, "role", ["audience", "host"]);
          }(e2), t2 && FP(t2);
          const r2 = bV.reportApiInvoke(this._sessionId, { name: fP.SET_CLIENT_ROLE, options: [e2, t2], tag: EP.TRACER });
          if (this._mode === "rtc") {
            dD.warning("[".concat(this._clientId, "]rtc mode can not use setClientRole")), LD("warning", this, "setClientRole", e2, "rtc mode can not use setClientRole");
            const t3 = new tD(eD.INVALID_OPERATION, "rtc mode can not use setClientRole");
            return r2.onError(t3), t3.throw();
          }
          if (t2 && t2.level && e2 === "host") {
            const e3 = new tD(eD.INVALID_OPERATION, "host mode can not set audience latency level");
            return r2.onError(e3), e3.throw();
          }
          try {
            if (e2 === "audience" && this._p2pChannel.hasLocalMedia()) {
              const e3 = new tD(eD.INVALID_OPERATION, "can not set client role to audience when publishing stream");
              return r2.onError(e3), e3.throw();
            }
            await this._gateway.setClientRole(e2, t2), dD.info("[".concat(this._clientId, "] set client role to ").concat(e2, ", level: ").concat(t2 && t2.level)), LD("info", this, "setClientRole", { role: e2, level: t2 && t2.level }), r2.onSuccess();
          } catch (e3) {
            throw r2.onError(e3), e3;
          }
        }
        setProxyServer(e2, t2) {
          if ($L(e2, "proxyServer"), !t2) {
            if (this.connectionState !== "DISCONNECTED")
              throw new tD(eD.INVALID_OPERATION, "Set proxy server before join channel");
            if (this._cloudProxyServerMode !== "disabled" || this._useLocalAccessPoint)
              throw new tD(eD.INVALID_OPERATION, "You have already set the proxy");
          }
          this._proxyServer = e2, bV.setProxyServer(this._proxyServer), dD.setProxyServer(this._proxyServer), yD(this._proxyServer), dD.info("[".concat(this._clientId, "] Set proxy server ").concat(t2 ? "by initialize call" : "", " success.")), LD("info", this, "setProxyServer", [...arguments], "success");
        }
        setTurnServer(e2, t2) {
          if (Array.isArray(e2) || (e2 = [e2]), !t2) {
            if (this.connectionState !== "DISCONNECTED")
              throw new tD(eD.INVALID_OPERATION, "Set turn server before join channel");
            if (this._cloudProxyServerMode !== "disabled" || this._useLocalAccessPoint)
              throw new tD(eD.INVALID_OPERATION, "You have already set the proxy");
          }
          if (QP(e2))
            return this._turnServer = { servers: e2, mode: "original-manual" }, dD.info("[".concat(this._clientId, "] Set original turnserver ").concat(t2 ? "by initialize call" : "", " success: ").concat(e2.map((e3) => e3.urls).join(","), ".")), void LD("info", this, "setOriginalTurnServer", [...arguments], "success");
          e2.forEach((e3) => xP(e3)), this._turnServer = { servers: e2, mode: "manual" }, dD.info("[".concat(this._clientId, "] Set turnserver ").concat(t2 ? "by initialize call" : "", " success.")), LD("info", this, "setTurnServer", [...arguments], "success");
        }
        startProxyServer(e2) {
          const t2 = bV.reportApiInvoke(this._sessionId, { name: fP.START_PROXY_SERVER, options: [], tag: EP.TRACER });
          if (this.connectionState !== "DISCONNECTED") {
            const e3 = new tD(eD.INVALID_OPERATION, "Start proxy server before join channel");
            throw t2.onError(e3), e3;
          }
          if (this._proxyServer || this._turnServer.mode === "manual" || this._useLocalAccessPoint) {
            const e3 = new tD(eD.INVALID_OPERATION, "You have already set the proxy");
            throw t2.onError(e3), e3;
          }
          const r2 = [1, 2, 3, 4, 5];
          let i2;
          switch (e2 === void 0 && (e2 = 1), e2) {
            case 1:
              i2 = "normal";
              break;
            case 2:
              i2 = "443only";
              break;
            case 3:
              i2 = "proxy3";
              break;
            case 4:
              i2 = "proxy4";
              break;
            case 5:
              i2 = "proxy5";
              break;
            default: {
              const e3 = new tD(eD.INVALID_PARAMS, "proxy server mode must be ".concat(r2.join("|")));
              throw t2.onError(e3), e3;
            }
          }
          this._cloudProxyServerMode = i2, this.store.cloudProxyServerMode = i2, dD.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode), LD("info", this, "startProxyServer", this._cloudProxyServerMode), t2.onSuccess();
        }
        stopProxyServer() {
          const e2 = bV.reportApiInvoke(this._sessionId, { name: fP.STOP_PROXY_SERVER, options: [], tag: EP.TRACER });
          if (this.connectionState !== "DISCONNECTED")
            throw new tD(eD.INVALID_OPERATION, "Stop proxy server after leave channel");
          bV.setProxyServer(), dD.setProxyServer(), yD(), this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled", dD.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode), LD("info", this, "stopProxyServer", this._cloudProxyServerMode), this._proxyServer = void 0, this._turnServer = { mode: "auto", servers: [] }, e2.onSuccess();
        }
        setLocalAccessPoints(e2, t2) {
          if (eP(e2, "serverList"), $L(t2, "domain"), this._proxyServer || this._cloudProxyServerMode !== "disabled")
            throw new tD(eD.INVALID_OPERATION, "set local access point failed, You have already set the cloud proxy");
          const r2 = /^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/;
          e2 = e2.map((e3) => r2.test(e3) ? "".concat(e3.replace(/\./g, "-"), ".").concat(t2) : e3), this._useLocalAccessPoint = true, WD("WEBCS_DOMAIN", e2), WD("WEBCS_DOMAIN_BACKUP_LIST", e2), WD("GATEWAY_DOMAINS", [t2]), WD("EVENT_REPORT_DOMAIN", e2[0]), WD("EVENT_REPORT_BACKUP_DOMAIN", e2[1] || e2[0]), WD("LOG_UPLOAD_SERVER", "".concat(e2[0], ":6444")), dD.info("set local access point success"), LD("info", this, "setLocalAccessPoints");
        }
        async setRemoteDefaultVideoStreamType(e2) {
          if (XL(e2, "streamType", [0, 1]), this._remoteDefaultVideoStreamType = e2, this._joinInfo)
            try {
              await this._gateway.setDefaultRemoteVideoStreamType(e2), this._joinInfo.defaultVideoStream = this._remoteDefaultVideoStreamType;
            } catch (e3) {
              throw dD.error("[".concat(this._clientId, "] set default remote video stream type error"), e3.toString()), e3;
            }
          else
            dD.debug("haven't joined yet, cache remoteDefaultVideoStreamType ".concat(e2));
        }
        async setRemoteVideoStreamType(e2, t2) {
          XL(t2, "streamType", [0, 1]);
          const r2 = bV.reportApiInvoke(this._sessionId, { name: fP.SET_REMOTE_VIDEO_STREAM_TYPE, options: [e2, t2], tag: EP.TRACER });
          try {
            await this._gateway.setRemoteVideoStreamType(e2, t2), setTimeout(() => {
              const t3 = this._users.find((t4) => t4.uid === e2);
              t3 && t3.videoTrack && t3.videoTrack.updateMediaStreamTrackResolution();
            }, 2e3);
          } catch (e3) {
            throw r2.onError(e3), dD.error("[".concat(this._clientId, "] set remote video stream type error"), e3.toString()), LD("error", this, "setRemoteVideoStreamType", void 0, e3.toString()), e3;
          }
          dD.info("[".concat(this._clientId, "] set remote ").concat(e2, " video stream type to ").concat(t2)), LD("info", this, "setRemoteVideoStreamType", { uid: e2, streamType: t2 }), this._remoteStreamTypeCacheMap.set(e2, t2), r2.onSuccess();
        }
        async setStreamFallbackOption(e2, t2) {
          XL(t2, "fallbackType", [0, 1, 2]);
          const r2 = bV.reportApiInvoke(this._sessionId, { name: fP.SET_STREAM_FALLBACK_OPTION, options: ["too long to show", t2], tag: EP.TRACER });
          try {
            await this._gateway.setStreamFallbackOption(e2, t2);
          } catch (e3) {
            throw r2.onError(e3), dD.error("[".concat(this._clientId, "] set stream fallback option"), e3.toString()), LD("error", this, "setStreamFallbackOption", void 0, e3.toString()), e3;
          }
          dD.info("[".concat(this._clientId, "] set remote ").concat(e2, " stream fallback type to ").concat(t2)), LD("info", this, "setStreamFallbackOption", { uid: e2, fallbackType: t2 }), this._streamFallbackTypeCacheMap.set(e2, t2), r2.onSuccess();
        }
        setEncryptionConfig(e2, t2, r2) {
          !function(e3) {
            XL(e3, "encryptionMode", ["aes-128-xts", "aes-256-xts", "aes-128-ecb", "sm4-128-ecb", "aes-128-gcm", "aes-256-gcm", "aes-128-gcm2", "aes-256-gcm2", "none"]);
          }(e2), $L(t2, "secret");
          if (["aes-128-gcm2", "aes-256-gcm2"].includes(e2)) {
            if (!r2 || !(r2 instanceof Uint8Array && r2.length === 32))
              throw new tD(eD.INVALID_PARAMS, "salt must be an Uint8Array and exactly equal to 32 bytes");
          } else if (r2)
            throw new tD(eD.INVALID_PARAMS, "current encrypt mode does not need salt");
          new RegExp(`^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*,.<>?/:;'"|{}\\[\\]])(?=.{8,})`).test(t2) || (dD.warning("The secret is not strong:\n      The secret must contain at least 1 lowercase alphabetical character,\n      The secret must contain at least 1 uppercase alphabetical character,\n      The secret must contain at least 1 numeric character,\n      The secret must contain at least one special character,\n      The secret must be eight characters or longer.\n      "), TD("warning", this, "The secret is not strong:\n      The secret must contain at least 1 lowercase alphabetical character,\n      The secret must contain at least 1 uppercase alphabetical character,\n      The secret must contain at least 1 numeric character,\n      The secret must contain at least one special character,\n      The secret must be eight characters or longer.\n      ")), this._encryptionMode = e2, this._encryptionSecret = t2, r2 && (this._encryptionSalt = xG(r2));
        }
        async renewToken(e2) {
          $L(e2, "token", 1, 2047);
          const t2 = bV.reportApiInvoke(this._sessionId, { name: fP.RENEW_TOKEN, options: [e2], tag: EP.TRACER });
          if (!this._key || !this._joinInfo) {
            const e3 = new tD(eD.INVALID_OPERATION, "renewToken should not be called before user join");
            return t2.onError(e3), e3.throw();
          }
          const r2 = this._key;
          this._key = e2, this._joinInfo && (this._joinInfo.token = e2);
          const i2 = await this._renewTokenMutex.lock();
          try {
            if (JD("USE_NEW_TOKEN")) {
              dD.debug("start renew token with ticket from unilbs"), LD("debug", this, "renewToken", "unilbs");
              const t3 = await BJ(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || rD);
              dD.debug("[".concat(this._clientId, "] get ticket from unilbs success")), LD("debug", this, "renewToken", "unilbs", "success"), await this._gateway.renewToken({ token: e2, ticket: t3 });
            } else
              dD.debug("start renew token without ticket"), LD("debug", this, "renewToken"), await this._gateway.renewToken({ token: e2 });
            dD.debug("[".concat(this._clientId, "] renewToken success")), LD("debug", this, "renewToken", void 0, "success"), t2.onSuccess();
          } catch (e3) {
            throw this._key = r2, this._joinInfo.token = r2, t2.onError(e3), dD.error("[".concat(this._clientId, "] renewToken failed"), e3.toString()), LD("error", this, "renewToken", void 0, e3.toString()), e3;
          } finally {
            i2();
          }
        }
        enableAudioVolumeIndicator() {
          const e2 = bV.reportApiInvoke(this._sessionId, { name: fP.ENABLE_AUDIO_VOLUME_INDICATOR, options: [], tag: EP.TRACER });
          if (this._audioVolumeIndicationInterval)
            return dD.warning("you have already enabled audio volume indicator!"), LD("warning", this, "enableAudioVolumeIndicator", "you have already enabled audio volume indicator!"), e2.onSuccess();
          this._audioVolumeIndicationInterval = window.setInterval(() => {
            const e3 = this._p2pChannel.getAudioLevels();
            this.emit(wP.VOLUME_INDICATOR, e3);
          }, JD("AUDIO_VOLUME_INDICATION_INTERVAL") || 2e3), e2.onSuccess();
        }
        getRTCStats() {
          const e2 = this._statsCollector.getRTCStats(), t2 = this._gateway.getInChannelInfo();
          return e2.Duration = Math.round(t2.duration / 1e3), e2;
        }
        startLiveStreaming(e2, t2) {
          const r2 = bV.reportApiInvoke(this._sessionId, { name: fP.START_LIVE_STREAMING, options: [e2, t2], tag: EP.TRACER });
          if (!t2) {
            if (this._codec !== "h264") {
              const e3 = new tD(eD.LIVE_STREAMING_INVALID_RAW_STREAM, "raw streaming is only support h264");
              return r2.onError(e3), nR.reject(e3);
            }
            if (!this._p2pChannel.hasLocalMedia()) {
              const e3 = new tD(eD.LIVE_STREAMING_INVALID_RAW_STREAM, "can not find stream to raw streaming");
              return r2.onError(e3), nR.reject(e3);
            }
          }
          if (this._liveRawStreamingClient && this._liveRawStreamingClient.hasUrl(e2) || this._liveTranscodeStreamingClient && this._liveTranscodeStreamingClient.hasUrl(e2)) {
            const e3 = new tD(eD.LIVE_STREAMING_TASK_CONFLICT);
            return r2.onError(e3), nR.reject(e3);
          }
          const i2 = t2 ? WP.TRANSCODE : WP.RAW;
          return this._createLiveStreamingClient(i2).startLiveStreamingTask(e2, i2).then(() => r2.onSuccess()).catch((e3) => {
            throw r2.onError(e3), e3;
          });
        }
        setLiveTranscoding(e2) {
          const t2 = bV.reportApiInvoke(this._sessionId, { name: fP.SET_LIVE_TRANSCODING, options: [e2], tag: EP.TRACER });
          return this._createLiveStreamingClient(WP.TRANSCODE).setTranscodingConfig(e2).then(() => t2.onSuccess()).catch((e3) => {
            throw t2.onError(e3), e3;
          });
        }
        stopLiveStreaming(e2) {
          const t2 = bV.reportApiInvoke(this._sessionId, { name: fP.STOP_LIVE_STREAMING, options: [e2], tag: EP.TRACER }), r2 = [this._liveRawStreamingClient, this._liveTranscodeStreamingClient].filter((t3) => t3 && t3.hasUrl(e2));
          if (!r2.length) {
            const e3 = new tD(eD.INVALID_PARAMS, "can not find live streaming url to stop");
            return t2.onError(e3), nR.reject(e3);
          }
          return nR.all(r2.map((t3) => t3 && t3.stopLiveStreamingTask(e2))).then(() => t2.onSuccess()).catch((e3) => {
            throw t2.onError(e3), e3;
          });
        }
        async addInjectStreamUrl(e2, t2) {
          const r2 = bV.reportApiInvoke(this._sessionId, { name: fP.ADD_INJECT_STREAM_URL, options: [e2, t2], tag: EP.TRACER });
          try {
            if (!this._joinInfo)
              throw new tD(eD.INVALID_OPERATION, "can not addInjectStreamUrl, no joininfo");
            const r3 = this._createLiveStreamingClient(WP.INJECT);
            r3.setInjectStreamConfig(t2, 0), await r3.startLiveStreamingTask(e2, WP.INJECT);
          } catch (e3) {
            throw r2.onError(e3), e3;
          }
          r2.onSuccess();
        }
        async removeInjectStreamUrl() {
          const e2 = bV.reportApiInvoke(this._sessionId, { name: fP.REMOVE_INJECT_STREAM_URL, options: [], tag: EP.TRACER });
          try {
            var t2;
            const e3 = this._createLiveStreamingClient(WP.INJECT), r2 = Array.from(nV(t2 = e3.streamingTasks).call(t2)).find((e4) => e4.mode === WP.INJECT);
            if (!this._joinInfo || !r2)
              throw new tD(eD.INVALID_OPERATION, "can remove addInjectStreamUrl, no joininfo or inject task");
            await e3.stopLiveStreamingTask(r2.url);
          } catch (t3) {
            throw e2.onError(t3), t3;
          }
          e2.onSuccess();
        }
        async startChannelMediaRelay(e2) {
          const t2 = bV.reportApiInvoke(this._sessionId, { name: fP.START_CHANNEL_MEDIA_RELAY, options: [e2], tag: EP.TRACER });
          try {
            WJ(e2);
            const t3 = this._createChannelMediaRelayClient();
            await t3.startChannelMediaRelay(e2);
          } catch (e3) {
            return t2.onError(e3), e3.throw();
          }
          t2.onSuccess();
        }
        async updateChannelMediaRelay(e2) {
          const t2 = bV.reportApiInvoke(this._sessionId, { name: fP.UPDATE_CHANNEL_MEDIA_RELAY, options: [e2], tag: EP.TRACER });
          try {
            WJ(e2);
            const t3 = this._createChannelMediaRelayClient();
            await t3.updateChannelMediaRelay(e2);
          } catch (e3) {
            return t2.onError(e3), e3.throw();
          }
          t2.onSuccess();
        }
        async stopChannelMediaRelay() {
          const e2 = bV.reportApiInvoke(this._sessionId, { name: fP.STOP_CHANNEL_MEDIA_RELAY, options: [], tag: EP.TRACER });
          try {
            const e3 = this._createChannelMediaRelayClient();
            await e3.stopChannelMediaRelay();
          } catch (t2) {
            return e2.onError(t2), t2.throw();
          }
          e2.onSuccess();
        }
        sendStreamMessage(e2) {
          let t2 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
          if (!this._joinInfo)
            throw new tD(eD.INVALID_OPERATION, "can not send data stream, not joined");
          if (typeof e2 == "string") {
            e2 = new TextEncoder().encode(e2);
          }
          if (new Blob([e2]).size > 1024)
            throw new tD(eD.INVALID_PARAMS, "stream message out of range.");
          return this._gateway.signal.request(DP.DATA_STREAM, { payload: xG(e2) }, !t2);
        }
        sendMetadata(e2) {
          if (!this._joinInfo)
            throw new tD(eD.INVALID_OPERATION, "can not send metadata, not joined");
          if (new Blob([e2]).size > 1024)
            throw new tD(eD.METADATA_OUT_OF_RANGE);
          return this._gateway.signal.request(DP.SEND_METADATA, { session_id: this._joinInfo.sid, metadata: xG(e2) });
        }
        async sendCustomReportMessage(e2) {
          Array.isArray(e2) || (e2 = [e2]), e2.forEach(AP);
          const t2 = bV.reportApiInvoke(this._sessionId, { name: fP.SEND_CUSTOM_REPORT_MESSAGE, options: [JSON.stringify(e2)], tag: EP.TRACER });
          if (!this._joinInfo) {
            const e3 = new tD(eD.INVALID_OPERATION, "can not send custom report, not joined");
            return t2.onError(e3), e3.throw();
          }
          await bV.sendCustomReportMessage(this._joinInfo.sid, e2), t2.onSuccess();
        }
        getLocalAudioStats() {
          return this._statsCollector.getLocalAudioTrackStats();
        }
        getRemoteAudioStats() {
          return this._statsCollector.getRemoteAudioTrackStats();
        }
        getLocalVideoStats() {
          return this._statsCollector.getLocalVideoTrackStats();
        }
        getRemoteVideoStats() {
          return this._statsCollector.getRemoteVideoTrackStats();
        }
        getRemoteNetworkQuality() {
          return this._statsCollector.getRemoteNetworkQualityStats();
        }
        async pickSVCLayer(e2, t2) {
          XL(t2.spatialLayer, "spatialLayer", [0, 1, 2, 3]), XL(t2.temporalLayer, "temporalLayer", [0, 1, 2, 3]);
          try {
            await this._gateway.pickSVCLayer(e2, t2);
          } catch (e3) {
            throw dD.error("[".concat(this._clientId, "] pick SVC layer failed"), e3.toString()), ND("error", this, "pickSVCLayer", t2, e3.toString()), e3;
          }
        }
        _reset() {
          dD.debug("[".concat(this._clientId, "] reset client")), ND("debug", this, "_reset"), this._axiosCancelSource.cancel(), this._axiosCancelSource = zN.CancelToken.source(), this._streamFallbackTypeCacheMap = /* @__PURE__ */ new Map(), this._remoteStreamTypeCacheMap = /* @__PURE__ */ new Map(), this._configDistribute.stopGetConfigDistribute(), this._joinInfo = void 0, this._proxyServer = void 0, this._defaultStreamFallbackType = void 0, this._sessionId = null, this.store.sessionId = null, this._statsCollector.reset(), this._key = void 0, this._appId = void 0, this._uid = void 0, this.store.uid = void 0, this._channelName = void 0, this._encryptionMode = "none", this._encryptionSecret = null, this._encryptionSalt = null, this._users.forEach((e2) => {
            e2._audioTrack && e2._audioTrack._destroy(), e2._videoTrack && e2._videoTrack._destroy();
          }), this._users = [], this._audioVolumeIndicationInterval && (window.clearInterval(this._audioVolumeIndicationInterval), this._audioVolumeIndicationInterval = void 0), this._cloudProxyServerMode === "fallback" && (this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled"), this._p2pChannel.reset(), this._publishMutex = new kV("client-publish"), this._subscribeMutex = new kV("client-subscribe"), this._networkQualityInterval && (window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = void 0), this._injectStreamingClient && (this._injectStreamingClient.terminate(), this._injectStreamingClient.removeAllListeners(), this._injectStreamingClient = void 0), this._liveRawStreamingClient && (this._liveRawStreamingClient.terminate(), this._liveRawStreamingClient.removeAllListeners(), this._liveRawStreamingClient = void 0), this._liveTranscodeStreamingClient && (this._liveTranscodeStreamingClient.terminate(), this._liveTranscodeStreamingClient.removeAllListeners(), this._liveTranscodeStreamingClient = void 0), this._channelMediaRelayClient && (this._channelMediaRelayClient.dispose(), this._channelMediaRelayClient = void 0);
        }
        _startSession(e2, t2) {
          const r2 = e2 || RG();
          e2 ? dD.debug("[".concat(this._clientId, "] new Session ").concat(r2)) : dD.debug("[".concat(this._clientId, "] renewSession ").concat(this._sessionId, " => ").concat(r2)), ND("debug", this, "_startSession", { newSid: r2, sid: this._sessionId }), this._sessionId = r2, this.store.sessionId = r2, t2 ? bV.sessionInit(this._sessionId, { lts: new Date().getTime(), cname: t2.channel, appid: t2.appId, mode: this._mode }) : this._joinInfo ? bV.sessionInit(this._sessionId, { lts: new Date().getTime(), cname: this._joinInfo.cname, appid: this._joinInfo.appId, mode: this._mode }) : this._gateway.joinInfo && bV.sessionInit(this._sessionId, { lts: new Date().getTime(), cname: this._gateway.joinInfo.cname, appid: this._gateway.joinInfo.appId, mode: this._mode }), this._joinInfo && (this._joinInfo.sid = r2), this._gateway.joinInfo && (this._gateway.joinInfo.sid = r2);
        }
        async _publishHighStream(e2) {
          if (!this._joinInfo || this._uid === void 0)
            throw new tD(eD.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
          if (this.connectionState !== "CONNECTED" && this.connectionState !== "RECONNECTING")
            throw new tD(eD.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state"));
          if (this._turnServer.mode === "auto" && JD("FORCE_TURN") && !JD("TURN_ENABLE_TCP") && !JD("TURN_ENABLE_UDP"))
            throw new tD(eD.UNEXPECTED_ERROR, "force TURN With No TURN Configuration");
          dD.debug("[".concat(this._clientId, "] publish high stream")), ND("debug", this, "_publishHighStream");
          try {
            const r2 = await this._p2pChannel.publish(e2, this._isDualStreamEnabled, this._lowStreamParameter), i2 = (await r2.next()).value;
            if (i2) {
              var t2;
              let e3;
              try {
                e3 = await this._gateway.publish(this._uid, i2, true);
              } catch (e4) {
                if (e4.code !== eD.DISCONNECT_P2P)
                  throw r2.throw(e4), e4;
              }
              await r2.next(((t2 = e3) === null || t2 === void 0 ? void 0 : t2.ortc) || []);
            }
            this._p2pChannel.reportPublishEvent(true, null);
            for (const t3 of e2)
              t3 instanceof $q && t3._encoderConfig && this._gateway.setVideoProfile(t3._encoderConfig), !t3.muted && t3.enabled || await this._p2pChannel.muteLocalTrack(t3);
          } catch (t3) {
            if (this._p2pChannel.reportPublishEvent(false, t3 == null ? void 0 : t3.code, e2), (t3 == null ? void 0 : t3.code) === eD.WS_ABORT)
              return;
            throw t3;
          }
        }
        async _publishLowStream() {
          if (!this._joinInfo || this._uid === void 0)
            throw new tD(eD.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
          if (this.connectionState !== "CONNECTED" && this.connectionState !== "RECONNECTING")
            throw new tD(eD.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state"));
          dD.debug("[".concat(this._clientId, "] publish low stream")), ND("debug", this, "_publishLowStream");
          const e2 = this._configDistribute.getLowStreamConfigDistribute();
          e2 && e2.bitrate && (this._lowStreamParameter || (this._lowStreamParameter = { width: 160, height: 120, framerate: 15, bitrate: 50 }), this._lowStreamParameter && this._lowStreamParameter.bitrate && e2.bitrate < this._lowStreamParameter.bitrate && (this._lowStreamParameter.bitrate = e2.bitrate));
          try {
            const e3 = await this._p2pChannel.publishLowStream(this._lowStreamParameter), r2 = (await e3.next()).value;
            if (r2) {
              var t2;
              let i2;
              try {
                i2 = await this._gateway.publish(this._uid, r2, true);
              } catch (t3) {
                if (t3.code !== eD.DISCONNECT_P2P)
                  throw e3.throw(t3), t3;
              }
              e3.next(((t2 = i2) === null || t2 === void 0 ? void 0 : t2.ortc) || []), this._p2pChannel.reportPublishEvent(true, null, void 0, true);
            }
          } catch (e3) {
            if (this._p2pChannel.reportPublishEvent(false, e3 == null ? void 0 : e3.code, void 0, true), (e3 == null ? void 0 : e3.code) === eD.WS_ABORT)
              return;
            throw e3;
          }
        }
        _createLiveStreamingClient(e2) {
          if (!this._joinInfo || !this._appId) {
            return new tD(eD.INVALID_OPERATION, "can not create live streaming client, please join channel first").throw();
          }
          const t2 = () => new HJ(this._joinInfo, this._config.websocketRetryConfig || rD, this._config.httpRetryConfig || rD), r2 = (e3) => {
            e3.onLiveStreamError = (e4, t3) => {
              bV.reportApiInvoke(this._sessionId, { name: fP.ON_LIVE_STREAM_ERROR, options: [e4, t3], tag: EP.TRACER }).onSuccess(), this.emit(wP.LIVE_STREAMING_ERROR, e4, t3);
            }, e3.onLiveStreamWarning = (e4, t3) => {
              bV.reportApiInvoke(this._sessionId, { name: fP.ON_LIVE_STREAM_WARNING, options: [e4, t3], tag: EP.TRACER }).onSuccess(), this.emit(wP.LIVE_STREAMING_WARNING, e4, t3);
            }, e3.on(tk.REQUEST_WORKER_MANAGER_LIST, (e4, t3, r3) => {
              if (!this._joinInfo)
                return r3(new tD(eD.INVALID_OPERATION, "can not find join info to get worker manager"));
              PJ(e4, this._joinInfo, this._axiosCancelSource.token, rD).then(t3).catch(r3);
            });
          };
          switch (e2) {
            case WP.RAW:
              return this._liveRawStreamingClient || (this._liveRawStreamingClient = t2(), r2(this._liveRawStreamingClient)), this._liveRawStreamingClient;
            case WP.TRANSCODE:
              return this._liveTranscodeStreamingClient || (this._liveTranscodeStreamingClient = t2(), r2(this._liveTranscodeStreamingClient)), this._liveTranscodeStreamingClient;
            case WP.INJECT:
              return this._injectStreamingClient || (this._injectStreamingClient = t2(), this._injectStreamingClient.on(tk.REQUEST_WORKER_MANAGER_LIST, (e3, t3, r3) => {
                if (!this._joinInfo)
                  return r3(new tD(eD.INVALID_OPERATION, "can not find join info to get worker manager"));
                PJ(e3, this._joinInfo, this._axiosCancelSource.token, rD).then(t3).catch(r3);
              }), this._injectStreamingClient.onInjectStatusChange = (e3, t3, r3) => {
                this.emit(wP.INJECT_STREAM_STATUS, e3, t3, r3);
              }), this._injectStreamingClient;
          }
        }
        _createChannelMediaRelayClient() {
          if (!this._joinInfo) {
            return new tD(eD.INVALID_OPERATION, "can not create channel media relay client, please join channel first").throw();
          }
          return this._channelMediaRelayClient || (this._channelMediaRelayClient = new qJ(this._joinInfo, this._clientId, this._config.websocketRetryConfig || rD, this._config.httpRetryConfig || rD), this._channelMediaRelayClient.on("state", (e2) => {
            e2 === sk.RELAY_STATE_FAILURE && this._channelMediaRelayClient && this._channelMediaRelayClient.dispose(), this.emit(wP.CHANNEL_MEDIA_RELAY_STATE, e2);
          }), this._channelMediaRelayClient.on("event", (e2) => {
            this.emit(wP.CHANNEL_MEDIA_RELAY_EVENT, e2);
          })), this._channelMediaRelayClient;
        }
        _handleGatewayEvents() {
          this._gateway.on(dk.DISCONNECT_P2P, async () => {
            await this._p2pChannel.disconnectForReconnect();
          }), this._gateway.on(dk.CONNECTION_STATE_CHANGE, (e2, t2, r2) => {
            var i2;
            if (r2 === TP.FALLBACK)
              return;
            const n2 = () => {
              this.emit(wP.CONNECTION_STATE_CHANGE, e2, t2, r2);
            };
            if (bV.reportApiInvoke(this._sessionId || ((i2 = this._gateway.joinInfo) === null || i2 === void 0 ? void 0 : i2.sid) || null, { name: fP.CONNECTION_STATE_CHANGE, options: [e2, t2, r2], tag: EP.TRACER }).onSuccess(JSON.stringify({ cur: e2, prev: t2, reason: r2 })), dD.info("[".concat(this._clientId, "] connection state change: ").concat(t2, " -> ").concat(e2)), wD("info", this, "connection-state-change", "".concat(t2, " -> ").concat(e2)), e2 === "DISCONNECTED")
              return this._reset(), void n2();
            if (e2 === "RECONNECTING")
              this._users.forEach((e3) => {
                e3._trust_in_room_ = false, e3._trust_audio_enabled_state_ = false, e3._trust_video_enabled_state_ = false, e3._trust_audio_mute_state_ = false, e3._trust_video_mute_state_ = false, e3._trust_stream_added_state_ = false;
              }), this._userOfflineTimeout && window.clearTimeout(this._userOfflineTimeout), this._streamRemovedTimeout && window.clearTimeout(this._streamRemovedTimeout), this._userOfflineTimeout = void 0, this._streamRemovedTimeout = void 0;
            else if (e2 === "CONNECTED") {
              var o2;
              this._streamFallbackTypeCacheMap.forEach((e3, t3) => {
                this._gateway.setStreamFallbackOption(t3, e3).catch((e4) => {
                  dD.warning("[".concat(this._clientId, "] auto set stream fallback option failed"), e4), TD("warning", this, "auto set stream fallback option failed, ".concat(e4.toString()));
                });
              }), this._remoteStreamTypeCacheMap.forEach((e3, t3) => {
                this._gateway.setRemoteVideoStreamType(t3, e3).catch((e4) => {
                  dD.warning("[".concat(this._clientId, "] auto set remote stream type failed"), e4), TD("warning", this, "auto set remote stream type failed, ".concat(e4.toString()));
                });
              }), this._remoteDefaultVideoStreamType !== void 0 && ((o2 = this._joinInfo) === null || o2 === void 0 ? void 0 : o2.defaultVideoStream) === void 0 && this.setRemoteDefaultVideoStreamType(this._remoteDefaultVideoStreamType).then(() => {
                dD.debug("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway connected"));
              }).catch((e3) => {
                dD.error("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway failed, ").concat(e3));
              }), this._p2pChannel.republish(), this._userOfflineTimeout = window.setTimeout(() => {
                if (this.connectionState !== "CONNECTED")
                  return;
                this._userOfflineTimeout = void 0;
                this._users.filter((e3) => !e3._trust_in_room_).forEach((e3) => {
                  dD.debug("[".concat(this._clientId, "] user offline timeout, emit user offline ").concat(e3.uid)), TD("debug", this, "user offline timeout, emit user offline ".concat(e3.uid)), this._handleUserOffline({ uid: e3.uid });
                });
              }, 3e3), this._streamRemovedTimeout = window.setTimeout(() => {
                this.connectionState === "CONNECTED" && (this._streamRemovedTimeout = void 0, this._users.forEach((e3) => {
                  e3._trust_audio_mute_state_ || (dD.debug("[".concat(this._clientId, "] auto dispatch audio unmute event ").concat(e3.uid)), TD("debug", this, "auto dispatch audio unmute event ".concat(e3.uid)), this._handleMuteStream(e3.uid, "audio", false)), e3._trust_video_mute_state_ || (dD.debug("[".concat(this._clientId, "] auto dispatch video unmute event ").concat(e3.uid)), TD("debug", this, "auto dispatch video unmute event ".concat(e3.uid)), this._handleMuteStream(e3.uid, "video", false)), e3._trust_audio_enabled_state_ || (dD.debug("[".concat(this._clientId, "] auto dispatch enable local audio ").concat(e3.uid)), TD("debug", this, "auto dispatch enable local audio ".concat(e3.uid)), this._handleSetStreamLocalEnable("audio", e3.uid, true)), !e3._trust_video_enabled_state_ && e3._video_enabled_ && (dD.debug("[".concat(this._clientId, "] auto dispatch enable local video ").concat(e3.uid)), TD("debug", this, "auto dispatch enable local video ".concat(e3.uid)), this._handleSetStreamLocalEnable("video", e3.uid, true)), e3._trust_stream_added_state_ || (dD.debug("[".concat(this._clientId, "] auto dispatch stream remove ").concat(e3.uid)), TD("debug", this, "auto dispatch stream remove ".concat(e3.uid)), this._handleRemoveStream({ uid: e3.uid, uint_id: e3._uintid }));
                }));
              }, 1e3);
            }
            n2();
          }), this._gateway.on(dk.REQUEST_NEW_GATEWAY_LIST, (e2, t2) => {
            if (!this._joinInfo)
              return t2(new tD(eD.UNEXPECTED_ERROR, "can not recover, no join info"));
            wJ(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || rD, this.store).then((t3) => {
              this._joinInfo && (this._joinInfo.apResponse = t3.gatewayInfo.res, this._joinInfo.gatewayAddrs = t3.gatewayInfo.gatewayAddrs, this._joinInfo.uni_lbs_ip = t3.gatewayInfo.uni_lbs_ip), e2(t3.gatewayInfo.gatewayAddrs.map((e3) => {
                if (this._joinInfo && this._joinInfo.proxyServer) {
                  const t4 = e3.address.split(":");
                  return "wss://".concat(this._joinInfo.proxyServer, "/ws/?h=").concat(t4[0], "&p=").concat(t4[1]);
                }
                return "wss://".concat(e3.address);
              }));
            }).catch(t2);
          }), this._gateway.on(dk.NETWORK_QUALITY, (e2) => {
            this._networkQualitySensitivity === "normal" && this.emit(wP.NETWORK_QUALITY, e2);
          }), this._gateway.on(dk.STREAM_TYPE_CHANGE, (e2, t2) => {
            this.emit(wP.STREAM_TYPE_CHANGED, e2, t2);
            bV.reportApiInvoke(this._sessionId, { name: fP.STREAM_TYPE_CHANGE, options: [e2, t2], tag: EP.TRACER }).onSuccess(JSON.stringify({ uid: e2, streamType: t2 }));
          }), this._gateway.on(dk.IS_P2P_DISCONNECTED, (e2) => {
            this._p2pChannel.isP2PDisconnected() ? e2(true) : this._p2pChannel.hasLocalMedia() || this._p2pChannel.hasRemoteMedia() ? e2(false) : e2(true);
          }), this._gateway.on(dk.NEED_RENEW_SESSION, () => {
            this._startSession();
          }), this._gateway.on(dk.REQUEST_P2P_CONNECTION_PARAMS, async (e2, t2, r2) => {
            try {
              t2(await this._p2pChannel.startP2PConnection(e2));
            } catch (e3) {
              r2(e3);
            }
          }), this._gateway.on(dk.JOIN_RESPONSE, (e2, t2, r2) => {
            const { dtlsParameters: i2, iceParameters: n2, candidates: o2, rtpCapabilities: s2, setup: a2, cname: c2 } = xZ(e2.ortc, t2, r2);
            this._p2pChannel.connect(n2, i2, o2, s2, a2, c2);
          }), this._gateway.signal.on(PP.ON_USER_ONLINE, this._handleUserOnline), this._gateway.signal.on(PP.ON_USER_OFFLINE, this._handleUserOffline), this._gateway.signal.on(PP.ON_ADD_AUDIO_STREAM, (e2) => this._handleAddAudioOrVideoStream("audio", e2.uid, e2.ssrcId, e2.cname, e2.uint_id, e2.ortc)), this._gateway.signal.on(PP.ON_ADD_VIDEO_STREAM, (e2) => this._handleAddAudioOrVideoStream("video", e2.uid, e2.ssrcId, e2.cname, e2.uint_id, e2.ortc, e2.rtxSsrcId)), this._gateway.signal.on(PP.ON_REMOVE_STREAM, this._handleRemoveStream), this._gateway.signal.on(PP.ON_P2P_LOST, this._handleP2PLost), this._gateway.signal.on(PP.MUTE_AUDIO, (e2) => (wD("debug", ["AgoraRTCGateway", this._clientId], "mute_audio", { uid: e2.uid }), this._handleMuteStream(e2.uid, "audio", true))), this._gateway.signal.on(PP.UNMUTE_AUDIO, (e2) => (wD("debug", ["AgoraRTCGateway", this._clientId], "unmute_audio", { uid: e2.uid }), this._handleMuteStream(e2.uid, "audio", false))), this._gateway.signal.on(PP.MUTE_VIDEO, (e2) => (wD("debug", ["AgoraRTCGateway", this._clientId], "mute_video", { uid: e2.uid }), this._handleMuteStream(e2.uid, "video", true))), this._gateway.signal.on(PP.UNMUTE_VIDEO, (e2) => (wD("debug", ["AgoraRTCGateway", this._clientId], "unmute_video", { uid: e2.uid }), this._handleMuteStream(e2.uid, "video", false))), this._gateway.signal.on(PP.RECEIVE_METADATA, (e2) => {
            const t2 = QG(e2.metadata);
            this.emit(wP.RECEIVE_METADATA, e2.uid, t2);
          }), this._gateway.signal.on(PP.ON_DATA_STREAM, (e2) => {
            e2.seq && delete e2.seq, e2.payload = QG(e2.payload), this.emit(wP.STREAM_MESSAGE, e2.uid, e2.payload), this.onStreamMessage && this.onStreamMessage(e2);
          }), this._gateway.signal.on(PP.ON_CRYPT_ERROR, () => {
            UG(() => {
              dD.warning("[".concat(this._clientId, "] on crypt error")), wD("warning", this, "crypt_error"), this.emit(wP.CRYPT_ERROR);
            }, this._sessionId);
          }), this._gateway.signal.on(PP.ON_TOKEN_PRIVILEGE_WILL_EXPIRE, this._handleTokenWillExpire), this._gateway.signal.on(PP.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
            dD.warning("[".concat(this._clientId, "] received message onTokenPrivilegeDidExpire, please get new token and join again")), wD("warning", this, "token_privilege_did_expire"), this._gateway.leave(true), this.emit(wP.ON_TOKEN_PRIVILEGE_DID_EXPIRE), this._reset();
          }), this._gateway.signal.on(PP.ON_STREAM_FALLBACK_UPDATE, (e2) => {
            dD.debug("[".concat(this._clientId, "] stream fallback peerId: ").concat(e2.stream_id, ", attr: ").concat(e2.stream_type)), wD("debug", this, "stream_fallback_update", { peerId: e2.stream_id, attr: e2.stream_type }), this.emit(wP.STREAM_FALLBACK, e2.stream_id, e2.stream_type === 1 ? "fallback" : "recover");
          }), this._gateway.signal.on(PP.ON_PUBLISH_STREAM, (e2) => {
            this.uid === this._uid && (this._p2pChannel.reportPublishEvent(true, null, void 0, false, JSON.stringify({ proxy: e2.proxy })), dD.info("[".concat(this._clientId, "] on publish stream, ").concat(JSON.stringify(e2))), wD("info", this, "publish_stream", e2));
          }), this._gateway.signal.on(PP.ENABLE_LOCAL_VIDEO, (e2) => {
            this._handleSetStreamLocalEnable("video", e2.uid, true);
          }), this._gateway.signal.on(PP.DISABLE_LOCAL_VIDEO, (e2) => {
            this._handleSetStreamLocalEnable("video", e2.uid, false);
          }), this._gateway.signal.on(NP.REQUEST_TIMEOUT, (e2, t2) => {
            if (this._joinInfo)
              switch (e2) {
                case DP.PUBLISH: {
                  if (!t2)
                    return;
                  const e3 = (t2 = t2).ortc;
                  if (e3) {
                    var r2, i2, n2, o2;
                    const s2 = e3.some((e4) => {
                      let { stream_type: t3 } = e4;
                      return t3 === ck.Audio;
                    }), a2 = e3.some((e4) => {
                      let { stream_type: t3 } = e4;
                      return t3 !== ck.Audio;
                    }), c2 = e3.some((e4) => {
                      let { stream_type: t3 } = e4;
                      return t3 === ck.Screen || t3 === ck.ScreenLow;
                    });
                    t2.state === "offer" && bV.publish(this._joinInfo.sid, { eventElapse: $j.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: false, ec: eD.TIMEOUT, audio: s2, video: a2, p2pid: t2.p2p_id, publishRequestid: this.store.pubId, screenshare: c2, audioName: s2 ? (r2 = e3.find((e4) => {
                      let { stream_type: t3 } = e4;
                      return t3 === ck.Audio;
                    })) === null || r2 === void 0 || (i2 = r2.ssrcs[0]) === null || i2 === void 0 ? void 0 : i2.ssrcId.toString() : void 0, videoName: a2 ? (n2 = e3.find((e4) => {
                      let { stream_type: t3 } = e4;
                      return t3 !== ck.Audio;
                    })) === null || n2 === void 0 || (o2 = n2.ssrcs[0]) === null || o2 === void 0 ? void 0 : o2.ssrcId.toString() : void 0 });
                  }
                  break;
                }
                case DP.SUBSCRIBE:
                  (t2 = t2) && bV.subscribe(this._joinInfo.sid, { succ: false, ec: eD.TIMEOUT, audio: t2.stream_type === yk.AUDIO, video: t2.stream_type === yk.VIDEO, peerid: t2.stream_id, subscribeRequestid: t2.ssrcId, p2pid: this.store.p2pId, eventElapse: $j.measureFromSubscribeStart(this.store.clientId, t2.ssrcId) });
              }
          }), this._gateway.signal.on(PP.ON_P2P_OK, (e2) => {
            this.uid, this._uid;
          }), this._gateway.signal.on(PP.ON_PUBLISHED_USER_LIST, (e2) => {
            if (e2 == null || !e2.users)
              return;
            const t2 = [], r2 = [];
            for (const i2 of e2.users) {
              let e3 = this._users.find((e4) => e4.uid === i2.stream_id);
              e3 ? e3._trust_in_room_ = true : (e3 = new iz(i2.stream_id, i2.stream_id), this._users.push(e3), this.getListeners(wP.PUBLISHED_USER_LIST).length === 0 && (dD.debug("[".concat(this._clientId, "] user online"), i2.stream_id), bD("info", this, "user-joined", { uid: i2.stream_id }), this.emit(wP.USER_JOINED, e3)));
              const n2 = uk.Audio & i2.stream_type, o2 = (uk.Video | uk.LwoVideo) & i2.stream_type, s2 = n2 && e3.hasAudio, a2 = o2 && e3.hasVideo;
              i2.stream_type !== uk.Nothing && (e3._trust_stream_added_state_ = true), o2 && (e3._video_added_ = true, e3._videoSSRC = i2.video_ssrc), n2 && (e3._audio_added_ = true, e3._audioSSRC = i2.audio_ssrc), n2 && !s2 && this.getListeners(wP.PUBLISHED_USER_LIST).length === 0 && (dD.info("[".concat(this._clientId, "] remote user ").concat(e3.uid, " published audio")), TD("info", this, "remote user ".concat(e3.uid, " published audio")), this.emit(wP.USER_PUBLISHED, e3, "audio")), o2 && !a2 && this.getListeners(wP.PUBLISHED_USER_LIST).length === 0 && (dD.info("[".concat(this._clientId, "] remote user ").concat(e3.uid, " published video")), TD("info", this, "remote user ".concat(e3.uid, " published video")), this.emit(wP.USER_PUBLISHED, e3, "video")), (n2 && !s2 || o2 && !a2) && t2.push(e3), o2 && this._p2pChannel.hasPendingRemoteMedia(e3, "video") && r2.push({ user: e3, mediaType: "video" }), n2 && this._p2pChannel.hasPendingRemoteMedia(e3, "audio") && r2.push({ user: e3, mediaType: "audio" });
            }
            r2.length > 0 && (dD.debug("[".concat(this._clientId, "] RE massSubscribe after reconnect ").concat(r2.map((e3) => "user: ".concat(e3.user.uid, ", mediaType: ").concat(e3.mediaType)).join("; "), " ")), this.massSubscribe(r2).catch((e3) => {
              dD.error("[".concat(this._clientId, "] mass resubscribe error"), e3.toString());
            })), this.getListeners(wP.PUBLISHED_USER_LIST).length > 0 ? (dD.info("[".concat(this._clientId, "] client emit user-list event, users: ").concat(t2.map((e3) => e3.uid).join(", "))), this.emit(wP.PUBLISHED_USER_LIST, t2)) : dD.info("[".concat(this._clientId, "] client not emit user-list event case there is no user-list listener, users: ").concat(t2.map((e3) => e3.uid).join(", ")));
          });
        }
        _handleP2PChannelEvents() {
          this._p2pChannel.on(bk.RequestMuteLocal, async (e2, t2, r2) => {
            if (this._joinInfo)
              try {
                await this._gateway.muteLocal(e2, this._joinInfo.stringUid || this._joinInfo.uid), t2();
              } catch (e3) {
                e3.code === eD.DISCONNECT_P2P ? t2() : r2(e3);
              }
            else
              t2();
          }), this._p2pChannel.on(bk.RequestUnmuteLocal, async (e2, t2, r2) => {
            if (this._joinInfo)
              try {
                await this._gateway.unmuteLocal(e2, this._joinInfo.stringUid || this._joinInfo.uid), t2();
              } catch (e3) {
                e3.code === eD.DISCONNECT_P2P ? t2() : r2(e3);
              }
            else
              t2();
          }), this._p2pChannel.on(bk.RequestRePublish, (e2, t2, r2) => {
            this.publish(e2, false).then(t2).catch(r2);
          }), this._p2pChannel.on(bk.RequestReSubscribe, async (e2, t2, r2) => {
            try {
              for (const { user: t3, kind: r3 } of e2)
                r3 === yk.VIDEO ? await this.subscribe(t3, "video") : await this.subscribe(t3, "audio");
              t2();
            } catch (e3) {
              r2(e3);
            }
          }), this._p2pChannel.on(bk.RequestUploadStats, (e2, t2) => {
            this._gateway.uploadStats(e2, t2);
          }), this._p2pChannel.on(bk.MediaReconnectStart, (e2) => {
            this.emit(wP.MEDIA_RECONNECT_START, e2);
          }), this._p2pChannel.on(bk.MediaReconnectEnd, (e2) => {
            this.emit(wP.MEDIA_RECONNECT_END, e2);
          }), this._p2pChannel.on(bk.NeedSignalRTT, (e2) => {
            e2(this._gateway.getSignalRTT());
          }), this._p2pChannel.on(bk.RequestRestartICE, async () => {
            const e2 = await this._p2pChannel.reEstablish();
            if (e2) {
              const { restartICEResponse: t2, gatewayIP: r2, gatewayPort: i2 } = await this._gateway.restartICE({ iceParameters: e2.iceParameters }), { candidates: n2, iceParameters: o2 } = function(e3, t3, r3) {
                const i3 = e3.ice;
                let n3;
                return t3 !== void 0 && r3 !== void 0 ? (n3 = [{ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t3, port: r3.toString(), type: "host", extension: {} }], dD.debug("Using remote candidate from AP ".concat(t3, ":").concat(r3)), TD("debug", [], "Using remote candidate from AP ".concat(t3, ":").concat(r3))) : n3 = i3.candidates.map((e4) => ({ foundation: e4.foundation, componentId: "1", transport: e4.protocol, priority: e4.priority.toString(), connectionAddress: e4.ip, port: e4.port.toString(), type: e4.type, extension: {} })), { candidates: n3, iceParameters: { iceUfrag: i3.iceUfrag, icePwd: i3.icePwd } };
              }(t2, r2, i2);
              await e2.restartICE(o2, n2);
            }
          }), this._p2pChannel.on(bk.RequestReconnect, async () => {
            this._gateway.reconnect();
          }), this._p2pChannel.on(bk.RequestReconnectPC, async () => {
            var e2;
            const { iceParameters: t2, dtlsParameters: r2, rtpCapabilities: i2 } = await this._p2pChannel.startP2PConnection({ turnServer: (e2 = this._joinInfo) === null || e2 === void 0 ? void 0 : e2.turnServer }), { gatewayEstablishParams: n2, gatewayIP: o2, gatewayPort: s2 } = await this._gateway.reconnectPC({ iceParameters: t2, dtlsParameters: r2, rtpCapabilities: i2 }), { dtlsParameters: a2, iceParameters: c2, candidates: d2, rtpCapabilities: u2, setup: A2, cname: h2 } = xZ(n2, o2, s2);
            await this._p2pChannel.connect(c2, a2, d2, u2, A2, h2), await this._p2pChannel.republish(), await this._p2pChannel.reSubscribe();
          }), this._p2pChannel.on(bk.RequestUnpublishForReconnectPC, async (e2, t2, r2) => {
            this._joinInfo && this._uid !== void 0 ? (await this._gateway.unpublish(e2, this._uid), t2()) : r2();
          }), this._p2pChannel.on(bk.P2PLost, () => {
            this.emit(wP.P2P_LOST, this.store.uid);
          }), this._p2pChannel.on(bk.UpdateVideoEncoder, (e2) => {
            e2._encoderConfig && this._gateway.setVideoProfile(e2._encoderConfig);
          }), this._p2pChannel.on(bk.ConnectionTypeChange, (e2) => {
            this.emit(wP.IS_USING_CLOUD_PROXY, e2);
          });
        }
        getKeyMetrics() {
          return this.store.keyMetrics;
        }
        getJoinChannelServiceRecords() {
          return dD.debug("getJoinChannelServiceRecords"), this.store.joinChannelServiceRecords;
        }
      }).prototype, "setProxyServer", [A1], Object.getOwnPropertyDescriptor(m1.prototype, "setProxyServer"), m1.prototype), zF(m1.prototype, "setTurnServer", [h1], Object.getOwnPropertyDescriptor(m1.prototype, "setTurnServer"), m1.prototype), zF(m1.prototype, "setLocalAccessPoints", [l1], Object.getOwnPropertyDescriptor(m1.prototype, "setLocalAccessPoints"), m1.prototype), zF(m1.prototype, "setRemoteDefaultVideoStreamType", [p1], Object.getOwnPropertyDescriptor(m1.prototype, "setRemoteDefaultVideoStreamType"), m1.prototype), zF(m1.prototype, "setEncryptionConfig", [g1], Object.getOwnPropertyDescriptor(m1.prototype, "setEncryptionConfig"), m1.prototype), zF(m1.prototype, "pickSVCLayer", [f1], Object.getOwnPropertyDescriptor(m1.prototype, "pickSVCLayer"), m1.prototype), zF(m1.prototype, "getJoinChannelServiceRecords", [E1], Object.getOwnPropertyDescriptor(m1.prototype, "getJoinChannelServiceRecords"), m1.prototype), I1 = m1)) || I1);
      class S1 extends qV {
        set currentState(e2) {
          e2 !== this._currentState && (this._currentState = e2, this.emit(BP.AUDIO_SOURCE_STATE_CHANGE, this._currentState));
        }
        get currentState() {
          return this._currentState;
        }
        constructor(e2) {
          let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          super(), kO(this, "audioBuffer", void 0), kO(this, "sourceNode", void 0), kO(this, "startPlayTime", 0), kO(this, "startPlayOffset", 0), kO(this, "pausePlayTime", 0), kO(this, "options", void 0), kO(this, "currentLoopCount", 0), kO(this, "_currentState", "stopped"), this.audioBuffer = e2, this.options = t2, this.startPlayOffset = this.options.startPlayTime || 0;
        }
        createWebAudioDiagram() {
          return this.context.createGain();
        }
        get duration() {
          return this.audioBuffer.duration;
        }
        get currentTime() {
          return this.currentState === "stopped" ? 0 : this.currentState === "paused" ? this.pausePlayTime : (this.context.currentTime - this.startPlayTime + this.startPlayOffset) % this.audioBuffer.duration;
        }
        updateOptions(e2) {
          this.currentState === "stopped" ? (this.options = e2, this.startPlayOffset = this.options.startPlayTime || 0) : dD.warning("can not set audio source options");
        }
        startProcessAudioBuffer() {
          this.sourceNode && this.stopProcessAudioBuffer(), this.sourceNode = this.createSourceNode(), this.startSourceNode(), this.currentState = "playing";
        }
        pauseProcessAudioBuffer() {
          this.sourceNode && this.currentState === "playing" && (this.pausePlayTime = this.currentTime, this.sourceNode.onended = null, this.sourceNode.stop(), this.sourceNode.buffer = null, this.sourceNode = this.createSourceNode(), this.currentState = "paused");
        }
        seekAudioBuffer(e2) {
          this.sourceNode && (this.sourceNode.onended = null, this.currentState === "playing" && this.sourceNode.stop(), this.sourceNode = this.createSourceNode(), this.currentState === "playing" ? (this.startPlayOffset = e2, this.startSourceNode()) : this.currentState === "paused" && (this.pausePlayTime = e2));
        }
        resumeProcessAudioBuffer() {
          this.currentState === "paused" && this.sourceNode && (this.startPlayOffset = this.pausePlayTime, this.pausePlayTime = 0, this.startSourceNode(), this.currentState = "playing");
        }
        stopProcessAudioBuffer() {
          if (this.sourceNode) {
            this.sourceNode.onended = null;
            try {
              this.sourceNode.stop();
            } catch (e2) {
            }
            this.reset();
          }
        }
        startSourceNode() {
          this.sourceNode && this.sourceNode.buffer && (this.sourceNode.start(0, this.startPlayOffset), this.startPlayTime = this.context.currentTime, this.sourceNode.onended = this.handleSourceNodeEnded.bind(this));
        }
        createSourceNode() {
          const e2 = this.context.createBufferSource();
          return e2.buffer = this.audioBuffer, e2.loop = !!this.options.loop, e2.connect(this.outputNode), e2;
        }
        handleSourceNodeEnded() {
          if (this.currentLoopCount += 1, this.options.cycle && this.options.cycle > this.currentLoopCount)
            return this.startPlayOffset = 0, this.sourceNode = void 0, void this.startProcessAudioBuffer();
          this.reset();
        }
        reset() {
          this.startPlayOffset = this.options.startPlayTime || 0, this.currentState = "stopped", this.sourceNode && (this.sourceNode.disconnect(), this.sourceNode = void 0), this.currentLoopCount = 0;
        }
      }
      const R1 = /* @__PURE__ */ new Map();
      async function y1(e2, t2) {
        let r2 = null;
        if (typeof e2 == "string") {
          const t3 = R1.get(e2);
          if (t3)
            return dD.debug("use cached audio resource: ", e2), t3;
          try {
            r2 = (await nD(() => zN.get(e2, { responseType: "arraybuffer" }), void 0, void 0, { maxRetryCount: 3 })).data;
          } catch (e3) {
            throw new tD(eD.FETCH_AUDIO_FILE_FAILED, e3.toString());
          }
        } else {
          const t3 = new nR((t4, r3) => {
            const i3 = new FileReader();
            i3.onload = (e3) => {
              e3.target ? t4(e3.target.result) : r3(new tD(eD.READ_LOCAL_AUDIO_FILE_ERROR));
            }, i3.onerror = () => {
              r3(new tD(eD.READ_LOCAL_AUDIO_FILE_ERROR));
            }, i3.readAsArrayBuffer(e2);
          });
          r2 = await t3;
        }
        const i2 = await function(e3) {
          const t3 = GV();
          return new nR((r3, i3) => {
            t3.decodeAudioData(e3, (e4) => {
              r3(e4);
            }, (e4) => {
              i3(new tD(eD.DECODE_AUDIO_FILE_FAILED, e4.toString()));
            });
          });
        }(r2);
        return typeof e2 == "string" && t2 && R1.set(e2, i2), i2;
      }
      function T1(e2, t2) {
        var r2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var i2 = Object.getOwnPropertySymbols(e2);
          t2 && (i2 = i2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), r2.push.apply(r2, i2);
        }
        return r2;
      }
      function w1(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r2 = arguments[t2] != null ? arguments[t2] : {};
          t2 % 2 ? T1(Object(r2), true).forEach(function(t3) {
            kO(e2, t3, r2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : T1(Object(r2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
          });
        }
        return e2;
      }
      function b1(e2, t2, r2, i2) {
        r2.optimizationMode && (i2 && i2.width && i2.height ? (r2.encoderConfig = w1(w1({}, i2), {}, { bitrateMin: i2.bitrateMin, bitrateMax: i2.bitrateMax }), r2.optimizationMode !== "motion" && r2.optimizationMode !== "detail" || (t2.contentHint = r2.optimizationMode, t2.contentHint === r2.optimizationMode ? (dD.debug("[".concat(e2, "] set content hint to"), r2.optimizationMode), LD("debug", ["AgoraRTC"], "videoTrackOptimizationModeProcess", [e2, r2, i2])) : (dD.debug("[".concat(e2, "] set content hint failed")), LD("warning", ["AgoraRTC"], "videoTrackOptimizationModeProcess", [e2, r2, i2], "failed")))) : (dD.warning("[".concat(e2, "] can not apply optimization mode bitrate config, no encoderConfig")), TD("warning", ["AgoraRTC"], "[".concat(e2, "] can not apply optimization mode bitrate config, no encoderConfig"))));
      }
      const O1 = oO().name;
      function N1(e2, t2, r2, i2) {
        let n2, o2 = 0, s2 = null;
        return new nR((a2, c2) => {
          setTimeout(() => {
            n2 && (n2(), a2(o2));
          }, t2), n2 = YV(() => {
            !function() {
              o2 > i2 && n2 && (n2(), a2(o2));
              const t3 = r2.getContext("2d");
              if (!t3) {
                const e3 = new tD(eD.UNEXPECTED_ERROR, "can not get canvas 2d context.");
                return dD.error(e3.toString()), void c2(e3);
              }
              t3.drawImage(e2, 0, 0, 160, 120);
              const d2 = t3.getImageData(0, 0, r2.width, r2.height), u2 = Math.floor(d2.data.length / 3);
              if (s2) {
                for (let e3 = 0; e3 < u2; e3 += 3)
                  if (d2.data[e3] !== s2[e3])
                    return o2 += 1, void (s2 = d2.data);
                s2 = d2.data;
              } else
                s2 = d2.data;
            }();
          }, 30);
        });
      }
      class D1 {
        constructor(e2, t2) {
          kO(this, "id", 0), kO(this, "element", void 0), kO(this, "peerPair", void 0), kO(this, "context", void 0), kO(this, "audioPlayerElement", void 0), kO(this, "audioTrack", void 0), D1.count += 1, this.id = D1.count, this.element = e2, this.context = t2;
        }
        initPeers() {
          this.peerPair = [new RTCPeerConnection(), new RTCPeerConnection()], this.peerPair[1].ontrack = (e2) => {
            const t2 = document.createElement("audio");
            t2.srcObject = new MediaStream([e2.track]), t2.play(), this.audioPlayerElement = t2;
          };
        }
        async switchSdp() {
          if (!this.peerPair)
            return;
          const e2 = async (e3, t3) => {
            const r2 = t3 === "offer" ? await e3.createOffer() : await e3.createAnswer();
            return await e3.setLocalDescription(r2), e3.iceGatheringState === "complete" ? e3.localDescription : new nR((t4) => {
              e3.onicegatheringstatechange = () => {
                e3.iceGatheringState === "complete" && t4(e3.localDescription);
              };
            });
          }, t2 = async (e3, t3) => await e3.setRemoteDescription(t3);
          try {
            const r2 = await e2(this.peerPair[0], "offer");
            await t2(this.peerPair[1], r2);
            const i2 = await e2(this.peerPair[1], "answer");
            await t2(this.peerPair[0], i2);
          } catch (e3) {
            throw new tD(eD.LOCAL_AEC_ERROR, e3.toString()).print();
          }
        }
        async getTracksFromMediaElement(e2) {
          if (this.audioTrack)
            return this.audioTrack;
          let t2;
          try {
            e2 instanceof HTMLVideoElement && (e2.captureStream ? e2.captureStream() : e2.mozCaptureStream()), t2 = this.context.createMediaStreamDestination();
            this.context.createMediaElementSource(e2).connect(t2);
          } catch (e3) {
            throw new tD(eD.LOCAL_AEC_ERROR, e3.toString()).print();
          }
          if (!t2) {
            throw new tD(eD.LOCAL_AEC_ERROR, "no dest node when local aec").print();
          }
          const r2 = t2.stream.getAudioTracks()[0];
          return this.audioTrack = r2, r2;
        }
        getElement() {
          return this.element;
        }
        async startEchoCancellation() {
          this.context.resume(), this.peerPair && this.close(), this.initPeers();
          const e2 = this.element, t2 = await this.getTracksFromMediaElement(e2);
          this.peerPair && this.peerPair[0].addTrack(t2), await this.switchSdp();
        }
        close() {
          dD.debug("close echo cancellation unit, id is", this.id), this.audioPlayerElement && this.audioPlayerElement.pause(), this.peerPair && this.peerPair.forEach((e2) => {
            e2.close();
          }), this.peerPair = void 0, this.audioPlayerElement = void 0;
        }
      }
      var L1, P1;
      kO(D1, "count", 0);
      const k1 = window.AudioContext || window.webkitAudioContext;
      const B1 = new (L1 = TV({ report: bV }), zF((P1 = class {
        constructor() {
          kO(this, "units", []), kO(this, "context", void 0);
        }
        processExternalMediaAEC(e2) {
          if (!this._doesEnvironmentNeedAEC())
            return dD.debug("the system does not need to process local aec"), -1;
          this.context || (this.context = new k1());
          let t2 = this.units.find((t3) => t3 && t3.getElement() === e2);
          return t2 || (t2 = new D1(e2, this.context), this.units.push(t2)), t2.startEchoCancellation(), dD.debug("start processing local audio echo cancellation, id is", t2.id), t2.id;
        }
        _doesEnvironmentNeedAEC() {
          return oO().name !== tO.SAFARI;
        }
      }).prototype, "processExternalMediaAEC", [L1], Object.getOwnPropertyDescriptor(P1.prototype, "processExternalMediaAEC"), P1.prototype), P1)();
      WD("PROCESS_ID", "process-".concat(SG(8, ""), "-").concat(SG(4, ""), "-").concat(SG(4, ""), "-").concat(SG(4, ""), "-").concat(SG(12, ""))), function() {
        const e2 = oO();
        Bk.getDisplayMedia = function(e3) {
          if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia)
            return true;
          return false;
        }(), Bk.getStreamFromExtension = e2.name === tO.CHROME && Number(e2.version) > 34, Bk.supportUnifiedPlan = function() {
          if (!window.RTCRtpTransceiver)
            return false;
          if (!("currentDirection" in RTCRtpTransceiver.prototype))
            return false;
          const e3 = new RTCPeerConnection();
          let t2 = false;
          try {
            e3.addTransceiver("audio"), t2 = true;
          } catch (e4) {
          }
          return e3.close(), t2;
        }(), Bk.supportMinBitrate = e2.name === tO.CHROME || e2.name === tO.EDGE, Bk.supportSetRtpSenderParameters = function() {
          const e3 = oO();
          if (!window.RTCRtpSender || !window.RTCRtpSender.prototype.setParameters || !window.RTCRtpSender.prototype.getParameters)
            return false;
          return !!yO() || (!(!pO() && !uO()) || e3.name === tO.FIREFOX && Number(e3.version) >= 64);
        }(), e2.name === tO.SAFARI && (Number(e2.version) >= 14 ? Bk.supportDualStream = true : Bk.supportDualStream = false), Bk.webAudioMediaStreamDest = function() {
          const e3 = oO();
          if (e3.name === tO.SAFARI && Number(e3.version) < 12)
            return false;
          return true;
        }(), Bk.supportReplaceTrack = function() {
          if (!window.RTCRtpSender)
            return false;
          if (typeof RTCRtpSender.prototype.replaceTrack == "function")
            return true;
          return false;
        }(), Bk.supportWebGL = typeof WebGLRenderingContext != "undefined", Bk.supportRequestFrame = !!window.CanvasCaptureMediaStreamTrack, yO() || (Bk.webAudioWithAEC = true), Bk.supportShareAudio = function() {
          const e3 = oO();
          if ((e3.os === eO.WIN_10 || e3.os === eO.WIN_81 || e3.os === eO.WIN_7 || e3.os === eO.LINUX || e3.os === eO.MAC_OS) && e3.name === tO.CHROME && Number(e3.version) >= 74)
            return true;
          return false;
        }(), Bk.supportDualStreamEncoding = function() {
          const e3 = oO();
          return e3.name === "Safari" && Number(e3.version) >= 14;
        }(), dD.info("browser compatibility", JSON.stringify(Bk), JSON.stringify(e2)), ND("info", [], "updateAgoraRTCCompatibility", { browserCompatibility: Bk, browserInfo: e2 });
      }(), function() {
        let e2;
        try {
          e2 = window.localStorage.getItem("websdk_ng_global_parameter");
        } catch (e3) {
          return void dD.error("Error loading sdk config", e3.message);
        }
        if (e2)
          try {
            const t2 = JSON.parse(window.atob(e2)), r2 = Date.now();
            dD.debug("Loading global parameters from cache", t2), ND("debug", [], "loadConfigFromLocalStorage", t2), Object.keys(t2).forEach((e3) => {
              if (Object.prototype.hasOwnProperty.call(qD, e3)) {
                const { value: i2, expires: n2 } = t2[e3];
                if (n2 && n2 <= r2)
                  return;
                zD[e3] = i2, qD[e3] = i2;
              }
            });
          } catch (t2) {
            dD.error("Error loading mutableParamsCache: ".concat(e2), t2.message);
          }
      }();
      const M1 = { __CLIENT_LIST__: rL, __TRACK_LIST__: iL, VERSION: MD, BUILD: BD, setParameter: WD, getParameter: JD, getSupportedCodec: async function() {
        let e2 = { audio: [], video: [] };
        try {
          let t2 = new RTCPeerConnection();
          t2.addTransceiver("video", { direction: "recvonly" }), t2.addTransceiver("audio", { direction: "recvonly" });
          const r2 = (await t2.createOffer()).sdp;
          if (!r2)
            return e2;
          t2.close(), t2 = null, e2 = function(e3) {
            const t3 = { video: [], audio: [] };
            return e3.match(/ VP8/i) && t3.video.push("VP8"), e3.match(/ VP9/i) && t3.video.push("VP9"), e3.match(/ AV1/i) && t3.video.push("AV1"), e3.match(/ H264/i) && t3.video.push("H264"), e3.match(/ opus/i) && t3.audio.push("OPUS"), e3.match(/ PCMU/i) && t3.audio.push("PCMU"), e3.match(/ PCMA/i) && t3.audio.push("PCMA"), e3.match(/ G722/i) && t3.audio.push("G722"), t3;
          }(r2);
        } catch (e3) {
          throw new tD(eD.CREATE_OFFER_FAILED, e3.toString && e3.toString()).print();
        }
        return e2;
      }, checkSystemRequirements: function() {
        const e2 = bV.reportApiInvoke(null, { name: fP.CHECK_SYSTEM_REQUIREMENTS, options: [], tag: EP.TRACER });
        let t2 = false;
        try {
          const e3 = window.RTCPeerConnection, r3 = navigator.mediaDevices && navigator.mediaDevices.getUserMedia, i3 = window.WebSocket;
          t2 = !!(e3 && r3 && i3);
        } catch (e3) {
          return dD.error("check system requirement failed: ", e3), false;
        }
        let r2 = false;
        const i2 = oO();
        i2.name === tO.CHROME && Number(i2.version) >= 58 && (!hO() || AO()) && (r2 = true), i2.name === tO.FIREFOX && Number(i2.version) >= 56 && (r2 = true), i2.name === tO.OPERA && Number(i2.version) >= 45 && (r2 = true), i2.name === tO.SAFARI && Number(i2.version) >= 11 && (r2 = true), (SO() || oO().name === tO.QQ) && (r2 = true), dD.debug("checkSystemRequirements, api:", t2, "browser", r2);
        const n2 = t2 && r2;
        return e2.onSuccess(n2), n2;
      }, getDevices: function(e2) {
        return dj.enumerateDevices(true, true, e2);
      }, getMicrophones: function(e2) {
        return dj.getRecordingDevices(e2);
      }, getCameras: function(e2) {
        return dj.getCamerasDevices(e2);
      }, getElectronScreenSources: $V, getPlaybackDevices: function(e2) {
        return dj.getSpeakers(e2);
      }, createClient: function() {
        let e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { codec: "vp8", audioCodec: "opus", mode: "rtc" };
        const t2 = bV.reportApiInvoke(null, { name: fP.CREATE_CLIENT, options: [e2], tag: EP.TRACER });
        try {
          UP(e2);
        } catch (e3) {
          throw t2.onError(e3), e3;
        }
        return e2.audioCodec === void 0 && (e2.audioCodec = "opus"), t2.onSuccess(), new v1(C1(C1({ forceWaitGatewayResponse: true }, e2), {}, { role: e2.mode === "rtc" ? "host" : e2.role }));
      }, createCameraVideoTrack: async function() {
        let e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { encoderConfig: "480p_1" };
        const t2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.CREATE_CAM_VIDEO_TRACK, options: [w1({}, e2)] }), r2 = vq(e2), i2 = SG(8, "track-cam-");
        let n2 = null;
        dD.info("start create camera video track with config", JSON.stringify(e2), "trackId", i2), LD("info", ["AgoraRTC"], "createCameraVideoTrack", e2);
        try {
          n2 = (await oj({ video: r2 }, i2)).getVideoTracks()[0] || null;
        } catch (e3) {
          throw t2.onError(e3), e3;
        }
        if (!n2) {
          const e3 = new tD(eD.UNEXPECTED_ERROR, "can not find track in media stream");
          return t2.onError(e3), e3.throw();
        }
        e2.optimizationMode && b1(i2, n2, e2, e2.encoderConfig && jD(e2.encoderConfig));
        const o2 = new ez(n2, e2, r2, e2.scalabiltyMode ? KD(e2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e2.optimizationMode, i2);
        return t2.onSuccess(o2.getTrackId()), dD.info("create camera video success, trackId:", i2), LD("info", ["AgoraRTC"], "createCameraVideoTrack", void 0, i2), o2;
      }, createCustomVideoTrack: function(e2) {
        const t2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.CREATE_CUSTOM_VIDEO_TRACK, options: [e2] }), r2 = new $q(e2.mediaStreamTrack, { bitrateMax: e2.bitrateMax, bitrateMin: e2.bitrateMin }, e2.scalabiltyMode ? KD(e2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e2.optimizationMode);
        return t2.onSuccess(r2.getTrackId()), dD.info("create custom video track success with config", e2, "trackId", r2.getTrackId()), LD("info", ["AgoraRTC"], "createCustomVideoTrack", e2, r2.getTrackId()), r2;
      }, createScreenVideoTrack: async function() {
        let e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "disable";
        const r2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.CREATE_SCREEN_VIDEO_TRACK, options: [w1({}, e2), t2] });
        e2.encoderConfig ? typeof e2.encoderConfig == "string" || e2.encoderConfig.width && e2.encoderConfig.height || (e2.encoderConfig.width = { max: 1920 }, e2.encoderConfig.height = { max: 1080 }) : e2.encoderConfig = "1080p_2";
        const i2 = Sq(e2), n2 = SG(8, "track-scr");
        let o2 = null, s2 = null;
        const a2 = Mk();
        if (!a2.supportShareAudio && t2 === "enable") {
          const e3 = new tD(eD.NOT_SUPPORTED, "your browser or platform is not support share-screen with audio");
          return r2.onError(e3), e3.throw();
        }
        dD.info("start create screen video track with config", e2, "withAudio", t2, "trackId", n2), LD("info", ["AgoraRTC"], "createScreenVideoTrack", [e2, t2]);
        try {
          const e3 = await oj({ screen: i2, screenAudio: t2 === "auto" ? a2.supportShareAudio : t2 === "enable" }, n2);
          o2 = e3.getVideoTracks()[0] || null, s2 = e3.getAudioTracks()[0] || null;
        } catch (e3) {
          throw r2.onError(e3), e3;
        }
        if (!o2) {
          const e3 = new tD(eD.UNEXPECTED_ERROR, "can not find track in media stream");
          return r2.onError(e3), e3.throw();
        }
        if (!s2 && t2 === "enable") {
          o2 && o2.stop();
          const e3 = new tD(eD.SHARE_AUDIO_NOT_ALLOWED);
          return r2.onError(e3), e3.throw();
        }
        e2.optimizationMode || (e2.optimizationMode = "detail"), e2.optimizationMode && (b1(n2, o2, e2, e2.encoderConfig && GD(e2.encoderConfig)), e2.encoderConfig && typeof e2.encoderConfig != "string" && (e2.encoderConfig.bitrateMin = e2.encoderConfig.bitrateMax));
        const c2 = new $q(o2, e2.encoderConfig ? GD(e2.encoderConfig) : {}, e2.scalabiltyMode ? KD(e2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e2.optimizationMode, n2, [hk.SCREEN_TRACK]);
        if (!s2)
          return r2.onSuccess(c2.getTrackId()), dD.info("create screen video track success", "video:", c2.getTrackId()), LD("info", ["AgoraRTC"], "createScreenVideoTrack", void 0, { videoTrack: c2.getTrackId() }), c2;
        const d2 = new Hj(s2);
        return r2.onSuccess([c2.getTrackId(), d2.getTrackId()]), dD.info("create screen video track success", "video:", c2.getTrackId(), "audio:", d2.getTrackId()), LD("info", ["AgoraRTC"], "createScreenVideoTrack", void 0, { videoTrack: c2.getTrackId(), audioTrack: d2.getTrackId() }), [c2, d2];
      }, createMicrophoneAndCameraTracks: async function() {
        let e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { encoderConfig: "480p_1" };
        const r2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.CREATE_MIC_AND_CAM_TRACKS, options: [e2, t2] }), i2 = vq(t2), n2 = Rq(e2), o2 = SG(8, "track-mic-"), s2 = SG(8, "track-cam-");
        let a2 = null, c2 = null;
        dD.info("start create camera video track(".concat(s2, ") and microphone audio track(").concat(o2, ") with config, audio: ").concat(JSON.stringify(e2), ", video: ").concat(JSON.stringify(t2))), LD("info", ["AgoraRTC"], "createMicrophoneAndCameraTracks", { videoConfig: t2, audioConfig: e2 });
        try {
          const e3 = await oj({ audio: n2, video: i2 }, "".concat(o2, "-").concat(s2));
          a2 = e3.getAudioTracks()[0], c2 = e3.getVideoTracks()[0];
        } catch (e3) {
          throw r2.onError(e3), e3;
        }
        if (!a2 || !c2) {
          const e3 = new tD(eD.UNEXPECTED_ERROR, "can not find tracks in media stream");
          return r2.onError(e3), e3.throw();
        }
        t2.optimizationMode && b1(s2, c2, t2, t2.encoderConfig && jD(t2.encoderConfig));
        const d2 = new Yj(a2, e2, n2, o2), u2 = new ez(c2, t2, i2, t2.scalabiltyMode ? KD(t2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, t2.optimizationMode, s2);
        return r2.onSuccess([d2.getTrackId(), u2.getTrackId()]), dD.info("create camera video track(".concat(s2, ") and microphone audio track(").concat(o2, ") success")), LD("info", ["AgoraRTC"], "createMicrophoneAndCameraTracks", void 0, { videoTrackId: s2, audioTrackId: o2 }), [d2, u2];
      }, createMicrophoneAudioTrack: async function() {
        let e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const t2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.CREATE_MIC_AUDIO_TRACK, options: [e2] }), r2 = Rq(e2), i2 = SG(8, "track-mic-");
        let n2 = null;
        dD.info("start create microphone audio track with config", JSON.stringify(e2), "trackId", i2), LD("info", ["AgoraRTC"], "createMicrophoneAudioTrack", e2);
        try {
          n2 = (await oj({ audio: r2 }, i2)).getAudioTracks()[0] || null;
        } catch (e3) {
          throw t2.onError(e3), e3;
        }
        if (!n2) {
          const e3 = new tD(eD.UNEXPECTED_ERROR, "can not find track in media stream");
          return t2.onError(e3), e3.throw();
        }
        const o2 = new Yj(n2, e2, r2, i2);
        return t2.onSuccess(o2.getTrackId()), dD.info("create microphone audio track success, trackId:", i2), LD("info", ["AgoraRTC"], "createMicrophoneAudioTrack", e2, i2), o2;
      }, createCustomAudioTrack: function(e2) {
        const t2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.CREATE_CUSTOM_AUDIO_TRACK, options: [e2] }), r2 = new Hj(e2.mediaStreamTrack, e2.encoderConfig ? YD(e2.encoderConfig) : {});
        return dD.info("create custom audio track success with config", e2, "trackId", r2.getTrackId()), LD("info", ["AgoraRTC"], "createCustomAudioTrack", e2, r2.getTrackId()), t2.onSuccess(r2.getTrackId()), r2;
      }, createBufferSourceAudioTrack: async function(e2) {
        const t2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.CREATE_BUFFER_AUDIO_TRACK, options: [e2] }), r2 = SG(8, "track-buf-");
        dD.info("start create buffer source audio track with config", JSON.stringify(e2), "trackId", r2), LD("info", [], "createBufferSourceAudioTrack", e2);
        const i2 = e2.source;
        if (!(e2.source instanceof AudioBuffer))
          try {
            e2.source = await y1(e2.source, e2.cacheOnlineFile);
          } catch (e3) {
            return t2.onError(e3), e3.throw();
          }
        const n2 = new S1(e2.source), o2 = new Wj(i2, n2, e2.encoderConfig ? YD(e2.encoderConfig) : {}, r2);
        return dD.info("create buffer source audio track success, trackId:", r2), LD("info", ["AgoraRTC"], "createBufferSourceAudioTrack", void 0, r2), t2.onSuccess(o2.getTrackId()), o2;
      }, setLogLevel: function(e2) {
        JD("USE_NEW_LOG") ? function(e3) {
          e3 = Math.min(Math.max(0, e3), 4), fD = e3;
        }(e2) : dD.setLogLevel(e2);
      }, enableLogUpload: function() {
        JD("USE_NEW_LOG") ? WD("UPLOAD_LOG", true) : dD.enableLogUpload();
      }, disableLogUpload: function() {
        JD("USE_NEW_LOG") ? WD("UPLOAD_LOG", false) : dD.disableLogUpload();
      }, createChannelMediaRelayConfiguration: function() {
        return new YJ();
      }, checkAudioTrackIsActive: async function(e2) {
        let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5e3;
        const r2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.CHECK_AUDIO_TRACK_IS_ACTIVE, options: [t2] });
        if (!(e2 instanceof Hj || e2 instanceof M$)) {
          const e3 = new tD(eD.INVALID_TRACK, "the parameter is not a audio track");
          return r2.onError(e3), e3.throw();
        }
        t2 && t2 < 1e3 && (t2 = 1e3);
        const i2 = e2 instanceof Hj ? e2.getTrackLabel() : "remote_track", n2 = e2.getVolumeLevel();
        let o2 = n2, s2 = n2;
        const a2 = Date.now();
        return new nR((n3) => {
          const c2 = setInterval(() => {
            const d2 = e2.getVolumeLevel();
            o2 = d2 > o2 ? d2 : o2, s2 = d2 < s2 ? d2 : s2;
            const u2 = o2 - s2 > 1e-4, A2 = Date.now() - a2;
            if (u2 || A2 > t2) {
              clearInterval(c2);
              const t3 = u2, s3 = { duration: A2, deviceLabel: i2, maxVolumeLevel: o2, result: t3 };
              dD.info("[track-".concat(e2.getTrackId(), "] check audio track active completed. ").concat(JSON.stringify(s3))), r2.onSuccess(s3), n3(t3);
            }
          }, 200);
        });
      }, checkVideoTrackIsActive: async function(e2) {
        let t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5e3;
        const r2 = bV.reportApiInvoke(null, { tag: EP.TRACER, name: fP.CHECK_VIDEO_TRACK_IS_ACTIVE, options: [t2] });
        if (!(e2 instanceof $q || e2 instanceof B$)) {
          const e3 = new tD(eD.INVALID_TRACK, "the parameter is not a video track");
          return r2.onError(e3), e3.throw();
        }
        const i2 = 4;
        t2 && t2 < 1e3 && (t2 = 1e3);
        const n2 = e2 instanceof $q ? e2.getTrackLabel() : "remote_track", o2 = e2.getMediaStreamTrack(true), s2 = document.createElement("video");
        s2.style.width = "1px", s2.style.height = "1px", s2.setAttribute("muted", ""), s2.muted = true, s2.setAttribute("playsinline", ""), s2.controls = false, (pO() || uO()) && (s2.style.opacity = "0.01", s2.style.position = "fixed", s2.style.left = "0", s2.style.top = "0", document.body.appendChild(s2)), s2.srcObject = new MediaStream([o2]), s2.play();
        const a2 = document.createElement("canvas");
        a2.width = 160, a2.height = 120;
        let c2 = 0, d2 = 0;
        try {
          const e3 = Date.now();
          c2 = await N1(s2, t2, a2, i2), d2 = Date.now() - e3;
        } catch (e3) {
          throw r2.onError(e3), e3;
        }
        O1 === tO.SAFARI && (s2.pause(), s2.remove()), s2.srcObject = null;
        const u2 = c2 > i2, A2 = { duration: d2, changedPicNum: c2, deviceLabel: n2, result: u2 };
        return dD.info("[track-".concat(e2.getTrackId(), "] check video track active completed. ").concat(JSON.stringify(A2))), r2.onSuccess(A2), u2;
      }, setArea: function(e2) {
        const t2 = bV.reportApiInvoke(null, { name: fP.SET_AREA, options: e2, tag: EP.TRACER });
        try {
          let t3 = [];
          if (typeof e2 == "string" && (t3 = [e2]), Array.isArray(e2) && (e2.forEach((e3) => {
            if (!_k.includes(e3))
              throw new tD(eD.INVALID_PARAMS, "invalid area code");
          }), t3 = e2), Object.prototype.toString.call(e2) === "[object Object]") {
            const { areaCode: r3, excludedArea: i2 } = e2;
            if (!r3)
              throw new tD(eD.INVALID_PARAMS, "area code is needed");
            let n2 = r3;
            typeof r3 == "string" && (n2 = [r3]), t3 = i2 ? TJ(n2, i2) : n2;
          }
          WD("AREAS", t3);
          const r2 = ((e3) => {
            const t4 = { CODE: "", WEBCS_DOMAIN: [], WEBCS_DOMAIN_BACKUP_LIST: [], PROXY_CS: [], CDS_AP: [], ACCOUNT_REGISTER: [], UAP_AP: [], EVENT_REPORT_DOMAIN: [], EVENT_REPORT_BACKUP_DOMAIN: [], LOG_UPLOAD_SERVER: [], PROXY_SERVER_TYPE3: [] };
            return e3.map((e4) => {
              const r3 = vk[e4], i2 = Object.keys(r3);
              i2 && i2.map((e5) => {
                e5 !== "CODE" && (t4[e5] = t4[e5].concat(r3[e5]));
              });
            }), t4;
          })(t3);
          Object.keys(r2).map((e3) => {
            if (e3 === "LOG_UPLOAD_SERVER" || e3 === "EVENT_REPORT_DOMAIN" || e3 === "EVENT_REPORT_BACKUP_DOMAIN" || e3 === "PROXY_SERVER_TYPE3") {
              WD(e3, r2[e3][0]);
            } else
              WD(e3, r2[e3]);
          }), dD.debug("set area success:", t3.join(","));
        } catch (e3) {
          throw t2.onError(e3), e3;
        }
        t2.onSuccess();
      }, loadModule: async function(e2, t2) {
        if (dD.debug("loadModule: ".concat(e2.name, ", loadOption: ").concat(JSON.stringify(t2))), !e2.moduleInit)
          throw dD.debug("Invalid Plugin"), new tD(eD.INVALID_PLUGIN, "invalid plugin");
        try {
          QV.installPlugin(e2), await e2.moduleInit({ logger: dD, report: bV, pluginCenter: QV, getParameter: JD }, t2);
        } catch (e3) {
          throw new tD(eD.UNEXPECTED_ERROR, "unexpected error in loadModule", e3);
        }
      }, audioElementPlayCenter: lj, processExternalMediaAEC: function(e2) {
        B1.processExternalMediaAEC(e2);
      }, registerExtensions: function(e2) {
        e2.forEach((e3) => {
          const t2 = e3;
          t2.__registered__ = true, t2.logger.hookLog = dD.extLog, t2.reporter.hookApiInvoke = bV.extApiInvoke, t2.parameters && Object.keys(t2.parameters).forEach((e4) => {
            t2.parameters[e4] = JD(e4);
          });
        });
      }, ChannelMediaRelayError: ak, ChannelMediaRelayEvent: ok, ChannelMediaRelayState: sk, RemoteStreamFallbackType: pk, RemoteStreamType: lk, ConnectionDisconnectedReason: TP, AudienceLatencyLevelType: yP, AREAS: Ek };
      return Object.defineProperties(M1, { onAudioAutoplayFailed: { get: () => CV.onAudioAutoplayFailed, set: (e2) => {
        CV.onAudioAutoplayFailed = e2;
      } }, onAutoplayFailed: { get: () => CV.onAutoplayFailed, set: (e2) => {
        CV.onAutoplayFailed = e2;
      } } }), dj.on(mP.CAMERA_DEVICE_CHANGED, (e2) => {
        dD.info("camera device changed", JSON.stringify(e2)), M1.onCameraChanged && M1.onCameraChanged(e2);
      }), dj.on(mP.RECORDING_DEVICE_CHANGED, (e2) => {
        dD.info("microphone device changed", JSON.stringify(e2)), M1.onMicrophoneChanged && M1.onMicrophoneChanged(e2);
      }), dj.on(mP.PLAYOUT_DEVICE_CHANGED, (e2) => {
        dD.debug("playout device changed", JSON.stringify(e2)), M1.onPlaybackDeviceChanged && M1.onPlaybackDeviceChanged(e2);
      }), lj.onAutoplayFailed = () => {
        dD.info("detect audio element autoplay failed"), CV.onAudioAutoplayFailed && CV.onAudioAutoplayFailed();
      }, VV.on("autoplay-failed", () => {
        dD.info("detect webaudio autoplay failed"), CV.onAudioAutoplayFailed && CV.onAudioAutoplayFailed();
      }), window && (window.__ARTC__ = M1), M1;
    });
  }
});

// dep:agora-rtc-sdk-ng
var agora_rtc_sdk_ng_default = require_AgoraRTC_N_production();
export {
  agora_rtc_sdk_ng_default as default
};
/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
/*! formdata-polyfill. MIT License. Jimmy W?rting <https://jimmy.warting.se/opensource> */
/*!@license
	 * UAParser.js v0.7.28
	 * Lightweight JavaScript-based User-Agent string parser
	 * https://github.com/faisalman/ua-parser-js
	 *
	 * Copyright © 2012-2021 Faisal Salman <f@faisalman.com>
	 * Licensed under MIT License
	 */
//# sourceMappingURL=agora-rtc-sdk-ng.js.map
